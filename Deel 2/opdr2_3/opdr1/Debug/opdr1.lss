
opdr1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800200  00002d56  00002dea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d56  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000022b  00800256  00800256  00002e40  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002e40  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002e9c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005c0  00000000  00000000  00002ee0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000690e  00000000  00000000  000034a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001314  00000000  00000000  00009dae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000045c5  00000000  00000000  0000b0c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000014b0  00000000  00000000  0000f688  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b75  00000000  00000000  00010b38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000726a  00000000  00000000  000126ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000830  00000000  00000000  00019917  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8b c1       	rjmp	.+790    	; 0x31c <__bad_interrupt>
       6:	00 00       	nop
       8:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__vector_2>
       c:	87 c1       	rjmp	.+782    	; 0x31c <__bad_interrupt>
       e:	00 00       	nop
      10:	85 c1       	rjmp	.+778    	; 0x31c <__bad_interrupt>
      12:	00 00       	nop
      14:	83 c1       	rjmp	.+774    	; 0x31c <__bad_interrupt>
      16:	00 00       	nop
      18:	81 c1       	rjmp	.+770    	; 0x31c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7f c1       	rjmp	.+766    	; 0x31c <__bad_interrupt>
      1e:	00 00       	nop
      20:	7d c1       	rjmp	.+762    	; 0x31c <__bad_interrupt>
      22:	00 00       	nop
      24:	7b c1       	rjmp	.+758    	; 0x31c <__bad_interrupt>
      26:	00 00       	nop
      28:	79 c1       	rjmp	.+754    	; 0x31c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	77 c1       	rjmp	.+750    	; 0x31c <__bad_interrupt>
      2e:	00 00       	nop
      30:	75 c1       	rjmp	.+746    	; 0x31c <__bad_interrupt>
      32:	00 00       	nop
      34:	73 c1       	rjmp	.+742    	; 0x31c <__bad_interrupt>
      36:	00 00       	nop
      38:	71 c1       	rjmp	.+738    	; 0x31c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6f c1       	rjmp	.+734    	; 0x31c <__bad_interrupt>
      3e:	00 00       	nop
      40:	6d c1       	rjmp	.+730    	; 0x31c <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 c1 10 	jmp	0x2182	; 0x2182 <__vector_17>
      48:	69 c1       	rjmp	.+722    	; 0x31c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	67 c1       	rjmp	.+718    	; 0x31c <__bad_interrupt>
      4e:	00 00       	nop
      50:	65 c1       	rjmp	.+714    	; 0x31c <__bad_interrupt>
      52:	00 00       	nop
      54:	db c4       	rjmp	.+2486   	; 0xa0c <__vector_21>
      56:	00 00       	nop
      58:	61 c1       	rjmp	.+706    	; 0x31c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5f c1       	rjmp	.+702    	; 0x31c <__bad_interrupt>
      5e:	00 00       	nop
      60:	5d c1       	rjmp	.+698    	; 0x31c <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 21 0f 	jmp	0x1e42	; 0x1e42 <__vector_25>
      68:	49 c7       	rjmp	.+3730   	; 0xefc <__vector_26>
      6a:	00 00       	nop
      6c:	57 c1       	rjmp	.+686    	; 0x31c <__bad_interrupt>
      6e:	00 00       	nop
      70:	55 c1       	rjmp	.+682    	; 0x31c <__bad_interrupt>
      72:	00 00       	nop
      74:	53 c1       	rjmp	.+678    	; 0x31c <__bad_interrupt>
      76:	00 00       	nop
      78:	51 c1       	rjmp	.+674    	; 0x31c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4f c1       	rjmp	.+670    	; 0x31c <__bad_interrupt>
      7e:	00 00       	nop
      80:	4d c1       	rjmp	.+666    	; 0x31c <__bad_interrupt>
      82:	00 00       	nop
      84:	4b c1       	rjmp	.+662    	; 0x31c <__bad_interrupt>
      86:	00 00       	nop
      88:	49 c1       	rjmp	.+658    	; 0x31c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__vector_35>
      90:	7e c7       	rjmp	.+3836   	; 0xf8e <__vector_36>
      92:	00 00       	nop
      94:	db c7       	rjmp	.+4022   	; 0x104c <__vector_37>
      96:	00 00       	nop
      98:	41 c1       	rjmp	.+642    	; 0x31c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c1       	rjmp	.+858    	; 0x3f8 <__vector_39>
      9e:	00 00       	nop
      a0:	3d c1       	rjmp	.+634    	; 0x31c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3b c1       	rjmp	.+630    	; 0x31c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	39 c1       	rjmp	.+626    	; 0x31c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	37 c1       	rjmp	.+622    	; 0x31c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	35 c1       	rjmp	.+618    	; 0x31c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	33 c1       	rjmp	.+614    	; 0x31c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	31 c1       	rjmp	.+610    	; 0x31c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2f c1       	rjmp	.+606    	; 0x31c <__bad_interrupt>
      be:	00 00       	nop
      c0:	2d c1       	rjmp	.+602    	; 0x31c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2b c1       	rjmp	.+598    	; 0x31c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	29 c1       	rjmp	.+594    	; 0x31c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 6f 08 	jmp	0x10de	; 0x10de <__vector_51>
      d0:	0c 94 ce 08 	jmp	0x119c	; 0x119c <__vector_52>
      d4:	23 c1       	rjmp	.+582    	; 0x31c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 17 09 	jmp	0x122e	; 0x122e <__vector_54>
      dc:	0c 94 76 09 	jmp	0x12ec	; 0x12ec <__vector_55>
      e0:	1d c1       	rjmp	.+570    	; 0x31c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1b 02       	muls	r17, r27
      e6:	d6 02       	muls	r29, r22
      e8:	d6 02       	muls	r29, r22
      ea:	d6 02       	muls	r29, r22
      ec:	d6 02       	muls	r29, r22
      ee:	d6 02       	muls	r29, r22
      f0:	d6 02       	muls	r29, r22
      f2:	d6 02       	muls	r29, r22
      f4:	1b 02       	muls	r17, r27
      f6:	d6 02       	muls	r29, r22
      f8:	d6 02       	muls	r29, r22
      fa:	d6 02       	muls	r29, r22
      fc:	d6 02       	muls	r29, r22
      fe:	d6 02       	muls	r29, r22
     100:	d6 02       	muls	r29, r22
     102:	d6 02       	muls	r29, r22
     104:	1d 02       	muls	r17, r29
     106:	d6 02       	muls	r29, r22
     108:	d6 02       	muls	r29, r22
     10a:	d6 02       	muls	r29, r22
     10c:	d6 02       	muls	r29, r22
     10e:	d6 02       	muls	r29, r22
     110:	d6 02       	muls	r29, r22
     112:	d6 02       	muls	r29, r22
     114:	3a 02       	muls	r19, r26
     116:	d6 02       	muls	r29, r22
     118:	d6 02       	muls	r29, r22
     11a:	d6 02       	muls	r29, r22
     11c:	d6 02       	muls	r29, r22
     11e:	d6 02       	muls	r29, r22
     120:	d6 02       	muls	r29, r22
     122:	d6 02       	muls	r29, r22
     124:	1d 02       	muls	r17, r29
     126:	d6 02       	muls	r29, r22
     128:	d6 02       	muls	r29, r22
     12a:	d6 02       	muls	r29, r22
     12c:	d6 02       	muls	r29, r22
     12e:	d6 02       	muls	r29, r22
     130:	d6 02       	muls	r29, r22
     132:	d6 02       	muls	r29, r22
     134:	3a 02       	muls	r19, r26
     136:	d6 02       	muls	r29, r22
     138:	d6 02       	muls	r29, r22
     13a:	d6 02       	muls	r29, r22
     13c:	d6 02       	muls	r29, r22
     13e:	d6 02       	muls	r29, r22
     140:	d6 02       	muls	r29, r22
     142:	d6 02       	muls	r29, r22
     144:	d2 02       	muls	r29, r18
     146:	d6 02       	muls	r29, r22
     148:	d6 02       	muls	r29, r22
     14a:	d6 02       	muls	r29, r22
     14c:	d6 02       	muls	r29, r22
     14e:	d6 02       	muls	r29, r22
     150:	d6 02       	muls	r29, r22
     152:	d6 02       	muls	r29, r22
     154:	4e 02       	muls	r20, r30
     156:	d6 02       	muls	r29, r22
     158:	d6 02       	muls	r29, r22
     15a:	d6 02       	muls	r29, r22
     15c:	d6 02       	muls	r29, r22
     15e:	d6 02       	muls	r29, r22
     160:	d6 02       	muls	r29, r22
     162:	d6 02       	muls	r29, r22
     164:	71 02       	muls	r23, r17
     166:	d6 02       	muls	r29, r22
     168:	d6 02       	muls	r29, r22
     16a:	d6 02       	muls	r29, r22
     16c:	d6 02       	muls	r29, r22
     16e:	d6 02       	muls	r29, r22
     170:	d6 02       	muls	r29, r22
     172:	d6 02       	muls	r29, r22
     174:	42 02       	muls	r20, r18
     176:	d6 02       	muls	r29, r22
     178:	d6 02       	muls	r29, r22
     17a:	d6 02       	muls	r29, r22
     17c:	d6 02       	muls	r29, r22
     17e:	d6 02       	muls	r29, r22
     180:	d6 02       	muls	r29, r22
     182:	d6 02       	muls	r29, r22
     184:	60 02       	muls	r22, r16
     186:	d6 02       	muls	r29, r22
     188:	d6 02       	muls	r29, r22
     18a:	d6 02       	muls	r29, r22
     18c:	d6 02       	muls	r29, r22
     18e:	d6 02       	muls	r29, r22
     190:	d6 02       	muls	r29, r22
     192:	d6 02       	muls	r29, r22
     194:	a8 02       	muls	r26, r24
     196:	d6 02       	muls	r29, r22
     198:	d6 02       	muls	r29, r22
     19a:	d6 02       	muls	r29, r22
     19c:	d6 02       	muls	r29, r22
     19e:	d6 02       	muls	r29, r22
     1a0:	d6 02       	muls	r29, r22
     1a2:	d6 02       	muls	r29, r22
     1a4:	a8 02       	muls	r26, r24
     1a6:	d6 02       	muls	r29, r22
     1a8:	d6 02       	muls	r29, r22
     1aa:	d6 02       	muls	r29, r22
     1ac:	d6 02       	muls	r29, r22
     1ae:	d6 02       	muls	r29, r22
     1b0:	d6 02       	muls	r29, r22
     1b2:	d6 02       	muls	r29, r22
     1b4:	a3 02       	muls	r26, r19
     1b6:	d6 02       	muls	r29, r22
     1b8:	d6 02       	muls	r29, r22
     1ba:	d6 02       	muls	r29, r22
     1bc:	d6 02       	muls	r29, r22
     1be:	d6 02       	muls	r29, r22
     1c0:	d6 02       	muls	r29, r22
     1c2:	d6 02       	muls	r29, r22
     1c4:	a3 02       	muls	r26, r19
     1c6:	d6 02       	muls	r29, r22
     1c8:	d6 02       	muls	r29, r22
     1ca:	d6 02       	muls	r29, r22
     1cc:	d6 02       	muls	r29, r22
     1ce:	d6 02       	muls	r29, r22
     1d0:	d6 02       	muls	r29, r22
     1d2:	d6 02       	muls	r29, r22
     1d4:	b3 02       	muls	r27, r19
     1d6:	d6 02       	muls	r29, r22
     1d8:	d6 02       	muls	r29, r22
     1da:	d6 02       	muls	r29, r22
     1dc:	d6 02       	muls	r29, r22
     1de:	d6 02       	muls	r29, r22
     1e0:	d6 02       	muls	r29, r22
     1e2:	d6 02       	muls	r29, r22
     1e4:	c8 02       	muls	r28, r24
     1e6:	d6 02       	muls	r29, r22
     1e8:	d6 02       	muls	r29, r22
     1ea:	d6 02       	muls	r29, r22
     1ec:	d6 02       	muls	r29, r22
     1ee:	d6 02       	muls	r29, r22
     1f0:	d6 02       	muls	r29, r22
     1f2:	d6 02       	muls	r29, r22
     1f4:	b3 02       	muls	r27, r19
     1f6:	d6 02       	muls	r29, r22
     1f8:	d6 02       	muls	r29, r22
     1fa:	d6 02       	muls	r29, r22
     1fc:	d6 02       	muls	r29, r22
     1fe:	d6 02       	muls	r29, r22
     200:	d6 02       	muls	r29, r22
     202:	d6 02       	muls	r29, r22
     204:	c8 02       	muls	r28, r24
     206:	d6 02       	muls	r29, r22
     208:	d6 02       	muls	r29, r22
     20a:	d6 02       	muls	r29, r22
     20c:	d6 02       	muls	r29, r22
     20e:	d6 02       	muls	r29, r22
     210:	d6 02       	muls	r29, r22
     212:	d6 02       	muls	r29, r22
     214:	cc 02       	muls	r28, r28
     216:	d6 02       	muls	r29, r22
     218:	d6 02       	muls	r29, r22
     21a:	d6 02       	muls	r29, r22
     21c:	d6 02       	muls	r29, r22
     21e:	d6 02       	muls	r29, r22
     220:	d6 02       	muls	r29, r22
     222:	d6 02       	muls	r29, r22
     224:	79 02       	muls	r23, r25
     226:	d6 02       	muls	r29, r22
     228:	d6 02       	muls	r29, r22
     22a:	d6 02       	muls	r29, r22
     22c:	d6 02       	muls	r29, r22
     22e:	d6 02       	muls	r29, r22
     230:	d6 02       	muls	r29, r22
     232:	d6 02       	muls	r29, r22
     234:	79 02       	muls	r23, r25
     236:	d6 02       	muls	r29, r22
     238:	d6 02       	muls	r29, r22
     23a:	d6 02       	muls	r29, r22
     23c:	d6 02       	muls	r29, r22
     23e:	d6 02       	muls	r29, r22
     240:	d6 02       	muls	r29, r22
     242:	d6 02       	muls	r29, r22
     244:	7b 02       	muls	r23, r27
     246:	d6 02       	muls	r29, r22
     248:	d6 02       	muls	r29, r22
     24a:	d6 02       	muls	r29, r22
     24c:	d6 02       	muls	r29, r22
     24e:	d6 02       	muls	r29, r22
     250:	d6 02       	muls	r29, r22
     252:	d6 02       	muls	r29, r22
     254:	8b 02       	muls	r24, r27
     256:	d6 02       	muls	r29, r22
     258:	d6 02       	muls	r29, r22
     25a:	d6 02       	muls	r29, r22
     25c:	d6 02       	muls	r29, r22
     25e:	d6 02       	muls	r29, r22
     260:	d6 02       	muls	r29, r22
     262:	d6 02       	muls	r29, r22
     264:	9f 02       	muls	r25, r31

00000266 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     266:	0a e8       	ldi	r16, 0x8A	; 138
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	f2 eb       	ldi	r31, 0xB2	; 178
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	ff d1       	rcall	.+1022   	; 0x6a0 <uxListRemove>
     2a2:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 7f 02 	sts	0x027F, r24	; 0x80027f <uxCurrentNumberOfTasks>
     2ac:	80 91 89 02 	lds	r24, 0x0289	; 0x800289 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5d d0       	rcall	.+186    	; 0x37a <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5b d0       	rcall	.+182    	; 0x37a <vPortFree>
     2c4:	80 91 89 02 	lds	r24, 0x0289	; 0x800289 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	c3 d2       	rcall	.+1414   	; 0x85c <vPortYield>
     2d6:	60 d0       	rcall	.+192    	; 0x398 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	e6 e5       	ldi	r30, 0x56	; 86
     2f2:	fd e2       	ldi	r31, 0x2D	; 45
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	a6 35       	cpi	r26, 0x56	; 86
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	24 e0       	ldi	r18, 0x04	; 4
     306:	a6 e5       	ldi	r26, 0x56	; 86
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a1 38       	cpi	r26, 0x81	; 129
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	0e 94 8d 10 	call	0x211a	; 0x211a <main>
     318:	0c 94 a9 16 	jmp	0x2d52	; 0x2d52 <_exit>

0000031c <__bad_interrupt>:
     31c:	71 ce       	rjmp	.-798    	; 0x0 <__vectors>

0000031e <system_tick>:
#include <avr/common.h>

    .global	system_tick
	.type	system_tick, @function
system_tick:
    push r24
     31e:	8f 93       	push	r24
    in r24,_SFR_IO_ADDR(SREG)
     320:	8f b7       	in	r24, 0x3f	; 63
	push r24
     322:	8f 93       	push	r24
	cli
     324:	f8 94       	cli
    lds r24,__system_time+0
     326:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <__system_time>
    subi r24, (-1)
     32a:	8f 5f       	subi	r24, 0xFF	; 255
    sts __system_time+0,r24
     32c:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <__system_time>
    lds r24,__system_time+1
     330:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <__system_time+0x1>
    sbci r24, (-1)
     334:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+1,r24
     336:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <__system_time+0x1>
    lds r24,__system_time+2
     33a:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <__system_time+0x2>
    sbci r24, (-1)
     33e:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+2,r24
     340:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <__system_time+0x2>
    lds r24,__system_time+3
     344:	80 91 e7 02 	lds	r24, 0x02E7	; 0x8002e7 <__system_time+0x3>
    sbci r24, (-1)
     348:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+3,r24
     34a:	80 93 e7 02 	sts	0x02E7, r24	; 0x8002e7 <__system_time+0x3>
    pop r24
     34e:	8f 91       	pop	r24
    out _SFR_IO_ADDR(SREG),r24
     350:	8f bf       	out	0x3f, r24	; 63
    pop r24
     352:	8f 91       	pop	r24
    ret
     354:	08 95       	ret

00000356 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     356:	cf 93       	push	r28
     358:	df 93       	push	r29
     35a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35c:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     360:	ce 01       	movw	r24, r28
     362:	0e 94 9d 12 	call	0x253a	; 0x253a <malloc>
     366:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     368:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36c:	20 97       	sbiw	r28, 0x00	; 0
     36e:	09 f4       	brne	.+2      	; 0x372 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     370:	2c d0       	rcall	.+88     	; 0x3ca <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     372:	ce 01       	movw	r24, r28
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
	if( pv )
     37e:	00 97       	sbiw	r24, 0x00	; 0
     380:	41 f0       	breq	.+16     	; 0x392 <vPortFree+0x18>
     382:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     384:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <vTaskSuspendAll>
		{
			free( pv );
     388:	ce 01       	movw	r24, r28
     38a:	0e 94 35 13 	call	0x266a	; 0x266a <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38e:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskResumeAll>
	}
}
     392:	df 91       	pop	r29
     394:	cf 91       	pop	r28
     396:	08 95       	ret

00000398 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39e:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a2:	80 b7       	in	r24, 0x30	; 48
     3a4:	87 7f       	andi	r24, 0xF7	; 247
     3a6:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a8:	80 b7       	in	r24, 0x30	; 48
     3aa:	80 68       	ori	r24, 0x80	; 128
     3ac:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ae:	83 b7       	in	r24, 0x33	; 51
     3b0:	81 7f       	andi	r24, 0xF1	; 241
     3b2:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	0f 92       	push	r0

	sleep_enable();
     3ba:	83 b7       	in	r24, 0x33	; 51
     3bc:	81 60       	ori	r24, 0x01	; 1
     3be:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3c0:	0f 90       	pop	r0
     3c2:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c4:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c6:	13 be       	out	0x33, r1	; 51
     3c8:	08 95       	ret

000003ca <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3ca:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3cc:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3ce:	83 ed       	ldi	r24, 0xD3	; 211
     3d0:	90 e3       	ldi	r25, 0x30	; 48
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	f1 f7       	brne	.-4      	; 0x3d2 <vApplicationMallocFailedHook+0x8>
     3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <vApplicationMallocFailedHook+0xe>
     3d8:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3da:	1f 9a       	sbi	0x03, 7	; 3
     3dc:	f8 cf       	rjmp	.-16     	; 0x3ce <vApplicationMallocFailedHook+0x4>

000003de <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3de:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3e0:	2f 9a       	sbi	0x05, 7	; 5
     3e2:	2f e7       	ldi	r18, 0x7F	; 127
     3e4:	8a e1       	ldi	r24, 0x1A	; 26
     3e6:	96 e0       	ldi	r25, 0x06	; 6
     3e8:	21 50       	subi	r18, 0x01	; 1
     3ea:	80 40       	sbci	r24, 0x00	; 0
     3ec:	90 40       	sbci	r25, 0x00	; 0
     3ee:	e1 f7       	brne	.-8      	; 0x3e8 <vApplicationStackOverflowHook+0xa>
     3f0:	00 c0       	rjmp	.+0      	; 0x3f2 <vApplicationStackOverflowHook+0x14>
     3f2:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f4:	1f 9a       	sbi	0x03, 7	; 3
     3f6:	f5 cf       	rjmp	.-22     	; 0x3e2 <vApplicationStackOverflowHook+0x4>

000003f8 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f8:	1f 92       	push	r1
     3fa:	0f 92       	push	r0
     3fc:	0f b6       	in	r0, 0x3f	; 63
     3fe:	0f 92       	push	r0
     400:	11 24       	eor	r1, r1
     402:	0b b6       	in	r0, 0x3b	; 59
     404:	0f 92       	push	r0
     406:	2f 93       	push	r18
     408:	3f 93       	push	r19
     40a:	8f 93       	push	r24
     40c:	9f 93       	push	r25
     40e:	af 93       	push	r26
     410:	bf 93       	push	r27
     412:	ef 93       	push	r30
     414:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     416:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     41a:	8e 2f       	mov	r24, r30
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	fc 01       	movw	r30, r24
     420:	38 97       	sbiw	r30, 0x08	; 8
     422:	e1 3c       	cpi	r30, 0xC1	; 193
     424:	f1 05       	cpc	r31, r1
     426:	08 f0       	brcs	.+2      	; 0x42a <__FUSE_REGION_LENGTH__+0x2a>
     428:	c1 c0       	rjmp	.+386    	; 0x5ac <__FUSE_REGION_LENGTH__+0x1ac>
     42a:	88 27       	eor	r24, r24
     42c:	ee 58       	subi	r30, 0x8E	; 142
     42e:	ff 4f       	sbci	r31, 0xFF	; 255
     430:	8f 4f       	sbci	r24, 0xFF	; 255
     432:	0c 94 7c 12 	jmp	0x24f8	; 0x24f8 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     436:	10 92 56 02 	sts	0x0256, r1	; 0x800256 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     43a:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <__data_end>
     43e:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <I2C_msgSize>
     442:	e8 17       	cp	r30, r24
     444:	70 f4       	brcc	.+28     	; 0x462 <__FUSE_REGION_LENGTH__+0x62>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	8e 0f       	add	r24, r30
     44a:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <__data_end>
     44e:	f0 e0       	ldi	r31, 0x00	; 0
     450:	e6 5a       	subi	r30, 0xA6	; 166
     452:	fd 4f       	sbci	r31, 0xFD	; 253
     454:	80 81       	ld	r24, Z
     456:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     45a:	85 e8       	ldi	r24, 0x85	; 133
     45c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     460:	ac c0       	rjmp	.+344    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     462:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     466:	81 60       	ori	r24, 0x01	; 1
     468:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46c:	84 e9       	ldi	r24, 0x94	; 148
     46e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     472:	a3 c0       	rjmp	.+326    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     474:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     478:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47c:	85 ee       	ldi	r24, 0xE5	; 229
     47e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     482:	9b c0       	rjmp	.+310    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     484:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <__data_end>
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	8e 0f       	add	r24, r30
     48c:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <__data_end>
     490:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	e6 5a       	subi	r30, 0xA6	; 166
     498:	fd 4f       	sbci	r31, 0xFD	; 253
     49a:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49c:	20 91 56 02 	lds	r18, 0x0256	; 0x800256 <__data_end>
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <I2C_msgSize>
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	01 97       	sbiw	r24, 0x01	; 1
     4aa:	28 17       	cp	r18, r24
     4ac:	39 07       	cpc	r19, r25
     4ae:	24 f4       	brge	.+8      	; 0x4b8 <__FUSE_REGION_LENGTH__+0xb8>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b0:	85 ec       	ldi	r24, 0xC5	; 197
     4b2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b6:	81 c0       	rjmp	.+258    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b8:	85 e8       	ldi	r24, 0x85	; 133
     4ba:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4be:	7d c0       	rjmp	.+250    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4c0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c4:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <__data_end>
     4c8:	f0 e0       	ldi	r31, 0x00	; 0
     4ca:	e6 5a       	subi	r30, 0xA6	; 166
     4cc:	fd 4f       	sbci	r31, 0xFD	; 253
     4ce:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4d0:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     4d4:	81 60       	ori	r24, 0x01	; 1
     4d6:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4da:	84 ed       	ldi	r24, 0xD4	; 212
     4dc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4e0:	6c c0       	rjmp	.+216    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e6:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4ea:	85 ed       	ldi	r24, 0xD5	; 213
     4ec:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4f0:	64 c0       	rjmp	.+200    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f2:	10 92 56 02 	sts	0x0256, r1	; 0x800256 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f6:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <__data_end>
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	8e 0f       	add	r24, r30
     4fe:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <__data_end>
     502:	f0 e0       	ldi	r31, 0x00	; 0
     504:	e6 5a       	subi	r30, 0xA6	; 166
     506:	fd 4f       	sbci	r31, 0xFD	; 253
     508:	80 81       	ld	r24, Z
     50a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50e:	85 ec       	ldi	r24, 0xC5	; 197
     510:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     514:	52 c0       	rjmp	.+164    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     516:	90 91 56 02 	lds	r25, 0x0256	; 0x800256 <__data_end>
     51a:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <I2C_msgSize>
     51e:	98 13       	cpse	r25, r24
     520:	06 c0       	rjmp	.+12     	; 0x52e <__FUSE_REGION_LENGTH__+0x12e>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     522:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     526:	81 60       	ori	r24, 0x01	; 1
     528:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>
     52c:	04 c0       	rjmp	.+8      	; 0x536 <__FUSE_REGION_LENGTH__+0x136>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     532:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     536:	84 e0       	ldi	r24, 0x04	; 4
     538:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53c:	3e c0       	rjmp	.+124    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53e:	85 ec       	ldi	r24, 0xC5	; 197
     540:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     544:	3a c0       	rjmp	.+116    	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     546:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     54a:	84 60       	ori	r24, 0x04	; 4
     54c:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     550:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     554:	82 60       	ori	r24, 0x02	; 2
     556:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     55a:	10 92 56 02 	sts	0x0256, r1	; 0x800256 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55e:	85 ec       	ldi	r24, 0xC5	; 197
     560:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     564:	2a c0       	rjmp	.+84     	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     566:	e0 91 56 02 	lds	r30, 0x0256	; 0x800256 <__data_end>
     56a:	81 e0       	ldi	r24, 0x01	; 1
     56c:	8e 0f       	add	r24, r30
     56e:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <__data_end>
     572:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     576:	f0 e0       	ldi	r31, 0x00	; 0
     578:	e6 5a       	subi	r30, 0xA6	; 166
     57a:	fd 4f       	sbci	r31, 0xFD	; 253
     57c:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57e:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_statusReg>
     582:	81 60       	ori	r24, 0x01	; 1
     584:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     588:	85 ec       	ldi	r24, 0xC5	; 197
     58a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58e:	15 c0       	rjmp	.+42     	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     590:	85 e8       	ldi	r24, 0x85	; 133
     592:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     596:	11 c0       	rjmp	.+34     	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     598:	84 e0       	ldi	r24, 0x04	; 4
     59a:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a2:	0b c0       	rjmp	.+22     	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a4:	85 ee       	ldi	r24, 0xE5	; 229
     5a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5aa:	07 c0       	rjmp	.+14     	; 0x5ba <__FUSE_REGION_LENGTH__+0x1ba>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5ac:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5b0:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b4:	85 ed       	ldi	r24, 0xD5	; 213
     5b6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5ba:	ff 91       	pop	r31
     5bc:	ef 91       	pop	r30
     5be:	bf 91       	pop	r27
     5c0:	af 91       	pop	r26
     5c2:	9f 91       	pop	r25
     5c4:	8f 91       	pop	r24
     5c6:	3f 91       	pop	r19
     5c8:	2f 91       	pop	r18
     5ca:	0f 90       	pop	r0
     5cc:	0b be       	out	0x3b, r0	; 59
     5ce:	0f 90       	pop	r0
     5d0:	0f be       	out	0x3f, r0	; 63
     5d2:	0f 90       	pop	r0
     5d4:	1f 90       	pop	r1
     5d6:	18 95       	reti

000005d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5da:	03 96       	adiw	r24, 0x03	; 3
     5dc:	92 83       	std	Z+2, r25	; 0x02
     5de:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5e0:	2f ef       	ldi	r18, 0xFF	; 255
     5e2:	3f ef       	ldi	r19, 0xFF	; 255
     5e4:	34 83       	std	Z+4, r19	; 0x04
     5e6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e8:	96 83       	std	Z+6, r25	; 0x06
     5ea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ec:	90 87       	std	Z+8, r25	; 0x08
     5ee:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5f0:	10 82       	st	Z, r1
     5f2:	08 95       	ret

000005f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f4:	fc 01       	movw	r30, r24
     5f6:	11 86       	std	Z+9, r1	; 0x09
     5f8:	10 86       	std	Z+8, r1	; 0x08
     5fa:	08 95       	ret

000005fc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
     600:	9c 01       	movw	r18, r24
     602:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     604:	dc 01       	movw	r26, r24
     606:	11 96       	adiw	r26, 0x01	; 1
     608:	cd 91       	ld	r28, X+
     60a:	dc 91       	ld	r29, X
     60c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60e:	d3 83       	std	Z+3, r29	; 0x03
     610:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     612:	8c 81       	ldd	r24, Y+4	; 0x04
     614:	9d 81       	ldd	r25, Y+5	; 0x05
     616:	95 83       	std	Z+5, r25	; 0x05
     618:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     61a:	8c 81       	ldd	r24, Y+4	; 0x04
     61c:	9d 81       	ldd	r25, Y+5	; 0x05
     61e:	dc 01       	movw	r26, r24
     620:	13 96       	adiw	r26, 0x03	; 3
     622:	7c 93       	st	X, r23
     624:	6e 93       	st	-X, r22
     626:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     628:	7d 83       	std	Y+5, r23	; 0x05
     62a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62c:	31 87       	std	Z+9, r19	; 0x09
     62e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     630:	f9 01       	movw	r30, r18
     632:	80 81       	ld	r24, Z
     634:	8f 5f       	subi	r24, 0xFF	; 255
     636:	80 83       	st	Z, r24
}
     638:	df 91       	pop	r29
     63a:	cf 91       	pop	r28
     63c:	08 95       	ret

0000063e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     644:	48 81       	ld	r20, Y
     646:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     648:	4f 3f       	cpi	r20, 0xFF	; 255
     64a:	2f ef       	ldi	r18, 0xFF	; 255
     64c:	52 07       	cpc	r21, r18
     64e:	21 f4       	brne	.+8      	; 0x658 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     650:	fc 01       	movw	r30, r24
     652:	a7 81       	ldd	r26, Z+7	; 0x07
     654:	b0 85       	ldd	r27, Z+8	; 0x08
     656:	0d c0       	rjmp	.+26     	; 0x672 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     658:	dc 01       	movw	r26, r24
     65a:	13 96       	adiw	r26, 0x03	; 3
     65c:	01 c0       	rjmp	.+2      	; 0x660 <vListInsert+0x22>
     65e:	df 01       	movw	r26, r30
     660:	12 96       	adiw	r26, 0x02	; 2
     662:	ed 91       	ld	r30, X+
     664:	fc 91       	ld	r31, X
     666:	13 97       	sbiw	r26, 0x03	; 3
     668:	20 81       	ld	r18, Z
     66a:	31 81       	ldd	r19, Z+1	; 0x01
     66c:	42 17       	cp	r20, r18
     66e:	53 07       	cpc	r21, r19
     670:	b0 f7       	brcc	.-20     	; 0x65e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     672:	12 96       	adiw	r26, 0x02	; 2
     674:	ed 91       	ld	r30, X+
     676:	fc 91       	ld	r31, X
     678:	13 97       	sbiw	r26, 0x03	; 3
     67a:	fb 83       	std	Y+3, r31	; 0x03
     67c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67e:	d5 83       	std	Z+5, r29	; 0x05
     680:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     682:	bd 83       	std	Y+5, r27	; 0x05
     684:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     686:	13 96       	adiw	r26, 0x03	; 3
     688:	dc 93       	st	X, r29
     68a:	ce 93       	st	-X, r28
     68c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68e:	99 87       	std	Y+9, r25	; 0x09
     690:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     692:	fc 01       	movw	r30, r24
     694:	20 81       	ld	r18, Z
     696:	2f 5f       	subi	r18, 0xFF	; 255
     698:	20 83       	st	Z, r18
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	08 95       	ret

000006a0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6a0:	cf 93       	push	r28
     6a2:	df 93       	push	r29
     6a4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a6:	a0 85       	ldd	r26, Z+8	; 0x08
     6a8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6aa:	c2 81       	ldd	r28, Z+2	; 0x02
     6ac:	d3 81       	ldd	r29, Z+3	; 0x03
     6ae:	84 81       	ldd	r24, Z+4	; 0x04
     6b0:	95 81       	ldd	r25, Z+5	; 0x05
     6b2:	9d 83       	std	Y+5, r25	; 0x05
     6b4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b6:	c4 81       	ldd	r28, Z+4	; 0x04
     6b8:	d5 81       	ldd	r29, Z+5	; 0x05
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	93 81       	ldd	r25, Z+3	; 0x03
     6be:	9b 83       	std	Y+3, r25	; 0x03
     6c0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c2:	11 96       	adiw	r26, 0x01	; 1
     6c4:	8d 91       	ld	r24, X+
     6c6:	9c 91       	ld	r25, X
     6c8:	12 97       	sbiw	r26, 0x02	; 2
     6ca:	e8 17       	cp	r30, r24
     6cc:	f9 07       	cpc	r31, r25
     6ce:	31 f4       	brne	.+12     	; 0x6dc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6d0:	84 81       	ldd	r24, Z+4	; 0x04
     6d2:	95 81       	ldd	r25, Z+5	; 0x05
     6d4:	12 96       	adiw	r26, 0x02	; 2
     6d6:	9c 93       	st	X, r25
     6d8:	8e 93       	st	-X, r24
     6da:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6dc:	11 86       	std	Z+9, r1	; 0x09
     6de:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6e0:	8c 91       	ld	r24, X
     6e2:	81 50       	subi	r24, 0x01	; 1
     6e4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e6:	df 91       	pop	r29
     6e8:	cf 91       	pop	r28
     6ea:	08 95       	ret

000006ec <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     6ec:	31 e1       	ldi	r19, 0x11	; 17
     6ee:	fc 01       	movw	r30, r24
     6f0:	30 83       	st	Z, r19
     6f2:	31 97       	sbiw	r30, 0x01	; 1
     6f4:	22 e2       	ldi	r18, 0x22	; 34
     6f6:	20 83       	st	Z, r18
     6f8:	31 97       	sbiw	r30, 0x01	; 1
     6fa:	a3 e3       	ldi	r26, 0x33	; 51
     6fc:	a0 83       	st	Z, r26
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	60 83       	st	Z, r22
     702:	31 97       	sbiw	r30, 0x01	; 1
     704:	70 83       	st	Z, r23
     706:	31 97       	sbiw	r30, 0x01	; 1
     708:	10 82       	st	Z, r1
     70a:	31 97       	sbiw	r30, 0x01	; 1
     70c:	10 82       	st	Z, r1
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	60 e8       	ldi	r22, 0x80	; 128
     712:	60 83       	st	Z, r22
     714:	31 97       	sbiw	r30, 0x01	; 1
     716:	10 82       	st	Z, r1
     718:	31 97       	sbiw	r30, 0x01	; 1
     71a:	10 82       	st	Z, r1
     71c:	31 97       	sbiw	r30, 0x01	; 1
     71e:	10 82       	st	Z, r1
     720:	31 97       	sbiw	r30, 0x01	; 1
     722:	62 e0       	ldi	r22, 0x02	; 2
     724:	60 83       	st	Z, r22
     726:	31 97       	sbiw	r30, 0x01	; 1
     728:	63 e0       	ldi	r22, 0x03	; 3
     72a:	60 83       	st	Z, r22
     72c:	31 97       	sbiw	r30, 0x01	; 1
     72e:	64 e0       	ldi	r22, 0x04	; 4
     730:	60 83       	st	Z, r22
     732:	31 97       	sbiw	r30, 0x01	; 1
     734:	65 e0       	ldi	r22, 0x05	; 5
     736:	60 83       	st	Z, r22
     738:	31 97       	sbiw	r30, 0x01	; 1
     73a:	66 e0       	ldi	r22, 0x06	; 6
     73c:	60 83       	st	Z, r22
     73e:	31 97       	sbiw	r30, 0x01	; 1
     740:	67 e0       	ldi	r22, 0x07	; 7
     742:	60 83       	st	Z, r22
     744:	31 97       	sbiw	r30, 0x01	; 1
     746:	68 e0       	ldi	r22, 0x08	; 8
     748:	60 83       	st	Z, r22
     74a:	31 97       	sbiw	r30, 0x01	; 1
     74c:	69 e0       	ldi	r22, 0x09	; 9
     74e:	60 83       	st	Z, r22
     750:	31 97       	sbiw	r30, 0x01	; 1
     752:	60 e1       	ldi	r22, 0x10	; 16
     754:	60 83       	st	Z, r22
     756:	31 97       	sbiw	r30, 0x01	; 1
     758:	30 83       	st	Z, r19
     75a:	31 97       	sbiw	r30, 0x01	; 1
     75c:	32 e1       	ldi	r19, 0x12	; 18
     75e:	30 83       	st	Z, r19
     760:	31 97       	sbiw	r30, 0x01	; 1
     762:	33 e1       	ldi	r19, 0x13	; 19
     764:	30 83       	st	Z, r19
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	34 e1       	ldi	r19, 0x14	; 20
     76a:	30 83       	st	Z, r19
     76c:	31 97       	sbiw	r30, 0x01	; 1
     76e:	35 e1       	ldi	r19, 0x15	; 21
     770:	30 83       	st	Z, r19
     772:	31 97       	sbiw	r30, 0x01	; 1
     774:	36 e1       	ldi	r19, 0x16	; 22
     776:	30 83       	st	Z, r19
     778:	31 97       	sbiw	r30, 0x01	; 1
     77a:	37 e1       	ldi	r19, 0x17	; 23
     77c:	30 83       	st	Z, r19
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	38 e1       	ldi	r19, 0x18	; 24
     782:	30 83       	st	Z, r19
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	39 e1       	ldi	r19, 0x19	; 25
     788:	30 83       	st	Z, r19
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	30 e2       	ldi	r19, 0x20	; 32
     78e:	30 83       	st	Z, r19
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	31 e2       	ldi	r19, 0x21	; 33
     794:	30 83       	st	Z, r19
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	20 83       	st	Z, r18
     79a:	31 97       	sbiw	r30, 0x01	; 1
     79c:	23 e2       	ldi	r18, 0x23	; 35
     79e:	20 83       	st	Z, r18
     7a0:	31 97       	sbiw	r30, 0x01	; 1
     7a2:	40 83       	st	Z, r20
     7a4:	31 97       	sbiw	r30, 0x01	; 1
     7a6:	50 83       	st	Z, r21
     7a8:	31 97       	sbiw	r30, 0x01	; 1
     7aa:	26 e2       	ldi	r18, 0x26	; 38
     7ac:	20 83       	st	Z, r18
     7ae:	31 97       	sbiw	r30, 0x01	; 1
     7b0:	27 e2       	ldi	r18, 0x27	; 39
     7b2:	20 83       	st	Z, r18
     7b4:	31 97       	sbiw	r30, 0x01	; 1
     7b6:	28 e2       	ldi	r18, 0x28	; 40
     7b8:	20 83       	st	Z, r18
     7ba:	31 97       	sbiw	r30, 0x01	; 1
     7bc:	29 e2       	ldi	r18, 0x29	; 41
     7be:	20 83       	st	Z, r18
     7c0:	31 97       	sbiw	r30, 0x01	; 1
     7c2:	20 e3       	ldi	r18, 0x30	; 48
     7c4:	20 83       	st	Z, r18
     7c6:	31 97       	sbiw	r30, 0x01	; 1
     7c8:	21 e3       	ldi	r18, 0x31	; 49
     7ca:	20 83       	st	Z, r18
     7cc:	89 97       	sbiw	r24, 0x29	; 41
     7ce:	08 95       	ret

000007d0 <xPortStartScheduler>:
     7d0:	88 ec       	ldi	r24, 0xC8	; 200
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	90 93 e9 02 	sts	0x02E9, r25	; 0x8002e9 <portTickRateHz+0x1>
     7d8:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <portTickRateHz>
     7dc:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <ticksRemainingInSec+0x1>
     7e0:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <ticksRemainingInSec>
     7e4:	8d e4       	ldi	r24, 0x4D	; 77
     7e6:	87 bd       	out	0x27, r24	; 39
     7e8:	82 e0       	ldi	r24, 0x02	; 2
     7ea:	84 bd       	out	0x24, r24	; 36
     7ec:	85 e0       	ldi	r24, 0x05	; 5
     7ee:	85 bd       	out	0x25, r24	; 37
     7f0:	ee e6       	ldi	r30, 0x6E	; 110
     7f2:	f0 e0       	ldi	r31, 0x00	; 0
     7f4:	80 81       	ld	r24, Z
     7f6:	82 60       	ori	r24, 0x02	; 2
     7f8:	80 83       	st	Z, r24
     7fa:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
     7fe:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
     802:	cd 91       	ld	r28, X+
     804:	cd bf       	out	0x3d, r28	; 61
     806:	dd 91       	ld	r29, X+
     808:	de bf       	out	0x3e, r29	; 62
     80a:	ff 91       	pop	r31
     80c:	ef 91       	pop	r30
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	bf 91       	pop	r27
     814:	af 91       	pop	r26
     816:	9f 91       	pop	r25
     818:	8f 91       	pop	r24
     81a:	7f 91       	pop	r23
     81c:	6f 91       	pop	r22
     81e:	5f 91       	pop	r21
     820:	4f 91       	pop	r20
     822:	3f 91       	pop	r19
     824:	2f 91       	pop	r18
     826:	1f 91       	pop	r17
     828:	0f 91       	pop	r16
     82a:	ff 90       	pop	r15
     82c:	ef 90       	pop	r14
     82e:	df 90       	pop	r13
     830:	cf 90       	pop	r12
     832:	bf 90       	pop	r11
     834:	af 90       	pop	r10
     836:	9f 90       	pop	r9
     838:	8f 90       	pop	r8
     83a:	7f 90       	pop	r7
     83c:	6f 90       	pop	r6
     83e:	5f 90       	pop	r5
     840:	4f 90       	pop	r4
     842:	3f 90       	pop	r3
     844:	2f 90       	pop	r2
     846:	1f 90       	pop	r1
     848:	0f 90       	pop	r0
     84a:	0c be       	out	0x3c, r0	; 60
     84c:	0f 90       	pop	r0
     84e:	0b be       	out	0x3b, r0	; 59
     850:	0f 90       	pop	r0
     852:	0f be       	out	0x3f, r0	; 63
     854:	0f 90       	pop	r0
     856:	08 95       	ret
     858:	81 e0       	ldi	r24, 0x01	; 1
     85a:	08 95       	ret

0000085c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     85c:	0f 92       	push	r0
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	0b b6       	in	r0, 0x3b	; 59
     866:	0f 92       	push	r0
     868:	0c b6       	in	r0, 0x3c	; 60
     86a:	0f 92       	push	r0
     86c:	1f 92       	push	r1
     86e:	11 24       	eor	r1, r1
     870:	2f 92       	push	r2
     872:	3f 92       	push	r3
     874:	4f 92       	push	r4
     876:	5f 92       	push	r5
     878:	6f 92       	push	r6
     87a:	7f 92       	push	r7
     87c:	8f 92       	push	r8
     87e:	9f 92       	push	r9
     880:	af 92       	push	r10
     882:	bf 92       	push	r11
     884:	cf 92       	push	r12
     886:	df 92       	push	r13
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	2f 93       	push	r18
     892:	3f 93       	push	r19
     894:	4f 93       	push	r20
     896:	5f 93       	push	r21
     898:	6f 93       	push	r22
     89a:	7f 93       	push	r23
     89c:	8f 93       	push	r24
     89e:	9f 93       	push	r25
     8a0:	af 93       	push	r26
     8a2:	bf 93       	push	r27
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	ef 93       	push	r30
     8aa:	ff 93       	push	r31
     8ac:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
     8b0:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
     8b4:	0d b6       	in	r0, 0x3d	; 61
     8b6:	0d 92       	st	X+, r0
     8b8:	0e b6       	in	r0, 0x3e	; 62
     8ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     8bc:	0e 94 a1 0c 	call	0x1942	; 0x1942 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     8c0:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
     8c4:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
     8c8:	cd 91       	ld	r28, X+
     8ca:	cd bf       	out	0x3d, r28	; 61
     8cc:	dd 91       	ld	r29, X+
     8ce:	de bf       	out	0x3e, r29	; 62
     8d0:	ff 91       	pop	r31
     8d2:	ef 91       	pop	r30
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	bf 91       	pop	r27
     8da:	af 91       	pop	r26
     8dc:	9f 91       	pop	r25
     8de:	8f 91       	pop	r24
     8e0:	7f 91       	pop	r23
     8e2:	6f 91       	pop	r22
     8e4:	5f 91       	pop	r21
     8e6:	4f 91       	pop	r20
     8e8:	3f 91       	pop	r19
     8ea:	2f 91       	pop	r18
     8ec:	1f 91       	pop	r17
     8ee:	0f 91       	pop	r16
     8f0:	ff 90       	pop	r15
     8f2:	ef 90       	pop	r14
     8f4:	df 90       	pop	r13
     8f6:	cf 90       	pop	r12
     8f8:	bf 90       	pop	r11
     8fa:	af 90       	pop	r10
     8fc:	9f 90       	pop	r9
     8fe:	8f 90       	pop	r8
     900:	7f 90       	pop	r7
     902:	6f 90       	pop	r6
     904:	5f 90       	pop	r5
     906:	4f 90       	pop	r4
     908:	3f 90       	pop	r3
     90a:	2f 90       	pop	r2
     90c:	1f 90       	pop	r1
     90e:	0f 90       	pop	r0
     910:	0c be       	out	0x3c, r0	; 60
     912:	0f 90       	pop	r0
     914:	0b be       	out	0x3b, r0	; 59
     916:	0f 90       	pop	r0
     918:	0f be       	out	0x3f, r0	; 63
     91a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     91c:	08 95       	ret

0000091e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     91e:	0f 92       	push	r0
     920:	0f b6       	in	r0, 0x3f	; 63
     922:	f8 94       	cli
     924:	0f 92       	push	r0
     926:	0b b6       	in	r0, 0x3b	; 59
     928:	0f 92       	push	r0
     92a:	0c b6       	in	r0, 0x3c	; 60
     92c:	0f 92       	push	r0
     92e:	1f 92       	push	r1
     930:	11 24       	eor	r1, r1
     932:	2f 92       	push	r2
     934:	3f 92       	push	r3
     936:	4f 92       	push	r4
     938:	5f 92       	push	r5
     93a:	6f 92       	push	r6
     93c:	7f 92       	push	r7
     93e:	8f 92       	push	r8
     940:	9f 92       	push	r9
     942:	af 92       	push	r10
     944:	bf 92       	push	r11
     946:	cf 92       	push	r12
     948:	df 92       	push	r13
     94a:	ef 92       	push	r14
     94c:	ff 92       	push	r15
     94e:	0f 93       	push	r16
     950:	1f 93       	push	r17
     952:	2f 93       	push	r18
     954:	3f 93       	push	r19
     956:	4f 93       	push	r20
     958:	5f 93       	push	r21
     95a:	6f 93       	push	r22
     95c:	7f 93       	push	r23
     95e:	8f 93       	push	r24
     960:	9f 93       	push	r25
     962:	af 93       	push	r26
     964:	bf 93       	push	r27
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	ef 93       	push	r30
     96c:	ff 93       	push	r31
     96e:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
     972:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
     976:	0d b6       	in	r0, 0x3d	; 61
     978:	0d 92       	st	X+, r0
     97a:	0e b6       	in	r0, 0x3e	; 62
     97c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     97e:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
     980:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <ticksRemainingInSec>
     984:	90 91 eb 02 	lds	r25, 0x02EB	; 0x8002eb <ticksRemainingInSec+0x1>
     988:	01 97       	sbiw	r24, 0x01	; 1
     98a:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <ticksRemainingInSec+0x1>
     98e:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <ticksRemainingInSec>
     992:	89 2b       	or	r24, r25
     994:	49 f4       	brne	.+18     	; 0x9a8 <vPortYieldFromTick+0x8a>
	{
		system_tick();
     996:	c3 dc       	rcall	.-1658   	; 0x31e <system_tick>
		ticksRemainingInSec = portTickRateHz;
     998:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <portTickRateHz>
     99c:	90 91 e9 02 	lds	r25, 0x02E9	; 0x8002e9 <portTickRateHz+0x1>
     9a0:	90 93 eb 02 	sts	0x02EB, r25	; 0x8002eb <ticksRemainingInSec+0x1>
     9a4:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
     9a8:	95 d6       	rcall	.+3370   	; 0x16d4 <xTaskIncrementTick>
	{
		vTaskSwitchContext();
     9aa:	81 11       	cpse	r24, r1
     9ac:	ca d7       	rcall	.+3988   	; 0x1942 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
     9ae:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
     9b2:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
     9b6:	cd 91       	ld	r28, X+
     9b8:	cd bf       	out	0x3d, r28	; 61
     9ba:	dd 91       	ld	r29, X+
     9bc:	de bf       	out	0x3e, r29	; 62
     9be:	ff 91       	pop	r31
     9c0:	ef 91       	pop	r30
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	bf 91       	pop	r27
     9c8:	af 91       	pop	r26
     9ca:	9f 91       	pop	r25
     9cc:	8f 91       	pop	r24
     9ce:	7f 91       	pop	r23
     9d0:	6f 91       	pop	r22
     9d2:	5f 91       	pop	r21
     9d4:	4f 91       	pop	r20
     9d6:	3f 91       	pop	r19
     9d8:	2f 91       	pop	r18
     9da:	1f 91       	pop	r17
     9dc:	0f 91       	pop	r16
     9de:	ff 90       	pop	r15
     9e0:	ef 90       	pop	r14
     9e2:	df 90       	pop	r13
     9e4:	cf 90       	pop	r12
     9e6:	bf 90       	pop	r11
     9e8:	af 90       	pop	r10
     9ea:	9f 90       	pop	r9
     9ec:	8f 90       	pop	r8
     9ee:	7f 90       	pop	r7
     9f0:	6f 90       	pop	r6
     9f2:	5f 90       	pop	r5
     9f4:	4f 90       	pop	r4
     9f6:	3f 90       	pop	r3
     9f8:	2f 90       	pop	r2
     9fa:	1f 90       	pop	r1
     9fc:	0f 90       	pop	r0
     9fe:	0c be       	out	0x3c, r0	; 60
     a00:	0f 90       	pop	r0
     a02:	0b be       	out	0x3b, r0	; 59
     a04:	0f 90       	pop	r0
     a06:	0f be       	out	0x3f, r0	; 63
     a08:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     a0a:	08 95       	ret

00000a0c <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     a0c:	88 df       	rcall	.-240    	; 0x91e <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     a0e:	18 95       	reti

00000a10 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     a10:	0f b6       	in	r0, 0x3f	; 63
     a12:	f8 94       	cli
     a14:	0f 92       	push	r0
     a16:	fc 01       	movw	r30, r24
     a18:	92 8d       	ldd	r25, Z+26	; 0x1a
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	91 11       	cpse	r25, r1
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	08 95       	ret

00000a26 <prvCopyDataToQueue>:
     a26:	0f 93       	push	r16
     a28:	1f 93       	push	r17
     a2a:	cf 93       	push	r28
     a2c:	df 93       	push	r29
     a2e:	ec 01       	movw	r28, r24
     a30:	04 2f       	mov	r16, r20
     a32:	1a 8d       	ldd	r17, Y+26	; 0x1a
     a34:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a36:	41 11       	cpse	r20, r1
     a38:	0c c0       	rjmp	.+24     	; 0xa52 <prvCopyDataToQueue+0x2c>
     a3a:	88 81       	ld	r24, Y
     a3c:	99 81       	ldd	r25, Y+1	; 0x01
     a3e:	89 2b       	or	r24, r25
     a40:	09 f0       	breq	.+2      	; 0xa44 <prvCopyDataToQueue+0x1e>
     a42:	42 c0       	rjmp	.+132    	; 0xac8 <prvCopyDataToQueue+0xa2>
     a44:	8a 81       	ldd	r24, Y+2	; 0x02
     a46:	9b 81       	ldd	r25, Y+3	; 0x03
     a48:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskPriorityDisinherit>
     a4c:	1b 82       	std	Y+3, r1	; 0x03
     a4e:	1a 82       	std	Y+2, r1	; 0x02
     a50:	42 c0       	rjmp	.+132    	; 0xad6 <prvCopyDataToQueue+0xb0>
     a52:	01 11       	cpse	r16, r1
     a54:	17 c0       	rjmp	.+46     	; 0xa84 <prvCopyDataToQueue+0x5e>
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	8c 81       	ldd	r24, Y+4	; 0x04
     a5a:	9d 81       	ldd	r25, Y+5	; 0x05
     a5c:	0e 94 be 13 	call	0x277c	; 0x277c <memcpy>
     a60:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a62:	8c 81       	ldd	r24, Y+4	; 0x04
     a64:	9d 81       	ldd	r25, Y+5	; 0x05
     a66:	82 0f       	add	r24, r18
     a68:	91 1d       	adc	r25, r1
     a6a:	9d 83       	std	Y+5, r25	; 0x05
     a6c:	8c 83       	std	Y+4, r24	; 0x04
     a6e:	2a 81       	ldd	r18, Y+2	; 0x02
     a70:	3b 81       	ldd	r19, Y+3	; 0x03
     a72:	82 17       	cp	r24, r18
     a74:	93 07       	cpc	r25, r19
     a76:	50 f1       	brcs	.+84     	; 0xacc <prvCopyDataToQueue+0xa6>
     a78:	88 81       	ld	r24, Y
     a7a:	99 81       	ldd	r25, Y+1	; 0x01
     a7c:	9d 83       	std	Y+5, r25	; 0x05
     a7e:	8c 83       	std	Y+4, r24	; 0x04
     a80:	80 e0       	ldi	r24, 0x00	; 0
     a82:	29 c0       	rjmp	.+82     	; 0xad6 <prvCopyDataToQueue+0xb0>
     a84:	50 e0       	ldi	r21, 0x00	; 0
     a86:	8e 81       	ldd	r24, Y+6	; 0x06
     a88:	9f 81       	ldd	r25, Y+7	; 0x07
     a8a:	0e 94 be 13 	call	0x277c	; 0x277c <memcpy>
     a8e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	91 95       	neg	r25
     a94:	81 95       	neg	r24
     a96:	91 09       	sbc	r25, r1
     a98:	2e 81       	ldd	r18, Y+6	; 0x06
     a9a:	3f 81       	ldd	r19, Y+7	; 0x07
     a9c:	28 0f       	add	r18, r24
     a9e:	39 1f       	adc	r19, r25
     aa0:	3f 83       	std	Y+7, r19	; 0x07
     aa2:	2e 83       	std	Y+6, r18	; 0x06
     aa4:	48 81       	ld	r20, Y
     aa6:	59 81       	ldd	r21, Y+1	; 0x01
     aa8:	24 17       	cp	r18, r20
     aaa:	35 07       	cpc	r19, r21
     aac:	30 f4       	brcc	.+12     	; 0xaba <prvCopyDataToQueue+0x94>
     aae:	2a 81       	ldd	r18, Y+2	; 0x02
     ab0:	3b 81       	ldd	r19, Y+3	; 0x03
     ab2:	82 0f       	add	r24, r18
     ab4:	93 1f       	adc	r25, r19
     ab6:	9f 83       	std	Y+7, r25	; 0x07
     ab8:	8e 83       	std	Y+6, r24	; 0x06
     aba:	02 30       	cpi	r16, 0x02	; 2
     abc:	49 f4       	brne	.+18     	; 0xad0 <prvCopyDataToQueue+0xaa>
     abe:	11 23       	and	r17, r17
     ac0:	49 f0       	breq	.+18     	; 0xad4 <prvCopyDataToQueue+0xae>
     ac2:	11 50       	subi	r17, 0x01	; 1
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	07 c0       	rjmp	.+14     	; 0xad6 <prvCopyDataToQueue+0xb0>
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	05 c0       	rjmp	.+10     	; 0xad6 <prvCopyDataToQueue+0xb0>
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	03 c0       	rjmp	.+6      	; 0xad6 <prvCopyDataToQueue+0xb0>
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	01 c0       	rjmp	.+2      	; 0xad6 <prvCopyDataToQueue+0xb0>
     ad4:	80 e0       	ldi	r24, 0x00	; 0
     ad6:	1f 5f       	subi	r17, 0xFF	; 255
     ad8:	1a 8f       	std	Y+26, r17	; 0x1a
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	1f 91       	pop	r17
     ae0:	0f 91       	pop	r16
     ae2:	08 95       	ret

00000ae4 <prvCopyDataFromQueue>:
     ae4:	fc 01       	movw	r30, r24
     ae6:	44 8d       	ldd	r20, Z+28	; 0x1c
     ae8:	44 23       	and	r20, r20
     aea:	a9 f0       	breq	.+42     	; 0xb16 <prvCopyDataFromQueue+0x32>
     aec:	50 e0       	ldi	r21, 0x00	; 0
     aee:	26 81       	ldd	r18, Z+6	; 0x06
     af0:	37 81       	ldd	r19, Z+7	; 0x07
     af2:	24 0f       	add	r18, r20
     af4:	35 1f       	adc	r19, r21
     af6:	37 83       	std	Z+7, r19	; 0x07
     af8:	26 83       	std	Z+6, r18	; 0x06
     afa:	82 81       	ldd	r24, Z+2	; 0x02
     afc:	93 81       	ldd	r25, Z+3	; 0x03
     afe:	28 17       	cp	r18, r24
     b00:	39 07       	cpc	r19, r25
     b02:	20 f0       	brcs	.+8      	; 0xb0c <prvCopyDataFromQueue+0x28>
     b04:	80 81       	ld	r24, Z
     b06:	91 81       	ldd	r25, Z+1	; 0x01
     b08:	97 83       	std	Z+7, r25	; 0x07
     b0a:	86 83       	std	Z+6, r24	; 0x06
     b0c:	cb 01       	movw	r24, r22
     b0e:	66 81       	ldd	r22, Z+6	; 0x06
     b10:	77 81       	ldd	r23, Z+7	; 0x07
     b12:	0c 94 be 13 	jmp	0x277c	; 0x277c <memcpy>
     b16:	08 95       	ret

00000b18 <prvUnlockQueue>:
     b18:	ef 92       	push	r14
     b1a:	ff 92       	push	r15
     b1c:	0f 93       	push	r16
     b1e:	1f 93       	push	r17
     b20:	cf 93       	push	r28
     b22:	8c 01       	movw	r16, r24
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	0f 92       	push	r0
     b2a:	fc 01       	movw	r30, r24
     b2c:	c6 8d       	ldd	r28, Z+30	; 0x1e
     b2e:	1c 16       	cp	r1, r28
     b30:	a4 f4       	brge	.+40     	; 0xb5a <prvUnlockQueue+0x42>
     b32:	81 89       	ldd	r24, Z+17	; 0x11
     b34:	81 11       	cpse	r24, r1
     b36:	06 c0       	rjmp	.+12     	; 0xb44 <prvUnlockQueue+0x2c>
     b38:	10 c0       	rjmp	.+32     	; 0xb5a <prvUnlockQueue+0x42>
     b3a:	f8 01       	movw	r30, r16
     b3c:	81 89       	ldd	r24, Z+17	; 0x11
     b3e:	81 11       	cpse	r24, r1
     b40:	05 c0       	rjmp	.+10     	; 0xb4c <prvUnlockQueue+0x34>
     b42:	0b c0       	rjmp	.+22     	; 0xb5a <prvUnlockQueue+0x42>
     b44:	78 01       	movw	r14, r16
     b46:	f1 e1       	ldi	r31, 0x11	; 17
     b48:	ef 0e       	add	r14, r31
     b4a:	f1 1c       	adc	r15, r1
     b4c:	c7 01       	movw	r24, r14
     b4e:	8b d7       	rcall	.+3862   	; 0x1a66 <xTaskRemoveFromEventList>
     b50:	81 11       	cpse	r24, r1
     b52:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <vTaskMissedYield>
     b56:	c1 50       	subi	r28, 0x01	; 1
     b58:	81 f7       	brne	.-32     	; 0xb3a <prvUnlockQueue+0x22>
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	f8 01       	movw	r30, r16
     b5e:	86 8f       	std	Z+30, r24	; 0x1e
     b60:	0f 90       	pop	r0
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	0f b6       	in	r0, 0x3f	; 63
     b66:	f8 94       	cli
     b68:	0f 92       	push	r0
     b6a:	c5 8d       	ldd	r28, Z+29	; 0x1d
     b6c:	1c 16       	cp	r1, r28
     b6e:	9c f4       	brge	.+38     	; 0xb96 <prvUnlockQueue+0x7e>
     b70:	80 85       	ldd	r24, Z+8	; 0x08
     b72:	81 11       	cpse	r24, r1
     b74:	06 c0       	rjmp	.+12     	; 0xb82 <prvUnlockQueue+0x6a>
     b76:	0f c0       	rjmp	.+30     	; 0xb96 <prvUnlockQueue+0x7e>
     b78:	f8 01       	movw	r30, r16
     b7a:	80 85       	ldd	r24, Z+8	; 0x08
     b7c:	81 11       	cpse	r24, r1
     b7e:	05 c0       	rjmp	.+10     	; 0xb8a <prvUnlockQueue+0x72>
     b80:	0a c0       	rjmp	.+20     	; 0xb96 <prvUnlockQueue+0x7e>
     b82:	78 01       	movw	r14, r16
     b84:	f8 e0       	ldi	r31, 0x08	; 8
     b86:	ef 0e       	add	r14, r31
     b88:	f1 1c       	adc	r15, r1
     b8a:	c7 01       	movw	r24, r14
     b8c:	6c d7       	rcall	.+3800   	; 0x1a66 <xTaskRemoveFromEventList>
     b8e:	81 11       	cpse	r24, r1
     b90:	f5 d7       	rcall	.+4074   	; 0x1b7c <vTaskMissedYield>
     b92:	c1 50       	subi	r28, 0x01	; 1
     b94:	89 f7       	brne	.-30     	; 0xb78 <prvUnlockQueue+0x60>
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	f8 01       	movw	r30, r16
     b9a:	85 8f       	std	Z+29, r24	; 0x1d
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	cf 91       	pop	r28
     ba2:	1f 91       	pop	r17
     ba4:	0f 91       	pop	r16
     ba6:	ff 90       	pop	r15
     ba8:	ef 90       	pop	r14
     baa:	08 95       	ret

00000bac <xQueueGenericReset>:
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	ec 01       	movw	r28, r24
     bb2:	0f b6       	in	r0, 0x3f	; 63
     bb4:	f8 94       	cli
     bb6:	0f 92       	push	r0
     bb8:	48 81       	ld	r20, Y
     bba:	59 81       	ldd	r21, Y+1	; 0x01
     bbc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	7b 8d       	ldd	r23, Y+27	; 0x1b
     bc2:	72 9f       	mul	r23, r18
     bc4:	c0 01       	movw	r24, r0
     bc6:	73 9f       	mul	r23, r19
     bc8:	90 0d       	add	r25, r0
     bca:	11 24       	eor	r1, r1
     bcc:	fa 01       	movw	r30, r20
     bce:	e8 0f       	add	r30, r24
     bd0:	f9 1f       	adc	r31, r25
     bd2:	fb 83       	std	Y+3, r31	; 0x03
     bd4:	ea 83       	std	Y+2, r30	; 0x02
     bd6:	1a 8e       	std	Y+26, r1	; 0x1a
     bd8:	5d 83       	std	Y+5, r21	; 0x05
     bda:	4c 83       	std	Y+4, r20	; 0x04
     bdc:	82 1b       	sub	r24, r18
     bde:	93 0b       	sbc	r25, r19
     be0:	84 0f       	add	r24, r20
     be2:	95 1f       	adc	r25, r21
     be4:	9f 83       	std	Y+7, r25	; 0x07
     be6:	8e 83       	std	Y+6, r24	; 0x06
     be8:	8f ef       	ldi	r24, 0xFF	; 255
     bea:	8d 8f       	std	Y+29, r24	; 0x1d
     bec:	8e 8f       	std	Y+30, r24	; 0x1e
     bee:	61 11       	cpse	r22, r1
     bf0:	0a c0       	rjmp	.+20     	; 0xc06 <xQueueGenericReset+0x5a>
     bf2:	88 85       	ldd	r24, Y+8	; 0x08
     bf4:	88 23       	and	r24, r24
     bf6:	69 f0       	breq	.+26     	; 0xc12 <xQueueGenericReset+0x66>
     bf8:	ce 01       	movw	r24, r28
     bfa:	08 96       	adiw	r24, 0x08	; 8
     bfc:	34 d7       	rcall	.+3688   	; 0x1a66 <xTaskRemoveFromEventList>
     bfe:	88 23       	and	r24, r24
     c00:	41 f0       	breq	.+16     	; 0xc12 <xQueueGenericReset+0x66>
     c02:	2c de       	rcall	.-936    	; 0x85c <vPortYield>
     c04:	06 c0       	rjmp	.+12     	; 0xc12 <xQueueGenericReset+0x66>
     c06:	ce 01       	movw	r24, r28
     c08:	08 96       	adiw	r24, 0x08	; 8
     c0a:	e6 dc       	rcall	.-1588   	; 0x5d8 <vListInitialise>
     c0c:	ce 01       	movw	r24, r28
     c0e:	41 96       	adiw	r24, 0x11	; 17
     c10:	e3 dc       	rcall	.-1594   	; 0x5d8 <vListInitialise>
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	08 95       	ret

00000c1e <xQueueGenericCreate>:
     c1e:	0f 93       	push	r16
     c20:	1f 93       	push	r17
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	08 2f       	mov	r16, r24
     c28:	16 2f       	mov	r17, r22
     c2a:	66 23       	and	r22, r22
     c2c:	b1 f0       	breq	.+44     	; 0xc5a <xQueueGenericCreate+0x3c>
     c2e:	86 9f       	mul	r24, r22
     c30:	c0 01       	movw	r24, r0
     c32:	11 24       	eor	r1, r1
     c34:	4f 96       	adiw	r24, 0x1f	; 31
     c36:	8f db       	rcall	.-2274   	; 0x356 <pvPortMalloc>
     c38:	ec 01       	movw	r28, r24
     c3a:	00 97       	sbiw	r24, 0x00	; 0
     c3c:	39 f4       	brne	.+14     	; 0xc4c <xQueueGenericCreate+0x2e>
     c3e:	13 c0       	rjmp	.+38     	; 0xc66 <xQueueGenericCreate+0x48>
     c40:	0b 8f       	std	Y+27, r16	; 0x1b
     c42:	1c 8f       	std	Y+28, r17	; 0x1c
     c44:	61 e0       	ldi	r22, 0x01	; 1
     c46:	ce 01       	movw	r24, r28
     c48:	b1 df       	rcall	.-158    	; 0xbac <xQueueGenericReset>
     c4a:	0d c0       	rjmp	.+26     	; 0xc66 <xQueueGenericCreate+0x48>
     c4c:	4f 96       	adiw	r24, 0x1f	; 31
     c4e:	99 83       	std	Y+1, r25	; 0x01
     c50:	88 83       	st	Y, r24
     c52:	f6 cf       	rjmp	.-20     	; 0xc40 <xQueueGenericCreate+0x22>
     c54:	d9 83       	std	Y+1, r29	; 0x01
     c56:	c8 83       	st	Y, r28
     c58:	f3 cf       	rjmp	.-26     	; 0xc40 <xQueueGenericCreate+0x22>
     c5a:	8f e1       	ldi	r24, 0x1F	; 31
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	7b db       	rcall	.-2314   	; 0x356 <pvPortMalloc>
     c60:	ec 01       	movw	r28, r24
     c62:	89 2b       	or	r24, r25
     c64:	b9 f7       	brne	.-18     	; 0xc54 <xQueueGenericCreate+0x36>
     c66:	ce 01       	movw	r24, r28
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	1f 91       	pop	r17
     c6e:	0f 91       	pop	r16
     c70:	08 95       	ret

00000c72 <xQueueGenericSend>:
     c72:	9f 92       	push	r9
     c74:	af 92       	push	r10
     c76:	bf 92       	push	r11
     c78:	cf 92       	push	r12
     c7a:	df 92       	push	r13
     c7c:	ef 92       	push	r14
     c7e:	ff 92       	push	r15
     c80:	0f 93       	push	r16
     c82:	1f 93       	push	r17
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
     c88:	00 d0       	rcall	.+0      	; 0xc8a <xQueueGenericSend+0x18>
     c8a:	1f 92       	push	r1
     c8c:	1f 92       	push	r1
     c8e:	cd b7       	in	r28, 0x3d	; 61
     c90:	de b7       	in	r29, 0x3e	; 62
     c92:	8c 01       	movw	r16, r24
     c94:	6b 01       	movw	r12, r22
     c96:	5d 83       	std	Y+5, r21	; 0x05
     c98:	4c 83       	std	Y+4, r20	; 0x04
     c9a:	a2 2e       	mov	r10, r18
     c9c:	b1 2c       	mov	r11, r1
     c9e:	99 24       	eor	r9, r9
     ca0:	93 94       	inc	r9
     ca2:	7c 01       	movw	r14, r24
     ca4:	88 e0       	ldi	r24, 0x08	; 8
     ca6:	e8 0e       	add	r14, r24
     ca8:	f1 1c       	adc	r15, r1
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
     cb0:	f8 01       	movw	r30, r16
     cb2:	92 8d       	ldd	r25, Z+26	; 0x1a
     cb4:	83 8d       	ldd	r24, Z+27	; 0x1b
     cb6:	98 17       	cp	r25, r24
     cb8:	18 f0       	brcs	.+6      	; 0xcc0 <xQueueGenericSend+0x4e>
     cba:	f2 e0       	ldi	r31, 0x02	; 2
     cbc:	af 12       	cpse	r10, r31
     cbe:	15 c0       	rjmp	.+42     	; 0xcea <xQueueGenericSend+0x78>
     cc0:	4a 2d       	mov	r20, r10
     cc2:	b6 01       	movw	r22, r12
     cc4:	c8 01       	movw	r24, r16
     cc6:	af de       	rcall	.-674    	; 0xa26 <prvCopyDataToQueue>
     cc8:	f8 01       	movw	r30, r16
     cca:	91 89       	ldd	r25, Z+17	; 0x11
     ccc:	99 23       	and	r25, r25
     cce:	39 f0       	breq	.+14     	; 0xcde <xQueueGenericSend+0x6c>
     cd0:	c8 01       	movw	r24, r16
     cd2:	41 96       	adiw	r24, 0x11	; 17
     cd4:	c8 d6       	rcall	.+3472   	; 0x1a66 <xTaskRemoveFromEventList>
     cd6:	88 23       	and	r24, r24
     cd8:	21 f0       	breq	.+8      	; 0xce2 <xQueueGenericSend+0x70>
     cda:	c0 dd       	rcall	.-1152   	; 0x85c <vPortYield>
     cdc:	02 c0       	rjmp	.+4      	; 0xce2 <xQueueGenericSend+0x70>
     cde:	81 11       	cpse	r24, r1
     ce0:	bd dd       	rcall	.-1158   	; 0x85c <vPortYield>
     ce2:	0f 90       	pop	r0
     ce4:	0f be       	out	0x3f, r0	; 63
     ce6:	81 e0       	ldi	r24, 0x01	; 1
     ce8:	45 c0       	rjmp	.+138    	; 0xd74 <xQueueGenericSend+0x102>
     cea:	8c 81       	ldd	r24, Y+4	; 0x04
     cec:	9d 81       	ldd	r25, Y+5	; 0x05
     cee:	89 2b       	or	r24, r25
     cf0:	21 f4       	brne	.+8      	; 0xcfa <xQueueGenericSend+0x88>
     cf2:	0f 90       	pop	r0
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	3d c0       	rjmp	.+122    	; 0xd74 <xQueueGenericSend+0x102>
     cfa:	b1 10       	cpse	r11, r1
     cfc:	04 c0       	rjmp	.+8      	; 0xd06 <xQueueGenericSend+0x94>
     cfe:	ce 01       	movw	r24, r28
     d00:	01 96       	adiw	r24, 0x01	; 1
     d02:	f9 d6       	rcall	.+3570   	; 0x1af6 <vTaskSetTimeOutState>
     d04:	b9 2c       	mov	r11, r9
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63
     d0a:	de d4       	rcall	.+2492   	; 0x16c8 <vTaskSuspendAll>
     d0c:	0f b6       	in	r0, 0x3f	; 63
     d0e:	f8 94       	cli
     d10:	0f 92       	push	r0
     d12:	f8 01       	movw	r30, r16
     d14:	85 8d       	ldd	r24, Z+29	; 0x1d
     d16:	8f 3f       	cpi	r24, 0xFF	; 255
     d18:	09 f4       	brne	.+2      	; 0xd1c <xQueueGenericSend+0xaa>
     d1a:	15 8e       	std	Z+29, r1	; 0x1d
     d1c:	f8 01       	movw	r30, r16
     d1e:	86 8d       	ldd	r24, Z+30	; 0x1e
     d20:	8f 3f       	cpi	r24, 0xFF	; 255
     d22:	09 f4       	brne	.+2      	; 0xd26 <xQueueGenericSend+0xb4>
     d24:	16 8e       	std	Z+30, r1	; 0x1e
     d26:	0f 90       	pop	r0
     d28:	0f be       	out	0x3f, r0	; 63
     d2a:	be 01       	movw	r22, r28
     d2c:	6c 5f       	subi	r22, 0xFC	; 252
     d2e:	7f 4f       	sbci	r23, 0xFF	; 255
     d30:	ce 01       	movw	r24, r28
     d32:	01 96       	adiw	r24, 0x01	; 1
     d34:	eb d6       	rcall	.+3542   	; 0x1b0c <xTaskCheckForTimeOut>
     d36:	81 11       	cpse	r24, r1
     d38:	19 c0       	rjmp	.+50     	; 0xd6c <xQueueGenericSend+0xfa>
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	f8 94       	cli
     d3e:	0f 92       	push	r0
     d40:	f8 01       	movw	r30, r16
     d42:	92 8d       	ldd	r25, Z+26	; 0x1a
     d44:	83 8d       	ldd	r24, Z+27	; 0x1b
     d46:	0f 90       	pop	r0
     d48:	0f be       	out	0x3f, r0	; 63
     d4a:	98 13       	cpse	r25, r24
     d4c:	0b c0       	rjmp	.+22     	; 0xd64 <xQueueGenericSend+0xf2>
     d4e:	6c 81       	ldd	r22, Y+4	; 0x04
     d50:	7d 81       	ldd	r23, Y+5	; 0x05
     d52:	c7 01       	movw	r24, r14
     d54:	77 d6       	rcall	.+3310   	; 0x1a44 <vTaskPlaceOnEventList>
     d56:	c8 01       	movw	r24, r16
     d58:	df de       	rcall	.-578    	; 0xb18 <prvUnlockQueue>
     d5a:	76 d5       	rcall	.+2796   	; 0x1848 <xTaskResumeAll>
     d5c:	81 11       	cpse	r24, r1
     d5e:	a5 cf       	rjmp	.-182    	; 0xcaa <xQueueGenericSend+0x38>
     d60:	7d dd       	rcall	.-1286   	; 0x85c <vPortYield>
     d62:	a3 cf       	rjmp	.-186    	; 0xcaa <xQueueGenericSend+0x38>
     d64:	c8 01       	movw	r24, r16
     d66:	d8 de       	rcall	.-592    	; 0xb18 <prvUnlockQueue>
     d68:	6f d5       	rcall	.+2782   	; 0x1848 <xTaskResumeAll>
     d6a:	9f cf       	rjmp	.-194    	; 0xcaa <xQueueGenericSend+0x38>
     d6c:	c8 01       	movw	r24, r16
     d6e:	d4 de       	rcall	.-600    	; 0xb18 <prvUnlockQueue>
     d70:	6b d5       	rcall	.+2774   	; 0x1848 <xTaskResumeAll>
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	0f 90       	pop	r0
     d76:	0f 90       	pop	r0
     d78:	0f 90       	pop	r0
     d7a:	0f 90       	pop	r0
     d7c:	0f 90       	pop	r0
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	ff 90       	pop	r15
     d88:	ef 90       	pop	r14
     d8a:	df 90       	pop	r13
     d8c:	cf 90       	pop	r12
     d8e:	bf 90       	pop	r11
     d90:	af 90       	pop	r10
     d92:	9f 90       	pop	r9
     d94:	08 95       	ret

00000d96 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     d96:	8f 92       	push	r8
     d98:	9f 92       	push	r9
     d9a:	af 92       	push	r10
     d9c:	bf 92       	push	r11
     d9e:	cf 92       	push	r12
     da0:	df 92       	push	r13
     da2:	ef 92       	push	r14
     da4:	ff 92       	push	r15
     da6:	0f 93       	push	r16
     da8:	1f 93       	push	r17
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <xQueueGenericReceive+0x1a>
     db0:	1f 92       	push	r1
     db2:	1f 92       	push	r1
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
     db8:	8c 01       	movw	r16, r24
     dba:	5b 01       	movw	r10, r22
     dbc:	5d 83       	std	Y+5, r21	; 0x05
     dbe:	4c 83       	std	Y+4, r20	; 0x04
     dc0:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     dc2:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     dc4:	99 24       	eor	r9, r9
     dc6:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     dc8:	6c 01       	movw	r12, r24
     dca:	81 e1       	ldi	r24, 0x11	; 17
     dcc:	c8 0e       	add	r12, r24
     dce:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dd6:	f8 01       	movw	r30, r16
     dd8:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     dda:	ff 20       	and	r15, r15
     ddc:	61 f1       	breq	.+88     	; 0xe36 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     dde:	c6 80       	ldd	r12, Z+6	; 0x06
     de0:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     de2:	b5 01       	movw	r22, r10
     de4:	c8 01       	movw	r24, r16
     de6:	7e de       	rcall	.-772    	; 0xae4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     de8:	81 10       	cpse	r8, r1
     dea:	16 c0       	rjmp	.+44     	; 0xe18 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     dec:	fa 94       	dec	r15
     dee:	f8 01       	movw	r30, r16
     df0:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     df2:	80 81       	ld	r24, Z
     df4:	91 81       	ldd	r25, Z+1	; 0x01
     df6:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     df8:	21 f4       	brne	.+8      	; 0xe02 <xQueueGenericReceive+0x6c>
     dfa:	66 d7       	rcall	.+3788   	; 0x1cc8 <pvTaskIncrementMutexHeldCount>
     dfc:	f8 01       	movw	r30, r16
     dfe:	93 83       	std	Z+3, r25	; 0x03
     e00:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e02:	f8 01       	movw	r30, r16
     e04:	80 85       	ldd	r24, Z+8	; 0x08
     e06:	88 23       	and	r24, r24
     e08:	91 f0       	breq	.+36     	; 0xe2e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e0a:	c8 01       	movw	r24, r16
     e0c:	08 96       	adiw	r24, 0x08	; 8
     e0e:	2b d6       	rcall	.+3158   	; 0x1a66 <xTaskRemoveFromEventList>
     e10:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     e12:	69 f0       	breq	.+26     	; 0xe2e <xQueueGenericReceive+0x98>
     e14:	23 dd       	rcall	.-1466   	; 0x85c <vPortYield>
     e16:	0b c0       	rjmp	.+22     	; 0xe2e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     e18:	f8 01       	movw	r30, r16
     e1a:	d7 82       	std	Z+7, r13	; 0x07
     e1c:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e1e:	81 89       	ldd	r24, Z+17	; 0x11
     e20:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e22:	29 f0       	breq	.+10     	; 0xe2e <xQueueGenericReceive+0x98>
     e24:	c8 01       	movw	r24, r16
     e26:	41 96       	adiw	r24, 0x11	; 17
     e28:	1e d6       	rcall	.+3132   	; 0x1a66 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e2a:	81 11       	cpse	r24, r1
     e2c:	17 dd       	rcall	.-1490   	; 0x85c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	51 c0       	rjmp	.+162    	; 0xed8 <xQueueGenericReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e36:	8c 81       	ldd	r24, Y+4	; 0x04
     e38:	9d 81       	ldd	r25, Y+5	; 0x05
     e3a:	89 2b       	or	r24, r25
     e3c:	21 f4       	brne	.+8      	; 0xe46 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e3e:	0f 90       	pop	r0
     e40:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e42:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     e44:	49 c0       	rjmp	.+146    	; 0xed8 <xQueueGenericReceive+0x142>
     e46:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e48:	04 c0       	rjmp	.+8      	; 0xe52 <xQueueGenericReceive+0xbc>
     e4a:	ce 01       	movw	r24, r28
     e4c:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     e4e:	53 d6       	rcall	.+3238   	; 0x1af6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e50:	e9 2c       	mov	r14, r9
     e52:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e54:	0f be       	out	0x3f, r0	; 63
     e56:	38 d4       	rcall	.+2160   	; 0x16c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
     e5e:	f8 01       	movw	r30, r16
     e60:	85 8d       	ldd	r24, Z+29	; 0x1d
     e62:	8f 3f       	cpi	r24, 0xFF	; 255
     e64:	09 f4       	brne	.+2      	; 0xe68 <xQueueGenericReceive+0xd2>
     e66:	15 8e       	std	Z+29, r1	; 0x1d
     e68:	f8 01       	movw	r30, r16
     e6a:	86 8d       	ldd	r24, Z+30	; 0x1e
     e6c:	8f 3f       	cpi	r24, 0xFF	; 255
     e6e:	09 f4       	brne	.+2      	; 0xe72 <xQueueGenericReceive+0xdc>
     e70:	16 8e       	std	Z+30, r1	; 0x1e
     e72:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	be 01       	movw	r22, r28
     e78:	6c 5f       	subi	r22, 0xFC	; 252
     e7a:	7f 4f       	sbci	r23, 0xFF	; 255
     e7c:	ce 01       	movw	r24, r28
     e7e:	01 96       	adiw	r24, 0x01	; 1
     e80:	45 d6       	rcall	.+3210   	; 0x1b0c <xTaskCheckForTimeOut>
     e82:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e84:	20 c0       	rjmp	.+64     	; 0xec6 <xQueueGenericReceive+0x130>
     e86:	c8 01       	movw	r24, r16
     e88:	c3 dd       	rcall	.-1146   	; 0xa10 <prvIsQueueEmpty>
     e8a:	88 23       	and	r24, r24
     e8c:	c1 f0       	breq	.+48     	; 0xebe <xQueueGenericReceive+0x128>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e8e:	f8 01       	movw	r30, r16
     e90:	80 81       	ld	r24, Z
     e92:	91 81       	ldd	r25, Z+1	; 0x01
     e94:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
     e96:	41 f4       	brne	.+16     	; 0xea8 <xQueueGenericReceive+0x112>
     e98:	0f b6       	in	r0, 0x3f	; 63
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     e9a:	f8 94       	cli
     e9c:	0f 92       	push	r0
						}
						taskEXIT_CRITICAL();
     e9e:	82 81       	ldd	r24, Z+2	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ea0:	93 81       	ldd	r25, Z+3	; 0x03
     ea2:	70 d6       	rcall	.+3296   	; 0x1b84 <vTaskPriorityInherit>
     ea4:	0f 90       	pop	r0
				prvUnlockQueue( pxQueue );
     ea6:	0f be       	out	0x3f, r0	; 63
				if( xTaskResumeAll() == pdFALSE )
     ea8:	6c 81       	ldd	r22, Y+4	; 0x04
     eaa:	7d 81       	ldd	r23, Y+5	; 0x05
     eac:	c6 01       	movw	r24, r12
				{
					portYIELD_WITHIN_API();
     eae:	ca d5       	rcall	.+2964   	; 0x1a44 <vTaskPlaceOnEventList>
     eb0:	c8 01       	movw	r24, r16
     eb2:	32 de       	rcall	.-924    	; 0xb18 <prvUnlockQueue>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     eb4:	c9 d4       	rcall	.+2450   	; 0x1848 <xTaskResumeAll>
     eb6:	81 11       	cpse	r24, r1
     eb8:	8b cf       	rjmp	.-234    	; 0xdd0 <xQueueGenericReceive+0x3a>
				( void ) xTaskResumeAll();
     eba:	d0 dc       	rcall	.-1632   	; 0x85c <vPortYield>
     ebc:	89 cf       	rjmp	.-238    	; 0xdd0 <xQueueGenericReceive+0x3a>
     ebe:	c8 01       	movw	r24, r16
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     ec0:	2b de       	rcall	.-938    	; 0xb18 <prvUnlockQueue>
     ec2:	c2 d4       	rcall	.+2436   	; 0x1848 <xTaskResumeAll>
     ec4:	85 cf       	rjmp	.-246    	; 0xdd0 <xQueueGenericReceive+0x3a>
			( void ) xTaskResumeAll();
     ec6:	c8 01       	movw	r24, r16
     ec8:	27 de       	rcall	.-946    	; 0xb18 <prvUnlockQueue>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     eca:	be d4       	rcall	.+2428   	; 0x1848 <xTaskResumeAll>
     ecc:	c8 01       	movw	r24, r16
     ece:	a0 dd       	rcall	.-1216   	; 0xa10 <prvIsQueueEmpty>
     ed0:	88 23       	and	r24, r24
     ed2:	09 f4       	brne	.+2      	; 0xed6 <xQueueGenericReceive+0x140>
     ed4:	7d cf       	rjmp	.-262    	; 0xdd0 <xQueueGenericReceive+0x3a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     ed6:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	0f 90       	pop	r0
     ede:	0f 90       	pop	r0
     ee0:	0f 90       	pop	r0
     ee2:	df 91       	pop	r29
     ee4:	cf 91       	pop	r28
     ee6:	1f 91       	pop	r17
     ee8:	0f 91       	pop	r16
     eea:	ff 90       	pop	r15
     eec:	ef 90       	pop	r14
     eee:	df 90       	pop	r13
     ef0:	cf 90       	pop	r12
     ef2:	bf 90       	pop	r11
     ef4:	af 90       	pop	r10
     ef6:	9f 90       	pop	r9
     ef8:	8f 90       	pop	r8
     efa:	08 95       	ret

00000efc <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
     efc:	1f 92       	push	r1
     efe:	0f 92       	push	r0
     f00:	0f b6       	in	r0, 0x3f	; 63
     f02:	0f 92       	push	r0
     f04:	11 24       	eor	r1, r1
     f06:	0b b6       	in	r0, 0x3b	; 59
     f08:	0f 92       	push	r0
     f0a:	2f 93       	push	r18
     f0c:	8f 93       	push	r24
     f0e:	9f 93       	push	r25
     f10:	af 93       	push	r26
     f12:	bf 93       	push	r27
     f14:	ef 93       	push	r30
     f16:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	0f 92       	push	r0
	{
	    count = buffer->count;
     f1e:	80 91 f9 02 	lds	r24, 0x02F9	; 0x8002f9 <xSerialPort+0xd>
     f22:	90 91 fa 02 	lds	r25, 0x02FA	; 0x8002fa <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
     f2a:	89 2b       	or	r24, r25
     f2c:	31 f4       	brne	.+12     	; 0xf3a <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
     f2e:	e1 ec       	ldi	r30, 0xC1	; 193
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	80 81       	ld	r24, Z
     f34:	8f 7d       	andi	r24, 0xDF	; 223
     f36:	80 83       	st	Z, r24
     f38:	1c c0       	rjmp	.+56     	; 0xf72 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     f3a:	e9 ef       	ldi	r30, 0xF9	; 249
     f3c:	f2 e0       	ldi	r31, 0x02	; 2

	uint8_t data = *buffer->out;
     f3e:	a4 81       	ldd	r26, Z+4	; 0x04
     f40:	b5 81       	ldd	r27, Z+5	; 0x05
     f42:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
     f44:	b5 83       	std	Z+5, r27	; 0x05
     f46:	a4 83       	std	Z+4, r26	; 0x04
     f48:	80 85       	ldd	r24, Z+8	; 0x08
     f4a:	91 85       	ldd	r25, Z+9	; 0x09
     f4c:	a8 17       	cp	r26, r24
     f4e:	b9 07       	cpc	r27, r25
     f50:	21 f4       	brne	.+8      	; 0xf5a <__vector_26+0x5e>
	  buffer->out = buffer->start;
     f52:	86 81       	ldd	r24, Z+6	; 0x06
     f54:	97 81       	ldd	r25, Z+7	; 0x07
     f56:	95 83       	std	Z+5, r25	; 0x05
     f58:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
     f5a:	0f b6       	in	r0, 0x3f	; 63
     f5c:	f8 94       	cli
     f5e:	0f 92       	push	r0
	{
	    buffer->count--;
     f60:	80 81       	ld	r24, Z
     f62:	91 81       	ldd	r25, Z+1	; 0x01
     f64:	01 97       	sbiw	r24, 0x01	; 1
     f66:	91 83       	std	Z+1, r25	; 0x01
     f68:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
     f6e:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
     f72:	ff 91       	pop	r31
     f74:	ef 91       	pop	r30
     f76:	bf 91       	pop	r27
     f78:	af 91       	pop	r26
     f7a:	9f 91       	pop	r25
     f7c:	8f 91       	pop	r24
     f7e:	2f 91       	pop	r18
     f80:	0f 90       	pop	r0
     f82:	0b be       	out	0x3b, r0	; 59
     f84:	0f 90       	pop	r0
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	0f 90       	pop	r0
     f8a:	1f 90       	pop	r1
     f8c:	18 95       	reti

00000f8e <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
     f8e:	1f 92       	push	r1
     f90:	0f 92       	push	r0
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	0f 92       	push	r0
     f96:	11 24       	eor	r1, r1
     f98:	0b b6       	in	r0, 0x3b	; 59
     f9a:	0f 92       	push	r0
     f9c:	2f 93       	push	r18
     f9e:	3f 93       	push	r19
     fa0:	4f 93       	push	r20
     fa2:	8f 93       	push	r24
     fa4:	9f 93       	push	r25
     fa6:	af 93       	push	r26
     fa8:	bf 93       	push	r27
     faa:	ef 93       	push	r30
     fac:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
     fae:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     fb2:	8c 71       	andi	r24, 0x1C	; 28
     fb4:	71 f0       	breq	.+28     	; 0xfd2 <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
     fb6:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     fba:	88 23       	and	r24, r24
     fbc:	0c f0       	brlt	.+2      	; 0xfc0 <__vector_36+0x32>
     fbe:	36 c0       	rjmp	.+108    	; 0x102c <__vector_36+0x9e>
     fc0:	ae ec       	ldi	r26, 0xCE	; 206
     fc2:	b0 e0       	ldi	r27, 0x00	; 0
     fc4:	e8 ec       	ldi	r30, 0xC8	; 200
     fc6:	f0 e0       	ldi	r31, 0x00	; 0
     fc8:	8c 91       	ld	r24, X
     fca:	80 81       	ld	r24, Z
     fcc:	88 23       	and	r24, r24
     fce:	e4 f3       	brlt	.-8      	; 0xfc8 <__vector_36+0x3a>
     fd0:	2d c0       	rjmp	.+90     	; 0x102c <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
     fd2:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     fd6:	0f b6       	in	r0, 0x3f	; 63
     fd8:	f8 94       	cli
     fda:	0f 92       	push	r0
	{
	    count = buffer->count;
     fdc:	e2 e5       	ldi	r30, 0x52	; 82
     fde:	f3 e0       	ldi	r31, 0x03	; 3
     fe0:	21 81       	ldd	r18, Z+1	; 0x01
     fe2:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
     fe4:	0f 90       	pop	r0
     fe6:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
     fe8:	83 85       	ldd	r24, Z+11	; 0x0b
     fea:	94 85       	ldd	r25, Z+12	; 0x0c
     fec:	28 17       	cp	r18, r24
     fee:	39 07       	cpc	r19, r25
     ff0:	e9 f0       	breq	.+58     	; 0x102c <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     ff2:	e3 e5       	ldi	r30, 0x53	; 83
     ff4:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
     ff6:	a2 81       	ldd	r26, Z+2	; 0x02
     ff8:	b3 81       	ldd	r27, Z+3	; 0x03
     ffa:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
     ffc:	82 81       	ldd	r24, Z+2	; 0x02
     ffe:	93 81       	ldd	r25, Z+3	; 0x03
    1000:	01 96       	adiw	r24, 0x01	; 1
    1002:	93 83       	std	Z+3, r25	; 0x03
    1004:	82 83       	std	Z+2, r24	; 0x02
    1006:	20 85       	ldd	r18, Z+8	; 0x08
    1008:	31 85       	ldd	r19, Z+9	; 0x09
    100a:	82 17       	cp	r24, r18
    100c:	93 07       	cpc	r25, r19
    100e:	21 f4       	brne	.+8      	; 0x1018 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    1010:	86 81       	ldd	r24, Z+6	; 0x06
    1012:	97 81       	ldd	r25, Z+7	; 0x07
    1014:	93 83       	std	Z+3, r25	; 0x03
    1016:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1018:	0f b6       	in	r0, 0x3f	; 63
    101a:	f8 94       	cli
    101c:	0f 92       	push	r0
	{
	    buffer->count++;
    101e:	80 81       	ld	r24, Z
    1020:	91 81       	ldd	r25, Z+1	; 0x01
    1022:	01 96       	adiw	r24, 0x01	; 1
    1024:	91 83       	std	Z+1, r25	; 0x01
    1026:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1028:	0f 90       	pop	r0
    102a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    102c:	ff 91       	pop	r31
    102e:	ef 91       	pop	r30
    1030:	bf 91       	pop	r27
    1032:	af 91       	pop	r26
    1034:	9f 91       	pop	r25
    1036:	8f 91       	pop	r24
    1038:	4f 91       	pop	r20
    103a:	3f 91       	pop	r19
    103c:	2f 91       	pop	r18
    103e:	0f 90       	pop	r0
    1040:	0b be       	out	0x3b, r0	; 59
    1042:	0f 90       	pop	r0
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	0f 90       	pop	r0
    1048:	1f 90       	pop	r1
    104a:	18 95       	reti

0000104c <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	0b b6       	in	r0, 0x3b	; 59
    1058:	0f 92       	push	r0
    105a:	2f 93       	push	r18
    105c:	8f 93       	push	r24
    105e:	9f 93       	push	r25
    1060:	af 93       	push	r26
    1062:	bf 93       	push	r27
    1064:	ef 93       	push	r30
    1066:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	0f 92       	push	r0
	{
	    count = buffer->count;
    106e:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <xSerial1Port+0xd>
    1072:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1076:	0f 90       	pop	r0
    1078:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    107a:	89 2b       	or	r24, r25
    107c:	31 f4       	brne	.+12     	; 0x108a <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    107e:	e9 ec       	ldi	r30, 0xC9	; 201
    1080:	f0 e0       	ldi	r31, 0x00	; 0
    1082:	80 81       	ld	r24, Z
    1084:	8f 7d       	andi	r24, 0xDF	; 223
    1086:	80 83       	st	Z, r24
    1088:	1c c0       	rjmp	.+56     	; 0x10c2 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    108a:	ef e5       	ldi	r30, 0x5F	; 95
    108c:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    108e:	a4 81       	ldd	r26, Z+4	; 0x04
    1090:	b5 81       	ldd	r27, Z+5	; 0x05
    1092:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1094:	b5 83       	std	Z+5, r27	; 0x05
    1096:	a4 83       	std	Z+4, r26	; 0x04
    1098:	80 85       	ldd	r24, Z+8	; 0x08
    109a:	91 85       	ldd	r25, Z+9	; 0x09
    109c:	a8 17       	cp	r26, r24
    109e:	b9 07       	cpc	r27, r25
    10a0:	21 f4       	brne	.+8      	; 0x10aa <__vector_37+0x5e>
	  buffer->out = buffer->start;
    10a2:	86 81       	ldd	r24, Z+6	; 0x06
    10a4:	97 81       	ldd	r25, Z+7	; 0x07
    10a6:	95 83       	std	Z+5, r25	; 0x05
    10a8:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	f8 94       	cli
    10ae:	0f 92       	push	r0
	{
	    buffer->count--;
    10b0:	80 81       	ld	r24, Z
    10b2:	91 81       	ldd	r25, Z+1	; 0x01
    10b4:	01 97       	sbiw	r24, 0x01	; 1
    10b6:	91 83       	std	Z+1, r25	; 0x01
    10b8:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    10ba:	0f 90       	pop	r0
    10bc:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    10be:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    10c2:	ff 91       	pop	r31
    10c4:	ef 91       	pop	r30
    10c6:	bf 91       	pop	r27
    10c8:	af 91       	pop	r26
    10ca:	9f 91       	pop	r25
    10cc:	8f 91       	pop	r24
    10ce:	2f 91       	pop	r18
    10d0:	0f 90       	pop	r0
    10d2:	0b be       	out	0x3b, r0	; 59
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	0f 90       	pop	r0
    10da:	1f 90       	pop	r1
    10dc:	18 95       	reti

000010de <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    10de:	1f 92       	push	r1
    10e0:	0f 92       	push	r0
    10e2:	0f b6       	in	r0, 0x3f	; 63
    10e4:	0f 92       	push	r0
    10e6:	11 24       	eor	r1, r1
    10e8:	0b b6       	in	r0, 0x3b	; 59
    10ea:	0f 92       	push	r0
    10ec:	2f 93       	push	r18
    10ee:	3f 93       	push	r19
    10f0:	4f 93       	push	r20
    10f2:	8f 93       	push	r24
    10f4:	9f 93       	push	r25
    10f6:	af 93       	push	r26
    10f8:	bf 93       	push	r27
    10fa:	ef 93       	push	r30
    10fc:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    10fe:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1102:	8c 71       	andi	r24, 0x1C	; 28
    1104:	71 f0       	breq	.+28     	; 0x1122 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1106:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    110a:	88 23       	and	r24, r24
    110c:	0c f0       	brlt	.+2      	; 0x1110 <__vector_51+0x32>
    110e:	36 c0       	rjmp	.+108    	; 0x117c <__vector_51+0x9e>
    1110:	a6 ed       	ldi	r26, 0xD6	; 214
    1112:	b0 e0       	ldi	r27, 0x00	; 0
    1114:	e0 ed       	ldi	r30, 0xD0	; 208
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	8c 91       	ld	r24, X
    111a:	80 81       	ld	r24, Z
    111c:	88 23       	and	r24, r24
    111e:	e4 f3       	brlt	.-8      	; 0x1118 <__vector_51+0x3a>
    1120:	2d c0       	rjmp	.+90     	; 0x117c <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    1122:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1126:	0f b6       	in	r0, 0x3f	; 63
    1128:	f8 94       	cli
    112a:	0f 92       	push	r0
	{
	    count = buffer->count;
    112c:	ee e0       	ldi	r30, 0x0E	; 14
    112e:	f3 e0       	ldi	r31, 0x03	; 3
    1130:	21 81       	ldd	r18, Z+1	; 0x01
    1132:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1134:	0f 90       	pop	r0
    1136:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    1138:	83 85       	ldd	r24, Z+11	; 0x0b
    113a:	94 85       	ldd	r25, Z+12	; 0x0c
    113c:	28 17       	cp	r18, r24
    113e:	39 07       	cpc	r19, r25
    1140:	e9 f0       	breq	.+58     	; 0x117c <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1142:	ef e0       	ldi	r30, 0x0F	; 15
    1144:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    1146:	a2 81       	ldd	r26, Z+2	; 0x02
    1148:	b3 81       	ldd	r27, Z+3	; 0x03
    114a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    114c:	82 81       	ldd	r24, Z+2	; 0x02
    114e:	93 81       	ldd	r25, Z+3	; 0x03
    1150:	01 96       	adiw	r24, 0x01	; 1
    1152:	93 83       	std	Z+3, r25	; 0x03
    1154:	82 83       	std	Z+2, r24	; 0x02
    1156:	20 85       	ldd	r18, Z+8	; 0x08
    1158:	31 85       	ldd	r19, Z+9	; 0x09
    115a:	82 17       	cp	r24, r18
    115c:	93 07       	cpc	r25, r19
    115e:	21 f4       	brne	.+8      	; 0x1168 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    1160:	86 81       	ldd	r24, Z+6	; 0x06
    1162:	97 81       	ldd	r25, Z+7	; 0x07
    1164:	93 83       	std	Z+3, r25	; 0x03
    1166:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	0f 92       	push	r0
	{
	    buffer->count++;
    116e:	80 81       	ld	r24, Z
    1170:	91 81       	ldd	r25, Z+1	; 0x01
    1172:	01 96       	adiw	r24, 0x01	; 1
    1174:	91 83       	std	Z+1, r25	; 0x01
    1176:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1178:	0f 90       	pop	r0
    117a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    117c:	ff 91       	pop	r31
    117e:	ef 91       	pop	r30
    1180:	bf 91       	pop	r27
    1182:	af 91       	pop	r26
    1184:	9f 91       	pop	r25
    1186:	8f 91       	pop	r24
    1188:	4f 91       	pop	r20
    118a:	3f 91       	pop	r19
    118c:	2f 91       	pop	r18
    118e:	0f 90       	pop	r0
    1190:	0b be       	out	0x3b, r0	; 59
    1192:	0f 90       	pop	r0
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	0f 90       	pop	r0
    1198:	1f 90       	pop	r1
    119a:	18 95       	reti

0000119c <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    119c:	1f 92       	push	r1
    119e:	0f 92       	push	r0
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	0f 92       	push	r0
    11a4:	11 24       	eor	r1, r1
    11a6:	0b b6       	in	r0, 0x3b	; 59
    11a8:	0f 92       	push	r0
    11aa:	2f 93       	push	r18
    11ac:	8f 93       	push	r24
    11ae:	9f 93       	push	r25
    11b0:	af 93       	push	r26
    11b2:	bf 93       	push	r27
    11b4:	ef 93       	push	r30
    11b6:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    11b8:	0f b6       	in	r0, 0x3f	; 63
    11ba:	f8 94       	cli
    11bc:	0f 92       	push	r0
	{
	    count = buffer->count;
    11be:	80 91 1b 03 	lds	r24, 0x031B	; 0x80031b <xSerial2Port+0xd>
    11c2:	90 91 1c 03 	lds	r25, 0x031C	; 0x80031c <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    11c6:	0f 90       	pop	r0
    11c8:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    11ca:	89 2b       	or	r24, r25
    11cc:	31 f4       	brne	.+12     	; 0x11da <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    11ce:	e1 ed       	ldi	r30, 0xD1	; 209
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	80 81       	ld	r24, Z
    11d4:	8f 7d       	andi	r24, 0xDF	; 223
    11d6:	80 83       	st	Z, r24
    11d8:	1c c0       	rjmp	.+56     	; 0x1212 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    11da:	eb e1       	ldi	r30, 0x1B	; 27
    11dc:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    11de:	a4 81       	ldd	r26, Z+4	; 0x04
    11e0:	b5 81       	ldd	r27, Z+5	; 0x05
    11e2:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    11e4:	b5 83       	std	Z+5, r27	; 0x05
    11e6:	a4 83       	std	Z+4, r26	; 0x04
    11e8:	80 85       	ldd	r24, Z+8	; 0x08
    11ea:	91 85       	ldd	r25, Z+9	; 0x09
    11ec:	a8 17       	cp	r26, r24
    11ee:	b9 07       	cpc	r27, r25
    11f0:	21 f4       	brne	.+8      	; 0x11fa <__vector_52+0x5e>
	  buffer->out = buffer->start;
    11f2:	86 81       	ldd	r24, Z+6	; 0x06
    11f4:	97 81       	ldd	r25, Z+7	; 0x07
    11f6:	95 83       	std	Z+5, r25	; 0x05
    11f8:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    11fa:	0f b6       	in	r0, 0x3f	; 63
    11fc:	f8 94       	cli
    11fe:	0f 92       	push	r0
	{
	    buffer->count--;
    1200:	80 81       	ld	r24, Z
    1202:	91 81       	ldd	r25, Z+1	; 0x01
    1204:	01 97       	sbiw	r24, 0x01	; 1
    1206:	91 83       	std	Z+1, r25	; 0x01
    1208:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    120a:	0f 90       	pop	r0
    120c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    120e:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    1212:	ff 91       	pop	r31
    1214:	ef 91       	pop	r30
    1216:	bf 91       	pop	r27
    1218:	af 91       	pop	r26
    121a:	9f 91       	pop	r25
    121c:	8f 91       	pop	r24
    121e:	2f 91       	pop	r18
    1220:	0f 90       	pop	r0
    1222:	0b be       	out	0x3b, r0	; 59
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	0f 90       	pop	r0
    122a:	1f 90       	pop	r1
    122c:	18 95       	reti

0000122e <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    122e:	1f 92       	push	r1
    1230:	0f 92       	push	r0
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	0f 92       	push	r0
    1236:	11 24       	eor	r1, r1
    1238:	0b b6       	in	r0, 0x3b	; 59
    123a:	0f 92       	push	r0
    123c:	2f 93       	push	r18
    123e:	3f 93       	push	r19
    1240:	4f 93       	push	r20
    1242:	8f 93       	push	r24
    1244:	9f 93       	push	r25
    1246:	af 93       	push	r26
    1248:	bf 93       	push	r27
    124a:	ef 93       	push	r30
    124c:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    124e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1252:	8c 71       	andi	r24, 0x1C	; 28
    1254:	71 f0       	breq	.+28     	; 0x1272 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    1256:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    125a:	88 23       	and	r24, r24
    125c:	0c f0       	brlt	.+2      	; 0x1260 <__vector_54+0x32>
    125e:	36 c0       	rjmp	.+108    	; 0x12cc <__vector_54+0x9e>
    1260:	a6 e3       	ldi	r26, 0x36	; 54
    1262:	b1 e0       	ldi	r27, 0x01	; 1
    1264:	e0 e3       	ldi	r30, 0x30	; 48
    1266:	f1 e0       	ldi	r31, 0x01	; 1
    1268:	8c 91       	ld	r24, X
    126a:	80 81       	ld	r24, Z
    126c:	88 23       	and	r24, r24
    126e:	e4 f3       	brlt	.-8      	; 0x1268 <__vector_54+0x3a>
    1270:	2d c0       	rjmp	.+90     	; 0x12cc <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1272:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1276:	0f b6       	in	r0, 0x3f	; 63
    1278:	f8 94       	cli
    127a:	0f 92       	push	r0
	{
	    count = buffer->count;
    127c:	e0 e3       	ldi	r30, 0x30	; 48
    127e:	f3 e0       	ldi	r31, 0x03	; 3
    1280:	21 81       	ldd	r18, Z+1	; 0x01
    1282:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1284:	0f 90       	pop	r0
    1286:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1288:	83 85       	ldd	r24, Z+11	; 0x0b
    128a:	94 85       	ldd	r25, Z+12	; 0x0c
    128c:	28 17       	cp	r18, r24
    128e:	39 07       	cpc	r19, r25
    1290:	e9 f0       	breq	.+58     	; 0x12cc <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1292:	e1 e3       	ldi	r30, 0x31	; 49
    1294:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    1296:	a2 81       	ldd	r26, Z+2	; 0x02
    1298:	b3 81       	ldd	r27, Z+3	; 0x03
    129a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    129c:	82 81       	ldd	r24, Z+2	; 0x02
    129e:	93 81       	ldd	r25, Z+3	; 0x03
    12a0:	01 96       	adiw	r24, 0x01	; 1
    12a2:	93 83       	std	Z+3, r25	; 0x03
    12a4:	82 83       	std	Z+2, r24	; 0x02
    12a6:	20 85       	ldd	r18, Z+8	; 0x08
    12a8:	31 85       	ldd	r19, Z+9	; 0x09
    12aa:	82 17       	cp	r24, r18
    12ac:	93 07       	cpc	r25, r19
    12ae:	21 f4       	brne	.+8      	; 0x12b8 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    12b0:	86 81       	ldd	r24, Z+6	; 0x06
    12b2:	97 81       	ldd	r25, Z+7	; 0x07
    12b4:	93 83       	std	Z+3, r25	; 0x03
    12b6:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
	{
	    buffer->count++;
    12be:	80 81       	ld	r24, Z
    12c0:	91 81       	ldd	r25, Z+1	; 0x01
    12c2:	01 96       	adiw	r24, 0x01	; 1
    12c4:	91 83       	std	Z+1, r25	; 0x01
    12c6:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    12c8:	0f 90       	pop	r0
    12ca:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    12cc:	ff 91       	pop	r31
    12ce:	ef 91       	pop	r30
    12d0:	bf 91       	pop	r27
    12d2:	af 91       	pop	r26
    12d4:	9f 91       	pop	r25
    12d6:	8f 91       	pop	r24
    12d8:	4f 91       	pop	r20
    12da:	3f 91       	pop	r19
    12dc:	2f 91       	pop	r18
    12de:	0f 90       	pop	r0
    12e0:	0b be       	out	0x3b, r0	; 59
    12e2:	0f 90       	pop	r0
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	0f 90       	pop	r0
    12e8:	1f 90       	pop	r1
    12ea:	18 95       	reti

000012ec <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    12ec:	1f 92       	push	r1
    12ee:	0f 92       	push	r0
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	0f 92       	push	r0
    12f4:	11 24       	eor	r1, r1
    12f6:	0b b6       	in	r0, 0x3b	; 59
    12f8:	0f 92       	push	r0
    12fa:	2f 93       	push	r18
    12fc:	8f 93       	push	r24
    12fe:	9f 93       	push	r25
    1300:	af 93       	push	r26
    1302:	bf 93       	push	r27
    1304:	ef 93       	push	r30
    1306:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	f8 94       	cli
    130c:	0f 92       	push	r0
	{
	    count = buffer->count;
    130e:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <xSerial3Port+0xd>
    1312:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    131a:	89 2b       	or	r24, r25
    131c:	31 f4       	brne	.+12     	; 0x132a <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    131e:	e1 e3       	ldi	r30, 0x31	; 49
    1320:	f1 e0       	ldi	r31, 0x01	; 1
    1322:	80 81       	ld	r24, Z
    1324:	8f 7d       	andi	r24, 0xDF	; 223
    1326:	80 83       	st	Z, r24
    1328:	1c c0       	rjmp	.+56     	; 0x1362 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    132a:	ed e3       	ldi	r30, 0x3D	; 61
    132c:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    132e:	a4 81       	ldd	r26, Z+4	; 0x04
    1330:	b5 81       	ldd	r27, Z+5	; 0x05
    1332:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1334:	b5 83       	std	Z+5, r27	; 0x05
    1336:	a4 83       	std	Z+4, r26	; 0x04
    1338:	80 85       	ldd	r24, Z+8	; 0x08
    133a:	91 85       	ldd	r25, Z+9	; 0x09
    133c:	a8 17       	cp	r26, r24
    133e:	b9 07       	cpc	r27, r25
    1340:	21 f4       	brne	.+8      	; 0x134a <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1342:	86 81       	ldd	r24, Z+6	; 0x06
    1344:	97 81       	ldd	r25, Z+7	; 0x07
    1346:	95 83       	std	Z+5, r25	; 0x05
    1348:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    134a:	0f b6       	in	r0, 0x3f	; 63
    134c:	f8 94       	cli
    134e:	0f 92       	push	r0
	{
	    buffer->count--;
    1350:	80 81       	ld	r24, Z
    1352:	91 81       	ldd	r25, Z+1	; 0x01
    1354:	01 97       	sbiw	r24, 0x01	; 1
    1356:	91 83       	std	Z+1, r25	; 0x01
    1358:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    135a:	0f 90       	pop	r0
    135c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    135e:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1362:	ff 91       	pop	r31
    1364:	ef 91       	pop	r30
    1366:	bf 91       	pop	r27
    1368:	af 91       	pop	r26
    136a:	9f 91       	pop	r25
    136c:	8f 91       	pop	r24
    136e:	2f 91       	pop	r18
    1370:	0f 90       	pop	r0
    1372:	0b be       	out	0x3b, r0	; 59
    1374:	0f 90       	pop	r0
    1376:	0f be       	out	0x3f, r0	; 63
    1378:	0f 90       	pop	r0
    137a:	1f 90       	pop	r1
    137c:	18 95       	reti

0000137e <prvResetNextTaskUnblockTime>:
    137e:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxDelayedTaskList>
    1382:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    1386:	80 81       	ld	r24, Z
    1388:	81 11       	cpse	r24, r1
    138a:	07 c0       	rjmp	.+14     	; 0x139a <prvResetNextTaskUnblockTime+0x1c>
    138c:	8f ef       	ldi	r24, 0xFF	; 255
    138e:	9f ef       	ldi	r25, 0xFF	; 255
    1390:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <xNextTaskUnblockTime+0x1>
    1394:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <xNextTaskUnblockTime>
    1398:	08 95       	ret
    139a:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxDelayedTaskList>
    139e:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    13a2:	05 80       	ldd	r0, Z+5	; 0x05
    13a4:	f6 81       	ldd	r31, Z+6	; 0x06
    13a6:	e0 2d       	mov	r30, r0
    13a8:	06 80       	ldd	r0, Z+6	; 0x06
    13aa:	f7 81       	ldd	r31, Z+7	; 0x07
    13ac:	e0 2d       	mov	r30, r0
    13ae:	82 81       	ldd	r24, Z+2	; 0x02
    13b0:	93 81       	ldd	r25, Z+3	; 0x03
    13b2:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <xNextTaskUnblockTime+0x1>
    13b6:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <xNextTaskUnblockTime>
    13ba:	08 95       	ret

000013bc <prvAddCurrentTaskToDelayedList>:
    13bc:	ff 92       	push	r15
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	cf 93       	push	r28
    13c4:	df 93       	push	r29
    13c6:	ec 01       	movw	r28, r24
    13c8:	f6 2e       	mov	r15, r22
    13ca:	00 91 7d 02 	lds	r16, 0x027D	; 0x80027d <xTickCount>
    13ce:	10 91 7e 02 	lds	r17, 0x027E	; 0x80027e <xTickCount+0x1>
    13d2:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    13d6:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    13da:	02 96       	adiw	r24, 0x02	; 2
    13dc:	61 d9       	rcall	.-3390   	; 0x6a0 <uxListRemove>
    13de:	cf 3f       	cpi	r28, 0xFF	; 255
    13e0:	8f ef       	ldi	r24, 0xFF	; 255
    13e2:	d8 07       	cpc	r29, r24
    13e4:	61 f4       	brne	.+24     	; 0x13fe <prvAddCurrentTaskToDelayedList+0x42>
    13e6:	ff 20       	and	r15, r15
    13e8:	51 f0       	breq	.+20     	; 0x13fe <prvAddCurrentTaskToDelayedList+0x42>
    13ea:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    13ee:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    13f2:	6e 5f       	subi	r22, 0xFE	; 254
    13f4:	7f 4f       	sbci	r23, 0xFF	; 255
    13f6:	80 e8       	ldi	r24, 0x80	; 128
    13f8:	92 e0       	ldi	r25, 0x02	; 2
    13fa:	00 d9       	rcall	.-3584   	; 0x5fc <vListInsertEnd>
    13fc:	2d c0       	rjmp	.+90     	; 0x1458 <prvAddCurrentTaskToDelayedList+0x9c>
    13fe:	c0 0f       	add	r28, r16
    1400:	d1 1f       	adc	r29, r17
    1402:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1406:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    140a:	d3 83       	std	Z+3, r29	; 0x03
    140c:	c2 83       	std	Z+2, r28	; 0x02
    140e:	c0 17       	cp	r28, r16
    1410:	d1 07       	cpc	r29, r17
    1412:	60 f4       	brcc	.+24     	; 0x142c <prvAddCurrentTaskToDelayedList+0x70>
    1414:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1418:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    141c:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <pxOverflowDelayedTaskList>
    1420:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <pxOverflowDelayedTaskList+0x1>
    1424:	6e 5f       	subi	r22, 0xFE	; 254
    1426:	7f 4f       	sbci	r23, 0xFF	; 255
    1428:	0a d9       	rcall	.-3564   	; 0x63e <vListInsert>
    142a:	16 c0       	rjmp	.+44     	; 0x1458 <prvAddCurrentTaskToDelayedList+0x9c>
    142c:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1430:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1434:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <pxDelayedTaskList>
    1438:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    143c:	6e 5f       	subi	r22, 0xFE	; 254
    143e:	7f 4f       	sbci	r23, 0xFF	; 255
    1440:	fe d8       	rcall	.-3588   	; 0x63e <vListInsert>
    1442:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <xNextTaskUnblockTime>
    1446:	90 91 76 02 	lds	r25, 0x0276	; 0x800276 <xNextTaskUnblockTime+0x1>
    144a:	c8 17       	cp	r28, r24
    144c:	d9 07       	cpc	r29, r25
    144e:	20 f4       	brcc	.+8      	; 0x1458 <prvAddCurrentTaskToDelayedList+0x9c>
    1450:	d0 93 76 02 	sts	0x0276, r29	; 0x800276 <xNextTaskUnblockTime+0x1>
    1454:	c0 93 75 02 	sts	0x0275, r28	; 0x800275 <xNextTaskUnblockTime>
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	08 95       	ret

00001464 <xTaskCreate>:
    1464:	4f 92       	push	r4
    1466:	5f 92       	push	r5
    1468:	6f 92       	push	r6
    146a:	7f 92       	push	r7
    146c:	8f 92       	push	r8
    146e:	9f 92       	push	r9
    1470:	af 92       	push	r10
    1472:	bf 92       	push	r11
    1474:	cf 92       	push	r12
    1476:	df 92       	push	r13
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	cf 93       	push	r28
    1480:	df 93       	push	r29
    1482:	4c 01       	movw	r8, r24
    1484:	6b 01       	movw	r12, r22
    1486:	5a 01       	movw	r10, r20
    1488:	29 01       	movw	r4, r18
    148a:	ca 01       	movw	r24, r20
    148c:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    1490:	3c 01       	movw	r6, r24
    1492:	89 2b       	or	r24, r25
    1494:	09 f4       	brne	.+2      	; 0x1498 <xTaskCreate+0x34>
    1496:	df c0       	rjmp	.+446    	; 0x1656 <xTaskCreate+0x1f2>
    1498:	88 e2       	ldi	r24, 0x28	; 40
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    14a0:	ec 01       	movw	r28, r24
    14a2:	89 2b       	or	r24, r25
    14a4:	b1 f0       	breq	.+44     	; 0x14d2 <xTaskCreate+0x6e>
    14a6:	78 8e       	std	Y+24, r7	; 0x18
    14a8:	6f 8a       	std	Y+23, r6	; 0x17
    14aa:	a5 01       	movw	r20, r10
    14ac:	65 ea       	ldi	r22, 0xA5	; 165
    14ae:	70 e0       	ldi	r23, 0x00	; 0
    14b0:	c3 01       	movw	r24, r6
    14b2:	0e 94 c7 13 	call	0x278e	; 0x278e <memset>
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	a8 1a       	sub	r10, r24
    14ba:	b1 08       	sbc	r11, r1
    14bc:	8f 89       	ldd	r24, Y+23	; 0x17
    14be:	98 8d       	ldd	r25, Y+24	; 0x18
    14c0:	a8 0e       	add	r10, r24
    14c2:	b9 1e       	adc	r11, r25
    14c4:	d6 01       	movw	r26, r12
    14c6:	8c 91       	ld	r24, X
    14c8:	89 8f       	std	Y+25, r24	; 0x19
    14ca:	8c 91       	ld	r24, X
    14cc:	81 11       	cpse	r24, r1
    14ce:	05 c0       	rjmp	.+10     	; 0x14da <xTaskCreate+0x76>
    14d0:	18 c0       	rjmp	.+48     	; 0x1502 <xTaskCreate+0x9e>
    14d2:	c3 01       	movw	r24, r6
    14d4:	0e 94 bd 01 	call	0x37a	; 0x37a <vPortFree>
    14d8:	be c0       	rjmp	.+380    	; 0x1656 <xTaskCreate+0x1f2>
    14da:	ae 01       	movw	r20, r28
    14dc:	46 5e       	subi	r20, 0xE6	; 230
    14de:	5f 4f       	sbci	r21, 0xFF	; 255
    14e0:	f6 01       	movw	r30, r12
    14e2:	31 96       	adiw	r30, 0x01	; 1
    14e4:	b8 e0       	ldi	r27, 0x08	; 8
    14e6:	cb 0e       	add	r12, r27
    14e8:	d1 1c       	adc	r13, r1
    14ea:	cf 01       	movw	r24, r30
    14ec:	21 91       	ld	r18, Z+
    14ee:	da 01       	movw	r26, r20
    14f0:	2d 93       	st	X+, r18
    14f2:	ad 01       	movw	r20, r26
    14f4:	dc 01       	movw	r26, r24
    14f6:	8c 91       	ld	r24, X
    14f8:	88 23       	and	r24, r24
    14fa:	19 f0       	breq	.+6      	; 0x1502 <xTaskCreate+0x9e>
    14fc:	ec 15       	cp	r30, r12
    14fe:	fd 05       	cpc	r31, r13
    1500:	a1 f7       	brne	.-24     	; 0x14ea <xTaskCreate+0x86>
    1502:	18 a2       	std	Y+32, r1	; 0x20
    1504:	04 30       	cpi	r16, 0x04	; 4
    1506:	08 f0       	brcs	.+2      	; 0x150a <xTaskCreate+0xa6>
    1508:	03 e0       	ldi	r16, 0x03	; 3
    150a:	0e 8b       	std	Y+22, r16	; 0x16
    150c:	09 a3       	std	Y+33, r16	; 0x21
    150e:	1a a2       	std	Y+34, r1	; 0x22
    1510:	6e 01       	movw	r12, r28
    1512:	b2 e0       	ldi	r27, 0x02	; 2
    1514:	cb 0e       	add	r12, r27
    1516:	d1 1c       	adc	r13, r1
    1518:	c6 01       	movw	r24, r12
    151a:	6c d8       	rcall	.-3880   	; 0x5f4 <vListInitialiseItem>
    151c:	ce 01       	movw	r24, r28
    151e:	0c 96       	adiw	r24, 0x0c	; 12
    1520:	69 d8       	rcall	.-3886   	; 0x5f4 <vListInitialiseItem>
    1522:	d9 87       	std	Y+9, r29	; 0x09
    1524:	c8 87       	std	Y+8, r28	; 0x08
    1526:	84 e0       	ldi	r24, 0x04	; 4
    1528:	90 e0       	ldi	r25, 0x00	; 0
    152a:	80 1b       	sub	r24, r16
    152c:	91 09       	sbc	r25, r1
    152e:	9d 87       	std	Y+13, r25	; 0x0d
    1530:	8c 87       	std	Y+12, r24	; 0x0c
    1532:	db 8b       	std	Y+19, r29	; 0x13
    1534:	ca 8b       	std	Y+18, r28	; 0x12
    1536:	1b a2       	std	Y+35, r1	; 0x23
    1538:	1c a2       	std	Y+36, r1	; 0x24
    153a:	1d a2       	std	Y+37, r1	; 0x25
    153c:	1e a2       	std	Y+38, r1	; 0x26
    153e:	1f a2       	std	Y+39, r1	; 0x27
    1540:	a2 01       	movw	r20, r4
    1542:	b4 01       	movw	r22, r8
    1544:	c5 01       	movw	r24, r10
    1546:	d2 d8       	rcall	.-3676   	; 0x6ec <pxPortInitialiseStack>
    1548:	99 83       	std	Y+1, r25	; 0x01
    154a:	88 83       	st	Y, r24
    154c:	e1 14       	cp	r14, r1
    154e:	f1 04       	cpc	r15, r1
    1550:	19 f0       	breq	.+6      	; 0x1558 <xTaskCreate+0xf4>
    1552:	f7 01       	movw	r30, r14
    1554:	d1 83       	std	Z+1, r29	; 0x01
    1556:	c0 83       	st	Z, r28
    1558:	0f b6       	in	r0, 0x3f	; 63
    155a:	f8 94       	cli
    155c:	0f 92       	push	r0
    155e:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <uxCurrentNumberOfTasks>
    1562:	8f 5f       	subi	r24, 0xFF	; 255
    1564:	80 93 7f 02 	sts	0x027F, r24	; 0x80027f <uxCurrentNumberOfTasks>
    1568:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    156c:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1570:	89 2b       	or	r24, r25
    1572:	89 f5       	brne	.+98     	; 0x15d6 <xTaskCreate+0x172>
    1574:	d0 93 d7 02 	sts	0x02D7, r29	; 0x8002d7 <pxCurrentTCB+0x1>
    1578:	c0 93 d6 02 	sts	0x02D6, r28	; 0x8002d6 <pxCurrentTCB>
    157c:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <uxCurrentNumberOfTasks>
    1580:	81 30       	cpi	r24, 0x01	; 1
    1582:	09 f0       	breq	.+2      	; 0x1586 <xTaskCreate+0x122>
    1584:	38 c0       	rjmp	.+112    	; 0x15f6 <xTaskCreate+0x192>
    1586:	82 eb       	ldi	r24, 0xB2	; 178
    1588:	92 e0       	ldi	r25, 0x02	; 2
    158a:	26 d8       	rcall	.-4020   	; 0x5d8 <vListInitialise>
    158c:	8b eb       	ldi	r24, 0xBB	; 187
    158e:	92 e0       	ldi	r25, 0x02	; 2
    1590:	23 d8       	rcall	.-4026   	; 0x5d8 <vListInitialise>
    1592:	84 ec       	ldi	r24, 0xC4	; 196
    1594:	92 e0       	ldi	r25, 0x02	; 2
    1596:	20 d8       	rcall	.-4032   	; 0x5d8 <vListInitialise>
    1598:	8d ec       	ldi	r24, 0xCD	; 205
    159a:	92 e0       	ldi	r25, 0x02	; 2
    159c:	1d d8       	rcall	.-4038   	; 0x5d8 <vListInitialise>
    159e:	89 ea       	ldi	r24, 0xA9	; 169
    15a0:	92 e0       	ldi	r25, 0x02	; 2
    15a2:	1a d8       	rcall	.-4044   	; 0x5d8 <vListInitialise>
    15a4:	80 ea       	ldi	r24, 0xA0	; 160
    15a6:	92 e0       	ldi	r25, 0x02	; 2
    15a8:	17 d8       	rcall	.-4050   	; 0x5d8 <vListInitialise>
    15aa:	83 e9       	ldi	r24, 0x93	; 147
    15ac:	92 e0       	ldi	r25, 0x02	; 2
    15ae:	14 d8       	rcall	.-4056   	; 0x5d8 <vListInitialise>
    15b0:	8a e8       	ldi	r24, 0x8A	; 138
    15b2:	92 e0       	ldi	r25, 0x02	; 2
    15b4:	11 d8       	rcall	.-4062   	; 0x5d8 <vListInitialise>
    15b6:	80 e8       	ldi	r24, 0x80	; 128
    15b8:	92 e0       	ldi	r25, 0x02	; 2
    15ba:	0e d8       	rcall	.-4068   	; 0x5d8 <vListInitialise>
    15bc:	89 ea       	ldi	r24, 0xA9	; 169
    15be:	92 e0       	ldi	r25, 0x02	; 2
    15c0:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <pxDelayedTaskList+0x1>
    15c4:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <pxDelayedTaskList>
    15c8:	80 ea       	ldi	r24, 0xA0	; 160
    15ca:	92 e0       	ldi	r25, 0x02	; 2
    15cc:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <pxOverflowDelayedTaskList+0x1>
    15d0:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <pxOverflowDelayedTaskList>
    15d4:	10 c0       	rjmp	.+32     	; 0x15f6 <xTaskCreate+0x192>
    15d6:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <xSchedulerRunning>
    15da:	81 11       	cpse	r24, r1
    15dc:	0c c0       	rjmp	.+24     	; 0x15f6 <xTaskCreate+0x192>
    15de:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    15e2:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    15e6:	96 89       	ldd	r25, Z+22	; 0x16
    15e8:	8e 89       	ldd	r24, Y+22	; 0x16
    15ea:	89 17       	cp	r24, r25
    15ec:	20 f0       	brcs	.+8      	; 0x15f6 <xTaskCreate+0x192>
    15ee:	d0 93 d7 02 	sts	0x02D7, r29	; 0x8002d7 <pxCurrentTCB+0x1>
    15f2:	c0 93 d6 02 	sts	0x02D6, r28	; 0x8002d6 <pxCurrentTCB>
    15f6:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <uxTaskNumber>
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <uxTaskNumber>
    1600:	8e 89       	ldd	r24, Y+22	; 0x16
    1602:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    1606:	98 17       	cp	r25, r24
    1608:	10 f4       	brcc	.+4      	; 0x160e <xTaskCreate+0x1aa>
    160a:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	9c 01       	movw	r18, r24
    1612:	22 0f       	add	r18, r18
    1614:	33 1f       	adc	r19, r19
    1616:	22 0f       	add	r18, r18
    1618:	33 1f       	adc	r19, r19
    161a:	22 0f       	add	r18, r18
    161c:	33 1f       	adc	r19, r19
    161e:	82 0f       	add	r24, r18
    1620:	93 1f       	adc	r25, r19
    1622:	b6 01       	movw	r22, r12
    1624:	8e 54       	subi	r24, 0x4E	; 78
    1626:	9d 4f       	sbci	r25, 0xFD	; 253
    1628:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    162c:	0f 90       	pop	r0
    162e:	0f be       	out	0x3f, r0	; 63
    1630:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <xSchedulerRunning>
    1634:	88 23       	and	r24, r24
    1636:	59 f0       	breq	.+22     	; 0x164e <xTaskCreate+0x1ea>
    1638:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    163c:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1640:	96 89       	ldd	r25, Z+22	; 0x16
    1642:	8e 89       	ldd	r24, Y+22	; 0x16
    1644:	98 17       	cp	r25, r24
    1646:	28 f4       	brcc	.+10     	; 0x1652 <xTaskCreate+0x1ee>
    1648:	09 d9       	rcall	.-3566   	; 0x85c <vPortYield>
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	05 c0       	rjmp	.+10     	; 0x1658 <xTaskCreate+0x1f4>
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	03 c0       	rjmp	.+6      	; 0x1658 <xTaskCreate+0x1f4>
    1652:	81 e0       	ldi	r24, 0x01	; 1
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <xTaskCreate+0x1f4>
    1656:	8f ef       	ldi	r24, 0xFF	; 255
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	bf 90       	pop	r11
    1668:	af 90       	pop	r10
    166a:	9f 90       	pop	r9
    166c:	8f 90       	pop	r8
    166e:	7f 90       	pop	r7
    1670:	6f 90       	pop	r6
    1672:	5f 90       	pop	r5
    1674:	4f 90       	pop	r4
    1676:	08 95       	ret

00001678 <vTaskStartScheduler>:
    1678:	ef 92       	push	r14
    167a:	ff 92       	push	r15
    167c:	0f 93       	push	r16
    167e:	0f 2e       	mov	r0, r31
    1680:	f3 e7       	ldi	r31, 0x73	; 115
    1682:	ef 2e       	mov	r14, r31
    1684:	f2 e0       	ldi	r31, 0x02	; 2
    1686:	ff 2e       	mov	r15, r31
    1688:	f0 2d       	mov	r31, r0
    168a:	00 e0       	ldi	r16, 0x00	; 0
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	30 e0       	ldi	r19, 0x00	; 0
    1690:	45 e5       	ldi	r20, 0x55	; 85
    1692:	50 e0       	ldi	r21, 0x00	; 0
    1694:	67 e0       	ldi	r22, 0x07	; 7
    1696:	72 e0       	ldi	r23, 0x02	; 2
    1698:	83 e3       	ldi	r24, 0x33	; 51
    169a:	91 e0       	ldi	r25, 0x01	; 1
    169c:	e3 de       	rcall	.-570    	; 0x1464 <xTaskCreate>
    169e:	81 30       	cpi	r24, 0x01	; 1
    16a0:	79 f4       	brne	.+30     	; 0x16c0 <vTaskStartScheduler+0x48>
    16a2:	f8 94       	cli
    16a4:	8f ef       	ldi	r24, 0xFF	; 255
    16a6:	9f ef       	ldi	r25, 0xFF	; 255
    16a8:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <xNextTaskUnblockTime+0x1>
    16ac:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <xNextTaskUnblockTime>
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <xSchedulerRunning>
    16b6:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <xTickCount+0x1>
    16ba:	10 92 7d 02 	sts	0x027D, r1	; 0x80027d <xTickCount>
    16be:	88 d8       	rcall	.-3824   	; 0x7d0 <xPortStartScheduler>
    16c0:	0f 91       	pop	r16
    16c2:	ff 90       	pop	r15
    16c4:	ef 90       	pop	r14
    16c6:	08 95       	ret

000016c8 <vTaskSuspendAll>:
    16c8:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    16cc:	8f 5f       	subi	r24, 0xFF	; 255
    16ce:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <uxSchedulerSuspended>
    16d2:	08 95       	ret

000016d4 <xTaskIncrementTick>:
    16d4:	cf 92       	push	r12
    16d6:	df 92       	push	r13
    16d8:	ef 92       	push	r14
    16da:	ff 92       	push	r15
    16dc:	0f 93       	push	r16
    16de:	1f 93       	push	r17
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    16e8:	81 11       	cpse	r24, r1
    16ea:	98 c0       	rjmp	.+304    	; 0x181c <xTaskIncrementTick+0x148>
    16ec:	e0 90 7d 02 	lds	r14, 0x027D	; 0x80027d <xTickCount>
    16f0:	f0 90 7e 02 	lds	r15, 0x027E	; 0x80027e <xTickCount+0x1>
    16f4:	8f ef       	ldi	r24, 0xFF	; 255
    16f6:	e8 1a       	sub	r14, r24
    16f8:	f8 0a       	sbc	r15, r24
    16fa:	f0 92 7e 02 	sts	0x027E, r15	; 0x80027e <xTickCount+0x1>
    16fe:	e0 92 7d 02 	sts	0x027D, r14	; 0x80027d <xTickCount>
    1702:	e1 14       	cp	r14, r1
    1704:	f1 04       	cpc	r15, r1
    1706:	b1 f4       	brne	.+44     	; 0x1734 <xTaskIncrementTick+0x60>
    1708:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <pxDelayedTaskList>
    170c:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    1710:	20 91 9c 02 	lds	r18, 0x029C	; 0x80029c <pxOverflowDelayedTaskList>
    1714:	30 91 9d 02 	lds	r19, 0x029D	; 0x80029d <pxOverflowDelayedTaskList+0x1>
    1718:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <pxDelayedTaskList+0x1>
    171c:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <pxDelayedTaskList>
    1720:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <pxOverflowDelayedTaskList+0x1>
    1724:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <pxOverflowDelayedTaskList>
    1728:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <xNumOfOverflows>
    172c:	8f 5f       	subi	r24, 0xFF	; 255
    172e:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <xNumOfOverflows>
    1732:	25 de       	rcall	.-950    	; 0x137e <prvResetNextTaskUnblockTime>
    1734:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <xNextTaskUnblockTime>
    1738:	90 91 76 02 	lds	r25, 0x0276	; 0x800276 <xNextTaskUnblockTime+0x1>
    173c:	e8 16       	cp	r14, r24
    173e:	f9 06       	cpc	r15, r25
    1740:	10 f4       	brcc	.+4      	; 0x1746 <xTaskIncrementTick+0x72>
    1742:	d1 2c       	mov	r13, r1
    1744:	53 c0       	rjmp	.+166    	; 0x17ec <xTaskIncrementTick+0x118>
    1746:	d1 2c       	mov	r13, r1
    1748:	cc 24       	eor	r12, r12
    174a:	c3 94       	inc	r12
    174c:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxDelayedTaskList>
    1750:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    1754:	80 81       	ld	r24, Z
    1756:	81 11       	cpse	r24, r1
    1758:	07 c0       	rjmp	.+14     	; 0x1768 <xTaskIncrementTick+0x94>
    175a:	8f ef       	ldi	r24, 0xFF	; 255
    175c:	9f ef       	ldi	r25, 0xFF	; 255
    175e:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <xNextTaskUnblockTime+0x1>
    1762:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <xNextTaskUnblockTime>
    1766:	42 c0       	rjmp	.+132    	; 0x17ec <xTaskIncrementTick+0x118>
    1768:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxDelayedTaskList>
    176c:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxDelayedTaskList+0x1>
    1770:	05 80       	ldd	r0, Z+5	; 0x05
    1772:	f6 81       	ldd	r31, Z+6	; 0x06
    1774:	e0 2d       	mov	r30, r0
    1776:	c6 81       	ldd	r28, Z+6	; 0x06
    1778:	d7 81       	ldd	r29, Z+7	; 0x07
    177a:	8a 81       	ldd	r24, Y+2	; 0x02
    177c:	9b 81       	ldd	r25, Y+3	; 0x03
    177e:	e8 16       	cp	r14, r24
    1780:	f9 06       	cpc	r15, r25
    1782:	28 f4       	brcc	.+10     	; 0x178e <xTaskIncrementTick+0xba>
    1784:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <xNextTaskUnblockTime+0x1>
    1788:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <xNextTaskUnblockTime>
    178c:	2f c0       	rjmp	.+94     	; 0x17ec <xTaskIncrementTick+0x118>
    178e:	8e 01       	movw	r16, r28
    1790:	0e 5f       	subi	r16, 0xFE	; 254
    1792:	1f 4f       	sbci	r17, 0xFF	; 255
    1794:	c8 01       	movw	r24, r16
    1796:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    179a:	8c 89       	ldd	r24, Y+20	; 0x14
    179c:	9d 89       	ldd	r25, Y+21	; 0x15
    179e:	89 2b       	or	r24, r25
    17a0:	21 f0       	breq	.+8      	; 0x17aa <xTaskIncrementTick+0xd6>
    17a2:	ce 01       	movw	r24, r28
    17a4:	0c 96       	adiw	r24, 0x0c	; 12
    17a6:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    17aa:	8e 89       	ldd	r24, Y+22	; 0x16
    17ac:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    17b0:	98 17       	cp	r25, r24
    17b2:	10 f4       	brcc	.+4      	; 0x17b8 <xTaskIncrementTick+0xe4>
    17b4:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	9c 01       	movw	r18, r24
    17bc:	22 0f       	add	r18, r18
    17be:	33 1f       	adc	r19, r19
    17c0:	22 0f       	add	r18, r18
    17c2:	33 1f       	adc	r19, r19
    17c4:	22 0f       	add	r18, r18
    17c6:	33 1f       	adc	r19, r19
    17c8:	82 0f       	add	r24, r18
    17ca:	93 1f       	adc	r25, r19
    17cc:	b8 01       	movw	r22, r16
    17ce:	8e 54       	subi	r24, 0x4E	; 78
    17d0:	9d 4f       	sbci	r25, 0xFD	; 253
    17d2:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    17d6:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    17da:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    17de:	9e 89       	ldd	r25, Y+22	; 0x16
    17e0:	86 89       	ldd	r24, Z+22	; 0x16
    17e2:	98 17       	cp	r25, r24
    17e4:	08 f4       	brcc	.+2      	; 0x17e8 <xTaskIncrementTick+0x114>
    17e6:	b2 cf       	rjmp	.-156    	; 0x174c <xTaskIncrementTick+0x78>
    17e8:	dc 2c       	mov	r13, r12
    17ea:	b0 cf       	rjmp	.-160    	; 0x174c <xTaskIncrementTick+0x78>
    17ec:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    17f0:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    17f4:	86 89       	ldd	r24, Z+22	; 0x16
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	fc 01       	movw	r30, r24
    17fa:	ee 0f       	add	r30, r30
    17fc:	ff 1f       	adc	r31, r31
    17fe:	ee 0f       	add	r30, r30
    1800:	ff 1f       	adc	r31, r31
    1802:	ee 0f       	add	r30, r30
    1804:	ff 1f       	adc	r31, r31
    1806:	8e 0f       	add	r24, r30
    1808:	9f 1f       	adc	r25, r31
    180a:	fc 01       	movw	r30, r24
    180c:	ee 54       	subi	r30, 0x4E	; 78
    180e:	fd 4f       	sbci	r31, 0xFD	; 253
    1810:	80 81       	ld	r24, Z
    1812:	82 30       	cpi	r24, 0x02	; 2
    1814:	48 f0       	brcs	.+18     	; 0x1828 <xTaskIncrementTick+0x154>
    1816:	dd 24       	eor	r13, r13
    1818:	d3 94       	inc	r13
    181a:	06 c0       	rjmp	.+12     	; 0x1828 <xTaskIncrementTick+0x154>
    181c:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <uxPendedTicks>
    1820:	8f 5f       	subi	r24, 0xFF	; 255
    1822:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxPendedTicks>
    1826:	d1 2c       	mov	r13, r1
    1828:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <xYieldPending>
    182c:	88 23       	and	r24, r24
    182e:	11 f0       	breq	.+4      	; 0x1834 <xTaskIncrementTick+0x160>
    1830:	dd 24       	eor	r13, r13
    1832:	d3 94       	inc	r13
    1834:	8d 2d       	mov	r24, r13
    1836:	df 91       	pop	r29
    1838:	cf 91       	pop	r28
    183a:	1f 91       	pop	r17
    183c:	0f 91       	pop	r16
    183e:	ff 90       	pop	r15
    1840:	ef 90       	pop	r14
    1842:	df 90       	pop	r13
    1844:	cf 90       	pop	r12
    1846:	08 95       	ret

00001848 <xTaskResumeAll>:
    1848:	df 92       	push	r13
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	0f 92       	push	r0
    185c:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    1860:	81 50       	subi	r24, 0x01	; 1
    1862:	80 93 72 02 	sts	0x0272, r24	; 0x800272 <uxSchedulerSuspended>
    1866:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    186a:	81 11       	cpse	r24, r1
    186c:	5d c0       	rjmp	.+186    	; 0x1928 <xTaskResumeAll+0xe0>
    186e:	80 91 7f 02 	lds	r24, 0x027F	; 0x80027f <uxCurrentNumberOfTasks>
    1872:	81 11       	cpse	r24, r1
    1874:	33 c0       	rjmp	.+102    	; 0x18dc <xTaskResumeAll+0x94>
    1876:	5b c0       	rjmp	.+182    	; 0x192e <xTaskResumeAll+0xe6>
    1878:	d7 01       	movw	r26, r14
    187a:	15 96       	adiw	r26, 0x05	; 5
    187c:	ed 91       	ld	r30, X+
    187e:	fc 91       	ld	r31, X
    1880:	16 97       	sbiw	r26, 0x06	; 6
    1882:	c6 81       	ldd	r28, Z+6	; 0x06
    1884:	d7 81       	ldd	r29, Z+7	; 0x07
    1886:	ce 01       	movw	r24, r28
    1888:	0c 96       	adiw	r24, 0x0c	; 12
    188a:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    188e:	8e 01       	movw	r16, r28
    1890:	0e 5f       	subi	r16, 0xFE	; 254
    1892:	1f 4f       	sbci	r17, 0xFF	; 255
    1894:	c8 01       	movw	r24, r16
    1896:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    189a:	8e 89       	ldd	r24, Y+22	; 0x16
    189c:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    18a0:	98 17       	cp	r25, r24
    18a2:	10 f4       	brcc	.+4      	; 0x18a8 <xTaskResumeAll+0x60>
    18a4:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	9c 01       	movw	r18, r24
    18ac:	22 0f       	add	r18, r18
    18ae:	33 1f       	adc	r19, r19
    18b0:	22 0f       	add	r18, r18
    18b2:	33 1f       	adc	r19, r19
    18b4:	22 0f       	add	r18, r18
    18b6:	33 1f       	adc	r19, r19
    18b8:	82 0f       	add	r24, r18
    18ba:	93 1f       	adc	r25, r19
    18bc:	b8 01       	movw	r22, r16
    18be:	8e 54       	subi	r24, 0x4E	; 78
    18c0:	9d 4f       	sbci	r25, 0xFD	; 253
    18c2:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    18c6:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    18ca:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    18ce:	9e 89       	ldd	r25, Y+22	; 0x16
    18d0:	86 89       	ldd	r24, Z+22	; 0x16
    18d2:	98 17       	cp	r25, r24
    18d4:	68 f0       	brcs	.+26     	; 0x18f0 <xTaskResumeAll+0xa8>
    18d6:	d0 92 79 02 	sts	0x0279, r13	; 0x800279 <xYieldPending>
    18da:	0a c0       	rjmp	.+20     	; 0x18f0 <xTaskResumeAll+0xa8>
    18dc:	c0 e0       	ldi	r28, 0x00	; 0
    18de:	d0 e0       	ldi	r29, 0x00	; 0
    18e0:	0f 2e       	mov	r0, r31
    18e2:	f3 e9       	ldi	r31, 0x93	; 147
    18e4:	ef 2e       	mov	r14, r31
    18e6:	f2 e0       	ldi	r31, 0x02	; 2
    18e8:	ff 2e       	mov	r15, r31
    18ea:	f0 2d       	mov	r31, r0
    18ec:	dd 24       	eor	r13, r13
    18ee:	d3 94       	inc	r13
    18f0:	f7 01       	movw	r30, r14
    18f2:	80 81       	ld	r24, Z
    18f4:	81 11       	cpse	r24, r1
    18f6:	c0 cf       	rjmp	.-128    	; 0x1878 <xTaskResumeAll+0x30>
    18f8:	cd 2b       	or	r28, r29
    18fa:	09 f0       	breq	.+2      	; 0x18fe <xTaskResumeAll+0xb6>
    18fc:	40 dd       	rcall	.-1408   	; 0x137e <prvResetNextTaskUnblockTime>
    18fe:	c0 91 7a 02 	lds	r28, 0x027A	; 0x80027a <uxPendedTicks>
    1902:	cc 23       	and	r28, r28
    1904:	49 f0       	breq	.+18     	; 0x1918 <xTaskResumeAll+0xd0>
    1906:	d1 e0       	ldi	r29, 0x01	; 1
    1908:	e5 de       	rcall	.-566    	; 0x16d4 <xTaskIncrementTick>
    190a:	81 11       	cpse	r24, r1
    190c:	d0 93 79 02 	sts	0x0279, r29	; 0x800279 <xYieldPending>
    1910:	c1 50       	subi	r28, 0x01	; 1
    1912:	d1 f7       	brne	.-12     	; 0x1908 <xTaskResumeAll+0xc0>
    1914:	10 92 7a 02 	sts	0x027A, r1	; 0x80027a <uxPendedTicks>
    1918:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <xYieldPending>
    191c:	88 23       	and	r24, r24
    191e:	31 f0       	breq	.+12     	; 0x192c <xTaskResumeAll+0xe4>
    1920:	0e 94 2e 04 	call	0x85c	; 0x85c <vPortYield>
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	03 c0       	rjmp	.+6      	; 0x192e <xTaskResumeAll+0xe6>
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	01 c0       	rjmp	.+2      	; 0x192e <xTaskResumeAll+0xe6>
    192c:	80 e0       	ldi	r24, 0x00	; 0
    192e:	0f 90       	pop	r0
    1930:	0f be       	out	0x3f, r0	; 63
    1932:	df 91       	pop	r29
    1934:	cf 91       	pop	r28
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ff 90       	pop	r15
    193c:	ef 90       	pop	r14
    193e:	df 90       	pop	r13
    1940:	08 95       	ret

00001942 <vTaskSwitchContext>:
    1942:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    1946:	88 23       	and	r24, r24
    1948:	21 f0       	breq	.+8      	; 0x1952 <vTaskSwitchContext+0x10>
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <xYieldPending>
    1950:	08 95       	ret
    1952:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <xYieldPending>
    1956:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    195a:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    195e:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1962:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1966:	2d 91       	ld	r18, X+
    1968:	3c 91       	ld	r19, X
    196a:	87 89       	ldd	r24, Z+23	; 0x17
    196c:	90 8d       	ldd	r25, Z+24	; 0x18
    196e:	82 17       	cp	r24, r18
    1970:	93 07       	cpc	r25, r19
    1972:	60 f0       	brcs	.+24     	; 0x198c <vTaskSwitchContext+0x4a>
    1974:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1978:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    197c:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1980:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1984:	67 5e       	subi	r22, 0xE7	; 231
    1986:	7f 4f       	sbci	r23, 0xFF	; 255
    1988:	0e 94 ef 01 	call	0x3de	; 0x3de <vApplicationStackOverflowHook>
    198c:	20 91 7c 02 	lds	r18, 0x027C	; 0x80027c <uxTopReadyPriority>
    1990:	82 2f       	mov	r24, r18
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	fc 01       	movw	r30, r24
    1996:	ee 0f       	add	r30, r30
    1998:	ff 1f       	adc	r31, r31
    199a:	ee 0f       	add	r30, r30
    199c:	ff 1f       	adc	r31, r31
    199e:	ee 0f       	add	r30, r30
    19a0:	ff 1f       	adc	r31, r31
    19a2:	e8 0f       	add	r30, r24
    19a4:	f9 1f       	adc	r31, r25
    19a6:	ee 54       	subi	r30, 0x4E	; 78
    19a8:	fd 4f       	sbci	r31, 0xFD	; 253
    19aa:	30 81       	ld	r19, Z
    19ac:	31 11       	cpse	r19, r1
    19ae:	11 c0       	rjmp	.+34     	; 0x19d2 <vTaskSwitchContext+0x90>
    19b0:	21 50       	subi	r18, 0x01	; 1
    19b2:	82 2f       	mov	r24, r18
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	fc 01       	movw	r30, r24
    19b8:	ee 0f       	add	r30, r30
    19ba:	ff 1f       	adc	r31, r31
    19bc:	ee 0f       	add	r30, r30
    19be:	ff 1f       	adc	r31, r31
    19c0:	ee 0f       	add	r30, r30
    19c2:	ff 1f       	adc	r31, r31
    19c4:	e8 0f       	add	r30, r24
    19c6:	f9 1f       	adc	r31, r25
    19c8:	ee 54       	subi	r30, 0x4E	; 78
    19ca:	fd 4f       	sbci	r31, 0xFD	; 253
    19cc:	30 81       	ld	r19, Z
    19ce:	33 23       	and	r19, r19
    19d0:	79 f3       	breq	.-34     	; 0x19b0 <vTaskSwitchContext+0x6e>
    19d2:	ac 01       	movw	r20, r24
    19d4:	44 0f       	add	r20, r20
    19d6:	55 1f       	adc	r21, r21
    19d8:	44 0f       	add	r20, r20
    19da:	55 1f       	adc	r21, r21
    19dc:	44 0f       	add	r20, r20
    19de:	55 1f       	adc	r21, r21
    19e0:	48 0f       	add	r20, r24
    19e2:	59 1f       	adc	r21, r25
    19e4:	da 01       	movw	r26, r20
    19e6:	ae 54       	subi	r26, 0x4E	; 78
    19e8:	bd 4f       	sbci	r27, 0xFD	; 253
    19ea:	11 96       	adiw	r26, 0x01	; 1
    19ec:	ed 91       	ld	r30, X+
    19ee:	fc 91       	ld	r31, X
    19f0:	12 97       	sbiw	r26, 0x02	; 2
    19f2:	02 80       	ldd	r0, Z+2	; 0x02
    19f4:	f3 81       	ldd	r31, Z+3	; 0x03
    19f6:	e0 2d       	mov	r30, r0
    19f8:	12 96       	adiw	r26, 0x02	; 2
    19fa:	fc 93       	st	X, r31
    19fc:	ee 93       	st	-X, r30
    19fe:	11 97       	sbiw	r26, 0x01	; 1
    1a00:	4b 54       	subi	r20, 0x4B	; 75
    1a02:	5d 4f       	sbci	r21, 0xFD	; 253
    1a04:	e4 17       	cp	r30, r20
    1a06:	f5 07       	cpc	r31, r21
    1a08:	29 f4       	brne	.+10     	; 0x1a14 <vTaskSwitchContext+0xd2>
    1a0a:	42 81       	ldd	r20, Z+2	; 0x02
    1a0c:	53 81       	ldd	r21, Z+3	; 0x03
    1a0e:	fd 01       	movw	r30, r26
    1a10:	52 83       	std	Z+2, r21	; 0x02
    1a12:	41 83       	std	Z+1, r20	; 0x01
    1a14:	fc 01       	movw	r30, r24
    1a16:	ee 0f       	add	r30, r30
    1a18:	ff 1f       	adc	r31, r31
    1a1a:	ee 0f       	add	r30, r30
    1a1c:	ff 1f       	adc	r31, r31
    1a1e:	ee 0f       	add	r30, r30
    1a20:	ff 1f       	adc	r31, r31
    1a22:	8e 0f       	add	r24, r30
    1a24:	9f 1f       	adc	r25, r31
    1a26:	fc 01       	movw	r30, r24
    1a28:	ee 54       	subi	r30, 0x4E	; 78
    1a2a:	fd 4f       	sbci	r31, 0xFD	; 253
    1a2c:	01 80       	ldd	r0, Z+1	; 0x01
    1a2e:	f2 81       	ldd	r31, Z+2	; 0x02
    1a30:	e0 2d       	mov	r30, r0
    1a32:	86 81       	ldd	r24, Z+6	; 0x06
    1a34:	97 81       	ldd	r25, Z+7	; 0x07
    1a36:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <pxCurrentTCB+0x1>
    1a3a:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <pxCurrentTCB>
    1a3e:	20 93 7c 02 	sts	0x027C, r18	; 0x80027c <uxTopReadyPriority>
    1a42:	08 95       	ret

00001a44 <vTaskPlaceOnEventList>:
    1a44:	cf 93       	push	r28
    1a46:	df 93       	push	r29
    1a48:	eb 01       	movw	r28, r22
    1a4a:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1a4e:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1a52:	64 5f       	subi	r22, 0xF4	; 244
    1a54:	7f 4f       	sbci	r23, 0xFF	; 255
    1a56:	0e 94 1f 03 	call	0x63e	; 0x63e <vListInsert>
    1a5a:	61 e0       	ldi	r22, 0x01	; 1
    1a5c:	ce 01       	movw	r24, r28
    1a5e:	ae dc       	rcall	.-1700   	; 0x13bc <prvAddCurrentTaskToDelayedList>
    1a60:	df 91       	pop	r29
    1a62:	cf 91       	pop	r28
    1a64:	08 95       	ret

00001a66 <xTaskRemoveFromEventList>:
    1a66:	0f 93       	push	r16
    1a68:	1f 93       	push	r17
    1a6a:	cf 93       	push	r28
    1a6c:	df 93       	push	r29
    1a6e:	dc 01       	movw	r26, r24
    1a70:	15 96       	adiw	r26, 0x05	; 5
    1a72:	ed 91       	ld	r30, X+
    1a74:	fc 91       	ld	r31, X
    1a76:	16 97       	sbiw	r26, 0x06	; 6
    1a78:	c6 81       	ldd	r28, Z+6	; 0x06
    1a7a:	d7 81       	ldd	r29, Z+7	; 0x07
    1a7c:	8e 01       	movw	r16, r28
    1a7e:	04 5f       	subi	r16, 0xF4	; 244
    1a80:	1f 4f       	sbci	r17, 0xFF	; 255
    1a82:	c8 01       	movw	r24, r16
    1a84:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    1a88:	80 91 72 02 	lds	r24, 0x0272	; 0x800272 <uxSchedulerSuspended>
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	1c c0       	rjmp	.+56     	; 0x1ac8 <xTaskRemoveFromEventList+0x62>
    1a90:	0a 50       	subi	r16, 0x0A	; 10
    1a92:	11 09       	sbc	r17, r1
    1a94:	c8 01       	movw	r24, r16
    1a96:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    1a9a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a9c:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    1aa0:	98 17       	cp	r25, r24
    1aa2:	10 f4       	brcc	.+4      	; 0x1aa8 <xTaskRemoveFromEventList+0x42>
    1aa4:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	9c 01       	movw	r18, r24
    1aac:	22 0f       	add	r18, r18
    1aae:	33 1f       	adc	r19, r19
    1ab0:	22 0f       	add	r18, r18
    1ab2:	33 1f       	adc	r19, r19
    1ab4:	22 0f       	add	r18, r18
    1ab6:	33 1f       	adc	r19, r19
    1ab8:	82 0f       	add	r24, r18
    1aba:	93 1f       	adc	r25, r19
    1abc:	b8 01       	movw	r22, r16
    1abe:	8e 54       	subi	r24, 0x4E	; 78
    1ac0:	9d 4f       	sbci	r25, 0xFD	; 253
    1ac2:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1ac6:	05 c0       	rjmp	.+10     	; 0x1ad2 <xTaskRemoveFromEventList+0x6c>
    1ac8:	b8 01       	movw	r22, r16
    1aca:	83 e9       	ldi	r24, 0x93	; 147
    1acc:	92 e0       	ldi	r25, 0x02	; 2
    1ace:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1ad2:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1ad6:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1ada:	9e 89       	ldd	r25, Y+22	; 0x16
    1adc:	86 89       	ldd	r24, Z+22	; 0x16
    1ade:	89 17       	cp	r24, r25
    1ae0:	20 f4       	brcc	.+8      	; 0x1aea <xTaskRemoveFromEventList+0x84>
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <xYieldPending>
    1ae8:	01 c0       	rjmp	.+2      	; 0x1aec <xTaskRemoveFromEventList+0x86>
    1aea:	80 e0       	ldi	r24, 0x00	; 0
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	1f 91       	pop	r17
    1af2:	0f 91       	pop	r16
    1af4:	08 95       	ret

00001af6 <vTaskSetTimeOutState>:
    1af6:	20 91 78 02 	lds	r18, 0x0278	; 0x800278 <xNumOfOverflows>
    1afa:	fc 01       	movw	r30, r24
    1afc:	20 83       	st	Z, r18
    1afe:	20 91 7d 02 	lds	r18, 0x027D	; 0x80027d <xTickCount>
    1b02:	30 91 7e 02 	lds	r19, 0x027E	; 0x80027e <xTickCount+0x1>
    1b06:	32 83       	std	Z+2, r19	; 0x02
    1b08:	21 83       	std	Z+1, r18	; 0x01
    1b0a:	08 95       	ret

00001b0c <xTaskCheckForTimeOut>:
    1b0c:	0f b6       	in	r0, 0x3f	; 63
    1b0e:	f8 94       	cli
    1b10:	0f 92       	push	r0
    1b12:	40 91 7d 02 	lds	r20, 0x027D	; 0x80027d <xTickCount>
    1b16:	50 91 7e 02 	lds	r21, 0x027E	; 0x80027e <xTickCount+0x1>
    1b1a:	db 01       	movw	r26, r22
    1b1c:	2d 91       	ld	r18, X+
    1b1e:	3c 91       	ld	r19, X
    1b20:	2f 3f       	cpi	r18, 0xFF	; 255
    1b22:	bf ef       	ldi	r27, 0xFF	; 255
    1b24:	3b 07       	cpc	r19, r27
    1b26:	11 f1       	breq	.+68     	; 0x1b6c <xTaskCheckForTimeOut+0x60>
    1b28:	e0 91 78 02 	lds	r30, 0x0278	; 0x800278 <xNumOfOverflows>
    1b2c:	dc 01       	movw	r26, r24
    1b2e:	fc 91       	ld	r31, X
    1b30:	fe 17       	cp	r31, r30
    1b32:	39 f0       	breq	.+14     	; 0x1b42 <xTaskCheckForTimeOut+0x36>
    1b34:	11 96       	adiw	r26, 0x01	; 1
    1b36:	ed 91       	ld	r30, X+
    1b38:	fc 91       	ld	r31, X
    1b3a:	12 97       	sbiw	r26, 0x02	; 2
    1b3c:	4e 17       	cp	r20, r30
    1b3e:	5f 07       	cpc	r21, r31
    1b40:	b8 f4       	brcc	.+46     	; 0x1b70 <xTaskCheckForTimeOut+0x64>
    1b42:	dc 01       	movw	r26, r24
    1b44:	11 96       	adiw	r26, 0x01	; 1
    1b46:	ed 91       	ld	r30, X+
    1b48:	fc 91       	ld	r31, X
    1b4a:	12 97       	sbiw	r26, 0x02	; 2
    1b4c:	da 01       	movw	r26, r20
    1b4e:	ae 1b       	sub	r26, r30
    1b50:	bf 0b       	sbc	r27, r31
    1b52:	a2 17       	cp	r26, r18
    1b54:	b3 07       	cpc	r27, r19
    1b56:	70 f4       	brcc	.+28     	; 0x1b74 <xTaskCheckForTimeOut+0x68>
    1b58:	db 01       	movw	r26, r22
    1b5a:	e4 1b       	sub	r30, r20
    1b5c:	f5 0b       	sbc	r31, r21
    1b5e:	2e 0f       	add	r18, r30
    1b60:	3f 1f       	adc	r19, r31
    1b62:	2d 93       	st	X+, r18
    1b64:	3c 93       	st	X, r19
    1b66:	c7 df       	rcall	.-114    	; 0x1af6 <vTaskSetTimeOutState>
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	05 c0       	rjmp	.+10     	; 0x1b76 <xTaskCheckForTimeOut+0x6a>
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	03 c0       	rjmp	.+6      	; 0x1b76 <xTaskCheckForTimeOut+0x6a>
    1b70:	81 e0       	ldi	r24, 0x01	; 1
    1b72:	01 c0       	rjmp	.+2      	; 0x1b76 <xTaskCheckForTimeOut+0x6a>
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	0f 90       	pop	r0
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	08 95       	ret

00001b7c <vTaskMissedYield>:
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <xYieldPending>
    1b82:	08 95       	ret

00001b84 <vTaskPriorityInherit>:
    1b84:	0f 93       	push	r16
    1b86:	1f 93       	push	r17
    1b88:	cf 93       	push	r28
    1b8a:	df 93       	push	r29
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	89 2b       	or	r24, r25
    1b90:	09 f4       	brne	.+2      	; 0x1b94 <vTaskPriorityInherit+0x10>
    1b92:	55 c0       	rjmp	.+170    	; 0x1c3e <vTaskPriorityInherit+0xba>
    1b94:	26 89       	ldd	r18, Z+22	; 0x16
    1b96:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1b9a:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1b9e:	56 96       	adiw	r26, 0x16	; 22
    1ba0:	8c 91       	ld	r24, X
    1ba2:	28 17       	cp	r18, r24
    1ba4:	08 f0       	brcs	.+2      	; 0x1ba8 <vTaskPriorityInherit+0x24>
    1ba6:	4b c0       	rjmp	.+150    	; 0x1c3e <vTaskPriorityInherit+0xba>
    1ba8:	84 85       	ldd	r24, Z+12	; 0x0c
    1baa:	95 85       	ldd	r25, Z+13	; 0x0d
    1bac:	99 23       	and	r25, r25
    1bae:	64 f0       	brlt	.+24     	; 0x1bc8 <vTaskPriorityInherit+0x44>
    1bb0:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1bb4:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1bb8:	56 96       	adiw	r26, 0x16	; 22
    1bba:	3c 91       	ld	r19, X
    1bbc:	84 e0       	ldi	r24, 0x04	; 4
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	83 1b       	sub	r24, r19
    1bc2:	91 09       	sbc	r25, r1
    1bc4:	95 87       	std	Z+13, r25	; 0x0d
    1bc6:	84 87       	std	Z+12, r24	; 0x0c
    1bc8:	30 e0       	ldi	r19, 0x00	; 0
    1bca:	c9 01       	movw	r24, r18
    1bcc:	88 0f       	add	r24, r24
    1bce:	99 1f       	adc	r25, r25
    1bd0:	88 0f       	add	r24, r24
    1bd2:	99 1f       	adc	r25, r25
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	28 0f       	add	r18, r24
    1bda:	39 1f       	adc	r19, r25
    1bdc:	2e 54       	subi	r18, 0x4E	; 78
    1bde:	3d 4f       	sbci	r19, 0xFD	; 253
    1be0:	82 85       	ldd	r24, Z+10	; 0x0a
    1be2:	93 85       	ldd	r25, Z+11	; 0x0b
    1be4:	82 17       	cp	r24, r18
    1be6:	93 07       	cpc	r25, r19
    1be8:	19 f5       	brne	.+70     	; 0x1c30 <vTaskPriorityInherit+0xac>
    1bea:	8f 01       	movw	r16, r30
    1bec:	ef 01       	movw	r28, r30
    1bee:	22 96       	adiw	r28, 0x02	; 2
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    1bf6:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1bfa:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1bfe:	86 89       	ldd	r24, Z+22	; 0x16
    1c00:	f8 01       	movw	r30, r16
    1c02:	86 8b       	std	Z+22, r24	; 0x16
    1c04:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    1c08:	98 17       	cp	r25, r24
    1c0a:	10 f4       	brcc	.+4      	; 0x1c10 <vTaskPriorityInherit+0x8c>
    1c0c:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	9c 01       	movw	r18, r24
    1c14:	22 0f       	add	r18, r18
    1c16:	33 1f       	adc	r19, r19
    1c18:	22 0f       	add	r18, r18
    1c1a:	33 1f       	adc	r19, r19
    1c1c:	22 0f       	add	r18, r18
    1c1e:	33 1f       	adc	r19, r19
    1c20:	82 0f       	add	r24, r18
    1c22:	93 1f       	adc	r25, r19
    1c24:	be 01       	movw	r22, r28
    1c26:	8e 54       	subi	r24, 0x4E	; 78
    1c28:	9d 4f       	sbci	r25, 0xFD	; 253
    1c2a:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1c2e:	07 c0       	rjmp	.+14     	; 0x1c3e <vTaskPriorityInherit+0xba>
    1c30:	a0 91 d6 02 	lds	r26, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1c34:	b0 91 d7 02 	lds	r27, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1c38:	56 96       	adiw	r26, 0x16	; 22
    1c3a:	8c 91       	ld	r24, X
    1c3c:	86 8b       	std	Z+22, r24	; 0x16
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	08 95       	ret

00001c48 <xTaskPriorityDisinherit>:
    1c48:	0f 93       	push	r16
    1c4a:	1f 93       	push	r17
    1c4c:	cf 93       	push	r28
    1c4e:	df 93       	push	r29
    1c50:	fc 01       	movw	r30, r24
    1c52:	89 2b       	or	r24, r25
    1c54:	79 f1       	breq	.+94     	; 0x1cb4 <xTaskPriorityDisinherit+0x6c>
    1c56:	82 a1       	ldd	r24, Z+34	; 0x22
    1c58:	81 50       	subi	r24, 0x01	; 1
    1c5a:	82 a3       	std	Z+34, r24	; 0x22
    1c5c:	26 89       	ldd	r18, Z+22	; 0x16
    1c5e:	91 a1       	ldd	r25, Z+33	; 0x21
    1c60:	29 17       	cp	r18, r25
    1c62:	51 f1       	breq	.+84     	; 0x1cb8 <xTaskPriorityDisinherit+0x70>
    1c64:	81 11       	cpse	r24, r1
    1c66:	2a c0       	rjmp	.+84     	; 0x1cbc <xTaskPriorityDisinherit+0x74>
    1c68:	ef 01       	movw	r28, r30
    1c6a:	8f 01       	movw	r16, r30
    1c6c:	0e 5f       	subi	r16, 0xFE	; 254
    1c6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c70:	c8 01       	movw	r24, r16
    1c72:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    1c76:	89 a1       	ldd	r24, Y+33	; 0x21
    1c78:	8e 8b       	std	Y+22, r24	; 0x16
    1c7a:	24 e0       	ldi	r18, 0x04	; 4
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	28 1b       	sub	r18, r24
    1c80:	31 09       	sbc	r19, r1
    1c82:	3d 87       	std	Y+13, r19	; 0x0d
    1c84:	2c 87       	std	Y+12, r18	; 0x0c
    1c86:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <uxTopReadyPriority>
    1c8a:	98 17       	cp	r25, r24
    1c8c:	10 f4       	brcc	.+4      	; 0x1c92 <xTaskPriorityDisinherit+0x4a>
    1c8e:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <uxTopReadyPriority>
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	9c 01       	movw	r18, r24
    1c96:	22 0f       	add	r18, r18
    1c98:	33 1f       	adc	r19, r19
    1c9a:	22 0f       	add	r18, r18
    1c9c:	33 1f       	adc	r19, r19
    1c9e:	22 0f       	add	r18, r18
    1ca0:	33 1f       	adc	r19, r19
    1ca2:	82 0f       	add	r24, r18
    1ca4:	93 1f       	adc	r25, r19
    1ca6:	b8 01       	movw	r22, r16
    1ca8:	8e 54       	subi	r24, 0x4E	; 78
    1caa:	9d 4f       	sbci	r25, 0xFD	; 253
    1cac:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	05 c0       	rjmp	.+10     	; 0x1cbe <xTaskPriorityDisinherit+0x76>
    1cb4:	80 e0       	ldi	r24, 0x00	; 0
    1cb6:	03 c0       	rjmp	.+6      	; 0x1cbe <xTaskPriorityDisinherit+0x76>
    1cb8:	80 e0       	ldi	r24, 0x00	; 0
    1cba:	01 c0       	rjmp	.+2      	; 0x1cbe <xTaskPriorityDisinherit+0x76>
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	df 91       	pop	r29
    1cc0:	cf 91       	pop	r28
    1cc2:	1f 91       	pop	r17
    1cc4:	0f 91       	pop	r16
    1cc6:	08 95       	ret

00001cc8 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1cc8:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1ccc:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1cd0:	89 2b       	or	r24, r25
    1cd2:	39 f0       	breq	.+14     	; 0x1ce2 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1cd4:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1cd8:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
    1cdc:	82 a1       	ldd	r24, Z+34	; 0x22
    1cde:	8f 5f       	subi	r24, 0xFF	; 255
    1ce0:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1ce2:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxCurrentTCB>
    1ce6:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxCurrentTCB+0x1>
	}
    1cea:	08 95       	ret

00001cec <initQ>:
		_delay_ms(50);
}

//main functions
void initQ(){
	sonarAfstand = xQueueCreate(10,sizeof(int));
    1cec:	40 e0       	ldi	r20, 0x00	; 0
    1cee:	62 e0       	ldi	r22, 0x02	; 2
    1cf0:	8a e0       	ldi	r24, 0x0A	; 10
    1cf2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xQueueGenericCreate>
    1cf6:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <sonarAfstand+0x1>
    1cfa:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <sonarAfstand>
	if(sonarAfstand==0) sonarAfstand = xQueueCreate(10,sizeof(int));
    1cfe:	89 2b       	or	r24, r25
    1d00:	49 f4       	brne	.+18     	; 0x1d14 <initQ+0x28>
    1d02:	40 e0       	ldi	r20, 0x00	; 0
    1d04:	62 e0       	ldi	r22, 0x02	; 2
    1d06:	8a e0       	ldi	r24, 0x0A	; 10
    1d08:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xQueueGenericCreate>
    1d0c:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <sonarAfstand+0x1>
    1d10:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <sonarAfstand>

	servoHoek = xQueueCreate(10,sizeof(int));
    1d14:	40 e0       	ldi	r20, 0x00	; 0
    1d16:	62 e0       	ldi	r22, 0x02	; 2
    1d18:	8a e0       	ldi	r24, 0x0A	; 10
    1d1a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xQueueGenericCreate>
    1d1e:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <servoHoek+0x1>
    1d22:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <servoHoek>
	if(servoHoek==0) servoHoek = xQueueCreate(10,sizeof(int));
    1d26:	89 2b       	or	r24, r25
    1d28:	49 f4       	brne	.+18     	; 0x1d3c <initQ+0x50>
    1d2a:	40 e0       	ldi	r20, 0x00	; 0
    1d2c:	62 e0       	ldi	r22, 0x02	; 2
    1d2e:	8a e0       	ldi	r24, 0x0A	; 10
    1d30:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xQueueGenericCreate>
    1d34:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <servoHoek+0x1>
    1d38:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <servoHoek>
    1d3c:	08 95       	ret

00001d3e <writeQ>:
}

void writeQ( int data)
{
	xQueueSend(servoHoek, (void*) &hoek, 0);
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	40 e0       	ldi	r20, 0x00	; 0
    1d42:	50 e0       	ldi	r21, 0x00	; 0
    1d44:	64 e7       	ldi	r22, 0x74	; 116
    1d46:	74 e0       	ldi	r23, 0x04	; 4
    1d48:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <servoHoek>
    1d4c:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <servoHoek+0x1>
    1d50:	0c 94 39 06 	jmp	0xc72	; 0xc72 <xQueueGenericSend>
    1d54:	08 95       	ret

00001d56 <readQ>:
}

void readQ()
{
	xQueueReceive(sonarAfstand, &afstand, 0);
    1d56:	20 e0       	ldi	r18, 0x00	; 0
    1d58:	40 e0       	ldi	r20, 0x00	; 0
    1d5a:	50 e0       	ldi	r21, 0x00	; 0
    1d5c:	6b e7       	ldi	r22, 0x7B	; 123
    1d5e:	74 e0       	ldi	r23, 0x04	; 4
    1d60:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <sonarAfstand>
    1d64:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <sonarAfstand+0x1>
    1d68:	16 c8       	rjmp	.-4052   	; 0xd96 <xQueueGenericReceive>
    1d6a:	08 95       	ret

00001d6c <UART_Init>:
}

void UART_Init( unsigned int ubrr)
{
	UBRR0H = (ubrr>>8);												// Set baud rate
    1d6c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L = ubrr;
    1d70:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

	UCSR0B = (1<<RXEN0) | (1<<TXEN0) | (1<<RXCIE0);					// Enable receiver and transmitter and enable RX interrupt
    1d74:	88 e9       	ldi	r24, 0x98	; 152
    1d76:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
	UCSR0C = (3<<UCSZ00);											// Set frame format: 8data, 1 stop bit
    1d7a:	86 e0       	ldi	r24, 0x06	; 6
    1d7c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1d80:	08 95       	ret

00001d82 <UART_Transmit>:
}

void UART_Transmit( unsigned char data )
{
	while ( !( UCSR0A & (1<<UDRE0)) ) {};							// Wait for empty transmit buffer
    1d82:	e0 ec       	ldi	r30, 0xC0	; 192
    1d84:	f0 e0       	ldi	r31, 0x00	; 0
    1d86:	90 81       	ld	r25, Z
    1d88:	95 ff       	sbrs	r25, 5
    1d8a:	fd cf       	rjmp	.-6      	; 0x1d86 <UART_Transmit+0x4>
	UDR0 = data;													// Put data into buffer, sends the data
    1d8c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1d90:	08 95       	ret

00001d92 <UART_Transmit_String>:
}

void UART_Transmit_String(const char *stringPtr)
{
    1d92:	cf 93       	push	r28
    1d94:	df 93       	push	r29
    1d96:	ec 01       	movw	r28, r24
	while(*stringPtr != 0x00)
    1d98:	88 81       	ld	r24, Y
    1d9a:	88 23       	and	r24, r24
    1d9c:	29 f0       	breq	.+10     	; 0x1da8 <UART_Transmit_String+0x16>
    1d9e:	21 96       	adiw	r28, 0x01	; 1
	{
		UART_Transmit(*stringPtr);
    1da0:	f0 df       	rcall	.-32     	; 0x1d82 <UART_Transmit>
	UDR0 = data;													// Put data into buffer, sends the data
}

void UART_Transmit_String(const char *stringPtr)
{
	while(*stringPtr != 0x00)
    1da2:	89 91       	ld	r24, Y+
    1da4:	81 11       	cpse	r24, r1
    1da6:	fc cf       	rjmp	.-8      	; 0x1da0 <UART_Transmit_String+0xe>
	{
		UART_Transmit(*stringPtr);
		stringPtr++;
	}
	
	UART_Transmit('\n');
    1da8:	8a e0       	ldi	r24, 0x0A	; 10
    1daa:	eb df       	rcall	.-42     	; 0x1d82 <UART_Transmit>
	UART_Transmit('\r');
    1dac:	8d e0       	ldi	r24, 0x0D	; 13
    1dae:	e9 df       	rcall	.-46     	; 0x1d82 <UART_Transmit>
    1db0:	df 91       	pop	r29
}
    1db2:	cf 91       	pop	r28
    1db4:	08 95       	ret

00001db6 <queueTaak>:
    1db6:	0f 2e       	mov	r0, r31
{
	while(1){
		//_delay_ms(DELAY_BETWEEN_TESTS_MS);
		readQ();
		if (afstand > 30) {
			afstand = 30;
    1db8:	fe e1       	ldi	r31, 0x1E	; 30
    1dba:	cf 2e       	mov	r12, r31
    1dbc:	d1 2c       	mov	r13, r1
    1dbe:	f0 2d       	mov	r31, r0
		}
		hoek = afstand / 30.0 * 180.0;

		sprintf(out, "Afstand = %dCM, Hoek = %d", afstand,hoek);
    1dc0:	0f 2e       	mov	r0, r31
    1dc2:	fc e0       	ldi	r31, 0x0C	; 12
    1dc4:	ef 2e       	mov	r14, r31
    1dc6:	f2 e0       	ldi	r31, 0x02	; 2
    1dc8:	ff 2e       	mov	r15, r31
    1dca:	f0 2d       	mov	r31, r0
    1dcc:	04 e7       	ldi	r16, 0x74	; 116
    1dce:	13 e0       	ldi	r17, 0x03	; 3

void queueTaak()
{
	while(1){
		//_delay_ms(DELAY_BETWEEN_TESTS_MS);
		readQ();
    1dd0:	c2 df       	rcall	.-124    	; 0x1d56 <readQ>
		if (afstand > 30) {
    1dd2:	80 91 7b 04 	lds	r24, 0x047B	; 0x80047b <afstand>
    1dd6:	90 91 7c 04 	lds	r25, 0x047C	; 0x80047c <afstand+0x1>
    1dda:	4f 97       	sbiw	r24, 0x1f	; 31
    1ddc:	24 f0       	brlt	.+8      	; 0x1de6 <queueTaak+0x30>
			afstand = 30;
    1dde:	d0 92 7c 04 	sts	0x047C, r13	; 0x80047c <afstand+0x1>
    1de2:	c0 92 7b 04 	sts	0x047B, r12	; 0x80047b <afstand>
		}
		hoek = afstand / 30.0 * 180.0;
    1de6:	c0 91 7b 04 	lds	r28, 0x047B	; 0x80047b <afstand>
    1dea:	d0 91 7c 04 	lds	r29, 0x047C	; 0x80047c <afstand+0x1>
    1dee:	be 01       	movw	r22, r28
    1df0:	0d 2e       	mov	r0, r29
    1df2:	00 0c       	add	r0, r0
    1df4:	88 0b       	sbc	r24, r24
    1df6:	99 0b       	sbc	r25, r25
    1df8:	6e d2       	rcall	.+1244   	; 0x22d6 <__floatsisf>
    1dfa:	20 e0       	ldi	r18, 0x00	; 0
    1dfc:	30 e0       	ldi	r19, 0x00	; 0
    1dfe:	40 ef       	ldi	r20, 0xF0	; 240
    1e00:	51 e4       	ldi	r21, 0x41	; 65
    1e02:	ce d1       	rcall	.+924    	; 0x21a0 <__divsf3>
    1e04:	20 e0       	ldi	r18, 0x00	; 0
    1e06:	30 e0       	ldi	r19, 0x00	; 0
    1e08:	44 e3       	ldi	r20, 0x34	; 52
    1e0a:	53 e4       	ldi	r21, 0x43	; 67
    1e0c:	f0 d2       	rcall	.+1504   	; 0x23ee <__mulsf3>
    1e0e:	30 d2       	rcall	.+1120   	; 0x2270 <__fixsfsi>
    1e10:	60 93 74 04 	sts	0x0474, r22	; 0x800474 <hoek>
    1e14:	70 93 75 04 	sts	0x0475, r23	; 0x800475 <hoek+0x1>

		sprintf(out, "Afstand = %dCM, Hoek = %d", afstand,hoek);
    1e18:	7f 93       	push	r23
    1e1a:	6f 93       	push	r22
    1e1c:	df 93       	push	r29
    1e1e:	cf 93       	push	r28
    1e20:	ff 92       	push	r15
    1e22:	ef 92       	push	r14
    1e24:	1f 93       	push	r17
		
		UART_Transmit_String(out);
    1e26:	0f 93       	push	r16
    1e28:	b9 d4       	rcall	.+2418   	; 0x279c <sprintf>
    1e2a:	c8 01       	movw	r24, r16
		writeQ();
    1e2c:	b2 df       	rcall	.-156    	; 0x1d92 <UART_Transmit_String>
    1e2e:	87 df       	rcall	.-242    	; 0x1d3e <writeQ>
	}
    1e30:	8d b7       	in	r24, 0x3d	; 61
    1e32:	9e b7       	in	r25, 0x3e	; 62
    1e34:	08 96       	adiw	r24, 0x08	; 8
    1e36:	0f b6       	in	r0, 0x3f	; 63
    1e38:	f8 94       	cli
    1e3a:	9e bf       	out	0x3e, r25	; 62
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	8d bf       	out	0x3d, r24	; 61
    1e40:	c7 cf       	rjmp	.-114    	; 0x1dd0 <queueTaak+0x1a>

00001e42 <__vector_25>:
	UART_Transmit('\n');
	UART_Transmit('\r');
}

ISR(USART0_RX_vect)
{
    1e42:	1f 92       	push	r1
    1e44:	0f 92       	push	r0
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	0f 92       	push	r0
    1e4a:	11 24       	eor	r1, r1
    1e4c:	0b b6       	in	r0, 0x3b	; 59
    1e4e:	0f 92       	push	r0
    1e50:	2f 93       	push	r18
    1e52:	3f 93       	push	r19
    1e54:	4f 93       	push	r20
    1e56:	5f 93       	push	r21
    1e58:	6f 93       	push	r22
    1e5a:	7f 93       	push	r23
    1e5c:	8f 93       	push	r24
    1e5e:	9f 93       	push	r25
    1e60:	af 93       	push	r26
    1e62:	bf 93       	push	r27
    1e64:	ef 93       	push	r30
    1e66:	ff 93       	push	r31
	ontvang = UDR0;
    1e68:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1e6c:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <ontvang>
	UART_Transmit(ontvang);
    1e70:	88 df       	rcall	.-240    	; 0x1d82 <UART_Transmit>
	state = RECEIVED_TRUE;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	90 93 e3 02 	sts	0x02E3, r25	; 0x8002e3 <state+0x1>
    1e7a:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <state>
}
    1e7e:	ff 91       	pop	r31
    1e80:	ef 91       	pop	r30
    1e82:	bf 91       	pop	r27
    1e84:	af 91       	pop	r26
    1e86:	9f 91       	pop	r25
    1e88:	8f 91       	pop	r24
    1e8a:	7f 91       	pop	r23
    1e8c:	6f 91       	pop	r22
    1e8e:	5f 91       	pop	r21
    1e90:	4f 91       	pop	r20
    1e92:	3f 91       	pop	r19
    1e94:	2f 91       	pop	r18
    1e96:	0f 90       	pop	r0
    1e98:	0b be       	out	0x3b, r0	; 59
    1e9a:	0f 90       	pop	r0
    1e9c:	0f be       	out	0x3f, r0	; 63
    1e9e:	0f 90       	pop	r0
    1ea0:	1f 90       	pop	r1
    1ea2:	18 95       	reti

00001ea4 <INT1_init>:

//Sonar functions
void INT1_init()
{
	EICRA |= (1 << ISC10) | (0 << ISC11);							// set rising or falling edge on INT1
    1ea4:	e9 e6       	ldi	r30, 0x69	; 105
    1ea6:	f0 e0       	ldi	r31, 0x00	; 0
    1ea8:	80 81       	ld	r24, Z
    1eaa:	84 60       	ori	r24, 0x04	; 4
    1eac:	80 83       	st	Z, r24
	EIMSK |= (1 << INT1);											// Enable INT1
    1eae:	e9 9a       	sbi	0x1d, 1	; 29
    1eb0:	08 95       	ret

00001eb2 <__vector_2>:
}

ISR(INT1_vect)
{
    1eb2:	1f 92       	push	r1
    1eb4:	0f 92       	push	r0
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	0f 92       	push	r0
    1eba:	11 24       	eor	r1, r1
    1ebc:	0b b6       	in	r0, 0x3b	; 59
    1ebe:	0f 92       	push	r0
    1ec0:	2f 93       	push	r18
    1ec2:	3f 93       	push	r19
    1ec4:	4f 93       	push	r20
    1ec6:	5f 93       	push	r21
    1ec8:	6f 93       	push	r22
    1eca:	7f 93       	push	r23
    1ecc:	8f 93       	push	r24
    1ece:	9f 93       	push	r25
    1ed0:	af 93       	push	r26
    1ed2:	bf 93       	push	r27
    1ed4:	ef 93       	push	r30
    1ed6:	ff 93       	push	r31
	if(running)														// check if the pulse has been send.
    1ed8:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <running>
    1edc:	88 23       	and	r24, r24
    1ede:	c1 f1       	breq	.+112    	; 0x1f50 <__vector_2+0x9e>
	{
		if(up == 0)													// voltage rise
    1ee0:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <up>
    1ee4:	81 11       	cpse	r24, r1
    1ee6:	10 c0       	rjmp	.+32     	; 0x1f08 <__vector_2+0x56>
		{
			up = 1;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <up>
			timerCounter = 0;
    1eee:	10 92 dc 02 	sts	0x02DC, r1	; 0x8002dc <timerCounter>
    1ef2:	10 92 dd 02 	sts	0x02DD, r1	; 0x8002dd <timerCounter+0x1>
    1ef6:	10 92 de 02 	sts	0x02DE, r1	; 0x8002de <timerCounter+0x2>
    1efa:	10 92 df 02 	sts	0x02DF, r1	; 0x8002df <timerCounter+0x3>
			TCNT3 = 0;
    1efe:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
    1f02:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
    1f06:	24 c0       	rjmp	.+72     	; 0x1f50 <__vector_2+0x9e>
		}
		else														// faling edge
		{
			up = 0;
    1f08:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <up>
			result = ((timerCounter * 65535 + TCNT3) / 58) / 2;
    1f0c:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <timerCounter>
    1f10:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <timerCounter+0x1>
    1f14:	40 91 de 02 	lds	r20, 0x02DE	; 0x8002de <timerCounter+0x2>
    1f18:	50 91 df 02 	lds	r21, 0x02DF	; 0x8002df <timerCounter+0x3>
    1f1c:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
    1f20:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
    1f24:	af ef       	ldi	r26, 0xFF	; 255
    1f26:	bf ef       	ldi	r27, 0xFF	; 255
    1f28:	fe d2       	rcall	.+1532   	; 0x2526 <__muluhisi3>
    1f2a:	6e 0f       	add	r22, r30
    1f2c:	7f 1f       	adc	r23, r31
    1f2e:	81 1d       	adc	r24, r1
    1f30:	91 1d       	adc	r25, r1
    1f32:	24 e7       	ldi	r18, 0x74	; 116
    1f34:	30 e0       	ldi	r19, 0x00	; 0
    1f36:	40 e0       	ldi	r20, 0x00	; 0
    1f38:	50 e0       	ldi	r21, 0x00	; 0
    1f3a:	bc d2       	rcall	.+1400   	; 0x24b4 <__udivmodsi4>
    1f3c:	20 93 d8 02 	sts	0x02D8, r18	; 0x8002d8 <result>
    1f40:	30 93 d9 02 	sts	0x02D9, r19	; 0x8002d9 <result+0x1>
    1f44:	40 93 da 02 	sts	0x02DA, r20	; 0x8002da <result+0x2>
    1f48:	50 93 db 02 	sts	0x02DB, r21	; 0x8002db <result+0x3>
			running = 0;
    1f4c:	10 92 e1 02 	sts	0x02E1, r1	; 0x8002e1 <running>
		}
	}
}
    1f50:	ff 91       	pop	r31
    1f52:	ef 91       	pop	r30
    1f54:	bf 91       	pop	r27
    1f56:	af 91       	pop	r26
    1f58:	9f 91       	pop	r25
    1f5a:	8f 91       	pop	r24
    1f5c:	7f 91       	pop	r23
    1f5e:	6f 91       	pop	r22
    1f60:	5f 91       	pop	r21
    1f62:	4f 91       	pop	r20
    1f64:	3f 91       	pop	r19
    1f66:	2f 91       	pop	r18
    1f68:	0f 90       	pop	r0
    1f6a:	0b be       	out	0x3b, r0	; 59
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	0f 90       	pop	r0
    1f72:	1f 90       	pop	r1
    1f74:	18 95       	reti

00001f76 <pulse>:

void pulse()
{
	PORTB &= ~(1 << TRIGGER);
    1f76:	28 98       	cbi	0x05, 0	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f78:	85 e0       	ldi	r24, 0x05	; 5
    1f7a:	8a 95       	dec	r24
    1f7c:	f1 f7       	brne	.-4      	; 0x1f7a <pulse+0x4>
    1f7e:	00 00       	nop
	_delay_us(1);


	PORTB |= (1 << TRIGGER);										// zet trigger op 1
    1f80:	28 9a       	sbi	0x05, 0	; 5
	running = 1;
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <running>
    1f88:	85 e3       	ldi	r24, 0x35	; 53
    1f8a:	8a 95       	dec	r24
    1f8c:	f1 f7       	brne	.-4      	; 0x1f8a <pulse+0x14>
    1f8e:	00 00       	nop
	_delay_us(10);													// wacht 10 microseconden
	PORTB &= ~(1 << TRIGGER);										// zet trigger op 0
    1f90:	28 98       	cbi	0x05, 0	; 5
    1f92:	08 95       	ret

00001f94 <sonarTaak>:
{
	//UART_Transmit_String("taak uitgevoerd");
	//wdt_enable(WDTO_2S);											// enable watchdog timer at 2 seconds
	while(1)
	{
		if(running == 0)
    1f94:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <running>
    1f98:	81 11       	cpse	r24, r1
    1f9a:	fc cf       	rjmp	.-8      	; 0x1f94 <sonarTaak>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f9c:	2f ef       	ldi	r18, 0xFF	; 255
    1f9e:	80 e7       	ldi	r24, 0x70	; 112
    1fa0:	92 e0       	ldi	r25, 0x02	; 2
    1fa2:	21 50       	subi	r18, 0x01	; 1
    1fa4:	80 40       	sbci	r24, 0x00	; 0
    1fa6:	90 40       	sbci	r25, 0x00	; 0
    1fa8:	e1 f7       	brne	.-8      	; 0x1fa2 <sonarTaak+0xe>
    1faa:	00 c0       	rjmp	.+0      	; 0x1fac <sonarTaak+0x18>
    1fac:	00 00       	nop
		{
			_delay_ms(DELAY_BETWEEN_TESTS_MS);
			pulse();
    1fae:	e3 df       	rcall	.-58     	; 0x1f76 <pulse>
			xQueueSend(sonarAfstand, (void*) &result,0);
    1fb0:	20 e0       	ldi	r18, 0x00	; 0
    1fb2:	40 e0       	ldi	r20, 0x00	; 0
    1fb4:	50 e0       	ldi	r21, 0x00	; 0
    1fb6:	68 ed       	ldi	r22, 0xD8	; 216
    1fb8:	72 e0       	ldi	r23, 0x02	; 2
    1fba:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <sonarAfstand>
    1fbe:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <sonarAfstand+0x1>
    1fc2:	0e 94 39 06 	call	0xc72	; 0xc72 <xQueueGenericSend>
    1fc6:	e6 cf       	rjmp	.-52     	; 0x1f94 <sonarTaak>

00001fc8 <timer3_init>:
	PORTB &= ~(1 << TRIGGER);										// zet trigger op 0
}

void timer3_init()
{
	TCCR3B |= (0 << CS30) | (1 << CS31) | (0 << CS32);				// prescaler 1024 so we get 15625Hz clock ticks. or 4.19 s per tick.
    1fc8:	e1 e9       	ldi	r30, 0x91	; 145
    1fca:	f0 e0       	ldi	r31, 0x00	; 0
    1fcc:	80 81       	ld	r24, Z
    1fce:	82 60       	ori	r24, 0x02	; 2
    1fd0:	80 83       	st	Z, r24
	TCNT3 = 0;														// init counter
    1fd2:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
    1fd6:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
	TIMSK3 |= (1 << TOIE3);											// enable overflow interrupt
    1fda:	e1 e7       	ldi	r30, 0x71	; 113
    1fdc:	f0 e0       	ldi	r31, 0x00	; 0
    1fde:	80 81       	ld	r24, Z
    1fe0:	81 60       	ori	r24, 0x01	; 1
    1fe2:	80 83       	st	Z, r24
    1fe4:	08 95       	ret

00001fe6 <__vector_35>:
}

ISR(TIMER3_OVF_vect)
{
    1fe6:	1f 92       	push	r1
    1fe8:	0f 92       	push	r0
    1fea:	0f b6       	in	r0, 0x3f	; 63
    1fec:	0f 92       	push	r0
    1fee:	11 24       	eor	r1, r1
    1ff0:	0b b6       	in	r0, 0x3b	; 59
    1ff2:	0f 92       	push	r0
    1ff4:	2f 93       	push	r18
    1ff6:	3f 93       	push	r19
    1ff8:	4f 93       	push	r20
    1ffa:	5f 93       	push	r21
    1ffc:	6f 93       	push	r22
    1ffe:	7f 93       	push	r23
    2000:	8f 93       	push	r24
    2002:	9f 93       	push	r25
    2004:	af 93       	push	r26
    2006:	bf 93       	push	r27
    2008:	ef 93       	push	r30
    200a:	ff 93       	push	r31
	if(up)
    200c:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <up>
    2010:	88 23       	and	r24, r24
    2012:	e1 f1       	breq	.+120    	; 0x208c <__vector_35+0xa6>
	{
		timerCounter++;
    2014:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <timerCounter>
    2018:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <timerCounter+0x1>
    201c:	a0 91 de 02 	lds	r26, 0x02DE	; 0x8002de <timerCounter+0x2>
    2020:	b0 91 df 02 	lds	r27, 0x02DF	; 0x8002df <timerCounter+0x3>
    2024:	01 96       	adiw	r24, 0x01	; 1
    2026:	a1 1d       	adc	r26, r1
    2028:	b1 1d       	adc	r27, r1
    202a:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <timerCounter>
    202e:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <timerCounter+0x1>
    2032:	a0 93 de 02 	sts	0x02DE, r26	; 0x8002de <timerCounter+0x2>
    2036:	b0 93 df 02 	sts	0x02DF, r27	; 0x8002df <timerCounter+0x3>
		uint32_t ticks = timerCounter * 65535 + TCNT3;
    203a:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <timerCounter>
    203e:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <timerCounter+0x1>
    2042:	40 91 de 02 	lds	r20, 0x02DE	; 0x8002de <timerCounter+0x2>
    2046:	50 91 df 02 	lds	r21, 0x02DF	; 0x8002df <timerCounter+0x3>
    204a:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
    204e:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
		uint32_t maxTicks = (uint32_t)MAX_RESP_TIME_MS * INSTR_PER_MS;
		if(ticks > maxTicks)
    2052:	af ef       	ldi	r26, 0xFF	; 255
    2054:	bf ef       	ldi	r27, 0xFF	; 255
    2056:	67 d2       	rcall	.+1230   	; 0x2526 <__muluhisi3>
    2058:	dc 01       	movw	r26, r24
    205a:	cb 01       	movw	r24, r22
    205c:	8e 0f       	add	r24, r30
    205e:	9f 1f       	adc	r25, r31
    2060:	a1 1d       	adc	r26, r1
    2062:	b1 1d       	adc	r27, r1
    2064:	81 30       	cpi	r24, 0x01	; 1
    2066:	94 4d       	sbci	r25, 0xD4	; 212
    2068:	a0 43       	sbci	r26, 0x30	; 48
    206a:	b1 05       	cpc	r27, r1
    206c:	78 f0       	brcs	.+30     	; 0x208c <__vector_35+0xa6>
		{
			up = 0;
    206e:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <up>
			running = 0;
    2072:	10 92 e1 02 	sts	0x02E1, r1	; 0x8002e1 <running>
			result = -1;
    2076:	8f ef       	ldi	r24, 0xFF	; 255
    2078:	9f ef       	ldi	r25, 0xFF	; 255
    207a:	dc 01       	movw	r26, r24
    207c:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <result>
    2080:	90 93 d9 02 	sts	0x02D9, r25	; 0x8002d9 <result+0x1>
    2084:	a0 93 da 02 	sts	0x02DA, r26	; 0x8002da <result+0x2>
    2088:	b0 93 db 02 	sts	0x02DB, r27	; 0x8002db <result+0x3>
		}
	}
}
    208c:	ff 91       	pop	r31
    208e:	ef 91       	pop	r30
    2090:	bf 91       	pop	r27
    2092:	af 91       	pop	r26
    2094:	9f 91       	pop	r25
    2096:	8f 91       	pop	r24
    2098:	7f 91       	pop	r23
    209a:	6f 91       	pop	r22
    209c:	5f 91       	pop	r21
    209e:	4f 91       	pop	r20
    20a0:	3f 91       	pop	r19
    20a2:	2f 91       	pop	r18
    20a4:	0f 90       	pop	r0
    20a6:	0b be       	out	0x3b, r0	; 59
    20a8:	0f 90       	pop	r0
    20aa:	0f be       	out	0x3f, r0	; 63
    20ac:	0f 90       	pop	r0
    20ae:	1f 90       	pop	r1
    20b0:	18 95       	reti

000020b2 <turnServo>:

void turnServo(uint8_t degrees)
{
	OCR1A = 20000 - (degrees * (1300 / 180) + 800);
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	22 27       	eor	r18, r18
    20b6:	33 27       	eor	r19, r19
    20b8:	28 1b       	sub	r18, r24
    20ba:	39 0b       	sbc	r19, r25
    20bc:	22 0f       	add	r18, r18
    20be:	33 1f       	adc	r19, r19
    20c0:	22 0f       	add	r18, r18
    20c2:	33 1f       	adc	r19, r19
    20c4:	22 0f       	add	r18, r18
    20c6:	33 1f       	adc	r19, r19
    20c8:	82 0f       	add	r24, r18
    20ca:	93 1f       	adc	r25, r19
    20cc:	95 5b       	subi	r25, 0xB5	; 181
    20ce:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    20d2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    20d6:	08 95       	ret

000020d8 <servoTaak>:

void servoTaak()
{
	while(1)
	{
		turnServo(hoek);
    20d8:	c4 e7       	ldi	r28, 0x74	; 116
    20da:	d4 e0       	ldi	r29, 0x04	; 4
    20dc:	88 81       	ld	r24, Y
    20de:	e9 df       	rcall	.-46     	; 0x20b2 <turnServo>
    20e0:	fd cf       	rjmp	.-6      	; 0x20dc <servoTaak+0x4>

000020e2 <initServo>:
	PORTA ^= (1 << PA7);
}*/

void initServo()
{
	TCCR1A |= (1 << WGM11);
    20e2:	e0 e8       	ldi	r30, 0x80	; 128
    20e4:	f0 e0       	ldi	r31, 0x00	; 0
    20e6:	80 81       	ld	r24, Z
    20e8:	82 60       	ori	r24, 0x02	; 2
    20ea:	80 83       	st	Z, r24
	TCCR1B |= (1 << CS11) | (1 << WGM13);
    20ec:	e1 e8       	ldi	r30, 0x81	; 129
    20ee:	f0 e0       	ldi	r31, 0x00	; 0
    20f0:	80 81       	ld	r24, Z
    20f2:	82 61       	ori	r24, 0x12	; 18
    20f4:	80 83       	st	Z, r24
	ICR1 = 20000;
    20f6:	80 e2       	ldi	r24, 0x20	; 32
    20f8:	9e e4       	ldi	r25, 0x4E	; 78
    20fa:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    20fe:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	OCR1A = 18500;
    2102:	84 e4       	ldi	r24, 0x44	; 68
    2104:	98 e4       	ldi	r25, 0x48	; 72
    2106:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    210a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	TIMSK1 |= (1 << 1);
    210e:	ef e6       	ldi	r30, 0x6F	; 111
    2110:	f0 e0       	ldi	r31, 0x00	; 0
    2112:	80 81       	ld	r24, Z
    2114:	82 60       	ori	r24, 0x02	; 2
    2116:	80 83       	st	Z, r24
    2118:	08 95       	ret

0000211a <main>:
//echo = digital pin 20
//servo = digital pin 12


int main() 
{
    211a:	ef 92       	push	r14
    211c:	ff 92       	push	r15
    211e:	0f 93       	push	r16
	DDRB |= (1 << TRIGGER);											// Trigger pin
    2120:	20 9a       	sbi	0x04, 0	; 4
	UART_Init(MYUBRR);
    2122:	87 e6       	ldi	r24, 0x67	; 103
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	22 de       	rcall	.-956    	; 0x1d6c <UART_Init>
	INT1_init();
    2128:	bd de       	rcall	.-646    	; 0x1ea4 <INT1_init>
	timer3_init();
    212a:	4e df       	rcall	.-356    	; 0x1fc8 <timer3_init>
	initServo();
    212c:	da df       	rcall	.-76     	; 0x20e2 <initServo>
    212e:	78 94       	sei
	sei();
	initQ();
    2130:	dd dd       	rcall	.-1094   	; 0x1cec <initQ>
    2132:	86 e2       	ldi	r24, 0x26	; 38
	UART_Transmit_String("Setup done");
    2134:	92 e0       	ldi	r25, 0x02	; 2
    2136:	2d de       	rcall	.-934    	; 0x1d92 <UART_Transmit_String>
    2138:	e1 2c       	mov	r14, r1
    213a:	f1 2c       	mov	r15, r1

	xTaskCreate(queueTaak,"Queue Taken",256,NULL,3,NULL);			//task voor lezen uit sonar queue en schrijven naar servo queue
    213c:	03 e0       	ldi	r16, 0x03	; 3
    213e:	20 e0       	ldi	r18, 0x00	; 0
    2140:	30 e0       	ldi	r19, 0x00	; 0
    2142:	40 e0       	ldi	r20, 0x00	; 0
    2144:	51 e0       	ldi	r21, 0x01	; 1
    2146:	61 e3       	ldi	r22, 0x31	; 49
    2148:	72 e0       	ldi	r23, 0x02	; 2
    214a:	8b ed       	ldi	r24, 0xDB	; 219
    214c:	9e e0       	ldi	r25, 0x0E	; 14
    214e:	8a d9       	rcall	.-3308   	; 0x1464 <xTaskCreate>
    2150:	20 e0       	ldi	r18, 0x00	; 0
    2152:	30 e0       	ldi	r19, 0x00	; 0
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,3,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
    2154:	40 e0       	ldi	r20, 0x00	; 0
    2156:	51 e0       	ldi	r21, 0x01	; 1
    2158:	6d e3       	ldi	r22, 0x3D	; 61
    215a:	72 e0       	ldi	r23, 0x02	; 2
    215c:	8a ec       	ldi	r24, 0xCA	; 202
    215e:	9f e0       	ldi	r25, 0x0F	; 15
    2160:	81 d9       	rcall	.-3326   	; 0x1464 <xTaskCreate>
    2162:	20 e0       	ldi	r18, 0x00	; 0
    2164:	30 e0       	ldi	r19, 0x00	; 0
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,3,NULL);			//code van Joris & Benjamin 
    2166:	40 e0       	ldi	r20, 0x00	; 0
    2168:	51 e0       	ldi	r21, 0x01	; 1
    216a:	6a e4       	ldi	r22, 0x4A	; 74
    216c:	72 e0       	ldi	r23, 0x02	; 2
    216e:	8c e6       	ldi	r24, 0x6C	; 108
    2170:	90 e1       	ldi	r25, 0x10	; 16
    2172:	78 d9       	rcall	.-3344   	; 0x1464 <xTaskCreate>
    2174:	81 da       	rcall	.-2814   	; 0x1678 <vTaskStartScheduler>

	vTaskStartScheduler();
    2176:	80 e0       	ldi	r24, 0x00	; 0
    2178:	90 e0       	ldi	r25, 0x00	; 0
}
    217a:	0f 91       	pop	r16
    217c:	ff 90       	pop	r15
    217e:	ef 90       	pop	r14
    2180:	08 95       	ret

00002182 <__vector_17>:
    2182:	1f 92       	push	r1
    2184:	0f 92       	push	r0
	OCR1A = 18500;
	TIMSK1 |= (1 << 1);
}

ISR(TIMER1_COMPA_vect)
{
    2186:	0f b6       	in	r0, 0x3f	; 63
    2188:	0f 92       	push	r0
    218a:	11 24       	eor	r1, r1
    218c:	8f 93       	push	r24
	PORTA ^= (1 << PA7);
    218e:	82 b1       	in	r24, 0x02	; 2
    2190:	80 58       	subi	r24, 0x80	; 128
    2192:	82 b9       	out	0x02, r24	; 2
    2194:	8f 91       	pop	r24
    2196:	0f 90       	pop	r0
    2198:	0f be       	out	0x3f, r0	; 63
    219a:	0f 90       	pop	r0
    219c:	1f 90       	pop	r1
    219e:	18 95       	reti

000021a0 <__divsf3>:
    21a0:	0c d0       	rcall	.+24     	; 0x21ba <__divsf3x>
    21a2:	eb c0       	rjmp	.+470    	; 0x237a <__fp_round>
    21a4:	e3 d0       	rcall	.+454    	; 0x236c <__fp_pscB>
    21a6:	40 f0       	brcs	.+16     	; 0x21b8 <__divsf3+0x18>
    21a8:	da d0       	rcall	.+436    	; 0x235e <__fp_pscA>
    21aa:	30 f0       	brcs	.+12     	; 0x21b8 <__divsf3+0x18>
    21ac:	21 f4       	brne	.+8      	; 0x21b6 <__divsf3+0x16>
    21ae:	5f 3f       	cpi	r21, 0xFF	; 255
    21b0:	19 f0       	breq	.+6      	; 0x21b8 <__divsf3+0x18>
    21b2:	cc c0       	rjmp	.+408    	; 0x234c <__fp_inf>
    21b4:	51 11       	cpse	r21, r1
    21b6:	15 c1       	rjmp	.+554    	; 0x23e2 <__fp_szero>
    21b8:	cf c0       	rjmp	.+414    	; 0x2358 <__fp_nan>

000021ba <__divsf3x>:
    21ba:	f0 d0       	rcall	.+480    	; 0x239c <__fp_split3>
    21bc:	98 f3       	brcs	.-26     	; 0x21a4 <__divsf3+0x4>

000021be <__divsf3_pse>:
    21be:	99 23       	and	r25, r25
    21c0:	c9 f3       	breq	.-14     	; 0x21b4 <__divsf3+0x14>
    21c2:	55 23       	and	r21, r21
    21c4:	b1 f3       	breq	.-20     	; 0x21b2 <__divsf3+0x12>
    21c6:	95 1b       	sub	r25, r21
    21c8:	55 0b       	sbc	r21, r21
    21ca:	bb 27       	eor	r27, r27
    21cc:	aa 27       	eor	r26, r26
    21ce:	62 17       	cp	r22, r18
    21d0:	73 07       	cpc	r23, r19
    21d2:	84 07       	cpc	r24, r20
    21d4:	38 f0       	brcs	.+14     	; 0x21e4 <__divsf3_pse+0x26>
    21d6:	9f 5f       	subi	r25, 0xFF	; 255
    21d8:	5f 4f       	sbci	r21, 0xFF	; 255
    21da:	22 0f       	add	r18, r18
    21dc:	33 1f       	adc	r19, r19
    21de:	44 1f       	adc	r20, r20
    21e0:	aa 1f       	adc	r26, r26
    21e2:	a9 f3       	breq	.-22     	; 0x21ce <__divsf3_pse+0x10>
    21e4:	33 d0       	rcall	.+102    	; 0x224c <__stack+0x4d>
    21e6:	0e 2e       	mov	r0, r30
    21e8:	3a f0       	brmi	.+14     	; 0x21f8 <__divsf3_pse+0x3a>
    21ea:	e0 e8       	ldi	r30, 0x80	; 128
    21ec:	30 d0       	rcall	.+96     	; 0x224e <__stack+0x4f>
    21ee:	91 50       	subi	r25, 0x01	; 1
    21f0:	50 40       	sbci	r21, 0x00	; 0
    21f2:	e6 95       	lsr	r30
    21f4:	00 1c       	adc	r0, r0
    21f6:	ca f7       	brpl	.-14     	; 0x21ea <__divsf3_pse+0x2c>
    21f8:	29 d0       	rcall	.+82     	; 0x224c <__stack+0x4d>
    21fa:	fe 2f       	mov	r31, r30
    21fc:	27 d0       	rcall	.+78     	; 0x224c <__stack+0x4d>
    21fe:	66 0f       	add	r22, r22
    2200:	77 1f       	adc	r23, r23
    2202:	88 1f       	adc	r24, r24
    2204:	bb 1f       	adc	r27, r27
    2206:	26 17       	cp	r18, r22
    2208:	37 07       	cpc	r19, r23
    220a:	48 07       	cpc	r20, r24
    220c:	ab 07       	cpc	r26, r27
    220e:	b0 e8       	ldi	r27, 0x80	; 128
    2210:	09 f0       	breq	.+2      	; 0x2214 <__stack+0x15>
    2212:	bb 0b       	sbc	r27, r27
    2214:	80 2d       	mov	r24, r0
    2216:	bf 01       	movw	r22, r30
    2218:	ff 27       	eor	r31, r31
    221a:	93 58       	subi	r25, 0x83	; 131
    221c:	5f 4f       	sbci	r21, 0xFF	; 255
    221e:	2a f0       	brmi	.+10     	; 0x222a <__stack+0x2b>
    2220:	9e 3f       	cpi	r25, 0xFE	; 254
    2222:	51 05       	cpc	r21, r1
    2224:	68 f0       	brcs	.+26     	; 0x2240 <__stack+0x41>
    2226:	92 c0       	rjmp	.+292    	; 0x234c <__fp_inf>
    2228:	dc c0       	rjmp	.+440    	; 0x23e2 <__fp_szero>
    222a:	5f 3f       	cpi	r21, 0xFF	; 255
    222c:	ec f3       	brlt	.-6      	; 0x2228 <__stack+0x29>
    222e:	98 3e       	cpi	r25, 0xE8	; 232
    2230:	dc f3       	brlt	.-10     	; 0x2228 <__stack+0x29>
    2232:	86 95       	lsr	r24
    2234:	77 95       	ror	r23
    2236:	67 95       	ror	r22
    2238:	b7 95       	ror	r27
    223a:	f7 95       	ror	r31
    223c:	9f 5f       	subi	r25, 0xFF	; 255
    223e:	c9 f7       	brne	.-14     	; 0x2232 <__stack+0x33>
    2240:	88 0f       	add	r24, r24
    2242:	91 1d       	adc	r25, r1
    2244:	96 95       	lsr	r25
    2246:	87 95       	ror	r24
    2248:	97 f9       	bld	r25, 7
    224a:	08 95       	ret
    224c:	e1 e0       	ldi	r30, 0x01	; 1
    224e:	66 0f       	add	r22, r22
    2250:	77 1f       	adc	r23, r23
    2252:	88 1f       	adc	r24, r24
    2254:	bb 1f       	adc	r27, r27
    2256:	62 17       	cp	r22, r18
    2258:	73 07       	cpc	r23, r19
    225a:	84 07       	cpc	r24, r20
    225c:	ba 07       	cpc	r27, r26
    225e:	20 f0       	brcs	.+8      	; 0x2268 <__stack+0x69>
    2260:	62 1b       	sub	r22, r18
    2262:	73 0b       	sbc	r23, r19
    2264:	84 0b       	sbc	r24, r20
    2266:	ba 0b       	sbc	r27, r26
    2268:	ee 1f       	adc	r30, r30
    226a:	88 f7       	brcc	.-30     	; 0x224e <__stack+0x4f>
    226c:	e0 95       	com	r30
    226e:	08 95       	ret

00002270 <__fixsfsi>:
    2270:	04 d0       	rcall	.+8      	; 0x227a <__fixunssfsi>
    2272:	68 94       	set
    2274:	b1 11       	cpse	r27, r1
    2276:	b5 c0       	rjmp	.+362    	; 0x23e2 <__fp_szero>
    2278:	08 95       	ret

0000227a <__fixunssfsi>:
    227a:	98 d0       	rcall	.+304    	; 0x23ac <__fp_splitA>
    227c:	88 f0       	brcs	.+34     	; 0x22a0 <__fixunssfsi+0x26>
    227e:	9f 57       	subi	r25, 0x7F	; 127
    2280:	90 f0       	brcs	.+36     	; 0x22a6 <__fixunssfsi+0x2c>
    2282:	b9 2f       	mov	r27, r25
    2284:	99 27       	eor	r25, r25
    2286:	b7 51       	subi	r27, 0x17	; 23
    2288:	a0 f0       	brcs	.+40     	; 0x22b2 <__fixunssfsi+0x38>
    228a:	d1 f0       	breq	.+52     	; 0x22c0 <__fixunssfsi+0x46>
    228c:	66 0f       	add	r22, r22
    228e:	77 1f       	adc	r23, r23
    2290:	88 1f       	adc	r24, r24
    2292:	99 1f       	adc	r25, r25
    2294:	1a f0       	brmi	.+6      	; 0x229c <__fixunssfsi+0x22>
    2296:	ba 95       	dec	r27
    2298:	c9 f7       	brne	.-14     	; 0x228c <__fixunssfsi+0x12>
    229a:	12 c0       	rjmp	.+36     	; 0x22c0 <__fixunssfsi+0x46>
    229c:	b1 30       	cpi	r27, 0x01	; 1
    229e:	81 f0       	breq	.+32     	; 0x22c0 <__fixunssfsi+0x46>
    22a0:	9f d0       	rcall	.+318    	; 0x23e0 <__fp_zero>
    22a2:	b1 e0       	ldi	r27, 0x01	; 1
    22a4:	08 95       	ret
    22a6:	9c c0       	rjmp	.+312    	; 0x23e0 <__fp_zero>
    22a8:	67 2f       	mov	r22, r23
    22aa:	78 2f       	mov	r23, r24
    22ac:	88 27       	eor	r24, r24
    22ae:	b8 5f       	subi	r27, 0xF8	; 248
    22b0:	39 f0       	breq	.+14     	; 0x22c0 <__fixunssfsi+0x46>
    22b2:	b9 3f       	cpi	r27, 0xF9	; 249
    22b4:	cc f3       	brlt	.-14     	; 0x22a8 <__fixunssfsi+0x2e>
    22b6:	86 95       	lsr	r24
    22b8:	77 95       	ror	r23
    22ba:	67 95       	ror	r22
    22bc:	b3 95       	inc	r27
    22be:	d9 f7       	brne	.-10     	; 0x22b6 <__fixunssfsi+0x3c>
    22c0:	3e f4       	brtc	.+14     	; 0x22d0 <__fixunssfsi+0x56>
    22c2:	90 95       	com	r25
    22c4:	80 95       	com	r24
    22c6:	70 95       	com	r23
    22c8:	61 95       	neg	r22
    22ca:	7f 4f       	sbci	r23, 0xFF	; 255
    22cc:	8f 4f       	sbci	r24, 0xFF	; 255
    22ce:	9f 4f       	sbci	r25, 0xFF	; 255
    22d0:	08 95       	ret

000022d2 <__floatunsisf>:
    22d2:	e8 94       	clt
    22d4:	09 c0       	rjmp	.+18     	; 0x22e8 <__floatsisf+0x12>

000022d6 <__floatsisf>:
    22d6:	97 fb       	bst	r25, 7
    22d8:	3e f4       	brtc	.+14     	; 0x22e8 <__floatsisf+0x12>
    22da:	90 95       	com	r25
    22dc:	80 95       	com	r24
    22de:	70 95       	com	r23
    22e0:	61 95       	neg	r22
    22e2:	7f 4f       	sbci	r23, 0xFF	; 255
    22e4:	8f 4f       	sbci	r24, 0xFF	; 255
    22e6:	9f 4f       	sbci	r25, 0xFF	; 255
    22e8:	99 23       	and	r25, r25
    22ea:	a9 f0       	breq	.+42     	; 0x2316 <__floatsisf+0x40>
    22ec:	f9 2f       	mov	r31, r25
    22ee:	96 e9       	ldi	r25, 0x96	; 150
    22f0:	bb 27       	eor	r27, r27
    22f2:	93 95       	inc	r25
    22f4:	f6 95       	lsr	r31
    22f6:	87 95       	ror	r24
    22f8:	77 95       	ror	r23
    22fa:	67 95       	ror	r22
    22fc:	b7 95       	ror	r27
    22fe:	f1 11       	cpse	r31, r1
    2300:	f8 cf       	rjmp	.-16     	; 0x22f2 <__floatsisf+0x1c>
    2302:	fa f4       	brpl	.+62     	; 0x2342 <__floatsisf+0x6c>
    2304:	bb 0f       	add	r27, r27
    2306:	11 f4       	brne	.+4      	; 0x230c <__floatsisf+0x36>
    2308:	60 ff       	sbrs	r22, 0
    230a:	1b c0       	rjmp	.+54     	; 0x2342 <__floatsisf+0x6c>
    230c:	6f 5f       	subi	r22, 0xFF	; 255
    230e:	7f 4f       	sbci	r23, 0xFF	; 255
    2310:	8f 4f       	sbci	r24, 0xFF	; 255
    2312:	9f 4f       	sbci	r25, 0xFF	; 255
    2314:	16 c0       	rjmp	.+44     	; 0x2342 <__floatsisf+0x6c>
    2316:	88 23       	and	r24, r24
    2318:	11 f0       	breq	.+4      	; 0x231e <__floatsisf+0x48>
    231a:	96 e9       	ldi	r25, 0x96	; 150
    231c:	11 c0       	rjmp	.+34     	; 0x2340 <__floatsisf+0x6a>
    231e:	77 23       	and	r23, r23
    2320:	21 f0       	breq	.+8      	; 0x232a <__floatsisf+0x54>
    2322:	9e e8       	ldi	r25, 0x8E	; 142
    2324:	87 2f       	mov	r24, r23
    2326:	76 2f       	mov	r23, r22
    2328:	05 c0       	rjmp	.+10     	; 0x2334 <__floatsisf+0x5e>
    232a:	66 23       	and	r22, r22
    232c:	71 f0       	breq	.+28     	; 0x234a <__floatsisf+0x74>
    232e:	96 e8       	ldi	r25, 0x86	; 134
    2330:	86 2f       	mov	r24, r22
    2332:	70 e0       	ldi	r23, 0x00	; 0
    2334:	60 e0       	ldi	r22, 0x00	; 0
    2336:	2a f0       	brmi	.+10     	; 0x2342 <__floatsisf+0x6c>
    2338:	9a 95       	dec	r25
    233a:	66 0f       	add	r22, r22
    233c:	77 1f       	adc	r23, r23
    233e:	88 1f       	adc	r24, r24
    2340:	da f7       	brpl	.-10     	; 0x2338 <__floatsisf+0x62>
    2342:	88 0f       	add	r24, r24
    2344:	96 95       	lsr	r25
    2346:	87 95       	ror	r24
    2348:	97 f9       	bld	r25, 7
    234a:	08 95       	ret

0000234c <__fp_inf>:
    234c:	97 f9       	bld	r25, 7
    234e:	9f 67       	ori	r25, 0x7F	; 127
    2350:	80 e8       	ldi	r24, 0x80	; 128
    2352:	70 e0       	ldi	r23, 0x00	; 0
    2354:	60 e0       	ldi	r22, 0x00	; 0
    2356:	08 95       	ret

00002358 <__fp_nan>:
    2358:	9f ef       	ldi	r25, 0xFF	; 255
    235a:	80 ec       	ldi	r24, 0xC0	; 192
    235c:	08 95       	ret

0000235e <__fp_pscA>:
    235e:	00 24       	eor	r0, r0
    2360:	0a 94       	dec	r0
    2362:	16 16       	cp	r1, r22
    2364:	17 06       	cpc	r1, r23
    2366:	18 06       	cpc	r1, r24
    2368:	09 06       	cpc	r0, r25
    236a:	08 95       	ret

0000236c <__fp_pscB>:
    236c:	00 24       	eor	r0, r0
    236e:	0a 94       	dec	r0
    2370:	12 16       	cp	r1, r18
    2372:	13 06       	cpc	r1, r19
    2374:	14 06       	cpc	r1, r20
    2376:	05 06       	cpc	r0, r21
    2378:	08 95       	ret

0000237a <__fp_round>:
    237a:	09 2e       	mov	r0, r25
    237c:	03 94       	inc	r0
    237e:	00 0c       	add	r0, r0
    2380:	11 f4       	brne	.+4      	; 0x2386 <__fp_round+0xc>
    2382:	88 23       	and	r24, r24
    2384:	52 f0       	brmi	.+20     	; 0x239a <__fp_round+0x20>
    2386:	bb 0f       	add	r27, r27
    2388:	40 f4       	brcc	.+16     	; 0x239a <__fp_round+0x20>
    238a:	bf 2b       	or	r27, r31
    238c:	11 f4       	brne	.+4      	; 0x2392 <__fp_round+0x18>
    238e:	60 ff       	sbrs	r22, 0
    2390:	04 c0       	rjmp	.+8      	; 0x239a <__fp_round+0x20>
    2392:	6f 5f       	subi	r22, 0xFF	; 255
    2394:	7f 4f       	sbci	r23, 0xFF	; 255
    2396:	8f 4f       	sbci	r24, 0xFF	; 255
    2398:	9f 4f       	sbci	r25, 0xFF	; 255
    239a:	08 95       	ret

0000239c <__fp_split3>:
    239c:	57 fd       	sbrc	r21, 7
    239e:	90 58       	subi	r25, 0x80	; 128
    23a0:	44 0f       	add	r20, r20
    23a2:	55 1f       	adc	r21, r21
    23a4:	59 f0       	breq	.+22     	; 0x23bc <__fp_splitA+0x10>
    23a6:	5f 3f       	cpi	r21, 0xFF	; 255
    23a8:	71 f0       	breq	.+28     	; 0x23c6 <__fp_splitA+0x1a>
    23aa:	47 95       	ror	r20

000023ac <__fp_splitA>:
    23ac:	88 0f       	add	r24, r24
    23ae:	97 fb       	bst	r25, 7
    23b0:	99 1f       	adc	r25, r25
    23b2:	61 f0       	breq	.+24     	; 0x23cc <__fp_splitA+0x20>
    23b4:	9f 3f       	cpi	r25, 0xFF	; 255
    23b6:	79 f0       	breq	.+30     	; 0x23d6 <__fp_splitA+0x2a>
    23b8:	87 95       	ror	r24
    23ba:	08 95       	ret
    23bc:	12 16       	cp	r1, r18
    23be:	13 06       	cpc	r1, r19
    23c0:	14 06       	cpc	r1, r20
    23c2:	55 1f       	adc	r21, r21
    23c4:	f2 cf       	rjmp	.-28     	; 0x23aa <__fp_split3+0xe>
    23c6:	46 95       	lsr	r20
    23c8:	f1 df       	rcall	.-30     	; 0x23ac <__fp_splitA>
    23ca:	08 c0       	rjmp	.+16     	; 0x23dc <__fp_splitA+0x30>
    23cc:	16 16       	cp	r1, r22
    23ce:	17 06       	cpc	r1, r23
    23d0:	18 06       	cpc	r1, r24
    23d2:	99 1f       	adc	r25, r25
    23d4:	f1 cf       	rjmp	.-30     	; 0x23b8 <__fp_splitA+0xc>
    23d6:	86 95       	lsr	r24
    23d8:	71 05       	cpc	r23, r1
    23da:	61 05       	cpc	r22, r1
    23dc:	08 94       	sec
    23de:	08 95       	ret

000023e0 <__fp_zero>:
    23e0:	e8 94       	clt

000023e2 <__fp_szero>:
    23e2:	bb 27       	eor	r27, r27
    23e4:	66 27       	eor	r22, r22
    23e6:	77 27       	eor	r23, r23
    23e8:	cb 01       	movw	r24, r22
    23ea:	97 f9       	bld	r25, 7
    23ec:	08 95       	ret

000023ee <__mulsf3>:
    23ee:	0b d0       	rcall	.+22     	; 0x2406 <__mulsf3x>
    23f0:	c4 cf       	rjmp	.-120    	; 0x237a <__fp_round>
    23f2:	b5 df       	rcall	.-150    	; 0x235e <__fp_pscA>
    23f4:	28 f0       	brcs	.+10     	; 0x2400 <__mulsf3+0x12>
    23f6:	ba df       	rcall	.-140    	; 0x236c <__fp_pscB>
    23f8:	18 f0       	brcs	.+6      	; 0x2400 <__mulsf3+0x12>
    23fa:	95 23       	and	r25, r21
    23fc:	09 f0       	breq	.+2      	; 0x2400 <__mulsf3+0x12>
    23fe:	a6 cf       	rjmp	.-180    	; 0x234c <__fp_inf>
    2400:	ab cf       	rjmp	.-170    	; 0x2358 <__fp_nan>
    2402:	11 24       	eor	r1, r1
    2404:	ee cf       	rjmp	.-36     	; 0x23e2 <__fp_szero>

00002406 <__mulsf3x>:
    2406:	ca df       	rcall	.-108    	; 0x239c <__fp_split3>
    2408:	a0 f3       	brcs	.-24     	; 0x23f2 <__mulsf3+0x4>

0000240a <__mulsf3_pse>:
    240a:	95 9f       	mul	r25, r21
    240c:	d1 f3       	breq	.-12     	; 0x2402 <__mulsf3+0x14>
    240e:	95 0f       	add	r25, r21
    2410:	50 e0       	ldi	r21, 0x00	; 0
    2412:	55 1f       	adc	r21, r21
    2414:	62 9f       	mul	r22, r18
    2416:	f0 01       	movw	r30, r0
    2418:	72 9f       	mul	r23, r18
    241a:	bb 27       	eor	r27, r27
    241c:	f0 0d       	add	r31, r0
    241e:	b1 1d       	adc	r27, r1
    2420:	63 9f       	mul	r22, r19
    2422:	aa 27       	eor	r26, r26
    2424:	f0 0d       	add	r31, r0
    2426:	b1 1d       	adc	r27, r1
    2428:	aa 1f       	adc	r26, r26
    242a:	64 9f       	mul	r22, r20
    242c:	66 27       	eor	r22, r22
    242e:	b0 0d       	add	r27, r0
    2430:	a1 1d       	adc	r26, r1
    2432:	66 1f       	adc	r22, r22
    2434:	82 9f       	mul	r24, r18
    2436:	22 27       	eor	r18, r18
    2438:	b0 0d       	add	r27, r0
    243a:	a1 1d       	adc	r26, r1
    243c:	62 1f       	adc	r22, r18
    243e:	73 9f       	mul	r23, r19
    2440:	b0 0d       	add	r27, r0
    2442:	a1 1d       	adc	r26, r1
    2444:	62 1f       	adc	r22, r18
    2446:	83 9f       	mul	r24, r19
    2448:	a0 0d       	add	r26, r0
    244a:	61 1d       	adc	r22, r1
    244c:	22 1f       	adc	r18, r18
    244e:	74 9f       	mul	r23, r20
    2450:	33 27       	eor	r19, r19
    2452:	a0 0d       	add	r26, r0
    2454:	61 1d       	adc	r22, r1
    2456:	23 1f       	adc	r18, r19
    2458:	84 9f       	mul	r24, r20
    245a:	60 0d       	add	r22, r0
    245c:	21 1d       	adc	r18, r1
    245e:	82 2f       	mov	r24, r18
    2460:	76 2f       	mov	r23, r22
    2462:	6a 2f       	mov	r22, r26
    2464:	11 24       	eor	r1, r1
    2466:	9f 57       	subi	r25, 0x7F	; 127
    2468:	50 40       	sbci	r21, 0x00	; 0
    246a:	8a f0       	brmi	.+34     	; 0x248e <__mulsf3_pse+0x84>
    246c:	e1 f0       	breq	.+56     	; 0x24a6 <__mulsf3_pse+0x9c>
    246e:	88 23       	and	r24, r24
    2470:	4a f0       	brmi	.+18     	; 0x2484 <__mulsf3_pse+0x7a>
    2472:	ee 0f       	add	r30, r30
    2474:	ff 1f       	adc	r31, r31
    2476:	bb 1f       	adc	r27, r27
    2478:	66 1f       	adc	r22, r22
    247a:	77 1f       	adc	r23, r23
    247c:	88 1f       	adc	r24, r24
    247e:	91 50       	subi	r25, 0x01	; 1
    2480:	50 40       	sbci	r21, 0x00	; 0
    2482:	a9 f7       	brne	.-22     	; 0x246e <__mulsf3_pse+0x64>
    2484:	9e 3f       	cpi	r25, 0xFE	; 254
    2486:	51 05       	cpc	r21, r1
    2488:	70 f0       	brcs	.+28     	; 0x24a6 <__mulsf3_pse+0x9c>
    248a:	60 cf       	rjmp	.-320    	; 0x234c <__fp_inf>
    248c:	aa cf       	rjmp	.-172    	; 0x23e2 <__fp_szero>
    248e:	5f 3f       	cpi	r21, 0xFF	; 255
    2490:	ec f3       	brlt	.-6      	; 0x248c <__mulsf3_pse+0x82>
    2492:	98 3e       	cpi	r25, 0xE8	; 232
    2494:	dc f3       	brlt	.-10     	; 0x248c <__mulsf3_pse+0x82>
    2496:	86 95       	lsr	r24
    2498:	77 95       	ror	r23
    249a:	67 95       	ror	r22
    249c:	b7 95       	ror	r27
    249e:	f7 95       	ror	r31
    24a0:	e7 95       	ror	r30
    24a2:	9f 5f       	subi	r25, 0xFF	; 255
    24a4:	c1 f7       	brne	.-16     	; 0x2496 <__mulsf3_pse+0x8c>
    24a6:	fe 2b       	or	r31, r30
    24a8:	88 0f       	add	r24, r24
    24aa:	91 1d       	adc	r25, r1
    24ac:	96 95       	lsr	r25
    24ae:	87 95       	ror	r24
    24b0:	97 f9       	bld	r25, 7
    24b2:	08 95       	ret

000024b4 <__udivmodsi4>:
    24b4:	a1 e2       	ldi	r26, 0x21	; 33
    24b6:	1a 2e       	mov	r1, r26
    24b8:	aa 1b       	sub	r26, r26
    24ba:	bb 1b       	sub	r27, r27
    24bc:	fd 01       	movw	r30, r26
    24be:	0d c0       	rjmp	.+26     	; 0x24da <__udivmodsi4_ep>

000024c0 <__udivmodsi4_loop>:
    24c0:	aa 1f       	adc	r26, r26
    24c2:	bb 1f       	adc	r27, r27
    24c4:	ee 1f       	adc	r30, r30
    24c6:	ff 1f       	adc	r31, r31
    24c8:	a2 17       	cp	r26, r18
    24ca:	b3 07       	cpc	r27, r19
    24cc:	e4 07       	cpc	r30, r20
    24ce:	f5 07       	cpc	r31, r21
    24d0:	20 f0       	brcs	.+8      	; 0x24da <__udivmodsi4_ep>
    24d2:	a2 1b       	sub	r26, r18
    24d4:	b3 0b       	sbc	r27, r19
    24d6:	e4 0b       	sbc	r30, r20
    24d8:	f5 0b       	sbc	r31, r21

000024da <__udivmodsi4_ep>:
    24da:	66 1f       	adc	r22, r22
    24dc:	77 1f       	adc	r23, r23
    24de:	88 1f       	adc	r24, r24
    24e0:	99 1f       	adc	r25, r25
    24e2:	1a 94       	dec	r1
    24e4:	69 f7       	brne	.-38     	; 0x24c0 <__udivmodsi4_loop>
    24e6:	60 95       	com	r22
    24e8:	70 95       	com	r23
    24ea:	80 95       	com	r24
    24ec:	90 95       	com	r25
    24ee:	9b 01       	movw	r18, r22
    24f0:	ac 01       	movw	r20, r24
    24f2:	bd 01       	movw	r22, r26
    24f4:	cf 01       	movw	r24, r30
    24f6:	08 95       	ret

000024f8 <__tablejump2__>:
    24f8:	ee 0f       	add	r30, r30
    24fa:	ff 1f       	adc	r31, r31
    24fc:	88 1f       	adc	r24, r24
    24fe:	8b bf       	out	0x3b, r24	; 59
    2500:	07 90       	elpm	r0, Z+
    2502:	f6 91       	elpm	r31, Z
    2504:	e0 2d       	mov	r30, r0
    2506:	19 94       	eijmp

00002508 <__umulhisi3>:
    2508:	a2 9f       	mul	r26, r18
    250a:	b0 01       	movw	r22, r0
    250c:	b3 9f       	mul	r27, r19
    250e:	c0 01       	movw	r24, r0
    2510:	a3 9f       	mul	r26, r19
    2512:	70 0d       	add	r23, r0
    2514:	81 1d       	adc	r24, r1
    2516:	11 24       	eor	r1, r1
    2518:	91 1d       	adc	r25, r1
    251a:	b2 9f       	mul	r27, r18
    251c:	70 0d       	add	r23, r0
    251e:	81 1d       	adc	r24, r1
    2520:	11 24       	eor	r1, r1
    2522:	91 1d       	adc	r25, r1
    2524:	08 95       	ret

00002526 <__muluhisi3>:
    2526:	f0 df       	rcall	.-32     	; 0x2508 <__umulhisi3>
    2528:	a5 9f       	mul	r26, r21
    252a:	90 0d       	add	r25, r0
    252c:	b4 9f       	mul	r27, r20
    252e:	90 0d       	add	r25, r0
    2530:	a4 9f       	mul	r26, r20
    2532:	80 0d       	add	r24, r0
    2534:	91 1d       	adc	r25, r1
    2536:	11 24       	eor	r1, r1
    2538:	08 95       	ret

0000253a <malloc>:
    253a:	0f 93       	push	r16
    253c:	1f 93       	push	r17
    253e:	cf 93       	push	r28
    2540:	df 93       	push	r29
    2542:	82 30       	cpi	r24, 0x02	; 2
    2544:	91 05       	cpc	r25, r1
    2546:	10 f4       	brcc	.+4      	; 0x254c <malloc+0x12>
    2548:	82 e0       	ldi	r24, 0x02	; 2
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	e0 91 7f 04 	lds	r30, 0x047F	; 0x80047f <__flp>
    2550:	f0 91 80 04 	lds	r31, 0x0480	; 0x800480 <__flp+0x1>
    2554:	20 e0       	ldi	r18, 0x00	; 0
    2556:	30 e0       	ldi	r19, 0x00	; 0
    2558:	a0 e0       	ldi	r26, 0x00	; 0
    255a:	b0 e0       	ldi	r27, 0x00	; 0
    255c:	30 97       	sbiw	r30, 0x00	; 0
    255e:	19 f1       	breq	.+70     	; 0x25a6 <malloc+0x6c>
    2560:	40 81       	ld	r20, Z
    2562:	51 81       	ldd	r21, Z+1	; 0x01
    2564:	02 81       	ldd	r16, Z+2	; 0x02
    2566:	13 81       	ldd	r17, Z+3	; 0x03
    2568:	48 17       	cp	r20, r24
    256a:	59 07       	cpc	r21, r25
    256c:	c8 f0       	brcs	.+50     	; 0x25a0 <malloc+0x66>
    256e:	84 17       	cp	r24, r20
    2570:	95 07       	cpc	r25, r21
    2572:	69 f4       	brne	.+26     	; 0x258e <malloc+0x54>
    2574:	10 97       	sbiw	r26, 0x00	; 0
    2576:	31 f0       	breq	.+12     	; 0x2584 <malloc+0x4a>
    2578:	12 96       	adiw	r26, 0x02	; 2
    257a:	0c 93       	st	X, r16
    257c:	12 97       	sbiw	r26, 0x02	; 2
    257e:	13 96       	adiw	r26, 0x03	; 3
    2580:	1c 93       	st	X, r17
    2582:	27 c0       	rjmp	.+78     	; 0x25d2 <malloc+0x98>
    2584:	00 93 7f 04 	sts	0x047F, r16	; 0x80047f <__flp>
    2588:	10 93 80 04 	sts	0x0480, r17	; 0x800480 <__flp+0x1>
    258c:	22 c0       	rjmp	.+68     	; 0x25d2 <malloc+0x98>
    258e:	21 15       	cp	r18, r1
    2590:	31 05       	cpc	r19, r1
    2592:	19 f0       	breq	.+6      	; 0x259a <malloc+0x60>
    2594:	42 17       	cp	r20, r18
    2596:	53 07       	cpc	r21, r19
    2598:	18 f4       	brcc	.+6      	; 0x25a0 <malloc+0x66>
    259a:	9a 01       	movw	r18, r20
    259c:	bd 01       	movw	r22, r26
    259e:	ef 01       	movw	r28, r30
    25a0:	df 01       	movw	r26, r30
    25a2:	f8 01       	movw	r30, r16
    25a4:	db cf       	rjmp	.-74     	; 0x255c <malloc+0x22>
    25a6:	21 15       	cp	r18, r1
    25a8:	31 05       	cpc	r19, r1
    25aa:	f9 f0       	breq	.+62     	; 0x25ea <malloc+0xb0>
    25ac:	28 1b       	sub	r18, r24
    25ae:	39 0b       	sbc	r19, r25
    25b0:	24 30       	cpi	r18, 0x04	; 4
    25b2:	31 05       	cpc	r19, r1
    25b4:	80 f4       	brcc	.+32     	; 0x25d6 <malloc+0x9c>
    25b6:	8a 81       	ldd	r24, Y+2	; 0x02
    25b8:	9b 81       	ldd	r25, Y+3	; 0x03
    25ba:	61 15       	cp	r22, r1
    25bc:	71 05       	cpc	r23, r1
    25be:	21 f0       	breq	.+8      	; 0x25c8 <malloc+0x8e>
    25c0:	fb 01       	movw	r30, r22
    25c2:	93 83       	std	Z+3, r25	; 0x03
    25c4:	82 83       	std	Z+2, r24	; 0x02
    25c6:	04 c0       	rjmp	.+8      	; 0x25d0 <malloc+0x96>
    25c8:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <__flp+0x1>
    25cc:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <__flp>
    25d0:	fe 01       	movw	r30, r28
    25d2:	32 96       	adiw	r30, 0x02	; 2
    25d4:	44 c0       	rjmp	.+136    	; 0x265e <malloc+0x124>
    25d6:	fe 01       	movw	r30, r28
    25d8:	e2 0f       	add	r30, r18
    25da:	f3 1f       	adc	r31, r19
    25dc:	81 93       	st	Z+, r24
    25de:	91 93       	st	Z+, r25
    25e0:	22 50       	subi	r18, 0x02	; 2
    25e2:	31 09       	sbc	r19, r1
    25e4:	39 83       	std	Y+1, r19	; 0x01
    25e6:	28 83       	st	Y, r18
    25e8:	3a c0       	rjmp	.+116    	; 0x265e <malloc+0x124>
    25ea:	20 91 7d 04 	lds	r18, 0x047D	; 0x80047d <__brkval>
    25ee:	30 91 7e 04 	lds	r19, 0x047E	; 0x80047e <__brkval+0x1>
    25f2:	23 2b       	or	r18, r19
    25f4:	41 f4       	brne	.+16     	; 0x2606 <malloc+0xcc>
    25f6:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    25fa:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    25fe:	30 93 7e 04 	sts	0x047E, r19	; 0x80047e <__brkval+0x1>
    2602:	20 93 7d 04 	sts	0x047D, r18	; 0x80047d <__brkval>
    2606:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    260a:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    260e:	21 15       	cp	r18, r1
    2610:	31 05       	cpc	r19, r1
    2612:	41 f4       	brne	.+16     	; 0x2624 <malloc+0xea>
    2614:	2d b7       	in	r18, 0x3d	; 61
    2616:	3e b7       	in	r19, 0x3e	; 62
    2618:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    261c:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2620:	24 1b       	sub	r18, r20
    2622:	35 0b       	sbc	r19, r21
    2624:	e0 91 7d 04 	lds	r30, 0x047D	; 0x80047d <__brkval>
    2628:	f0 91 7e 04 	lds	r31, 0x047E	; 0x80047e <__brkval+0x1>
    262c:	e2 17       	cp	r30, r18
    262e:	f3 07       	cpc	r31, r19
    2630:	a0 f4       	brcc	.+40     	; 0x265a <malloc+0x120>
    2632:	2e 1b       	sub	r18, r30
    2634:	3f 0b       	sbc	r19, r31
    2636:	28 17       	cp	r18, r24
    2638:	39 07       	cpc	r19, r25
    263a:	78 f0       	brcs	.+30     	; 0x265a <malloc+0x120>
    263c:	ac 01       	movw	r20, r24
    263e:	4e 5f       	subi	r20, 0xFE	; 254
    2640:	5f 4f       	sbci	r21, 0xFF	; 255
    2642:	24 17       	cp	r18, r20
    2644:	35 07       	cpc	r19, r21
    2646:	48 f0       	brcs	.+18     	; 0x265a <malloc+0x120>
    2648:	4e 0f       	add	r20, r30
    264a:	5f 1f       	adc	r21, r31
    264c:	50 93 7e 04 	sts	0x047E, r21	; 0x80047e <__brkval+0x1>
    2650:	40 93 7d 04 	sts	0x047D, r20	; 0x80047d <__brkval>
    2654:	81 93       	st	Z+, r24
    2656:	91 93       	st	Z+, r25
    2658:	02 c0       	rjmp	.+4      	; 0x265e <malloc+0x124>
    265a:	e0 e0       	ldi	r30, 0x00	; 0
    265c:	f0 e0       	ldi	r31, 0x00	; 0
    265e:	cf 01       	movw	r24, r30
    2660:	df 91       	pop	r29
    2662:	cf 91       	pop	r28
    2664:	1f 91       	pop	r17
    2666:	0f 91       	pop	r16
    2668:	08 95       	ret

0000266a <free>:
    266a:	cf 93       	push	r28
    266c:	df 93       	push	r29
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	09 f4       	brne	.+2      	; 0x2674 <free+0xa>
    2672:	81 c0       	rjmp	.+258    	; 0x2776 <free+0x10c>
    2674:	fc 01       	movw	r30, r24
    2676:	32 97       	sbiw	r30, 0x02	; 2
    2678:	13 82       	std	Z+3, r1	; 0x03
    267a:	12 82       	std	Z+2, r1	; 0x02
    267c:	a0 91 7f 04 	lds	r26, 0x047F	; 0x80047f <__flp>
    2680:	b0 91 80 04 	lds	r27, 0x0480	; 0x800480 <__flp+0x1>
    2684:	10 97       	sbiw	r26, 0x00	; 0
    2686:	81 f4       	brne	.+32     	; 0x26a8 <free+0x3e>
    2688:	20 81       	ld	r18, Z
    268a:	31 81       	ldd	r19, Z+1	; 0x01
    268c:	82 0f       	add	r24, r18
    268e:	93 1f       	adc	r25, r19
    2690:	20 91 7d 04 	lds	r18, 0x047D	; 0x80047d <__brkval>
    2694:	30 91 7e 04 	lds	r19, 0x047E	; 0x80047e <__brkval+0x1>
    2698:	28 17       	cp	r18, r24
    269a:	39 07       	cpc	r19, r25
    269c:	51 f5       	brne	.+84     	; 0x26f2 <free+0x88>
    269e:	f0 93 7e 04 	sts	0x047E, r31	; 0x80047e <__brkval+0x1>
    26a2:	e0 93 7d 04 	sts	0x047D, r30	; 0x80047d <__brkval>
    26a6:	67 c0       	rjmp	.+206    	; 0x2776 <free+0x10c>
    26a8:	ed 01       	movw	r28, r26
    26aa:	20 e0       	ldi	r18, 0x00	; 0
    26ac:	30 e0       	ldi	r19, 0x00	; 0
    26ae:	ce 17       	cp	r28, r30
    26b0:	df 07       	cpc	r29, r31
    26b2:	40 f4       	brcc	.+16     	; 0x26c4 <free+0x5a>
    26b4:	4a 81       	ldd	r20, Y+2	; 0x02
    26b6:	5b 81       	ldd	r21, Y+3	; 0x03
    26b8:	9e 01       	movw	r18, r28
    26ba:	41 15       	cp	r20, r1
    26bc:	51 05       	cpc	r21, r1
    26be:	f1 f0       	breq	.+60     	; 0x26fc <free+0x92>
    26c0:	ea 01       	movw	r28, r20
    26c2:	f5 cf       	rjmp	.-22     	; 0x26ae <free+0x44>
    26c4:	d3 83       	std	Z+3, r29	; 0x03
    26c6:	c2 83       	std	Z+2, r28	; 0x02
    26c8:	40 81       	ld	r20, Z
    26ca:	51 81       	ldd	r21, Z+1	; 0x01
    26cc:	84 0f       	add	r24, r20
    26ce:	95 1f       	adc	r25, r21
    26d0:	c8 17       	cp	r28, r24
    26d2:	d9 07       	cpc	r29, r25
    26d4:	59 f4       	brne	.+22     	; 0x26ec <free+0x82>
    26d6:	88 81       	ld	r24, Y
    26d8:	99 81       	ldd	r25, Y+1	; 0x01
    26da:	84 0f       	add	r24, r20
    26dc:	95 1f       	adc	r25, r21
    26de:	02 96       	adiw	r24, 0x02	; 2
    26e0:	91 83       	std	Z+1, r25	; 0x01
    26e2:	80 83       	st	Z, r24
    26e4:	8a 81       	ldd	r24, Y+2	; 0x02
    26e6:	9b 81       	ldd	r25, Y+3	; 0x03
    26e8:	93 83       	std	Z+3, r25	; 0x03
    26ea:	82 83       	std	Z+2, r24	; 0x02
    26ec:	21 15       	cp	r18, r1
    26ee:	31 05       	cpc	r19, r1
    26f0:	29 f4       	brne	.+10     	; 0x26fc <free+0x92>
    26f2:	f0 93 80 04 	sts	0x0480, r31	; 0x800480 <__flp+0x1>
    26f6:	e0 93 7f 04 	sts	0x047F, r30	; 0x80047f <__flp>
    26fa:	3d c0       	rjmp	.+122    	; 0x2776 <free+0x10c>
    26fc:	e9 01       	movw	r28, r18
    26fe:	fb 83       	std	Y+3, r31	; 0x03
    2700:	ea 83       	std	Y+2, r30	; 0x02
    2702:	49 91       	ld	r20, Y+
    2704:	59 91       	ld	r21, Y+
    2706:	c4 0f       	add	r28, r20
    2708:	d5 1f       	adc	r29, r21
    270a:	ec 17       	cp	r30, r28
    270c:	fd 07       	cpc	r31, r29
    270e:	61 f4       	brne	.+24     	; 0x2728 <free+0xbe>
    2710:	80 81       	ld	r24, Z
    2712:	91 81       	ldd	r25, Z+1	; 0x01
    2714:	84 0f       	add	r24, r20
    2716:	95 1f       	adc	r25, r21
    2718:	02 96       	adiw	r24, 0x02	; 2
    271a:	e9 01       	movw	r28, r18
    271c:	99 83       	std	Y+1, r25	; 0x01
    271e:	88 83       	st	Y, r24
    2720:	82 81       	ldd	r24, Z+2	; 0x02
    2722:	93 81       	ldd	r25, Z+3	; 0x03
    2724:	9b 83       	std	Y+3, r25	; 0x03
    2726:	8a 83       	std	Y+2, r24	; 0x02
    2728:	e0 e0       	ldi	r30, 0x00	; 0
    272a:	f0 e0       	ldi	r31, 0x00	; 0
    272c:	12 96       	adiw	r26, 0x02	; 2
    272e:	8d 91       	ld	r24, X+
    2730:	9c 91       	ld	r25, X
    2732:	13 97       	sbiw	r26, 0x03	; 3
    2734:	00 97       	sbiw	r24, 0x00	; 0
    2736:	19 f0       	breq	.+6      	; 0x273e <free+0xd4>
    2738:	fd 01       	movw	r30, r26
    273a:	dc 01       	movw	r26, r24
    273c:	f7 cf       	rjmp	.-18     	; 0x272c <free+0xc2>
    273e:	8d 91       	ld	r24, X+
    2740:	9c 91       	ld	r25, X
    2742:	11 97       	sbiw	r26, 0x01	; 1
    2744:	9d 01       	movw	r18, r26
    2746:	2e 5f       	subi	r18, 0xFE	; 254
    2748:	3f 4f       	sbci	r19, 0xFF	; 255
    274a:	82 0f       	add	r24, r18
    274c:	93 1f       	adc	r25, r19
    274e:	20 91 7d 04 	lds	r18, 0x047D	; 0x80047d <__brkval>
    2752:	30 91 7e 04 	lds	r19, 0x047E	; 0x80047e <__brkval+0x1>
    2756:	28 17       	cp	r18, r24
    2758:	39 07       	cpc	r19, r25
    275a:	69 f4       	brne	.+26     	; 0x2776 <free+0x10c>
    275c:	30 97       	sbiw	r30, 0x00	; 0
    275e:	29 f4       	brne	.+10     	; 0x276a <free+0x100>
    2760:	10 92 80 04 	sts	0x0480, r1	; 0x800480 <__flp+0x1>
    2764:	10 92 7f 04 	sts	0x047F, r1	; 0x80047f <__flp>
    2768:	02 c0       	rjmp	.+4      	; 0x276e <free+0x104>
    276a:	13 82       	std	Z+3, r1	; 0x03
    276c:	12 82       	std	Z+2, r1	; 0x02
    276e:	b0 93 7e 04 	sts	0x047E, r27	; 0x80047e <__brkval+0x1>
    2772:	a0 93 7d 04 	sts	0x047D, r26	; 0x80047d <__brkval>
    2776:	df 91       	pop	r29
    2778:	cf 91       	pop	r28
    277a:	08 95       	ret

0000277c <memcpy>:
    277c:	fb 01       	movw	r30, r22
    277e:	dc 01       	movw	r26, r24
    2780:	02 c0       	rjmp	.+4      	; 0x2786 <memcpy+0xa>
    2782:	01 90       	ld	r0, Z+
    2784:	0d 92       	st	X+, r0
    2786:	41 50       	subi	r20, 0x01	; 1
    2788:	50 40       	sbci	r21, 0x00	; 0
    278a:	d8 f7       	brcc	.-10     	; 0x2782 <memcpy+0x6>
    278c:	08 95       	ret

0000278e <memset>:
    278e:	dc 01       	movw	r26, r24
    2790:	01 c0       	rjmp	.+2      	; 0x2794 <memset+0x6>
    2792:	6d 93       	st	X+, r22
    2794:	41 50       	subi	r20, 0x01	; 1
    2796:	50 40       	sbci	r21, 0x00	; 0
    2798:	e0 f7       	brcc	.-8      	; 0x2792 <memset+0x4>
    279a:	08 95       	ret

0000279c <sprintf>:
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	cd b7       	in	r28, 0x3d	; 61
    27a6:	de b7       	in	r29, 0x3e	; 62
    27a8:	2e 97       	sbiw	r28, 0x0e	; 14
    27aa:	0f b6       	in	r0, 0x3f	; 63
    27ac:	f8 94       	cli
    27ae:	de bf       	out	0x3e, r29	; 62
    27b0:	0f be       	out	0x3f, r0	; 63
    27b2:	cd bf       	out	0x3d, r28	; 61
    27b4:	0e 89       	ldd	r16, Y+22	; 0x16
    27b6:	1f 89       	ldd	r17, Y+23	; 0x17
    27b8:	86 e0       	ldi	r24, 0x06	; 6
    27ba:	8c 83       	std	Y+4, r24	; 0x04
    27bc:	1a 83       	std	Y+2, r17	; 0x02
    27be:	09 83       	std	Y+1, r16	; 0x01
    27c0:	8f ef       	ldi	r24, 0xFF	; 255
    27c2:	9f e7       	ldi	r25, 0x7F	; 127
    27c4:	9e 83       	std	Y+6, r25	; 0x06
    27c6:	8d 83       	std	Y+5, r24	; 0x05
    27c8:	ae 01       	movw	r20, r28
    27ca:	46 5e       	subi	r20, 0xE6	; 230
    27cc:	5f 4f       	sbci	r21, 0xFF	; 255
    27ce:	68 8d       	ldd	r22, Y+24	; 0x18
    27d0:	79 8d       	ldd	r23, Y+25	; 0x19
    27d2:	ce 01       	movw	r24, r28
    27d4:	01 96       	adiw	r24, 0x01	; 1
    27d6:	10 d0       	rcall	.+32     	; 0x27f8 <vfprintf>
    27d8:	ef 81       	ldd	r30, Y+7	; 0x07
    27da:	f8 85       	ldd	r31, Y+8	; 0x08
    27dc:	e0 0f       	add	r30, r16
    27de:	f1 1f       	adc	r31, r17
    27e0:	10 82       	st	Z, r1
    27e2:	2e 96       	adiw	r28, 0x0e	; 14
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	de bf       	out	0x3e, r29	; 62
    27ea:	0f be       	out	0x3f, r0	; 63
    27ec:	cd bf       	out	0x3d, r28	; 61
    27ee:	df 91       	pop	r29
    27f0:	cf 91       	pop	r28
    27f2:	1f 91       	pop	r17
    27f4:	0f 91       	pop	r16
    27f6:	08 95       	ret

000027f8 <vfprintf>:
    27f8:	2f 92       	push	r2
    27fa:	3f 92       	push	r3
    27fc:	4f 92       	push	r4
    27fe:	5f 92       	push	r5
    2800:	6f 92       	push	r6
    2802:	7f 92       	push	r7
    2804:	8f 92       	push	r8
    2806:	9f 92       	push	r9
    2808:	af 92       	push	r10
    280a:	bf 92       	push	r11
    280c:	cf 92       	push	r12
    280e:	df 92       	push	r13
    2810:	ef 92       	push	r14
    2812:	ff 92       	push	r15
    2814:	0f 93       	push	r16
    2816:	1f 93       	push	r17
    2818:	cf 93       	push	r28
    281a:	df 93       	push	r29
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	2b 97       	sbiw	r28, 0x0b	; 11
    2822:	0f b6       	in	r0, 0x3f	; 63
    2824:	f8 94       	cli
    2826:	de bf       	out	0x3e, r29	; 62
    2828:	0f be       	out	0x3f, r0	; 63
    282a:	cd bf       	out	0x3d, r28	; 61
    282c:	6c 01       	movw	r12, r24
    282e:	7b 01       	movw	r14, r22
    2830:	8a 01       	movw	r16, r20
    2832:	fc 01       	movw	r30, r24
    2834:	17 82       	std	Z+7, r1	; 0x07
    2836:	16 82       	std	Z+6, r1	; 0x06
    2838:	83 81       	ldd	r24, Z+3	; 0x03
    283a:	81 ff       	sbrs	r24, 1
    283c:	bf c1       	rjmp	.+894    	; 0x2bbc <vfprintf+0x3c4>
    283e:	ce 01       	movw	r24, r28
    2840:	01 96       	adiw	r24, 0x01	; 1
    2842:	3c 01       	movw	r6, r24
    2844:	f6 01       	movw	r30, r12
    2846:	93 81       	ldd	r25, Z+3	; 0x03
    2848:	f7 01       	movw	r30, r14
    284a:	93 fd       	sbrc	r25, 3
    284c:	85 91       	lpm	r24, Z+
    284e:	93 ff       	sbrs	r25, 3
    2850:	81 91       	ld	r24, Z+
    2852:	7f 01       	movw	r14, r30
    2854:	88 23       	and	r24, r24
    2856:	09 f4       	brne	.+2      	; 0x285a <vfprintf+0x62>
    2858:	ad c1       	rjmp	.+858    	; 0x2bb4 <vfprintf+0x3bc>
    285a:	85 32       	cpi	r24, 0x25	; 37
    285c:	39 f4       	brne	.+14     	; 0x286c <vfprintf+0x74>
    285e:	93 fd       	sbrc	r25, 3
    2860:	85 91       	lpm	r24, Z+
    2862:	93 ff       	sbrs	r25, 3
    2864:	81 91       	ld	r24, Z+
    2866:	7f 01       	movw	r14, r30
    2868:	85 32       	cpi	r24, 0x25	; 37
    286a:	21 f4       	brne	.+8      	; 0x2874 <vfprintf+0x7c>
    286c:	b6 01       	movw	r22, r12
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	d6 d1       	rcall	.+940    	; 0x2c1e <fputc>
    2872:	e8 cf       	rjmp	.-48     	; 0x2844 <vfprintf+0x4c>
    2874:	91 2c       	mov	r9, r1
    2876:	21 2c       	mov	r2, r1
    2878:	31 2c       	mov	r3, r1
    287a:	ff e1       	ldi	r31, 0x1F	; 31
    287c:	f3 15       	cp	r31, r3
    287e:	d8 f0       	brcs	.+54     	; 0x28b6 <vfprintf+0xbe>
    2880:	8b 32       	cpi	r24, 0x2B	; 43
    2882:	79 f0       	breq	.+30     	; 0x28a2 <vfprintf+0xaa>
    2884:	38 f4       	brcc	.+14     	; 0x2894 <vfprintf+0x9c>
    2886:	80 32       	cpi	r24, 0x20	; 32
    2888:	79 f0       	breq	.+30     	; 0x28a8 <vfprintf+0xb0>
    288a:	83 32       	cpi	r24, 0x23	; 35
    288c:	a1 f4       	brne	.+40     	; 0x28b6 <vfprintf+0xbe>
    288e:	23 2d       	mov	r18, r3
    2890:	20 61       	ori	r18, 0x10	; 16
    2892:	1d c0       	rjmp	.+58     	; 0x28ce <vfprintf+0xd6>
    2894:	8d 32       	cpi	r24, 0x2D	; 45
    2896:	61 f0       	breq	.+24     	; 0x28b0 <vfprintf+0xb8>
    2898:	80 33       	cpi	r24, 0x30	; 48
    289a:	69 f4       	brne	.+26     	; 0x28b6 <vfprintf+0xbe>
    289c:	23 2d       	mov	r18, r3
    289e:	21 60       	ori	r18, 0x01	; 1
    28a0:	16 c0       	rjmp	.+44     	; 0x28ce <vfprintf+0xd6>
    28a2:	83 2d       	mov	r24, r3
    28a4:	82 60       	ori	r24, 0x02	; 2
    28a6:	38 2e       	mov	r3, r24
    28a8:	e3 2d       	mov	r30, r3
    28aa:	e4 60       	ori	r30, 0x04	; 4
    28ac:	3e 2e       	mov	r3, r30
    28ae:	2a c0       	rjmp	.+84     	; 0x2904 <vfprintf+0x10c>
    28b0:	f3 2d       	mov	r31, r3
    28b2:	f8 60       	ori	r31, 0x08	; 8
    28b4:	1d c0       	rjmp	.+58     	; 0x28f0 <vfprintf+0xf8>
    28b6:	37 fc       	sbrc	r3, 7
    28b8:	2d c0       	rjmp	.+90     	; 0x2914 <vfprintf+0x11c>
    28ba:	20 ed       	ldi	r18, 0xD0	; 208
    28bc:	28 0f       	add	r18, r24
    28be:	2a 30       	cpi	r18, 0x0A	; 10
    28c0:	40 f0       	brcs	.+16     	; 0x28d2 <vfprintf+0xda>
    28c2:	8e 32       	cpi	r24, 0x2E	; 46
    28c4:	b9 f4       	brne	.+46     	; 0x28f4 <vfprintf+0xfc>
    28c6:	36 fc       	sbrc	r3, 6
    28c8:	75 c1       	rjmp	.+746    	; 0x2bb4 <vfprintf+0x3bc>
    28ca:	23 2d       	mov	r18, r3
    28cc:	20 64       	ori	r18, 0x40	; 64
    28ce:	32 2e       	mov	r3, r18
    28d0:	19 c0       	rjmp	.+50     	; 0x2904 <vfprintf+0x10c>
    28d2:	36 fe       	sbrs	r3, 6
    28d4:	06 c0       	rjmp	.+12     	; 0x28e2 <vfprintf+0xea>
    28d6:	8a e0       	ldi	r24, 0x0A	; 10
    28d8:	98 9e       	mul	r9, r24
    28da:	20 0d       	add	r18, r0
    28dc:	11 24       	eor	r1, r1
    28de:	92 2e       	mov	r9, r18
    28e0:	11 c0       	rjmp	.+34     	; 0x2904 <vfprintf+0x10c>
    28e2:	ea e0       	ldi	r30, 0x0A	; 10
    28e4:	2e 9e       	mul	r2, r30
    28e6:	20 0d       	add	r18, r0
    28e8:	11 24       	eor	r1, r1
    28ea:	22 2e       	mov	r2, r18
    28ec:	f3 2d       	mov	r31, r3
    28ee:	f0 62       	ori	r31, 0x20	; 32
    28f0:	3f 2e       	mov	r3, r31
    28f2:	08 c0       	rjmp	.+16     	; 0x2904 <vfprintf+0x10c>
    28f4:	8c 36       	cpi	r24, 0x6C	; 108
    28f6:	21 f4       	brne	.+8      	; 0x2900 <vfprintf+0x108>
    28f8:	83 2d       	mov	r24, r3
    28fa:	80 68       	ori	r24, 0x80	; 128
    28fc:	38 2e       	mov	r3, r24
    28fe:	02 c0       	rjmp	.+4      	; 0x2904 <vfprintf+0x10c>
    2900:	88 36       	cpi	r24, 0x68	; 104
    2902:	41 f4       	brne	.+16     	; 0x2914 <vfprintf+0x11c>
    2904:	f7 01       	movw	r30, r14
    2906:	93 fd       	sbrc	r25, 3
    2908:	85 91       	lpm	r24, Z+
    290a:	93 ff       	sbrs	r25, 3
    290c:	81 91       	ld	r24, Z+
    290e:	7f 01       	movw	r14, r30
    2910:	81 11       	cpse	r24, r1
    2912:	b3 cf       	rjmp	.-154    	; 0x287a <vfprintf+0x82>
    2914:	98 2f       	mov	r25, r24
    2916:	9f 7d       	andi	r25, 0xDF	; 223
    2918:	95 54       	subi	r25, 0x45	; 69
    291a:	93 30       	cpi	r25, 0x03	; 3
    291c:	28 f4       	brcc	.+10     	; 0x2928 <vfprintf+0x130>
    291e:	0c 5f       	subi	r16, 0xFC	; 252
    2920:	1f 4f       	sbci	r17, 0xFF	; 255
    2922:	9f e3       	ldi	r25, 0x3F	; 63
    2924:	99 83       	std	Y+1, r25	; 0x01
    2926:	0d c0       	rjmp	.+26     	; 0x2942 <vfprintf+0x14a>
    2928:	83 36       	cpi	r24, 0x63	; 99
    292a:	31 f0       	breq	.+12     	; 0x2938 <vfprintf+0x140>
    292c:	83 37       	cpi	r24, 0x73	; 115
    292e:	71 f0       	breq	.+28     	; 0x294c <vfprintf+0x154>
    2930:	83 35       	cpi	r24, 0x53	; 83
    2932:	09 f0       	breq	.+2      	; 0x2936 <vfprintf+0x13e>
    2934:	55 c0       	rjmp	.+170    	; 0x29e0 <vfprintf+0x1e8>
    2936:	20 c0       	rjmp	.+64     	; 0x2978 <vfprintf+0x180>
    2938:	f8 01       	movw	r30, r16
    293a:	80 81       	ld	r24, Z
    293c:	89 83       	std	Y+1, r24	; 0x01
    293e:	0e 5f       	subi	r16, 0xFE	; 254
    2940:	1f 4f       	sbci	r17, 0xFF	; 255
    2942:	88 24       	eor	r8, r8
    2944:	83 94       	inc	r8
    2946:	91 2c       	mov	r9, r1
    2948:	53 01       	movw	r10, r6
    294a:	12 c0       	rjmp	.+36     	; 0x2970 <vfprintf+0x178>
    294c:	28 01       	movw	r4, r16
    294e:	f2 e0       	ldi	r31, 0x02	; 2
    2950:	4f 0e       	add	r4, r31
    2952:	51 1c       	adc	r5, r1
    2954:	f8 01       	movw	r30, r16
    2956:	a0 80       	ld	r10, Z
    2958:	b1 80       	ldd	r11, Z+1	; 0x01
    295a:	36 fe       	sbrs	r3, 6
    295c:	03 c0       	rjmp	.+6      	; 0x2964 <vfprintf+0x16c>
    295e:	69 2d       	mov	r22, r9
    2960:	70 e0       	ldi	r23, 0x00	; 0
    2962:	02 c0       	rjmp	.+4      	; 0x2968 <vfprintf+0x170>
    2964:	6f ef       	ldi	r22, 0xFF	; 255
    2966:	7f ef       	ldi	r23, 0xFF	; 255
    2968:	c5 01       	movw	r24, r10
    296a:	4e d1       	rcall	.+668    	; 0x2c08 <strnlen>
    296c:	4c 01       	movw	r8, r24
    296e:	82 01       	movw	r16, r4
    2970:	f3 2d       	mov	r31, r3
    2972:	ff 77       	andi	r31, 0x7F	; 127
    2974:	3f 2e       	mov	r3, r31
    2976:	15 c0       	rjmp	.+42     	; 0x29a2 <vfprintf+0x1aa>
    2978:	28 01       	movw	r4, r16
    297a:	22 e0       	ldi	r18, 0x02	; 2
    297c:	42 0e       	add	r4, r18
    297e:	51 1c       	adc	r5, r1
    2980:	f8 01       	movw	r30, r16
    2982:	a0 80       	ld	r10, Z
    2984:	b1 80       	ldd	r11, Z+1	; 0x01
    2986:	36 fe       	sbrs	r3, 6
    2988:	03 c0       	rjmp	.+6      	; 0x2990 <vfprintf+0x198>
    298a:	69 2d       	mov	r22, r9
    298c:	70 e0       	ldi	r23, 0x00	; 0
    298e:	02 c0       	rjmp	.+4      	; 0x2994 <vfprintf+0x19c>
    2990:	6f ef       	ldi	r22, 0xFF	; 255
    2992:	7f ef       	ldi	r23, 0xFF	; 255
    2994:	c5 01       	movw	r24, r10
    2996:	2d d1       	rcall	.+602    	; 0x2bf2 <strnlen_P>
    2998:	4c 01       	movw	r8, r24
    299a:	f3 2d       	mov	r31, r3
    299c:	f0 68       	ori	r31, 0x80	; 128
    299e:	3f 2e       	mov	r3, r31
    29a0:	82 01       	movw	r16, r4
    29a2:	33 fc       	sbrc	r3, 3
    29a4:	19 c0       	rjmp	.+50     	; 0x29d8 <vfprintf+0x1e0>
    29a6:	82 2d       	mov	r24, r2
    29a8:	90 e0       	ldi	r25, 0x00	; 0
    29aa:	88 16       	cp	r8, r24
    29ac:	99 06       	cpc	r9, r25
    29ae:	a0 f4       	brcc	.+40     	; 0x29d8 <vfprintf+0x1e0>
    29b0:	b6 01       	movw	r22, r12
    29b2:	80 e2       	ldi	r24, 0x20	; 32
    29b4:	90 e0       	ldi	r25, 0x00	; 0
    29b6:	33 d1       	rcall	.+614    	; 0x2c1e <fputc>
    29b8:	2a 94       	dec	r2
    29ba:	f5 cf       	rjmp	.-22     	; 0x29a6 <vfprintf+0x1ae>
    29bc:	f5 01       	movw	r30, r10
    29be:	37 fc       	sbrc	r3, 7
    29c0:	85 91       	lpm	r24, Z+
    29c2:	37 fe       	sbrs	r3, 7
    29c4:	81 91       	ld	r24, Z+
    29c6:	5f 01       	movw	r10, r30
    29c8:	b6 01       	movw	r22, r12
    29ca:	90 e0       	ldi	r25, 0x00	; 0
    29cc:	28 d1       	rcall	.+592    	; 0x2c1e <fputc>
    29ce:	21 10       	cpse	r2, r1
    29d0:	2a 94       	dec	r2
    29d2:	21 e0       	ldi	r18, 0x01	; 1
    29d4:	82 1a       	sub	r8, r18
    29d6:	91 08       	sbc	r9, r1
    29d8:	81 14       	cp	r8, r1
    29da:	91 04       	cpc	r9, r1
    29dc:	79 f7       	brne	.-34     	; 0x29bc <vfprintf+0x1c4>
    29de:	e1 c0       	rjmp	.+450    	; 0x2ba2 <vfprintf+0x3aa>
    29e0:	84 36       	cpi	r24, 0x64	; 100
    29e2:	11 f0       	breq	.+4      	; 0x29e8 <vfprintf+0x1f0>
    29e4:	89 36       	cpi	r24, 0x69	; 105
    29e6:	39 f5       	brne	.+78     	; 0x2a36 <vfprintf+0x23e>
    29e8:	f8 01       	movw	r30, r16
    29ea:	37 fe       	sbrs	r3, 7
    29ec:	07 c0       	rjmp	.+14     	; 0x29fc <vfprintf+0x204>
    29ee:	60 81       	ld	r22, Z
    29f0:	71 81       	ldd	r23, Z+1	; 0x01
    29f2:	82 81       	ldd	r24, Z+2	; 0x02
    29f4:	93 81       	ldd	r25, Z+3	; 0x03
    29f6:	0c 5f       	subi	r16, 0xFC	; 252
    29f8:	1f 4f       	sbci	r17, 0xFF	; 255
    29fa:	08 c0       	rjmp	.+16     	; 0x2a0c <vfprintf+0x214>
    29fc:	60 81       	ld	r22, Z
    29fe:	71 81       	ldd	r23, Z+1	; 0x01
    2a00:	07 2e       	mov	r0, r23
    2a02:	00 0c       	add	r0, r0
    2a04:	88 0b       	sbc	r24, r24
    2a06:	99 0b       	sbc	r25, r25
    2a08:	0e 5f       	subi	r16, 0xFE	; 254
    2a0a:	1f 4f       	sbci	r17, 0xFF	; 255
    2a0c:	f3 2d       	mov	r31, r3
    2a0e:	ff 76       	andi	r31, 0x6F	; 111
    2a10:	3f 2e       	mov	r3, r31
    2a12:	97 ff       	sbrs	r25, 7
    2a14:	09 c0       	rjmp	.+18     	; 0x2a28 <vfprintf+0x230>
    2a16:	90 95       	com	r25
    2a18:	80 95       	com	r24
    2a1a:	70 95       	com	r23
    2a1c:	61 95       	neg	r22
    2a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a20:	8f 4f       	sbci	r24, 0xFF	; 255
    2a22:	9f 4f       	sbci	r25, 0xFF	; 255
    2a24:	f0 68       	ori	r31, 0x80	; 128
    2a26:	3f 2e       	mov	r3, r31
    2a28:	2a e0       	ldi	r18, 0x0A	; 10
    2a2a:	30 e0       	ldi	r19, 0x00	; 0
    2a2c:	a3 01       	movw	r20, r6
    2a2e:	33 d1       	rcall	.+614    	; 0x2c96 <__ultoa_invert>
    2a30:	88 2e       	mov	r8, r24
    2a32:	86 18       	sub	r8, r6
    2a34:	44 c0       	rjmp	.+136    	; 0x2abe <vfprintf+0x2c6>
    2a36:	85 37       	cpi	r24, 0x75	; 117
    2a38:	31 f4       	brne	.+12     	; 0x2a46 <vfprintf+0x24e>
    2a3a:	23 2d       	mov	r18, r3
    2a3c:	2f 7e       	andi	r18, 0xEF	; 239
    2a3e:	b2 2e       	mov	r11, r18
    2a40:	2a e0       	ldi	r18, 0x0A	; 10
    2a42:	30 e0       	ldi	r19, 0x00	; 0
    2a44:	25 c0       	rjmp	.+74     	; 0x2a90 <vfprintf+0x298>
    2a46:	93 2d       	mov	r25, r3
    2a48:	99 7f       	andi	r25, 0xF9	; 249
    2a4a:	b9 2e       	mov	r11, r25
    2a4c:	8f 36       	cpi	r24, 0x6F	; 111
    2a4e:	c1 f0       	breq	.+48     	; 0x2a80 <vfprintf+0x288>
    2a50:	18 f4       	brcc	.+6      	; 0x2a58 <vfprintf+0x260>
    2a52:	88 35       	cpi	r24, 0x58	; 88
    2a54:	79 f0       	breq	.+30     	; 0x2a74 <vfprintf+0x27c>
    2a56:	ae c0       	rjmp	.+348    	; 0x2bb4 <vfprintf+0x3bc>
    2a58:	80 37       	cpi	r24, 0x70	; 112
    2a5a:	19 f0       	breq	.+6      	; 0x2a62 <vfprintf+0x26a>
    2a5c:	88 37       	cpi	r24, 0x78	; 120
    2a5e:	21 f0       	breq	.+8      	; 0x2a68 <vfprintf+0x270>
    2a60:	a9 c0       	rjmp	.+338    	; 0x2bb4 <vfprintf+0x3bc>
    2a62:	e9 2f       	mov	r30, r25
    2a64:	e0 61       	ori	r30, 0x10	; 16
    2a66:	be 2e       	mov	r11, r30
    2a68:	b4 fe       	sbrs	r11, 4
    2a6a:	0d c0       	rjmp	.+26     	; 0x2a86 <vfprintf+0x28e>
    2a6c:	fb 2d       	mov	r31, r11
    2a6e:	f4 60       	ori	r31, 0x04	; 4
    2a70:	bf 2e       	mov	r11, r31
    2a72:	09 c0       	rjmp	.+18     	; 0x2a86 <vfprintf+0x28e>
    2a74:	34 fe       	sbrs	r3, 4
    2a76:	0a c0       	rjmp	.+20     	; 0x2a8c <vfprintf+0x294>
    2a78:	29 2f       	mov	r18, r25
    2a7a:	26 60       	ori	r18, 0x06	; 6
    2a7c:	b2 2e       	mov	r11, r18
    2a7e:	06 c0       	rjmp	.+12     	; 0x2a8c <vfprintf+0x294>
    2a80:	28 e0       	ldi	r18, 0x08	; 8
    2a82:	30 e0       	ldi	r19, 0x00	; 0
    2a84:	05 c0       	rjmp	.+10     	; 0x2a90 <vfprintf+0x298>
    2a86:	20 e1       	ldi	r18, 0x10	; 16
    2a88:	30 e0       	ldi	r19, 0x00	; 0
    2a8a:	02 c0       	rjmp	.+4      	; 0x2a90 <vfprintf+0x298>
    2a8c:	20 e1       	ldi	r18, 0x10	; 16
    2a8e:	32 e0       	ldi	r19, 0x02	; 2
    2a90:	f8 01       	movw	r30, r16
    2a92:	b7 fe       	sbrs	r11, 7
    2a94:	07 c0       	rjmp	.+14     	; 0x2aa4 <vfprintf+0x2ac>
    2a96:	60 81       	ld	r22, Z
    2a98:	71 81       	ldd	r23, Z+1	; 0x01
    2a9a:	82 81       	ldd	r24, Z+2	; 0x02
    2a9c:	93 81       	ldd	r25, Z+3	; 0x03
    2a9e:	0c 5f       	subi	r16, 0xFC	; 252
    2aa0:	1f 4f       	sbci	r17, 0xFF	; 255
    2aa2:	06 c0       	rjmp	.+12     	; 0x2ab0 <vfprintf+0x2b8>
    2aa4:	60 81       	ld	r22, Z
    2aa6:	71 81       	ldd	r23, Z+1	; 0x01
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	0e 5f       	subi	r16, 0xFE	; 254
    2aae:	1f 4f       	sbci	r17, 0xFF	; 255
    2ab0:	a3 01       	movw	r20, r6
    2ab2:	f1 d0       	rcall	.+482    	; 0x2c96 <__ultoa_invert>
    2ab4:	88 2e       	mov	r8, r24
    2ab6:	86 18       	sub	r8, r6
    2ab8:	fb 2d       	mov	r31, r11
    2aba:	ff 77       	andi	r31, 0x7F	; 127
    2abc:	3f 2e       	mov	r3, r31
    2abe:	36 fe       	sbrs	r3, 6
    2ac0:	0d c0       	rjmp	.+26     	; 0x2adc <vfprintf+0x2e4>
    2ac2:	23 2d       	mov	r18, r3
    2ac4:	2e 7f       	andi	r18, 0xFE	; 254
    2ac6:	a2 2e       	mov	r10, r18
    2ac8:	89 14       	cp	r8, r9
    2aca:	58 f4       	brcc	.+22     	; 0x2ae2 <vfprintf+0x2ea>
    2acc:	34 fe       	sbrs	r3, 4
    2ace:	0b c0       	rjmp	.+22     	; 0x2ae6 <vfprintf+0x2ee>
    2ad0:	32 fc       	sbrc	r3, 2
    2ad2:	09 c0       	rjmp	.+18     	; 0x2ae6 <vfprintf+0x2ee>
    2ad4:	83 2d       	mov	r24, r3
    2ad6:	8e 7e       	andi	r24, 0xEE	; 238
    2ad8:	a8 2e       	mov	r10, r24
    2ada:	05 c0       	rjmp	.+10     	; 0x2ae6 <vfprintf+0x2ee>
    2adc:	b8 2c       	mov	r11, r8
    2ade:	a3 2c       	mov	r10, r3
    2ae0:	03 c0       	rjmp	.+6      	; 0x2ae8 <vfprintf+0x2f0>
    2ae2:	b8 2c       	mov	r11, r8
    2ae4:	01 c0       	rjmp	.+2      	; 0x2ae8 <vfprintf+0x2f0>
    2ae6:	b9 2c       	mov	r11, r9
    2ae8:	a4 fe       	sbrs	r10, 4
    2aea:	0f c0       	rjmp	.+30     	; 0x2b0a <vfprintf+0x312>
    2aec:	fe 01       	movw	r30, r28
    2aee:	e8 0d       	add	r30, r8
    2af0:	f1 1d       	adc	r31, r1
    2af2:	80 81       	ld	r24, Z
    2af4:	80 33       	cpi	r24, 0x30	; 48
    2af6:	21 f4       	brne	.+8      	; 0x2b00 <vfprintf+0x308>
    2af8:	9a 2d       	mov	r25, r10
    2afa:	99 7e       	andi	r25, 0xE9	; 233
    2afc:	a9 2e       	mov	r10, r25
    2afe:	09 c0       	rjmp	.+18     	; 0x2b12 <vfprintf+0x31a>
    2b00:	a2 fe       	sbrs	r10, 2
    2b02:	06 c0       	rjmp	.+12     	; 0x2b10 <vfprintf+0x318>
    2b04:	b3 94       	inc	r11
    2b06:	b3 94       	inc	r11
    2b08:	04 c0       	rjmp	.+8      	; 0x2b12 <vfprintf+0x31a>
    2b0a:	8a 2d       	mov	r24, r10
    2b0c:	86 78       	andi	r24, 0x86	; 134
    2b0e:	09 f0       	breq	.+2      	; 0x2b12 <vfprintf+0x31a>
    2b10:	b3 94       	inc	r11
    2b12:	a3 fc       	sbrc	r10, 3
    2b14:	10 c0       	rjmp	.+32     	; 0x2b36 <vfprintf+0x33e>
    2b16:	a0 fe       	sbrs	r10, 0
    2b18:	06 c0       	rjmp	.+12     	; 0x2b26 <vfprintf+0x32e>
    2b1a:	b2 14       	cp	r11, r2
    2b1c:	80 f4       	brcc	.+32     	; 0x2b3e <vfprintf+0x346>
    2b1e:	28 0c       	add	r2, r8
    2b20:	92 2c       	mov	r9, r2
    2b22:	9b 18       	sub	r9, r11
    2b24:	0d c0       	rjmp	.+26     	; 0x2b40 <vfprintf+0x348>
    2b26:	b2 14       	cp	r11, r2
    2b28:	58 f4       	brcc	.+22     	; 0x2b40 <vfprintf+0x348>
    2b2a:	b6 01       	movw	r22, r12
    2b2c:	80 e2       	ldi	r24, 0x20	; 32
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	76 d0       	rcall	.+236    	; 0x2c1e <fputc>
    2b32:	b3 94       	inc	r11
    2b34:	f8 cf       	rjmp	.-16     	; 0x2b26 <vfprintf+0x32e>
    2b36:	b2 14       	cp	r11, r2
    2b38:	18 f4       	brcc	.+6      	; 0x2b40 <vfprintf+0x348>
    2b3a:	2b 18       	sub	r2, r11
    2b3c:	02 c0       	rjmp	.+4      	; 0x2b42 <vfprintf+0x34a>
    2b3e:	98 2c       	mov	r9, r8
    2b40:	21 2c       	mov	r2, r1
    2b42:	a4 fe       	sbrs	r10, 4
    2b44:	0f c0       	rjmp	.+30     	; 0x2b64 <vfprintf+0x36c>
    2b46:	b6 01       	movw	r22, r12
    2b48:	80 e3       	ldi	r24, 0x30	; 48
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	68 d0       	rcall	.+208    	; 0x2c1e <fputc>
    2b4e:	a2 fe       	sbrs	r10, 2
    2b50:	16 c0       	rjmp	.+44     	; 0x2b7e <vfprintf+0x386>
    2b52:	a1 fc       	sbrc	r10, 1
    2b54:	03 c0       	rjmp	.+6      	; 0x2b5c <vfprintf+0x364>
    2b56:	88 e7       	ldi	r24, 0x78	; 120
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	02 c0       	rjmp	.+4      	; 0x2b60 <vfprintf+0x368>
    2b5c:	88 e5       	ldi	r24, 0x58	; 88
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	b6 01       	movw	r22, r12
    2b62:	0c c0       	rjmp	.+24     	; 0x2b7c <vfprintf+0x384>
    2b64:	8a 2d       	mov	r24, r10
    2b66:	86 78       	andi	r24, 0x86	; 134
    2b68:	51 f0       	breq	.+20     	; 0x2b7e <vfprintf+0x386>
    2b6a:	a1 fe       	sbrs	r10, 1
    2b6c:	02 c0       	rjmp	.+4      	; 0x2b72 <vfprintf+0x37a>
    2b6e:	8b e2       	ldi	r24, 0x2B	; 43
    2b70:	01 c0       	rjmp	.+2      	; 0x2b74 <vfprintf+0x37c>
    2b72:	80 e2       	ldi	r24, 0x20	; 32
    2b74:	a7 fc       	sbrc	r10, 7
    2b76:	8d e2       	ldi	r24, 0x2D	; 45
    2b78:	b6 01       	movw	r22, r12
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	50 d0       	rcall	.+160    	; 0x2c1e <fputc>
    2b7e:	89 14       	cp	r8, r9
    2b80:	30 f4       	brcc	.+12     	; 0x2b8e <vfprintf+0x396>
    2b82:	b6 01       	movw	r22, r12
    2b84:	80 e3       	ldi	r24, 0x30	; 48
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	4a d0       	rcall	.+148    	; 0x2c1e <fputc>
    2b8a:	9a 94       	dec	r9
    2b8c:	f8 cf       	rjmp	.-16     	; 0x2b7e <vfprintf+0x386>
    2b8e:	8a 94       	dec	r8
    2b90:	f3 01       	movw	r30, r6
    2b92:	e8 0d       	add	r30, r8
    2b94:	f1 1d       	adc	r31, r1
    2b96:	80 81       	ld	r24, Z
    2b98:	b6 01       	movw	r22, r12
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	40 d0       	rcall	.+128    	; 0x2c1e <fputc>
    2b9e:	81 10       	cpse	r8, r1
    2ba0:	f6 cf       	rjmp	.-20     	; 0x2b8e <vfprintf+0x396>
    2ba2:	22 20       	and	r2, r2
    2ba4:	09 f4       	brne	.+2      	; 0x2ba8 <vfprintf+0x3b0>
    2ba6:	4e ce       	rjmp	.-868    	; 0x2844 <vfprintf+0x4c>
    2ba8:	b6 01       	movw	r22, r12
    2baa:	80 e2       	ldi	r24, 0x20	; 32
    2bac:	90 e0       	ldi	r25, 0x00	; 0
    2bae:	37 d0       	rcall	.+110    	; 0x2c1e <fputc>
    2bb0:	2a 94       	dec	r2
    2bb2:	f7 cf       	rjmp	.-18     	; 0x2ba2 <vfprintf+0x3aa>
    2bb4:	f6 01       	movw	r30, r12
    2bb6:	86 81       	ldd	r24, Z+6	; 0x06
    2bb8:	97 81       	ldd	r25, Z+7	; 0x07
    2bba:	02 c0       	rjmp	.+4      	; 0x2bc0 <vfprintf+0x3c8>
    2bbc:	8f ef       	ldi	r24, 0xFF	; 255
    2bbe:	9f ef       	ldi	r25, 0xFF	; 255
    2bc0:	2b 96       	adiw	r28, 0x0b	; 11
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	f8 94       	cli
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	cd bf       	out	0x3d, r28	; 61
    2bcc:	df 91       	pop	r29
    2bce:	cf 91       	pop	r28
    2bd0:	1f 91       	pop	r17
    2bd2:	0f 91       	pop	r16
    2bd4:	ff 90       	pop	r15
    2bd6:	ef 90       	pop	r14
    2bd8:	df 90       	pop	r13
    2bda:	cf 90       	pop	r12
    2bdc:	bf 90       	pop	r11
    2bde:	af 90       	pop	r10
    2be0:	9f 90       	pop	r9
    2be2:	8f 90       	pop	r8
    2be4:	7f 90       	pop	r7
    2be6:	6f 90       	pop	r6
    2be8:	5f 90       	pop	r5
    2bea:	4f 90       	pop	r4
    2bec:	3f 90       	pop	r3
    2bee:	2f 90       	pop	r2
    2bf0:	08 95       	ret

00002bf2 <strnlen_P>:
    2bf2:	fc 01       	movw	r30, r24
    2bf4:	05 90       	lpm	r0, Z+
    2bf6:	61 50       	subi	r22, 0x01	; 1
    2bf8:	70 40       	sbci	r23, 0x00	; 0
    2bfa:	01 10       	cpse	r0, r1
    2bfc:	d8 f7       	brcc	.-10     	; 0x2bf4 <strnlen_P+0x2>
    2bfe:	80 95       	com	r24
    2c00:	90 95       	com	r25
    2c02:	8e 0f       	add	r24, r30
    2c04:	9f 1f       	adc	r25, r31
    2c06:	08 95       	ret

00002c08 <strnlen>:
    2c08:	fc 01       	movw	r30, r24
    2c0a:	61 50       	subi	r22, 0x01	; 1
    2c0c:	70 40       	sbci	r23, 0x00	; 0
    2c0e:	01 90       	ld	r0, Z+
    2c10:	01 10       	cpse	r0, r1
    2c12:	d8 f7       	brcc	.-10     	; 0x2c0a <strnlen+0x2>
    2c14:	80 95       	com	r24
    2c16:	90 95       	com	r25
    2c18:	8e 0f       	add	r24, r30
    2c1a:	9f 1f       	adc	r25, r31
    2c1c:	08 95       	ret

00002c1e <fputc>:
    2c1e:	0f 93       	push	r16
    2c20:	1f 93       	push	r17
    2c22:	cf 93       	push	r28
    2c24:	df 93       	push	r29
    2c26:	fb 01       	movw	r30, r22
    2c28:	23 81       	ldd	r18, Z+3	; 0x03
    2c2a:	21 fd       	sbrc	r18, 1
    2c2c:	03 c0       	rjmp	.+6      	; 0x2c34 <fputc+0x16>
    2c2e:	8f ef       	ldi	r24, 0xFF	; 255
    2c30:	9f ef       	ldi	r25, 0xFF	; 255
    2c32:	2c c0       	rjmp	.+88     	; 0x2c8c <fputc+0x6e>
    2c34:	22 ff       	sbrs	r18, 2
    2c36:	16 c0       	rjmp	.+44     	; 0x2c64 <fputc+0x46>
    2c38:	46 81       	ldd	r20, Z+6	; 0x06
    2c3a:	57 81       	ldd	r21, Z+7	; 0x07
    2c3c:	24 81       	ldd	r18, Z+4	; 0x04
    2c3e:	35 81       	ldd	r19, Z+5	; 0x05
    2c40:	42 17       	cp	r20, r18
    2c42:	53 07       	cpc	r21, r19
    2c44:	44 f4       	brge	.+16     	; 0x2c56 <fputc+0x38>
    2c46:	a0 81       	ld	r26, Z
    2c48:	b1 81       	ldd	r27, Z+1	; 0x01
    2c4a:	9d 01       	movw	r18, r26
    2c4c:	2f 5f       	subi	r18, 0xFF	; 255
    2c4e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c50:	31 83       	std	Z+1, r19	; 0x01
    2c52:	20 83       	st	Z, r18
    2c54:	8c 93       	st	X, r24
    2c56:	26 81       	ldd	r18, Z+6	; 0x06
    2c58:	37 81       	ldd	r19, Z+7	; 0x07
    2c5a:	2f 5f       	subi	r18, 0xFF	; 255
    2c5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c5e:	37 83       	std	Z+7, r19	; 0x07
    2c60:	26 83       	std	Z+6, r18	; 0x06
    2c62:	14 c0       	rjmp	.+40     	; 0x2c8c <fputc+0x6e>
    2c64:	8b 01       	movw	r16, r22
    2c66:	ec 01       	movw	r28, r24
    2c68:	fb 01       	movw	r30, r22
    2c6a:	00 84       	ldd	r0, Z+8	; 0x08
    2c6c:	f1 85       	ldd	r31, Z+9	; 0x09
    2c6e:	e0 2d       	mov	r30, r0
    2c70:	19 95       	eicall
    2c72:	89 2b       	or	r24, r25
    2c74:	e1 f6       	brne	.-72     	; 0x2c2e <fputc+0x10>
    2c76:	d8 01       	movw	r26, r16
    2c78:	16 96       	adiw	r26, 0x06	; 6
    2c7a:	8d 91       	ld	r24, X+
    2c7c:	9c 91       	ld	r25, X
    2c7e:	17 97       	sbiw	r26, 0x07	; 7
    2c80:	01 96       	adiw	r24, 0x01	; 1
    2c82:	17 96       	adiw	r26, 0x07	; 7
    2c84:	9c 93       	st	X, r25
    2c86:	8e 93       	st	-X, r24
    2c88:	16 97       	sbiw	r26, 0x06	; 6
    2c8a:	ce 01       	movw	r24, r28
    2c8c:	df 91       	pop	r29
    2c8e:	cf 91       	pop	r28
    2c90:	1f 91       	pop	r17
    2c92:	0f 91       	pop	r16
    2c94:	08 95       	ret

00002c96 <__ultoa_invert>:
    2c96:	fa 01       	movw	r30, r20
    2c98:	aa 27       	eor	r26, r26
    2c9a:	28 30       	cpi	r18, 0x08	; 8
    2c9c:	51 f1       	breq	.+84     	; 0x2cf2 <__ultoa_invert+0x5c>
    2c9e:	20 31       	cpi	r18, 0x10	; 16
    2ca0:	81 f1       	breq	.+96     	; 0x2d02 <__ultoa_invert+0x6c>
    2ca2:	e8 94       	clt
    2ca4:	6f 93       	push	r22
    2ca6:	6e 7f       	andi	r22, 0xFE	; 254
    2ca8:	6e 5f       	subi	r22, 0xFE	; 254
    2caa:	7f 4f       	sbci	r23, 0xFF	; 255
    2cac:	8f 4f       	sbci	r24, 0xFF	; 255
    2cae:	9f 4f       	sbci	r25, 0xFF	; 255
    2cb0:	af 4f       	sbci	r26, 0xFF	; 255
    2cb2:	b1 e0       	ldi	r27, 0x01	; 1
    2cb4:	3e d0       	rcall	.+124    	; 0x2d32 <__ultoa_invert+0x9c>
    2cb6:	b4 e0       	ldi	r27, 0x04	; 4
    2cb8:	3c d0       	rcall	.+120    	; 0x2d32 <__ultoa_invert+0x9c>
    2cba:	67 0f       	add	r22, r23
    2cbc:	78 1f       	adc	r23, r24
    2cbe:	89 1f       	adc	r24, r25
    2cc0:	9a 1f       	adc	r25, r26
    2cc2:	a1 1d       	adc	r26, r1
    2cc4:	68 0f       	add	r22, r24
    2cc6:	79 1f       	adc	r23, r25
    2cc8:	8a 1f       	adc	r24, r26
    2cca:	91 1d       	adc	r25, r1
    2ccc:	a1 1d       	adc	r26, r1
    2cce:	6a 0f       	add	r22, r26
    2cd0:	71 1d       	adc	r23, r1
    2cd2:	81 1d       	adc	r24, r1
    2cd4:	91 1d       	adc	r25, r1
    2cd6:	a1 1d       	adc	r26, r1
    2cd8:	20 d0       	rcall	.+64     	; 0x2d1a <__ultoa_invert+0x84>
    2cda:	09 f4       	brne	.+2      	; 0x2cde <__ultoa_invert+0x48>
    2cdc:	68 94       	set
    2cde:	3f 91       	pop	r19
    2ce0:	2a e0       	ldi	r18, 0x0A	; 10
    2ce2:	26 9f       	mul	r18, r22
    2ce4:	11 24       	eor	r1, r1
    2ce6:	30 19       	sub	r19, r0
    2ce8:	30 5d       	subi	r19, 0xD0	; 208
    2cea:	31 93       	st	Z+, r19
    2cec:	de f6       	brtc	.-74     	; 0x2ca4 <__ultoa_invert+0xe>
    2cee:	cf 01       	movw	r24, r30
    2cf0:	08 95       	ret
    2cf2:	46 2f       	mov	r20, r22
    2cf4:	47 70       	andi	r20, 0x07	; 7
    2cf6:	40 5d       	subi	r20, 0xD0	; 208
    2cf8:	41 93       	st	Z+, r20
    2cfa:	b3 e0       	ldi	r27, 0x03	; 3
    2cfc:	0f d0       	rcall	.+30     	; 0x2d1c <__ultoa_invert+0x86>
    2cfe:	c9 f7       	brne	.-14     	; 0x2cf2 <__ultoa_invert+0x5c>
    2d00:	f6 cf       	rjmp	.-20     	; 0x2cee <__ultoa_invert+0x58>
    2d02:	46 2f       	mov	r20, r22
    2d04:	4f 70       	andi	r20, 0x0F	; 15
    2d06:	40 5d       	subi	r20, 0xD0	; 208
    2d08:	4a 33       	cpi	r20, 0x3A	; 58
    2d0a:	18 f0       	brcs	.+6      	; 0x2d12 <__ultoa_invert+0x7c>
    2d0c:	49 5d       	subi	r20, 0xD9	; 217
    2d0e:	31 fd       	sbrc	r19, 1
    2d10:	40 52       	subi	r20, 0x20	; 32
    2d12:	41 93       	st	Z+, r20
    2d14:	02 d0       	rcall	.+4      	; 0x2d1a <__ultoa_invert+0x84>
    2d16:	a9 f7       	brne	.-22     	; 0x2d02 <__ultoa_invert+0x6c>
    2d18:	ea cf       	rjmp	.-44     	; 0x2cee <__ultoa_invert+0x58>
    2d1a:	b4 e0       	ldi	r27, 0x04	; 4
    2d1c:	a6 95       	lsr	r26
    2d1e:	97 95       	ror	r25
    2d20:	87 95       	ror	r24
    2d22:	77 95       	ror	r23
    2d24:	67 95       	ror	r22
    2d26:	ba 95       	dec	r27
    2d28:	c9 f7       	brne	.-14     	; 0x2d1c <__ultoa_invert+0x86>
    2d2a:	00 97       	sbiw	r24, 0x00	; 0
    2d2c:	61 05       	cpc	r22, r1
    2d2e:	71 05       	cpc	r23, r1
    2d30:	08 95       	ret
    2d32:	9b 01       	movw	r18, r22
    2d34:	ac 01       	movw	r20, r24
    2d36:	0a 2e       	mov	r0, r26
    2d38:	06 94       	lsr	r0
    2d3a:	57 95       	ror	r21
    2d3c:	47 95       	ror	r20
    2d3e:	37 95       	ror	r19
    2d40:	27 95       	ror	r18
    2d42:	ba 95       	dec	r27
    2d44:	c9 f7       	brne	.-14     	; 0x2d38 <__ultoa_invert+0xa2>
    2d46:	62 0f       	add	r22, r18
    2d48:	73 1f       	adc	r23, r19
    2d4a:	84 1f       	adc	r24, r20
    2d4c:	95 1f       	adc	r25, r21
    2d4e:	a0 1d       	adc	r26, r0
    2d50:	08 95       	ret

00002d52 <_exit>:
    2d52:	f8 94       	cli

00002d54 <__stop_program>:
    2d54:	ff cf       	rjmp	.-2      	; 0x2d54 <__stop_program>
