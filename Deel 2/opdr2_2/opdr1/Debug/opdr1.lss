
opdr1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000054  00800200  000022c2  00002356  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000120  00800254  00800254  000023aa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023aa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000023dc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000570  00000000  00000000  00002420  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006971  00000000  00000000  00002990  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001306  00000000  00000000  00009301  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004327  00000000  00000000  0000a607  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001384  00000000  00000000  0000e930  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b28  00000000  00000000  0000fcb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007134  00000000  00000000  000117dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007f8  00000000  00000000  00018910  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6d c1       	rjmp	.+730    	; 0x2dc <__ctors_end>
       2:	00 00       	nop
       4:	8c c1       	rjmp	.+792    	; 0x31e <__bad_interrupt>
       6:	00 00       	nop
       8:	8a c1       	rjmp	.+788    	; 0x31e <__bad_interrupt>
       a:	00 00       	nop
       c:	88 c1       	rjmp	.+784    	; 0x31e <__bad_interrupt>
       e:	00 00       	nop
      10:	86 c1       	rjmp	.+780    	; 0x31e <__bad_interrupt>
      12:	00 00       	nop
      14:	84 c1       	rjmp	.+776    	; 0x31e <__bad_interrupt>
      16:	00 00       	nop
      18:	82 c1       	rjmp	.+772    	; 0x31e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	80 c1       	rjmp	.+768    	; 0x31e <__bad_interrupt>
      1e:	00 00       	nop
      20:	7e c1       	rjmp	.+764    	; 0x31e <__bad_interrupt>
      22:	00 00       	nop
      24:	7c c1       	rjmp	.+760    	; 0x31e <__bad_interrupt>
      26:	00 00       	nop
      28:	7a c1       	rjmp	.+756    	; 0x31e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	78 c1       	rjmp	.+752    	; 0x31e <__bad_interrupt>
      2e:	00 00       	nop
      30:	76 c1       	rjmp	.+748    	; 0x31e <__bad_interrupt>
      32:	00 00       	nop
      34:	74 c1       	rjmp	.+744    	; 0x31e <__bad_interrupt>
      36:	00 00       	nop
      38:	72 c1       	rjmp	.+740    	; 0x31e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	70 c1       	rjmp	.+736    	; 0x31e <__bad_interrupt>
      3e:	00 00       	nop
      40:	6e c1       	rjmp	.+732    	; 0x31e <__bad_interrupt>
      42:	00 00       	nop
      44:	6c c1       	rjmp	.+728    	; 0x31e <__bad_interrupt>
      46:	00 00       	nop
      48:	6a c1       	rjmp	.+724    	; 0x31e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	68 c1       	rjmp	.+720    	; 0x31e <__bad_interrupt>
      4e:	00 00       	nop
      50:	66 c1       	rjmp	.+716    	; 0x31e <__bad_interrupt>
      52:	00 00       	nop
      54:	c4 c4       	rjmp	.+2440   	; 0x9de <__vector_21>
      56:	00 00       	nop
      58:	62 c1       	rjmp	.+708    	; 0x31e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	60 c1       	rjmp	.+704    	; 0x31e <__bad_interrupt>
      5e:	00 00       	nop
      60:	5e c1       	rjmp	.+700    	; 0x31e <__bad_interrupt>
      62:	00 00       	nop
      64:	38 c7       	rjmp	.+3696   	; 0xed6 <__vector_25>
      66:	00 00       	nop
      68:	95 c7       	rjmp	.+3882   	; 0xf94 <__vector_26>
      6a:	00 00       	nop
      6c:	58 c1       	rjmp	.+688    	; 0x31e <__bad_interrupt>
      6e:	00 00       	nop
      70:	56 c1       	rjmp	.+684    	; 0x31e <__bad_interrupt>
      72:	00 00       	nop
      74:	54 c1       	rjmp	.+680    	; 0x31e <__bad_interrupt>
      76:	00 00       	nop
      78:	52 c1       	rjmp	.+676    	; 0x31e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	50 c1       	rjmp	.+672    	; 0x31e <__bad_interrupt>
      7e:	00 00       	nop
      80:	4e c1       	rjmp	.+668    	; 0x31e <__bad_interrupt>
      82:	00 00       	nop
      84:	4c c1       	rjmp	.+664    	; 0x31e <__bad_interrupt>
      86:	00 00       	nop
      88:	4a c1       	rjmp	.+660    	; 0x31e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	48 c1       	rjmp	.+656    	; 0x31e <__bad_interrupt>
      8e:	00 00       	nop
      90:	ca c7       	rjmp	.+3988   	; 0x1026 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 72 08 	jmp	0x10e4	; 0x10e4 <__vector_37>
      98:	42 c1       	rjmp	.+644    	; 0x31e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	95 c1       	rjmp	.+810    	; 0x3c8 <__vector_39>
      9e:	00 00       	nop
      a0:	3e c1       	rjmp	.+636    	; 0x31e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3c c1       	rjmp	.+632    	; 0x31e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3a c1       	rjmp	.+628    	; 0x31e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	38 c1       	rjmp	.+624    	; 0x31e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	36 c1       	rjmp	.+620    	; 0x31e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	34 c1       	rjmp	.+616    	; 0x31e <__bad_interrupt>
      b6:	00 00       	nop
      b8:	32 c1       	rjmp	.+612    	; 0x31e <__bad_interrupt>
      ba:	00 00       	nop
      bc:	30 c1       	rjmp	.+608    	; 0x31e <__bad_interrupt>
      be:	00 00       	nop
      c0:	2e c1       	rjmp	.+604    	; 0x31e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2c c1       	rjmp	.+600    	; 0x31e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2a c1       	rjmp	.+596    	; 0x31e <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_51>
      d0:	0c 94 1a 09 	jmp	0x1234	; 0x1234 <__vector_52>
      d4:	24 c1       	rjmp	.+584    	; 0x31e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 63 09 	jmp	0x12c6	; 0x12c6 <__vector_54>
      dc:	0c 94 c2 09 	jmp	0x1384	; 0x1384 <__vector_55>
      e0:	1e c1       	rjmp	.+572    	; 0x31e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	03 02       	muls	r16, r19
      e6:	be 02       	muls	r27, r30
      e8:	be 02       	muls	r27, r30
      ea:	be 02       	muls	r27, r30
      ec:	be 02       	muls	r27, r30
      ee:	be 02       	muls	r27, r30
      f0:	be 02       	muls	r27, r30
      f2:	be 02       	muls	r27, r30
      f4:	03 02       	muls	r16, r19
      f6:	be 02       	muls	r27, r30
      f8:	be 02       	muls	r27, r30
      fa:	be 02       	muls	r27, r30
      fc:	be 02       	muls	r27, r30
      fe:	be 02       	muls	r27, r30
     100:	be 02       	muls	r27, r30
     102:	be 02       	muls	r27, r30
     104:	05 02       	muls	r16, r21
     106:	be 02       	muls	r27, r30
     108:	be 02       	muls	r27, r30
     10a:	be 02       	muls	r27, r30
     10c:	be 02       	muls	r27, r30
     10e:	be 02       	muls	r27, r30
     110:	be 02       	muls	r27, r30
     112:	be 02       	muls	r27, r30
     114:	22 02       	muls	r18, r18
     116:	be 02       	muls	r27, r30
     118:	be 02       	muls	r27, r30
     11a:	be 02       	muls	r27, r30
     11c:	be 02       	muls	r27, r30
     11e:	be 02       	muls	r27, r30
     120:	be 02       	muls	r27, r30
     122:	be 02       	muls	r27, r30
     124:	05 02       	muls	r16, r21
     126:	be 02       	muls	r27, r30
     128:	be 02       	muls	r27, r30
     12a:	be 02       	muls	r27, r30
     12c:	be 02       	muls	r27, r30
     12e:	be 02       	muls	r27, r30
     130:	be 02       	muls	r27, r30
     132:	be 02       	muls	r27, r30
     134:	22 02       	muls	r18, r18
     136:	be 02       	muls	r27, r30
     138:	be 02       	muls	r27, r30
     13a:	be 02       	muls	r27, r30
     13c:	be 02       	muls	r27, r30
     13e:	be 02       	muls	r27, r30
     140:	be 02       	muls	r27, r30
     142:	be 02       	muls	r27, r30
     144:	ba 02       	muls	r27, r26
     146:	be 02       	muls	r27, r30
     148:	be 02       	muls	r27, r30
     14a:	be 02       	muls	r27, r30
     14c:	be 02       	muls	r27, r30
     14e:	be 02       	muls	r27, r30
     150:	be 02       	muls	r27, r30
     152:	be 02       	muls	r27, r30
     154:	36 02       	muls	r19, r22
     156:	be 02       	muls	r27, r30
     158:	be 02       	muls	r27, r30
     15a:	be 02       	muls	r27, r30
     15c:	be 02       	muls	r27, r30
     15e:	be 02       	muls	r27, r30
     160:	be 02       	muls	r27, r30
     162:	be 02       	muls	r27, r30
     164:	59 02       	muls	r21, r25
     166:	be 02       	muls	r27, r30
     168:	be 02       	muls	r27, r30
     16a:	be 02       	muls	r27, r30
     16c:	be 02       	muls	r27, r30
     16e:	be 02       	muls	r27, r30
     170:	be 02       	muls	r27, r30
     172:	be 02       	muls	r27, r30
     174:	2a 02       	muls	r18, r26
     176:	be 02       	muls	r27, r30
     178:	be 02       	muls	r27, r30
     17a:	be 02       	muls	r27, r30
     17c:	be 02       	muls	r27, r30
     17e:	be 02       	muls	r27, r30
     180:	be 02       	muls	r27, r30
     182:	be 02       	muls	r27, r30
     184:	48 02       	muls	r20, r24
     186:	be 02       	muls	r27, r30
     188:	be 02       	muls	r27, r30
     18a:	be 02       	muls	r27, r30
     18c:	be 02       	muls	r27, r30
     18e:	be 02       	muls	r27, r30
     190:	be 02       	muls	r27, r30
     192:	be 02       	muls	r27, r30
     194:	90 02       	muls	r25, r16
     196:	be 02       	muls	r27, r30
     198:	be 02       	muls	r27, r30
     19a:	be 02       	muls	r27, r30
     19c:	be 02       	muls	r27, r30
     19e:	be 02       	muls	r27, r30
     1a0:	be 02       	muls	r27, r30
     1a2:	be 02       	muls	r27, r30
     1a4:	90 02       	muls	r25, r16
     1a6:	be 02       	muls	r27, r30
     1a8:	be 02       	muls	r27, r30
     1aa:	be 02       	muls	r27, r30
     1ac:	be 02       	muls	r27, r30
     1ae:	be 02       	muls	r27, r30
     1b0:	be 02       	muls	r27, r30
     1b2:	be 02       	muls	r27, r30
     1b4:	8b 02       	muls	r24, r27
     1b6:	be 02       	muls	r27, r30
     1b8:	be 02       	muls	r27, r30
     1ba:	be 02       	muls	r27, r30
     1bc:	be 02       	muls	r27, r30
     1be:	be 02       	muls	r27, r30
     1c0:	be 02       	muls	r27, r30
     1c2:	be 02       	muls	r27, r30
     1c4:	8b 02       	muls	r24, r27
     1c6:	be 02       	muls	r27, r30
     1c8:	be 02       	muls	r27, r30
     1ca:	be 02       	muls	r27, r30
     1cc:	be 02       	muls	r27, r30
     1ce:	be 02       	muls	r27, r30
     1d0:	be 02       	muls	r27, r30
     1d2:	be 02       	muls	r27, r30
     1d4:	9b 02       	muls	r25, r27
     1d6:	be 02       	muls	r27, r30
     1d8:	be 02       	muls	r27, r30
     1da:	be 02       	muls	r27, r30
     1dc:	be 02       	muls	r27, r30
     1de:	be 02       	muls	r27, r30
     1e0:	be 02       	muls	r27, r30
     1e2:	be 02       	muls	r27, r30
     1e4:	b0 02       	muls	r27, r16
     1e6:	be 02       	muls	r27, r30
     1e8:	be 02       	muls	r27, r30
     1ea:	be 02       	muls	r27, r30
     1ec:	be 02       	muls	r27, r30
     1ee:	be 02       	muls	r27, r30
     1f0:	be 02       	muls	r27, r30
     1f2:	be 02       	muls	r27, r30
     1f4:	9b 02       	muls	r25, r27
     1f6:	be 02       	muls	r27, r30
     1f8:	be 02       	muls	r27, r30
     1fa:	be 02       	muls	r27, r30
     1fc:	be 02       	muls	r27, r30
     1fe:	be 02       	muls	r27, r30
     200:	be 02       	muls	r27, r30
     202:	be 02       	muls	r27, r30
     204:	b0 02       	muls	r27, r16
     206:	be 02       	muls	r27, r30
     208:	be 02       	muls	r27, r30
     20a:	be 02       	muls	r27, r30
     20c:	be 02       	muls	r27, r30
     20e:	be 02       	muls	r27, r30
     210:	be 02       	muls	r27, r30
     212:	be 02       	muls	r27, r30
     214:	b4 02       	muls	r27, r20
     216:	be 02       	muls	r27, r30
     218:	be 02       	muls	r27, r30
     21a:	be 02       	muls	r27, r30
     21c:	be 02       	muls	r27, r30
     21e:	be 02       	muls	r27, r30
     220:	be 02       	muls	r27, r30
     222:	be 02       	muls	r27, r30
     224:	61 02       	muls	r22, r17
     226:	be 02       	muls	r27, r30
     228:	be 02       	muls	r27, r30
     22a:	be 02       	muls	r27, r30
     22c:	be 02       	muls	r27, r30
     22e:	be 02       	muls	r27, r30
     230:	be 02       	muls	r27, r30
     232:	be 02       	muls	r27, r30
     234:	61 02       	muls	r22, r17
     236:	be 02       	muls	r27, r30
     238:	be 02       	muls	r27, r30
     23a:	be 02       	muls	r27, r30
     23c:	be 02       	muls	r27, r30
     23e:	be 02       	muls	r27, r30
     240:	be 02       	muls	r27, r30
     242:	be 02       	muls	r27, r30
     244:	63 02       	muls	r22, r19
     246:	be 02       	muls	r27, r30
     248:	be 02       	muls	r27, r30
     24a:	be 02       	muls	r27, r30
     24c:	be 02       	muls	r27, r30
     24e:	be 02       	muls	r27, r30
     250:	be 02       	muls	r27, r30
     252:	be 02       	muls	r27, r30
     254:	73 02       	muls	r23, r19
     256:	be 02       	muls	r27, r30
     258:	be 02       	muls	r27, r30
     25a:	be 02       	muls	r27, r30
     25c:	be 02       	muls	r27, r30
     25e:	be 02       	muls	r27, r30
     260:	be 02       	muls	r27, r30
     262:	be 02       	muls	r27, r30
     264:	87 02       	muls	r24, r23

00000266 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     266:	08 e8       	ldi	r16, 0x88	; 136
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	f0 eb       	ldi	r31, 0xB0	; 176
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 b8 0b 	call	0x1770	; 0x1770 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	e7 d1       	rcall	.+974    	; 0x670 <uxListRemove>
     2a2:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 7d 02 	sts	0x027D, r24	; 0x80027d <uxCurrentNumberOfTasks>
     2ac:	80 91 87 02 	lds	r24, 0x0287	; 0x800287 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5e d0       	rcall	.+188    	; 0x37c <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5c d0       	rcall	.+184    	; 0x37c <vPortFree>
     2c4:	80 91 87 02 	lds	r24, 0x0287	; 0x800287 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	ab d2       	rcall	.+1366   	; 0x82c <vPortYield>
     2d6:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vApplicationIdleHook>
     2da:	f4 cf       	rjmp	.-24     	; 0x2c4 <prvIdleTask+0x5e>

000002dc <__ctors_end>:
     2dc:	11 24       	eor	r1, r1
     2de:	1f be       	out	0x3f, r1	; 63
     2e0:	cf ef       	ldi	r28, 0xFF	; 255
     2e2:	d1 e2       	ldi	r29, 0x21	; 33
     2e4:	de bf       	out	0x3e, r29	; 62
     2e6:	cd bf       	out	0x3d, r28	; 61
     2e8:	00 e0       	ldi	r16, 0x00	; 0
     2ea:	0c bf       	out	0x3c, r16	; 60

000002ec <__do_copy_data>:
     2ec:	12 e0       	ldi	r17, 0x02	; 2
     2ee:	a0 e0       	ldi	r26, 0x00	; 0
     2f0:	b2 e0       	ldi	r27, 0x02	; 2
     2f2:	e2 ec       	ldi	r30, 0xC2	; 194
     2f4:	f2 e2       	ldi	r31, 0x22	; 34
     2f6:	00 e0       	ldi	r16, 0x00	; 0
     2f8:	0b bf       	out	0x3b, r16	; 59
     2fa:	02 c0       	rjmp	.+4      	; 0x300 <__do_copy_data+0x14>
     2fc:	07 90       	elpm	r0, Z+
     2fe:	0d 92       	st	X+, r0
     300:	a4 35       	cpi	r26, 0x54	; 84
     302:	b1 07       	cpc	r27, r17
     304:	d9 f7       	brne	.-10     	; 0x2fc <__do_copy_data+0x10>

00000306 <__do_clear_bss>:
     306:	23 e0       	ldi	r18, 0x03	; 3
     308:	a4 e5       	ldi	r26, 0x54	; 84
     30a:	b2 e0       	ldi	r27, 0x02	; 2
     30c:	01 c0       	rjmp	.+2      	; 0x310 <.do_clear_bss_start>

0000030e <.do_clear_bss_loop>:
     30e:	1d 92       	st	X+, r1

00000310 <.do_clear_bss_start>:
     310:	a4 37       	cpi	r26, 0x74	; 116
     312:	b2 07       	cpc	r27, r18
     314:	e1 f7       	brne	.-8      	; 0x30e <.do_clear_bss_loop>
     316:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <main>
     31a:	0c 94 5f 11 	jmp	0x22be	; 0x22be <_exit>

0000031e <__bad_interrupt>:
     31e:	70 ce       	rjmp	.-800    	; 0x0 <__vectors>

00000320 <system_tick>:
#include <avr/common.h>

    .global	system_tick
	.type	system_tick, @function
system_tick:
    push r24
     320:	8f 93       	push	r24
    in r24,_SFR_IO_ADDR(SREG)
     322:	8f b7       	in	r24, 0x3f	; 63
	push r24
     324:	8f 93       	push	r24
	cli
     326:	f8 94       	cli
    lds r24,__system_time+0
     328:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <__system_time>
    subi r24, (-1)
     32c:	8f 5f       	subi	r24, 0xFF	; 255
    sts __system_time+0,r24
     32e:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <__system_time>
    lds r24,__system_time+1
     332:	80 91 df 02 	lds	r24, 0x02DF	; 0x8002df <__system_time+0x1>
    sbci r24, (-1)
     336:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+1,r24
     338:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <__system_time+0x1>
    lds r24,__system_time+2
     33c:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <__system_time+0x2>
    sbci r24, (-1)
     340:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+2,r24
     342:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <__system_time+0x2>
    lds r24,__system_time+3
     346:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <__system_time+0x3>
    sbci r24, (-1)
     34a:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+3,r24
     34c:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <__system_time+0x3>
    pop r24
     350:	8f 91       	pop	r24
    out _SFR_IO_ADDR(SREG),r24
     352:	8f bf       	out	0x3f, r24	; 63
    pop r24
     354:	8f 91       	pop	r24
    ret
     356:	08 95       	ret

00000358 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35e:	0e 94 b8 0b 	call	0x1770	; 0x1770 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     362:	ce 01       	movw	r24, r28
     364:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <malloc>
     368:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     36a:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36e:	20 97       	sbiw	r28, 0x00	; 0
     370:	09 f4       	brne	.+2      	; 0x374 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     372:	13 d0       	rcall	.+38     	; 0x39a <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     374:	ce 01       	movw	r24, r28
     376:	df 91       	pop	r29
     378:	cf 91       	pop	r28
     37a:	08 95       	ret

0000037c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     37c:	cf 93       	push	r28
     37e:	df 93       	push	r29
	if( pv )
     380:	00 97       	sbiw	r24, 0x00	; 0
     382:	41 f0       	breq	.+16     	; 0x394 <vPortFree+0x18>
     384:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     386:	0e 94 b8 0b 	call	0x1770	; 0x1770 <vTaskSuspendAll>
		{
			free( pv );
     38a:	ce 01       	movw	r24, r28
     38c:	0e 94 95 10 	call	0x212a	; 0x212a <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     390:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskResumeAll>
	}
}
     394:	df 91       	pop	r29
     396:	cf 91       	pop	r28
     398:	08 95       	ret

0000039a <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     39a:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     39c:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     39e:	83 ed       	ldi	r24, 0xD3	; 211
     3a0:	90 e3       	ldi	r25, 0x30	; 48
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	f1 f7       	brne	.-4      	; 0x3a2 <vApplicationMallocFailedHook+0x8>
     3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <vApplicationMallocFailedHook+0xe>
     3a8:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3aa:	1f 9a       	sbi	0x03, 7	; 3
     3ac:	f8 cf       	rjmp	.-16     	; 0x39e <vApplicationMallocFailedHook+0x4>

000003ae <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3ae:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3b0:	2f 9a       	sbi	0x05, 7	; 5
     3b2:	2f e7       	ldi	r18, 0x7F	; 127
     3b4:	8a e1       	ldi	r24, 0x1A	; 26
     3b6:	96 e0       	ldi	r25, 0x06	; 6
     3b8:	21 50       	subi	r18, 0x01	; 1
     3ba:	80 40       	sbci	r24, 0x00	; 0
     3bc:	90 40       	sbci	r25, 0x00	; 0
     3be:	e1 f7       	brne	.-8      	; 0x3b8 <vApplicationStackOverflowHook+0xa>
     3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <vApplicationStackOverflowHook+0x14>
     3c2:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3c4:	1f 9a       	sbi	0x03, 7	; 3
     3c6:	f5 cf       	rjmp	.-22     	; 0x3b2 <vApplicationStackOverflowHook+0x4>

000003c8 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3c8:	1f 92       	push	r1
     3ca:	0f 92       	push	r0
     3cc:	0f b6       	in	r0, 0x3f	; 63
     3ce:	0f 92       	push	r0
     3d0:	11 24       	eor	r1, r1
     3d2:	0b b6       	in	r0, 0x3b	; 59
     3d4:	0f 92       	push	r0
     3d6:	2f 93       	push	r18
     3d8:	3f 93       	push	r19
     3da:	8f 93       	push	r24
     3dc:	9f 93       	push	r25
     3de:	af 93       	push	r26
     3e0:	bf 93       	push	r27
     3e2:	ef 93       	push	r30
     3e4:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     3e6:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     3ea:	8e 2f       	mov	r24, r30
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	fc 01       	movw	r30, r24
     3f0:	38 97       	sbiw	r30, 0x08	; 8
     3f2:	e1 3c       	cpi	r30, 0xC1	; 193
     3f4:	f1 05       	cpc	r31, r1
     3f6:	08 f0       	brcs	.+2      	; 0x3fa <__vector_39+0x32>
     3f8:	c1 c0       	rjmp	.+386    	; 0x57c <__FUSE_REGION_LENGTH__+0x17c>
     3fa:	88 27       	eor	r24, r24
     3fc:	ee 58       	subi	r30, 0x8E	; 142
     3fe:	ff 4f       	sbci	r31, 0xFF	; 255
     400:	8f 4f       	sbci	r24, 0xFF	; 255
     402:	0c 94 f5 0f 	jmp	0x1fea	; 0x1fea <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     406:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     40a:	e0 91 54 02 	lds	r30, 0x0254	; 0x800254 <__data_end>
     40e:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_msgSize>
     412:	e8 17       	cp	r30, r24
     414:	70 f4       	brcc	.+28     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     416:	81 e0       	ldi	r24, 0x01	; 1
     418:	8e 0f       	add	r24, r30
     41a:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <__data_end>
     41e:	f0 e0       	ldi	r31, 0x00	; 0
     420:	e8 5a       	subi	r30, 0xA8	; 168
     422:	fd 4f       	sbci	r31, 0xFD	; 253
     424:	80 81       	ld	r24, Z
     426:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     42a:	85 e8       	ldi	r24, 0x85	; 133
     42c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     430:	ac c0       	rjmp	.+344    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     432:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     436:	81 60       	ori	r24, 0x01	; 1
     438:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     43c:	84 e9       	ldi	r24, 0x94	; 148
     43e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     442:	a3 c0       	rjmp	.+326    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     444:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     448:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     44c:	85 ee       	ldi	r24, 0xE5	; 229
     44e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     452:	9b c0       	rjmp	.+310    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     454:	e0 91 54 02 	lds	r30, 0x0254	; 0x800254 <__data_end>
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	8e 0f       	add	r24, r30
     45c:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <__data_end>
     460:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     464:	f0 e0       	ldi	r31, 0x00	; 0
     466:	e8 5a       	subi	r30, 0xA8	; 168
     468:	fd 4f       	sbci	r31, 0xFD	; 253
     46a:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     46c:	20 91 54 02 	lds	r18, 0x0254	; 0x800254 <__data_end>
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_msgSize>
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	01 97       	sbiw	r24, 0x01	; 1
     47a:	28 17       	cp	r18, r24
     47c:	39 07       	cpc	r19, r25
     47e:	24 f4       	brge	.+8      	; 0x488 <__FUSE_REGION_LENGTH__+0x88>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     480:	85 ec       	ldi	r24, 0xC5	; 197
     482:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     486:	81 c0       	rjmp	.+258    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     488:	85 e8       	ldi	r24, 0x85	; 133
     48a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     48e:	7d c0       	rjmp	.+250    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     490:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     494:	e0 91 54 02 	lds	r30, 0x0254	; 0x800254 <__data_end>
     498:	f0 e0       	ldi	r31, 0x00	; 0
     49a:	e8 5a       	subi	r30, 0xA8	; 168
     49c:	fd 4f       	sbci	r31, 0xFD	; 253
     49e:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4a0:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     4a4:	81 60       	ori	r24, 0x01	; 1
     4a6:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4aa:	84 ed       	ldi	r24, 0xD4	; 212
     4ac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4b0:	6c c0       	rjmp	.+216    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4b2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4b6:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4ba:	85 ed       	ldi	r24, 0xD5	; 213
     4bc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4c0:	64 c0       	rjmp	.+200    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4c2:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4c6:	e0 91 54 02 	lds	r30, 0x0254	; 0x800254 <__data_end>
     4ca:	81 e0       	ldi	r24, 0x01	; 1
     4cc:	8e 0f       	add	r24, r30
     4ce:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <__data_end>
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	e8 5a       	subi	r30, 0xA8	; 168
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	80 81       	ld	r24, Z
     4da:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     4de:	85 ec       	ldi	r24, 0xC5	; 197
     4e0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     4e4:	52 c0       	rjmp	.+164    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     4e6:	90 91 54 02 	lds	r25, 0x0254	; 0x800254 <__data_end>
     4ea:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <I2C_msgSize>
     4ee:	98 13       	cpse	r25, r24
     4f0:	06 c0       	rjmp	.+12     	; 0x4fe <__FUSE_REGION_LENGTH__+0xfe>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     4f2:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     4f6:	81 60       	ori	r24, 0x01	; 1
     4f8:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>
     4fc:	04 c0       	rjmp	.+8      	; 0x506 <__FUSE_REGION_LENGTH__+0x106>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     4fe:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     502:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     506:	84 e0       	ldi	r24, 0x04	; 4
     508:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     50c:	3e c0       	rjmp	.+124    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     50e:	85 ec       	ldi	r24, 0xC5	; 197
     510:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     514:	3a c0       	rjmp	.+116    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     516:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     51a:	84 60       	ori	r24, 0x04	; 4
     51c:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     520:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     524:	82 60       	ori	r24, 0x02	; 2
     526:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     52a:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     52e:	85 ec       	ldi	r24, 0xC5	; 197
     530:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     534:	2a c0       	rjmp	.+84     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     536:	e0 91 54 02 	lds	r30, 0x0254	; 0x800254 <__data_end>
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	8e 0f       	add	r24, r30
     53e:	80 93 54 02 	sts	0x0254, r24	; 0x800254 <__data_end>
     542:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	e8 5a       	subi	r30, 0xA8	; 168
     54a:	fd 4f       	sbci	r31, 0xFD	; 253
     54c:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     54e:	80 91 55 02 	lds	r24, 0x0255	; 0x800255 <I2C_statusReg>
     552:	81 60       	ori	r24, 0x01	; 1
     554:	80 93 55 02 	sts	0x0255, r24	; 0x800255 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     558:	85 ec       	ldi	r24, 0xC5	; 197
     55a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     55e:	15 c0       	rjmp	.+42     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     560:	85 e8       	ldi	r24, 0x85	; 133
     562:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     566:	11 c0       	rjmp	.+34     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     568:	84 e0       	ldi	r24, 0x04	; 4
     56a:	80 93 56 02 	sts	0x0256, r24	; 0x800256 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     56e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     572:	0b c0       	rjmp	.+22     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     574:	85 ee       	ldi	r24, 0xE5	; 229
     576:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     57a:	07 c0       	rjmp	.+14     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     57c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     580:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     584:	85 ed       	ldi	r24, 0xD5	; 213
     586:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     58a:	ff 91       	pop	r31
     58c:	ef 91       	pop	r30
     58e:	bf 91       	pop	r27
     590:	af 91       	pop	r26
     592:	9f 91       	pop	r25
     594:	8f 91       	pop	r24
     596:	3f 91       	pop	r19
     598:	2f 91       	pop	r18
     59a:	0f 90       	pop	r0
     59c:	0b be       	out	0x3b, r0	; 59
     59e:	0f 90       	pop	r0
     5a0:	0f be       	out	0x3f, r0	; 63
     5a2:	0f 90       	pop	r0
     5a4:	1f 90       	pop	r1
     5a6:	18 95       	reti

000005a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5a8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5aa:	03 96       	adiw	r24, 0x03	; 3
     5ac:	92 83       	std	Z+2, r25	; 0x02
     5ae:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5b0:	2f ef       	ldi	r18, 0xFF	; 255
     5b2:	3f ef       	ldi	r19, 0xFF	; 255
     5b4:	34 83       	std	Z+4, r19	; 0x04
     5b6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b8:	96 83       	std	Z+6, r25	; 0x06
     5ba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5bc:	90 87       	std	Z+8, r25	; 0x08
     5be:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5c0:	10 82       	st	Z, r1
     5c2:	08 95       	ret

000005c4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5c4:	fc 01       	movw	r30, r24
     5c6:	11 86       	std	Z+9, r1	; 0x09
     5c8:	10 86       	std	Z+8, r1	; 0x08
     5ca:	08 95       	ret

000005cc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5cc:	cf 93       	push	r28
     5ce:	df 93       	push	r29
     5d0:	9c 01       	movw	r18, r24
     5d2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     5d4:	dc 01       	movw	r26, r24
     5d6:	11 96       	adiw	r26, 0x01	; 1
     5d8:	cd 91       	ld	r28, X+
     5da:	dc 91       	ld	r29, X
     5dc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5de:	d3 83       	std	Z+3, r29	; 0x03
     5e0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5e2:	8c 81       	ldd	r24, Y+4	; 0x04
     5e4:	9d 81       	ldd	r25, Y+5	; 0x05
     5e6:	95 83       	std	Z+5, r25	; 0x05
     5e8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5ea:	8c 81       	ldd	r24, Y+4	; 0x04
     5ec:	9d 81       	ldd	r25, Y+5	; 0x05
     5ee:	dc 01       	movw	r26, r24
     5f0:	13 96       	adiw	r26, 0x03	; 3
     5f2:	7c 93       	st	X, r23
     5f4:	6e 93       	st	-X, r22
     5f6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     5f8:	7d 83       	std	Y+5, r23	; 0x05
     5fa:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5fc:	31 87       	std	Z+9, r19	; 0x09
     5fe:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     600:	f9 01       	movw	r30, r18
     602:	80 81       	ld	r24, Z
     604:	8f 5f       	subi	r24, 0xFF	; 255
     606:	80 83       	st	Z, r24
}
     608:	df 91       	pop	r29
     60a:	cf 91       	pop	r28
     60c:	08 95       	ret

0000060e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     614:	48 81       	ld	r20, Y
     616:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     618:	4f 3f       	cpi	r20, 0xFF	; 255
     61a:	2f ef       	ldi	r18, 0xFF	; 255
     61c:	52 07       	cpc	r21, r18
     61e:	21 f4       	brne	.+8      	; 0x628 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     620:	fc 01       	movw	r30, r24
     622:	a7 81       	ldd	r26, Z+7	; 0x07
     624:	b0 85       	ldd	r27, Z+8	; 0x08
     626:	0d c0       	rjmp	.+26     	; 0x642 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     628:	dc 01       	movw	r26, r24
     62a:	13 96       	adiw	r26, 0x03	; 3
     62c:	01 c0       	rjmp	.+2      	; 0x630 <vListInsert+0x22>
     62e:	df 01       	movw	r26, r30
     630:	12 96       	adiw	r26, 0x02	; 2
     632:	ed 91       	ld	r30, X+
     634:	fc 91       	ld	r31, X
     636:	13 97       	sbiw	r26, 0x03	; 3
     638:	20 81       	ld	r18, Z
     63a:	31 81       	ldd	r19, Z+1	; 0x01
     63c:	42 17       	cp	r20, r18
     63e:	53 07       	cpc	r21, r19
     640:	b0 f7       	brcc	.-20     	; 0x62e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     642:	12 96       	adiw	r26, 0x02	; 2
     644:	ed 91       	ld	r30, X+
     646:	fc 91       	ld	r31, X
     648:	13 97       	sbiw	r26, 0x03	; 3
     64a:	fb 83       	std	Y+3, r31	; 0x03
     64c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     64e:	d5 83       	std	Z+5, r29	; 0x05
     650:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     652:	bd 83       	std	Y+5, r27	; 0x05
     654:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     656:	13 96       	adiw	r26, 0x03	; 3
     658:	dc 93       	st	X, r29
     65a:	ce 93       	st	-X, r28
     65c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     65e:	99 87       	std	Y+9, r25	; 0x09
     660:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     662:	fc 01       	movw	r30, r24
     664:	20 81       	ld	r18, Z
     666:	2f 5f       	subi	r18, 0xFF	; 255
     668:	20 83       	st	Z, r18
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	08 95       	ret

00000670 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     676:	a0 85       	ldd	r26, Z+8	; 0x08
     678:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     67a:	c2 81       	ldd	r28, Z+2	; 0x02
     67c:	d3 81       	ldd	r29, Z+3	; 0x03
     67e:	84 81       	ldd	r24, Z+4	; 0x04
     680:	95 81       	ldd	r25, Z+5	; 0x05
     682:	9d 83       	std	Y+5, r25	; 0x05
     684:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     686:	c4 81       	ldd	r28, Z+4	; 0x04
     688:	d5 81       	ldd	r29, Z+5	; 0x05
     68a:	82 81       	ldd	r24, Z+2	; 0x02
     68c:	93 81       	ldd	r25, Z+3	; 0x03
     68e:	9b 83       	std	Y+3, r25	; 0x03
     690:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     692:	11 96       	adiw	r26, 0x01	; 1
     694:	8d 91       	ld	r24, X+
     696:	9c 91       	ld	r25, X
     698:	12 97       	sbiw	r26, 0x02	; 2
     69a:	e8 17       	cp	r30, r24
     69c:	f9 07       	cpc	r31, r25
     69e:	31 f4       	brne	.+12     	; 0x6ac <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6a0:	84 81       	ldd	r24, Z+4	; 0x04
     6a2:	95 81       	ldd	r25, Z+5	; 0x05
     6a4:	12 96       	adiw	r26, 0x02	; 2
     6a6:	9c 93       	st	X, r25
     6a8:	8e 93       	st	-X, r24
     6aa:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6ac:	11 86       	std	Z+9, r1	; 0x09
     6ae:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6b0:	8c 91       	ld	r24, X
     6b2:	81 50       	subi	r24, 0x01	; 1
     6b4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6b6:	df 91       	pop	r29
     6b8:	cf 91       	pop	r28
     6ba:	08 95       	ret

000006bc <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     6bc:	31 e1       	ldi	r19, 0x11	; 17
     6be:	fc 01       	movw	r30, r24
     6c0:	30 83       	st	Z, r19
     6c2:	31 97       	sbiw	r30, 0x01	; 1
     6c4:	22 e2       	ldi	r18, 0x22	; 34
     6c6:	20 83       	st	Z, r18
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	a3 e3       	ldi	r26, 0x33	; 51
     6cc:	a0 83       	st	Z, r26
     6ce:	31 97       	sbiw	r30, 0x01	; 1
     6d0:	60 83       	st	Z, r22
     6d2:	31 97       	sbiw	r30, 0x01	; 1
     6d4:	70 83       	st	Z, r23
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	10 82       	st	Z, r1
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	10 82       	st	Z, r1
     6de:	31 97       	sbiw	r30, 0x01	; 1
     6e0:	60 e8       	ldi	r22, 0x80	; 128
     6e2:	60 83       	st	Z, r22
     6e4:	31 97       	sbiw	r30, 0x01	; 1
     6e6:	10 82       	st	Z, r1
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	10 82       	st	Z, r1
     6ec:	31 97       	sbiw	r30, 0x01	; 1
     6ee:	10 82       	st	Z, r1
     6f0:	31 97       	sbiw	r30, 0x01	; 1
     6f2:	62 e0       	ldi	r22, 0x02	; 2
     6f4:	60 83       	st	Z, r22
     6f6:	31 97       	sbiw	r30, 0x01	; 1
     6f8:	63 e0       	ldi	r22, 0x03	; 3
     6fa:	60 83       	st	Z, r22
     6fc:	31 97       	sbiw	r30, 0x01	; 1
     6fe:	64 e0       	ldi	r22, 0x04	; 4
     700:	60 83       	st	Z, r22
     702:	31 97       	sbiw	r30, 0x01	; 1
     704:	65 e0       	ldi	r22, 0x05	; 5
     706:	60 83       	st	Z, r22
     708:	31 97       	sbiw	r30, 0x01	; 1
     70a:	66 e0       	ldi	r22, 0x06	; 6
     70c:	60 83       	st	Z, r22
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	67 e0       	ldi	r22, 0x07	; 7
     712:	60 83       	st	Z, r22
     714:	31 97       	sbiw	r30, 0x01	; 1
     716:	68 e0       	ldi	r22, 0x08	; 8
     718:	60 83       	st	Z, r22
     71a:	31 97       	sbiw	r30, 0x01	; 1
     71c:	69 e0       	ldi	r22, 0x09	; 9
     71e:	60 83       	st	Z, r22
     720:	31 97       	sbiw	r30, 0x01	; 1
     722:	60 e1       	ldi	r22, 0x10	; 16
     724:	60 83       	st	Z, r22
     726:	31 97       	sbiw	r30, 0x01	; 1
     728:	30 83       	st	Z, r19
     72a:	31 97       	sbiw	r30, 0x01	; 1
     72c:	32 e1       	ldi	r19, 0x12	; 18
     72e:	30 83       	st	Z, r19
     730:	31 97       	sbiw	r30, 0x01	; 1
     732:	33 e1       	ldi	r19, 0x13	; 19
     734:	30 83       	st	Z, r19
     736:	31 97       	sbiw	r30, 0x01	; 1
     738:	34 e1       	ldi	r19, 0x14	; 20
     73a:	30 83       	st	Z, r19
     73c:	31 97       	sbiw	r30, 0x01	; 1
     73e:	35 e1       	ldi	r19, 0x15	; 21
     740:	30 83       	st	Z, r19
     742:	31 97       	sbiw	r30, 0x01	; 1
     744:	36 e1       	ldi	r19, 0x16	; 22
     746:	30 83       	st	Z, r19
     748:	31 97       	sbiw	r30, 0x01	; 1
     74a:	37 e1       	ldi	r19, 0x17	; 23
     74c:	30 83       	st	Z, r19
     74e:	31 97       	sbiw	r30, 0x01	; 1
     750:	38 e1       	ldi	r19, 0x18	; 24
     752:	30 83       	st	Z, r19
     754:	31 97       	sbiw	r30, 0x01	; 1
     756:	39 e1       	ldi	r19, 0x19	; 25
     758:	30 83       	st	Z, r19
     75a:	31 97       	sbiw	r30, 0x01	; 1
     75c:	30 e2       	ldi	r19, 0x20	; 32
     75e:	30 83       	st	Z, r19
     760:	31 97       	sbiw	r30, 0x01	; 1
     762:	31 e2       	ldi	r19, 0x21	; 33
     764:	30 83       	st	Z, r19
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	20 83       	st	Z, r18
     76a:	31 97       	sbiw	r30, 0x01	; 1
     76c:	23 e2       	ldi	r18, 0x23	; 35
     76e:	20 83       	st	Z, r18
     770:	31 97       	sbiw	r30, 0x01	; 1
     772:	40 83       	st	Z, r20
     774:	31 97       	sbiw	r30, 0x01	; 1
     776:	50 83       	st	Z, r21
     778:	31 97       	sbiw	r30, 0x01	; 1
     77a:	26 e2       	ldi	r18, 0x26	; 38
     77c:	20 83       	st	Z, r18
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	27 e2       	ldi	r18, 0x27	; 39
     782:	20 83       	st	Z, r18
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	28 e2       	ldi	r18, 0x28	; 40
     788:	20 83       	st	Z, r18
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	29 e2       	ldi	r18, 0x29	; 41
     78e:	20 83       	st	Z, r18
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	20 e3       	ldi	r18, 0x30	; 48
     794:	20 83       	st	Z, r18
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	21 e3       	ldi	r18, 0x31	; 49
     79a:	20 83       	st	Z, r18
     79c:	89 97       	sbiw	r24, 0x29	; 41
     79e:	08 95       	ret

000007a0 <xPortStartScheduler>:
     7a0:	88 ec       	ldi	r24, 0xC8	; 200
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	90 93 e3 02 	sts	0x02E3, r25	; 0x8002e3 <portTickRateHz+0x1>
     7a8:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <portTickRateHz>
     7ac:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <ticksRemainingInSec+0x1>
     7b0:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <ticksRemainingInSec>
     7b4:	8d e4       	ldi	r24, 0x4D	; 77
     7b6:	87 bd       	out	0x27, r24	; 39
     7b8:	82 e0       	ldi	r24, 0x02	; 2
     7ba:	84 bd       	out	0x24, r24	; 36
     7bc:	85 e0       	ldi	r24, 0x05	; 5
     7be:	85 bd       	out	0x25, r24	; 37
     7c0:	ee e6       	ldi	r30, 0x6E	; 110
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	80 81       	ld	r24, Z
     7c6:	82 60       	ori	r24, 0x02	; 2
     7c8:	80 83       	st	Z, r24
     7ca:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
     7ce:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
     7d2:	cd 91       	ld	r28, X+
     7d4:	cd bf       	out	0x3d, r28	; 61
     7d6:	dd 91       	ld	r29, X+
     7d8:	de bf       	out	0x3e, r29	; 62
     7da:	ff 91       	pop	r31
     7dc:	ef 91       	pop	r30
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	bf 91       	pop	r27
     7e4:	af 91       	pop	r26
     7e6:	9f 91       	pop	r25
     7e8:	8f 91       	pop	r24
     7ea:	7f 91       	pop	r23
     7ec:	6f 91       	pop	r22
     7ee:	5f 91       	pop	r21
     7f0:	4f 91       	pop	r20
     7f2:	3f 91       	pop	r19
     7f4:	2f 91       	pop	r18
     7f6:	1f 91       	pop	r17
     7f8:	0f 91       	pop	r16
     7fa:	ff 90       	pop	r15
     7fc:	ef 90       	pop	r14
     7fe:	df 90       	pop	r13
     800:	cf 90       	pop	r12
     802:	bf 90       	pop	r11
     804:	af 90       	pop	r10
     806:	9f 90       	pop	r9
     808:	8f 90       	pop	r8
     80a:	7f 90       	pop	r7
     80c:	6f 90       	pop	r6
     80e:	5f 90       	pop	r5
     810:	4f 90       	pop	r4
     812:	3f 90       	pop	r3
     814:	2f 90       	pop	r2
     816:	1f 90       	pop	r1
     818:	0f 90       	pop	r0
     81a:	0c be       	out	0x3c, r0	; 60
     81c:	0f 90       	pop	r0
     81e:	0b be       	out	0x3b, r0	; 59
     820:	0f 90       	pop	r0
     822:	0f be       	out	0x3f, r0	; 63
     824:	0f 90       	pop	r0
     826:	08 95       	ret
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	08 95       	ret

0000082c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     82c:	0f 92       	push	r0
     82e:	0f b6       	in	r0, 0x3f	; 63
     830:	f8 94       	cli
     832:	0f 92       	push	r0
     834:	0b b6       	in	r0, 0x3b	; 59
     836:	0f 92       	push	r0
     838:	0c b6       	in	r0, 0x3c	; 60
     83a:	0f 92       	push	r0
     83c:	1f 92       	push	r1
     83e:	11 24       	eor	r1, r1
     840:	2f 92       	push	r2
     842:	3f 92       	push	r3
     844:	4f 92       	push	r4
     846:	5f 92       	push	r5
     848:	6f 92       	push	r6
     84a:	7f 92       	push	r7
     84c:	8f 92       	push	r8
     84e:	9f 92       	push	r9
     850:	af 92       	push	r10
     852:	bf 92       	push	r11
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	2f 93       	push	r18
     862:	3f 93       	push	r19
     864:	4f 93       	push	r20
     866:	5f 93       	push	r21
     868:	6f 93       	push	r22
     86a:	7f 93       	push	r23
     86c:	8f 93       	push	r24
     86e:	9f 93       	push	r25
     870:	af 93       	push	r26
     872:	bf 93       	push	r27
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	ef 93       	push	r30
     87a:	ff 93       	push	r31
     87c:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
     880:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
     884:	0d b6       	in	r0, 0x3d	; 61
     886:	0d 92       	st	X+, r0
     888:	0e b6       	in	r0, 0x3e	; 62
     88a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     88c:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     890:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
     894:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
     898:	cd 91       	ld	r28, X+
     89a:	cd bf       	out	0x3d, r28	; 61
     89c:	dd 91       	ld	r29, X+
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	ff 91       	pop	r31
     8a2:	ef 91       	pop	r30
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	bf 91       	pop	r27
     8aa:	af 91       	pop	r26
     8ac:	9f 91       	pop	r25
     8ae:	8f 91       	pop	r24
     8b0:	7f 91       	pop	r23
     8b2:	6f 91       	pop	r22
     8b4:	5f 91       	pop	r21
     8b6:	4f 91       	pop	r20
     8b8:	3f 91       	pop	r19
     8ba:	2f 91       	pop	r18
     8bc:	1f 91       	pop	r17
     8be:	0f 91       	pop	r16
     8c0:	ff 90       	pop	r15
     8c2:	ef 90       	pop	r14
     8c4:	df 90       	pop	r13
     8c6:	cf 90       	pop	r12
     8c8:	bf 90       	pop	r11
     8ca:	af 90       	pop	r10
     8cc:	9f 90       	pop	r9
     8ce:	8f 90       	pop	r8
     8d0:	7f 90       	pop	r7
     8d2:	6f 90       	pop	r6
     8d4:	5f 90       	pop	r5
     8d6:	4f 90       	pop	r4
     8d8:	3f 90       	pop	r3
     8da:	2f 90       	pop	r2
     8dc:	1f 90       	pop	r1
     8de:	0f 90       	pop	r0
     8e0:	0c be       	out	0x3c, r0	; 60
     8e2:	0f 90       	pop	r0
     8e4:	0b be       	out	0x3b, r0	; 59
     8e6:	0f 90       	pop	r0
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     8ec:	08 95       	ret

000008ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     8ee:	0f 92       	push	r0
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	0f 92       	push	r0
     8f6:	0b b6       	in	r0, 0x3b	; 59
     8f8:	0f 92       	push	r0
     8fa:	0c b6       	in	r0, 0x3c	; 60
     8fc:	0f 92       	push	r0
     8fe:	1f 92       	push	r1
     900:	11 24       	eor	r1, r1
     902:	2f 92       	push	r2
     904:	3f 92       	push	r3
     906:	4f 92       	push	r4
     908:	5f 92       	push	r5
     90a:	6f 92       	push	r6
     90c:	7f 92       	push	r7
     90e:	8f 92       	push	r8
     910:	9f 92       	push	r9
     912:	af 92       	push	r10
     914:	bf 92       	push	r11
     916:	cf 92       	push	r12
     918:	df 92       	push	r13
     91a:	ef 92       	push	r14
     91c:	ff 92       	push	r15
     91e:	0f 93       	push	r16
     920:	1f 93       	push	r17
     922:	2f 93       	push	r18
     924:	3f 93       	push	r19
     926:	4f 93       	push	r20
     928:	5f 93       	push	r21
     92a:	6f 93       	push	r22
     92c:	7f 93       	push	r23
     92e:	8f 93       	push	r24
     930:	9f 93       	push	r25
     932:	af 93       	push	r26
     934:	bf 93       	push	r27
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	ef 93       	push	r30
     93c:	ff 93       	push	r31
     93e:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
     942:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
     946:	0d b6       	in	r0, 0x3d	; 61
     948:	0d 92       	st	X+, r0
     94a:	0e b6       	in	r0, 0x3e	; 62
     94c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     94e:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
     950:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <ticksRemainingInSec>
     954:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <ticksRemainingInSec+0x1>
     958:	01 97       	sbiw	r24, 0x01	; 1
     95a:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <ticksRemainingInSec+0x1>
     95e:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <ticksRemainingInSec>
     962:	89 2b       	or	r24, r25
     964:	49 f4       	brne	.+18     	; 0x978 <vPortYieldFromTick+0x8a>
	{
		system_tick();
     966:	dc dc       	rcall	.-1608   	; 0x320 <system_tick>
		ticksRemainingInSec = portTickRateHz;
     968:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <portTickRateHz>
     96c:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <portTickRateHz+0x1>
     970:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <ticksRemainingInSec+0x1>
     974:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
     978:	0b d7       	rcall	.+3606   	; 0x1790 <xTaskIncrementTick>
     97a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     97c:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
     980:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
     984:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
     988:	cd 91       	ld	r28, X+
     98a:	cd bf       	out	0x3d, r28	; 61
     98c:	dd 91       	ld	r29, X+
     98e:	de bf       	out	0x3e, r29	; 62
     990:	ff 91       	pop	r31
     992:	ef 91       	pop	r30
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	bf 91       	pop	r27
     99a:	af 91       	pop	r26
     99c:	9f 91       	pop	r25
     99e:	8f 91       	pop	r24
     9a0:	7f 91       	pop	r23
     9a2:	6f 91       	pop	r22
     9a4:	5f 91       	pop	r21
     9a6:	4f 91       	pop	r20
     9a8:	3f 91       	pop	r19
     9aa:	2f 91       	pop	r18
     9ac:	1f 91       	pop	r17
     9ae:	0f 91       	pop	r16
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	bf 90       	pop	r11
     9ba:	af 90       	pop	r10
     9bc:	9f 90       	pop	r9
     9be:	8f 90       	pop	r8
     9c0:	7f 90       	pop	r7
     9c2:	6f 90       	pop	r6
     9c4:	5f 90       	pop	r5
     9c6:	4f 90       	pop	r4
     9c8:	3f 90       	pop	r3
     9ca:	2f 90       	pop	r2
     9cc:	1f 90       	pop	r1
     9ce:	0f 90       	pop	r0
     9d0:	0c be       	out	0x3c, r0	; 60
     9d2:	0f 90       	pop	r0
     9d4:	0b be       	out	0x3b, r0	; 59
     9d6:	0f 90       	pop	r0
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     9dc:	08 95       	ret

000009de <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     9de:	87 df       	rcall	.-242    	; 0x8ee <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     9e0:	18 95       	reti

000009e2 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	f8 94       	cli
     9e6:	0f 92       	push	r0
     9e8:	fc 01       	movw	r30, r24
     9ea:	92 8d       	ldd	r25, Z+26	; 0x1a
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	91 11       	cpse	r25, r1
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	08 95       	ret

000009f8 <prvCopyDataToQueue>:
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	ec 01       	movw	r28, r24
     a02:	04 2f       	mov	r16, r20
     a04:	1a 8d       	ldd	r17, Y+26	; 0x1a
     a06:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a08:	41 11       	cpse	r20, r1
     a0a:	0c c0       	rjmp	.+24     	; 0xa24 <prvCopyDataToQueue+0x2c>
     a0c:	88 81       	ld	r24, Y
     a0e:	99 81       	ldd	r25, Y+1	; 0x01
     a10:	89 2b       	or	r24, r25
     a12:	09 f0       	breq	.+2      	; 0xa16 <prvCopyDataToQueue+0x1e>
     a14:	42 c0       	rjmp	.+132    	; 0xa9a <prvCopyDataToQueue+0xa2>
     a16:	8a 81       	ldd	r24, Y+2	; 0x02
     a18:	9b 81       	ldd	r25, Y+3	; 0x03
     a1a:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskPriorityDisinherit>
     a1e:	1b 82       	std	Y+3, r1	; 0x03
     a20:	1a 82       	std	Y+2, r1	; 0x02
     a22:	42 c0       	rjmp	.+132    	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a24:	01 11       	cpse	r16, r1
     a26:	17 c0       	rjmp	.+46     	; 0xa56 <prvCopyDataToQueue+0x5e>
     a28:	50 e0       	ldi	r21, 0x00	; 0
     a2a:	8c 81       	ldd	r24, Y+4	; 0x04
     a2c:	9d 81       	ldd	r25, Y+5	; 0x05
     a2e:	0e 94 1e 11 	call	0x223c	; 0x223c <memcpy>
     a32:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a34:	8c 81       	ldd	r24, Y+4	; 0x04
     a36:	9d 81       	ldd	r25, Y+5	; 0x05
     a38:	82 0f       	add	r24, r18
     a3a:	91 1d       	adc	r25, r1
     a3c:	9d 83       	std	Y+5, r25	; 0x05
     a3e:	8c 83       	std	Y+4, r24	; 0x04
     a40:	2a 81       	ldd	r18, Y+2	; 0x02
     a42:	3b 81       	ldd	r19, Y+3	; 0x03
     a44:	82 17       	cp	r24, r18
     a46:	93 07       	cpc	r25, r19
     a48:	50 f1       	brcs	.+84     	; 0xa9e <prvCopyDataToQueue+0xa6>
     a4a:	88 81       	ld	r24, Y
     a4c:	99 81       	ldd	r25, Y+1	; 0x01
     a4e:	9d 83       	std	Y+5, r25	; 0x05
     a50:	8c 83       	std	Y+4, r24	; 0x04
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	29 c0       	rjmp	.+82     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	8e 81       	ldd	r24, Y+6	; 0x06
     a5a:	9f 81       	ldd	r25, Y+7	; 0x07
     a5c:	0e 94 1e 11 	call	0x223c	; 0x223c <memcpy>
     a60:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	91 95       	neg	r25
     a66:	81 95       	neg	r24
     a68:	91 09       	sbc	r25, r1
     a6a:	2e 81       	ldd	r18, Y+6	; 0x06
     a6c:	3f 81       	ldd	r19, Y+7	; 0x07
     a6e:	28 0f       	add	r18, r24
     a70:	39 1f       	adc	r19, r25
     a72:	3f 83       	std	Y+7, r19	; 0x07
     a74:	2e 83       	std	Y+6, r18	; 0x06
     a76:	48 81       	ld	r20, Y
     a78:	59 81       	ldd	r21, Y+1	; 0x01
     a7a:	24 17       	cp	r18, r20
     a7c:	35 07       	cpc	r19, r21
     a7e:	30 f4       	brcc	.+12     	; 0xa8c <prvCopyDataToQueue+0x94>
     a80:	2a 81       	ldd	r18, Y+2	; 0x02
     a82:	3b 81       	ldd	r19, Y+3	; 0x03
     a84:	82 0f       	add	r24, r18
     a86:	93 1f       	adc	r25, r19
     a88:	9f 83       	std	Y+7, r25	; 0x07
     a8a:	8e 83       	std	Y+6, r24	; 0x06
     a8c:	02 30       	cpi	r16, 0x02	; 2
     a8e:	49 f4       	brne	.+18     	; 0xaa2 <prvCopyDataToQueue+0xaa>
     a90:	11 23       	and	r17, r17
     a92:	49 f0       	breq	.+18     	; 0xaa6 <prvCopyDataToQueue+0xae>
     a94:	11 50       	subi	r17, 0x01	; 1
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	07 c0       	rjmp	.+14     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	05 c0       	rjmp	.+10     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	03 c0       	rjmp	.+6      	; 0xaa8 <prvCopyDataToQueue+0xb0>
     aa2:	80 e0       	ldi	r24, 0x00	; 0
     aa4:	01 c0       	rjmp	.+2      	; 0xaa8 <prvCopyDataToQueue+0xb0>
     aa6:	80 e0       	ldi	r24, 0x00	; 0
     aa8:	1f 5f       	subi	r17, 0xFF	; 255
     aaa:	1a 8f       	std	Y+26, r17	; 0x1a
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	1f 91       	pop	r17
     ab2:	0f 91       	pop	r16
     ab4:	08 95       	ret

00000ab6 <prvCopyDataFromQueue>:
     ab6:	fc 01       	movw	r30, r24
     ab8:	44 8d       	ldd	r20, Z+28	; 0x1c
     aba:	44 23       	and	r20, r20
     abc:	a9 f0       	breq	.+42     	; 0xae8 <prvCopyDataFromQueue+0x32>
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	26 81       	ldd	r18, Z+6	; 0x06
     ac2:	37 81       	ldd	r19, Z+7	; 0x07
     ac4:	24 0f       	add	r18, r20
     ac6:	35 1f       	adc	r19, r21
     ac8:	37 83       	std	Z+7, r19	; 0x07
     aca:	26 83       	std	Z+6, r18	; 0x06
     acc:	82 81       	ldd	r24, Z+2	; 0x02
     ace:	93 81       	ldd	r25, Z+3	; 0x03
     ad0:	28 17       	cp	r18, r24
     ad2:	39 07       	cpc	r19, r25
     ad4:	20 f0       	brcs	.+8      	; 0xade <prvCopyDataFromQueue+0x28>
     ad6:	80 81       	ld	r24, Z
     ad8:	91 81       	ldd	r25, Z+1	; 0x01
     ada:	97 83       	std	Z+7, r25	; 0x07
     adc:	86 83       	std	Z+6, r24	; 0x06
     ade:	cb 01       	movw	r24, r22
     ae0:	66 81       	ldd	r22, Z+6	; 0x06
     ae2:	77 81       	ldd	r23, Z+7	; 0x07
     ae4:	0c 94 1e 11 	jmp	0x223c	; 0x223c <memcpy>
     ae8:	08 95       	ret

00000aea <prvUnlockQueue>:
     aea:	ef 92       	push	r14
     aec:	ff 92       	push	r15
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	8c 01       	movw	r16, r24
     af6:	0f b6       	in	r0, 0x3f	; 63
     af8:	f8 94       	cli
     afa:	0f 92       	push	r0
     afc:	fc 01       	movw	r30, r24
     afe:	c6 8d       	ldd	r28, Z+30	; 0x1e
     b00:	1c 16       	cp	r1, r28
     b02:	ac f4       	brge	.+42     	; 0xb2e <prvUnlockQueue+0x44>
     b04:	81 89       	ldd	r24, Z+17	; 0x11
     b06:	81 11       	cpse	r24, r1
     b08:	06 c0       	rjmp	.+12     	; 0xb16 <prvUnlockQueue+0x2c>
     b0a:	11 c0       	rjmp	.+34     	; 0xb2e <prvUnlockQueue+0x44>
     b0c:	f8 01       	movw	r30, r16
     b0e:	81 89       	ldd	r24, Z+17	; 0x11
     b10:	81 11       	cpse	r24, r1
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <prvUnlockQueue+0x34>
     b14:	0c c0       	rjmp	.+24     	; 0xb2e <prvUnlockQueue+0x44>
     b16:	78 01       	movw	r14, r16
     b18:	f1 e1       	ldi	r31, 0x11	; 17
     b1a:	ef 0e       	add	r14, r31
     b1c:	f1 1c       	adc	r15, r1
     b1e:	c7 01       	movw	r24, r14
     b20:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <xTaskRemoveFromEventList>
     b24:	81 11       	cpse	r24, r1
     b26:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskMissedYield>
     b2a:	c1 50       	subi	r28, 0x01	; 1
     b2c:	79 f7       	brne	.-34     	; 0xb0c <prvUnlockQueue+0x22>
     b2e:	8f ef       	ldi	r24, 0xFF	; 255
     b30:	f8 01       	movw	r30, r16
     b32:	86 8f       	std	Z+30, r24	; 0x1e
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
     b3e:	c5 8d       	ldd	r28, Z+29	; 0x1d
     b40:	1c 16       	cp	r1, r28
     b42:	ac f4       	brge	.+42     	; 0xb6e <prvUnlockQueue+0x84>
     b44:	80 85       	ldd	r24, Z+8	; 0x08
     b46:	81 11       	cpse	r24, r1
     b48:	06 c0       	rjmp	.+12     	; 0xb56 <prvUnlockQueue+0x6c>
     b4a:	11 c0       	rjmp	.+34     	; 0xb6e <prvUnlockQueue+0x84>
     b4c:	f8 01       	movw	r30, r16
     b4e:	80 85       	ldd	r24, Z+8	; 0x08
     b50:	81 11       	cpse	r24, r1
     b52:	05 c0       	rjmp	.+10     	; 0xb5e <prvUnlockQueue+0x74>
     b54:	0c c0       	rjmp	.+24     	; 0xb6e <prvUnlockQueue+0x84>
     b56:	78 01       	movw	r14, r16
     b58:	f8 e0       	ldi	r31, 0x08	; 8
     b5a:	ef 0e       	add	r14, r31
     b5c:	f1 1c       	adc	r15, r1
     b5e:	c7 01       	movw	r24, r14
     b60:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <xTaskRemoveFromEventList>
     b64:	81 11       	cpse	r24, r1
     b66:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vTaskMissedYield>
     b6a:	c1 50       	subi	r28, 0x01	; 1
     b6c:	79 f7       	brne	.-34     	; 0xb4c <prvUnlockQueue+0x62>
     b6e:	8f ef       	ldi	r24, 0xFF	; 255
     b70:	f8 01       	movw	r30, r16
     b72:	85 8f       	std	Z+29, r24	; 0x1d
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
     b78:	cf 91       	pop	r28
     b7a:	1f 91       	pop	r17
     b7c:	0f 91       	pop	r16
     b7e:	ff 90       	pop	r15
     b80:	ef 90       	pop	r14
     b82:	08 95       	ret

00000b84 <xQueueGenericReset>:
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	ec 01       	movw	r28, r24
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
     b90:	48 81       	ld	r20, Y
     b92:	59 81       	ldd	r21, Y+1	; 0x01
     b94:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b96:	30 e0       	ldi	r19, 0x00	; 0
     b98:	7b 8d       	ldd	r23, Y+27	; 0x1b
     b9a:	72 9f       	mul	r23, r18
     b9c:	c0 01       	movw	r24, r0
     b9e:	73 9f       	mul	r23, r19
     ba0:	90 0d       	add	r25, r0
     ba2:	11 24       	eor	r1, r1
     ba4:	fa 01       	movw	r30, r20
     ba6:	e8 0f       	add	r30, r24
     ba8:	f9 1f       	adc	r31, r25
     baa:	fb 83       	std	Y+3, r31	; 0x03
     bac:	ea 83       	std	Y+2, r30	; 0x02
     bae:	1a 8e       	std	Y+26, r1	; 0x1a
     bb0:	5d 83       	std	Y+5, r21	; 0x05
     bb2:	4c 83       	std	Y+4, r20	; 0x04
     bb4:	82 1b       	sub	r24, r18
     bb6:	93 0b       	sbc	r25, r19
     bb8:	84 0f       	add	r24, r20
     bba:	95 1f       	adc	r25, r21
     bbc:	9f 83       	std	Y+7, r25	; 0x07
     bbe:	8e 83       	std	Y+6, r24	; 0x06
     bc0:	8f ef       	ldi	r24, 0xFF	; 255
     bc2:	8d 8f       	std	Y+29, r24	; 0x1d
     bc4:	8e 8f       	std	Y+30, r24	; 0x1e
     bc6:	61 11       	cpse	r22, r1
     bc8:	0a c0       	rjmp	.+20     	; 0xbde <xQueueGenericReset+0x5a>
     bca:	88 85       	ldd	r24, Y+8	; 0x08
     bcc:	88 23       	and	r24, r24
     bce:	69 f0       	breq	.+26     	; 0xbea <xQueueGenericReset+0x66>
     bd0:	ce 01       	movw	r24, r28
     bd2:	08 96       	adiw	r24, 0x08	; 8
     bd4:	e1 d7       	rcall	.+4034   	; 0x1b98 <xTaskRemoveFromEventList>
     bd6:	88 23       	and	r24, r24
     bd8:	41 f0       	breq	.+16     	; 0xbea <xQueueGenericReset+0x66>
     bda:	28 de       	rcall	.-944    	; 0x82c <vPortYield>
     bdc:	06 c0       	rjmp	.+12     	; 0xbea <xQueueGenericReset+0x66>
     bde:	ce 01       	movw	r24, r28
     be0:	08 96       	adiw	r24, 0x08	; 8
     be2:	e2 dc       	rcall	.-1596   	; 0x5a8 <vListInitialise>
     be4:	ce 01       	movw	r24, r28
     be6:	41 96       	adiw	r24, 0x11	; 17
     be8:	df dc       	rcall	.-1602   	; 0x5a8 <vListInitialise>
     bea:	0f 90       	pop	r0
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	81 e0       	ldi	r24, 0x01	; 1
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	08 95       	ret

00000bf6 <xQueueGenericCreate>:
     bf6:	0f 93       	push	r16
     bf8:	1f 93       	push	r17
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	08 2f       	mov	r16, r24
     c00:	16 2f       	mov	r17, r22
     c02:	66 23       	and	r22, r22
     c04:	b1 f0       	breq	.+44     	; 0xc32 <xQueueGenericCreate+0x3c>
     c06:	86 9f       	mul	r24, r22
     c08:	c0 01       	movw	r24, r0
     c0a:	11 24       	eor	r1, r1
     c0c:	4f 96       	adiw	r24, 0x1f	; 31
     c0e:	a4 db       	rcall	.-2232   	; 0x358 <pvPortMalloc>
     c10:	ec 01       	movw	r28, r24
     c12:	00 97       	sbiw	r24, 0x00	; 0
     c14:	39 f4       	brne	.+14     	; 0xc24 <xQueueGenericCreate+0x2e>
     c16:	13 c0       	rjmp	.+38     	; 0xc3e <xQueueGenericCreate+0x48>
     c18:	0b 8f       	std	Y+27, r16	; 0x1b
     c1a:	1c 8f       	std	Y+28, r17	; 0x1c
     c1c:	61 e0       	ldi	r22, 0x01	; 1
     c1e:	ce 01       	movw	r24, r28
     c20:	b1 df       	rcall	.-158    	; 0xb84 <xQueueGenericReset>
     c22:	0d c0       	rjmp	.+26     	; 0xc3e <xQueueGenericCreate+0x48>
     c24:	4f 96       	adiw	r24, 0x1f	; 31
     c26:	99 83       	std	Y+1, r25	; 0x01
     c28:	88 83       	st	Y, r24
     c2a:	f6 cf       	rjmp	.-20     	; 0xc18 <xQueueGenericCreate+0x22>
     c2c:	d9 83       	std	Y+1, r29	; 0x01
     c2e:	c8 83       	st	Y, r28
     c30:	f3 cf       	rjmp	.-26     	; 0xc18 <xQueueGenericCreate+0x22>
     c32:	8f e1       	ldi	r24, 0x1F	; 31
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	90 db       	rcall	.-2272   	; 0x358 <pvPortMalloc>
     c38:	ec 01       	movw	r28, r24
     c3a:	89 2b       	or	r24, r25
     c3c:	b9 f7       	brne	.-18     	; 0xc2c <xQueueGenericCreate+0x36>
     c3e:	ce 01       	movw	r24, r28
     c40:	df 91       	pop	r29
     c42:	cf 91       	pop	r28
     c44:	1f 91       	pop	r17
     c46:	0f 91       	pop	r16
     c48:	08 95       	ret

00000c4a <xQueueGenericSend>:
     c4a:	9f 92       	push	r9
     c4c:	af 92       	push	r10
     c4e:	bf 92       	push	r11
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	0f 93       	push	r16
     c5a:	1f 93       	push	r17
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	00 d0       	rcall	.+0      	; 0xc62 <xQueueGenericSend+0x18>
     c62:	1f 92       	push	r1
     c64:	1f 92       	push	r1
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
     c6a:	8c 01       	movw	r16, r24
     c6c:	6b 01       	movw	r12, r22
     c6e:	5d 83       	std	Y+5, r21	; 0x05
     c70:	4c 83       	std	Y+4, r20	; 0x04
     c72:	a2 2e       	mov	r10, r18
     c74:	b1 2c       	mov	r11, r1
     c76:	99 24       	eor	r9, r9
     c78:	93 94       	inc	r9
     c7a:	7c 01       	movw	r14, r24
     c7c:	88 e0       	ldi	r24, 0x08	; 8
     c7e:	e8 0e       	add	r14, r24
     c80:	f1 1c       	adc	r15, r1
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	0f 92       	push	r0
     c88:	f8 01       	movw	r30, r16
     c8a:	92 8d       	ldd	r25, Z+26	; 0x1a
     c8c:	83 8d       	ldd	r24, Z+27	; 0x1b
     c8e:	98 17       	cp	r25, r24
     c90:	18 f0       	brcs	.+6      	; 0xc98 <xQueueGenericSend+0x4e>
     c92:	f2 e0       	ldi	r31, 0x02	; 2
     c94:	af 12       	cpse	r10, r31
     c96:	15 c0       	rjmp	.+42     	; 0xcc2 <xQueueGenericSend+0x78>
     c98:	4a 2d       	mov	r20, r10
     c9a:	b6 01       	movw	r22, r12
     c9c:	c8 01       	movw	r24, r16
     c9e:	ac de       	rcall	.-680    	; 0x9f8 <prvCopyDataToQueue>
     ca0:	f8 01       	movw	r30, r16
     ca2:	91 89       	ldd	r25, Z+17	; 0x11
     ca4:	99 23       	and	r25, r25
     ca6:	39 f0       	breq	.+14     	; 0xcb6 <xQueueGenericSend+0x6c>
     ca8:	c8 01       	movw	r24, r16
     caa:	41 96       	adiw	r24, 0x11	; 17
     cac:	75 d7       	rcall	.+3818   	; 0x1b98 <xTaskRemoveFromEventList>
     cae:	88 23       	and	r24, r24
     cb0:	21 f0       	breq	.+8      	; 0xcba <xQueueGenericSend+0x70>
     cb2:	bc dd       	rcall	.-1160   	; 0x82c <vPortYield>
     cb4:	02 c0       	rjmp	.+4      	; 0xcba <xQueueGenericSend+0x70>
     cb6:	81 11       	cpse	r24, r1
     cb8:	b9 dd       	rcall	.-1166   	; 0x82c <vPortYield>
     cba:	0f 90       	pop	r0
     cbc:	0f be       	out	0x3f, r0	; 63
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	45 c0       	rjmp	.+138    	; 0xd4c <xQueueGenericSend+0x102>
     cc2:	8c 81       	ldd	r24, Y+4	; 0x04
     cc4:	9d 81       	ldd	r25, Y+5	; 0x05
     cc6:	89 2b       	or	r24, r25
     cc8:	21 f4       	brne	.+8      	; 0xcd2 <xQueueGenericSend+0x88>
     cca:	0f 90       	pop	r0
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	3d c0       	rjmp	.+122    	; 0xd4c <xQueueGenericSend+0x102>
     cd2:	b1 10       	cpse	r11, r1
     cd4:	04 c0       	rjmp	.+8      	; 0xcde <xQueueGenericSend+0x94>
     cd6:	ce 01       	movw	r24, r28
     cd8:	01 96       	adiw	r24, 0x01	; 1
     cda:	a6 d7       	rcall	.+3916   	; 0x1c28 <vTaskSetTimeOutState>
     cdc:	b9 2c       	mov	r11, r9
     cde:	0f 90       	pop	r0
     ce0:	0f be       	out	0x3f, r0	; 63
     ce2:	46 d5       	rcall	.+2700   	; 0x1770 <vTaskSuspendAll>
     ce4:	0f b6       	in	r0, 0x3f	; 63
     ce6:	f8 94       	cli
     ce8:	0f 92       	push	r0
     cea:	f8 01       	movw	r30, r16
     cec:	85 8d       	ldd	r24, Z+29	; 0x1d
     cee:	8f 3f       	cpi	r24, 0xFF	; 255
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <xQueueGenericSend+0xaa>
     cf2:	15 8e       	std	Z+29, r1	; 0x1d
     cf4:	f8 01       	movw	r30, r16
     cf6:	86 8d       	ldd	r24, Z+30	; 0x1e
     cf8:	8f 3f       	cpi	r24, 0xFF	; 255
     cfa:	09 f4       	brne	.+2      	; 0xcfe <xQueueGenericSend+0xb4>
     cfc:	16 8e       	std	Z+30, r1	; 0x1e
     cfe:	0f 90       	pop	r0
     d00:	0f be       	out	0x3f, r0	; 63
     d02:	be 01       	movw	r22, r28
     d04:	6c 5f       	subi	r22, 0xFC	; 252
     d06:	7f 4f       	sbci	r23, 0xFF	; 255
     d08:	ce 01       	movw	r24, r28
     d0a:	01 96       	adiw	r24, 0x01	; 1
     d0c:	98 d7       	rcall	.+3888   	; 0x1c3e <xTaskCheckForTimeOut>
     d0e:	81 11       	cpse	r24, r1
     d10:	19 c0       	rjmp	.+50     	; 0xd44 <xQueueGenericSend+0xfa>
     d12:	0f b6       	in	r0, 0x3f	; 63
     d14:	f8 94       	cli
     d16:	0f 92       	push	r0
     d18:	f8 01       	movw	r30, r16
     d1a:	92 8d       	ldd	r25, Z+26	; 0x1a
     d1c:	83 8d       	ldd	r24, Z+27	; 0x1b
     d1e:	0f 90       	pop	r0
     d20:	0f be       	out	0x3f, r0	; 63
     d22:	98 13       	cpse	r25, r24
     d24:	0b c0       	rjmp	.+22     	; 0xd3c <xQueueGenericSend+0xf2>
     d26:	6c 81       	ldd	r22, Y+4	; 0x04
     d28:	7d 81       	ldd	r23, Y+5	; 0x05
     d2a:	c7 01       	movw	r24, r14
     d2c:	24 d7       	rcall	.+3656   	; 0x1b76 <vTaskPlaceOnEventList>
     d2e:	c8 01       	movw	r24, r16
     d30:	dc de       	rcall	.-584    	; 0xaea <prvUnlockQueue>
     d32:	e8 d5       	rcall	.+3024   	; 0x1904 <xTaskResumeAll>
     d34:	81 11       	cpse	r24, r1
     d36:	a5 cf       	rjmp	.-182    	; 0xc82 <xQueueGenericSend+0x38>
     d38:	79 dd       	rcall	.-1294   	; 0x82c <vPortYield>
     d3a:	a3 cf       	rjmp	.-186    	; 0xc82 <xQueueGenericSend+0x38>
     d3c:	c8 01       	movw	r24, r16
     d3e:	d5 de       	rcall	.-598    	; 0xaea <prvUnlockQueue>
     d40:	e1 d5       	rcall	.+3010   	; 0x1904 <xTaskResumeAll>
     d42:	9f cf       	rjmp	.-194    	; 0xc82 <xQueueGenericSend+0x38>
     d44:	c8 01       	movw	r24, r16
     d46:	d1 de       	rcall	.-606    	; 0xaea <prvUnlockQueue>
     d48:	dd d5       	rcall	.+3002   	; 0x1904 <xTaskResumeAll>
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	0f 90       	pop	r0
     d4e:	0f 90       	pop	r0
     d50:	0f 90       	pop	r0
     d52:	0f 90       	pop	r0
     d54:	0f 90       	pop	r0
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	1f 91       	pop	r17
     d5c:	0f 91       	pop	r16
     d5e:	ff 90       	pop	r15
     d60:	ef 90       	pop	r14
     d62:	df 90       	pop	r13
     d64:	cf 90       	pop	r12
     d66:	bf 90       	pop	r11
     d68:	af 90       	pop	r10
     d6a:	9f 90       	pop	r9
     d6c:	08 95       	ret

00000d6e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     d6e:	8f 92       	push	r8
     d70:	9f 92       	push	r9
     d72:	af 92       	push	r10
     d74:	bf 92       	push	r11
     d76:	cf 92       	push	r12
     d78:	df 92       	push	r13
     d7a:	ef 92       	push	r14
     d7c:	ff 92       	push	r15
     d7e:	0f 93       	push	r16
     d80:	1f 93       	push	r17
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	00 d0       	rcall	.+0      	; 0xd88 <xQueueGenericReceive+0x1a>
     d88:	1f 92       	push	r1
     d8a:	1f 92       	push	r1
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
     d90:	8c 01       	movw	r16, r24
     d92:	5b 01       	movw	r10, r22
     d94:	5d 83       	std	Y+5, r21	; 0x05
     d96:	4c 83       	std	Y+4, r20	; 0x04
     d98:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     d9a:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d9c:	99 24       	eor	r9, r9
     d9e:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     da0:	6c 01       	movw	r12, r24
     da2:	81 e1       	ldi	r24, 0x11	; 17
     da4:	c8 0e       	add	r12, r24
     da6:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     da8:	0f b6       	in	r0, 0x3f	; 63
     daa:	f8 94       	cli
     dac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dae:	f8 01       	movw	r30, r16
     db0:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     db2:	ff 20       	and	r15, r15
     db4:	69 f1       	breq	.+90     	; 0xe10 <xQueueGenericReceive+0xa2>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     db6:	c6 80       	ldd	r12, Z+6	; 0x06
     db8:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dba:	b5 01       	movw	r22, r10
     dbc:	c8 01       	movw	r24, r16
     dbe:	7b de       	rcall	.-778    	; 0xab6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     dc0:	81 10       	cpse	r8, r1
     dc2:	17 c0       	rjmp	.+46     	; 0xdf2 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     dc4:	fa 94       	dec	r15
     dc6:	f8 01       	movw	r30, r16
     dc8:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     dca:	80 81       	ld	r24, Z
     dcc:	91 81       	ldd	r25, Z+1	; 0x01
     dce:	89 2b       	or	r24, r25
     dd0:	29 f4       	brne	.+10     	; 0xddc <xQueueGenericReceive+0x6e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     dd2:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <pvTaskIncrementMutexHeldCount>
     dd6:	f8 01       	movw	r30, r16
     dd8:	93 83       	std	Z+3, r25	; 0x03
     dda:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ddc:	f8 01       	movw	r30, r16
     dde:	80 85       	ldd	r24, Z+8	; 0x08
     de0:	88 23       	and	r24, r24
     de2:	91 f0       	breq	.+36     	; 0xe08 <xQueueGenericReceive+0x9a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     de4:	c8 01       	movw	r24, r16
     de6:	08 96       	adiw	r24, 0x08	; 8
     de8:	d7 d6       	rcall	.+3502   	; 0x1b98 <xTaskRemoveFromEventList>
     dea:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     dec:	69 f0       	breq	.+26     	; 0xe08 <xQueueGenericReceive+0x9a>
     dee:	1e dd       	rcall	.-1476   	; 0x82c <vPortYield>
     df0:	0b c0       	rjmp	.+22     	; 0xe08 <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     df2:	f8 01       	movw	r30, r16
     df4:	d7 82       	std	Z+7, r13	; 0x07
     df6:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     df8:	81 89       	ldd	r24, Z+17	; 0x11
     dfa:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dfc:	29 f0       	breq	.+10     	; 0xe08 <xQueueGenericReceive+0x9a>
     dfe:	c8 01       	movw	r24, r16
     e00:	41 96       	adiw	r24, 0x11	; 17
     e02:	ca d6       	rcall	.+3476   	; 0x1b98 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e04:	81 11       	cpse	r24, r1
     e06:	12 dd       	rcall	.-1500   	; 0x82c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e08:	0f 90       	pop	r0
     e0a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	51 c0       	rjmp	.+162    	; 0xeb2 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e10:	8c 81       	ldd	r24, Y+4	; 0x04
     e12:	9d 81       	ldd	r25, Y+5	; 0x05
     e14:	89 2b       	or	r24, r25
     e16:	21 f4       	brne	.+8      	; 0xe20 <xQueueGenericReceive+0xb2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e18:	0f 90       	pop	r0
     e1a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e1c:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     e1e:	49 c0       	rjmp	.+146    	; 0xeb2 <xQueueGenericReceive+0x144>
     e20:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e22:	04 c0       	rjmp	.+8      	; 0xe2c <xQueueGenericReceive+0xbe>
     e24:	ce 01       	movw	r24, r28
     e26:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     e28:	ff d6       	rcall	.+3582   	; 0x1c28 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e2a:	e9 2c       	mov	r14, r9
     e2c:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e2e:	0f be       	out	0x3f, r0	; 63
     e30:	9f d4       	rcall	.+2366   	; 0x1770 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	0f 92       	push	r0
     e38:	f8 01       	movw	r30, r16
     e3a:	85 8d       	ldd	r24, Z+29	; 0x1d
     e3c:	8f 3f       	cpi	r24, 0xFF	; 255
     e3e:	09 f4       	brne	.+2      	; 0xe42 <xQueueGenericReceive+0xd4>
     e40:	15 8e       	std	Z+29, r1	; 0x1d
     e42:	f8 01       	movw	r30, r16
     e44:	86 8d       	ldd	r24, Z+30	; 0x1e
     e46:	8f 3f       	cpi	r24, 0xFF	; 255
     e48:	09 f4       	brne	.+2      	; 0xe4c <xQueueGenericReceive+0xde>
     e4a:	16 8e       	std	Z+30, r1	; 0x1e
     e4c:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	be 01       	movw	r22, r28
     e52:	6c 5f       	subi	r22, 0xFC	; 252
     e54:	7f 4f       	sbci	r23, 0xFF	; 255
     e56:	ce 01       	movw	r24, r28
     e58:	01 96       	adiw	r24, 0x01	; 1
     e5a:	f1 d6       	rcall	.+3554   	; 0x1c3e <xTaskCheckForTimeOut>
     e5c:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e5e:	20 c0       	rjmp	.+64     	; 0xea0 <xQueueGenericReceive+0x132>
     e60:	c8 01       	movw	r24, r16
     e62:	bf dd       	rcall	.-1154   	; 0x9e2 <prvIsQueueEmpty>
     e64:	88 23       	and	r24, r24
     e66:	c1 f0       	breq	.+48     	; 0xe98 <xQueueGenericReceive+0x12a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e68:	f8 01       	movw	r30, r16
     e6a:	80 81       	ld	r24, Z
     e6c:	91 81       	ldd	r25, Z+1	; 0x01
     e6e:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
     e70:	41 f4       	brne	.+16     	; 0xe82 <xQueueGenericReceive+0x114>
     e72:	0f b6       	in	r0, 0x3f	; 63
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     e74:	f8 94       	cli
     e76:	0f 92       	push	r0
						}
						taskEXIT_CRITICAL();
     e78:	82 81       	ldd	r24, Z+2	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e7a:	93 81       	ldd	r25, Z+3	; 0x03
     e7c:	1c d7       	rcall	.+3640   	; 0x1cb6 <vTaskPriorityInherit>
     e7e:	0f 90       	pop	r0
				prvUnlockQueue( pxQueue );
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	6c 81       	ldd	r22, Y+4	; 0x04
				if( xTaskResumeAll() == pdFALSE )
     e84:	7d 81       	ldd	r23, Y+5	; 0x05
     e86:	c6 01       	movw	r24, r12
     e88:	76 d6       	rcall	.+3308   	; 0x1b76 <vTaskPlaceOnEventList>
				{
					portYIELD_WITHIN_API();
     e8a:	c8 01       	movw	r24, r16
     e8c:	2e de       	rcall	.-932    	; 0xaea <prvUnlockQueue>
     e8e:	3a d5       	rcall	.+2676   	; 0x1904 <xTaskResumeAll>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e90:	81 11       	cpse	r24, r1
     e92:	8a cf       	rjmp	.-236    	; 0xda8 <xQueueGenericReceive+0x3a>
     e94:	cb dc       	rcall	.-1642   	; 0x82c <vPortYield>
				( void ) xTaskResumeAll();
     e96:	88 cf       	rjmp	.-240    	; 0xda8 <xQueueGenericReceive+0x3a>
     e98:	c8 01       	movw	r24, r16
     e9a:	27 de       	rcall	.-946    	; 0xaea <prvUnlockQueue>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e9c:	33 d5       	rcall	.+2662   	; 0x1904 <xTaskResumeAll>
     e9e:	84 cf       	rjmp	.-248    	; 0xda8 <xQueueGenericReceive+0x3a>
     ea0:	c8 01       	movw	r24, r16
			( void ) xTaskResumeAll();
     ea2:	23 de       	rcall	.-954    	; 0xaea <prvUnlockQueue>
     ea4:	2f d5       	rcall	.+2654   	; 0x1904 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ea6:	c8 01       	movw	r24, r16
     ea8:	9c dd       	rcall	.-1224   	; 0x9e2 <prvIsQueueEmpty>
     eaa:	88 23       	and	r24, r24
     eac:	09 f4       	brne	.+2      	; 0xeb0 <xQueueGenericReceive+0x142>
     eae:	7c cf       	rjmp	.-264    	; 0xda8 <xQueueGenericReceive+0x3a>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     eb2:	0f 90       	pop	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     eb4:	0f 90       	pop	r0
     eb6:	0f 90       	pop	r0
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	df 91       	pop	r29
     ebe:	cf 91       	pop	r28
     ec0:	1f 91       	pop	r17
     ec2:	0f 91       	pop	r16
     ec4:	ff 90       	pop	r15
     ec6:	ef 90       	pop	r14
     ec8:	df 90       	pop	r13
     eca:	cf 90       	pop	r12
     ecc:	bf 90       	pop	r11
     ece:	af 90       	pop	r10
     ed0:	9f 90       	pop	r9
     ed2:	8f 90       	pop	r8
     ed4:	08 95       	ret

00000ed6 <__vector_25>:
     ed6:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
     ed8:	0f 92       	push	r0
     eda:	0f b6       	in	r0, 0x3f	; 63
     edc:	0f 92       	push	r0
     ede:	11 24       	eor	r1, r1
     ee0:	0b b6       	in	r0, 0x3b	; 59
     ee2:	0f 92       	push	r0
     ee4:	2f 93       	push	r18
     ee6:	3f 93       	push	r19
     ee8:	4f 93       	push	r20
     eea:	8f 93       	push	r24
     eec:	9f 93       	push	r25
     eee:	af 93       	push	r26
     ef0:	bf 93       	push	r27
     ef2:	ef 93       	push	r30
     ef4:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
     ef6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     efa:	8c 71       	andi	r24, 0x1C	; 28
     efc:	71 f0       	breq	.+28     	; 0xf1a <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
     efe:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     f02:	88 23       	and	r24, r24
     f04:	0c f0       	brlt	.+2      	; 0xf08 <__vector_25+0x32>
     f06:	36 c0       	rjmp	.+108    	; 0xf74 <__vector_25+0x9e>
     f08:	a6 ec       	ldi	r26, 0xC6	; 198
     f0a:	b0 e0       	ldi	r27, 0x00	; 0
     f0c:	e0 ec       	ldi	r30, 0xC0	; 192
     f0e:	f0 e0       	ldi	r31, 0x00	; 0
     f10:	8c 91       	ld	r24, X
     f12:	80 81       	ld	r24, Z
     f14:	88 23       	and	r24, r24
     f16:	e4 f3       	brlt	.-8      	; 0xf10 <__vector_25+0x3a>
     f18:	2d c0       	rjmp	.+90     	; 0xf74 <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
     f1a:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     f1e:	0f b6       	in	r0, 0x3f	; 63
     f20:	f8 94       	cli
     f22:	0f 92       	push	r0
	{
	    count = buffer->count;
     f24:	e6 ee       	ldi	r30, 0xE6	; 230
     f26:	f2 e0       	ldi	r31, 0x02	; 2
     f28:	21 81       	ldd	r18, Z+1	; 0x01
     f2a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
     f2c:	0f 90       	pop	r0
     f2e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
     f30:	83 85       	ldd	r24, Z+11	; 0x0b
     f32:	94 85       	ldd	r25, Z+12	; 0x0c
     f34:	28 17       	cp	r18, r24
     f36:	39 07       	cpc	r19, r25
     f38:	e9 f0       	breq	.+58     	; 0xf74 <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     f3a:	e7 ee       	ldi	r30, 0xE7	; 231
     f3c:	f2 e0       	ldi	r31, 0x02	; 2

	*buffer->in = data;
     f3e:	a2 81       	ldd	r26, Z+2	; 0x02
     f40:	b3 81       	ldd	r27, Z+3	; 0x03
     f42:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
     f44:	82 81       	ldd	r24, Z+2	; 0x02
     f46:	93 81       	ldd	r25, Z+3	; 0x03
     f48:	01 96       	adiw	r24, 0x01	; 1
     f4a:	93 83       	std	Z+3, r25	; 0x03
     f4c:	82 83       	std	Z+2, r24	; 0x02
     f4e:	20 85       	ldd	r18, Z+8	; 0x08
     f50:	31 85       	ldd	r19, Z+9	; 0x09
     f52:	82 17       	cp	r24, r18
     f54:	93 07       	cpc	r25, r19
     f56:	21 f4       	brne	.+8      	; 0xf60 <__vector_25+0x8a>
	  buffer->in = buffer->start;
     f58:	86 81       	ldd	r24, Z+6	; 0x06
     f5a:	97 81       	ldd	r25, Z+7	; 0x07
     f5c:	93 83       	std	Z+3, r25	; 0x03
     f5e:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
     f60:	0f b6       	in	r0, 0x3f	; 63
     f62:	f8 94       	cli
     f64:	0f 92       	push	r0
	{
	    buffer->count++;
     f66:	80 81       	ld	r24, Z
     f68:	91 81       	ldd	r25, Z+1	; 0x01
     f6a:	01 96       	adiw	r24, 0x01	; 1
     f6c:	91 83       	std	Z+1, r25	; 0x01
     f6e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     f70:	0f 90       	pop	r0
     f72:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
     f74:	ff 91       	pop	r31
     f76:	ef 91       	pop	r30
     f78:	bf 91       	pop	r27
     f7a:	af 91       	pop	r26
     f7c:	9f 91       	pop	r25
     f7e:	8f 91       	pop	r24
     f80:	4f 91       	pop	r20
     f82:	3f 91       	pop	r19
     f84:	2f 91       	pop	r18
     f86:	0f 90       	pop	r0
     f88:	0b be       	out	0x3b, r0	; 59
     f8a:	0f 90       	pop	r0
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	0f 90       	pop	r0
     f90:	1f 90       	pop	r1
     f92:	18 95       	reti

00000f94 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
     f94:	1f 92       	push	r1
     f96:	0f 92       	push	r0
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	0f 92       	push	r0
     f9c:	11 24       	eor	r1, r1
     f9e:	0b b6       	in	r0, 0x3b	; 59
     fa0:	0f 92       	push	r0
     fa2:	2f 93       	push	r18
     fa4:	8f 93       	push	r24
     fa6:	9f 93       	push	r25
     fa8:	af 93       	push	r26
     faa:	bf 93       	push	r27
     fac:	ef 93       	push	r30
     fae:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	0f 92       	push	r0
	{
	    count = buffer->count;
     fb6:	80 91 f3 02 	lds	r24, 0x02F3	; 0x8002f3 <xSerialPort+0xd>
     fba:	90 91 f4 02 	lds	r25, 0x02F4	; 0x8002f4 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
     fbe:	0f 90       	pop	r0
     fc0:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
     fc2:	89 2b       	or	r24, r25
     fc4:	31 f4       	brne	.+12     	; 0xfd2 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
     fc6:	e1 ec       	ldi	r30, 0xC1	; 193
     fc8:	f0 e0       	ldi	r31, 0x00	; 0
     fca:	80 81       	ld	r24, Z
     fcc:	8f 7d       	andi	r24, 0xDF	; 223
     fce:	80 83       	st	Z, r24
     fd0:	1c c0       	rjmp	.+56     	; 0x100a <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     fd2:	e3 ef       	ldi	r30, 0xF3	; 243
     fd4:	f2 e0       	ldi	r31, 0x02	; 2

	uint8_t data = *buffer->out;
     fd6:	a4 81       	ldd	r26, Z+4	; 0x04
     fd8:	b5 81       	ldd	r27, Z+5	; 0x05
     fda:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
     fdc:	b5 83       	std	Z+5, r27	; 0x05
     fde:	a4 83       	std	Z+4, r26	; 0x04
     fe0:	80 85       	ldd	r24, Z+8	; 0x08
     fe2:	91 85       	ldd	r25, Z+9	; 0x09
     fe4:	a8 17       	cp	r26, r24
     fe6:	b9 07       	cpc	r27, r25
     fe8:	21 f4       	brne	.+8      	; 0xff2 <__vector_26+0x5e>
	  buffer->out = buffer->start;
     fea:	86 81       	ldd	r24, Z+6	; 0x06
     fec:	97 81       	ldd	r25, Z+7	; 0x07
     fee:	95 83       	std	Z+5, r25	; 0x05
     ff0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
     ff2:	0f b6       	in	r0, 0x3f	; 63
     ff4:	f8 94       	cli
     ff6:	0f 92       	push	r0
	{
	    buffer->count--;
     ff8:	80 81       	ld	r24, Z
     ffa:	91 81       	ldd	r25, Z+1	; 0x01
     ffc:	01 97       	sbiw	r24, 0x01	; 1
     ffe:	91 83       	std	Z+1, r25	; 0x01
    1000:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1006:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    100a:	ff 91       	pop	r31
    100c:	ef 91       	pop	r30
    100e:	bf 91       	pop	r27
    1010:	af 91       	pop	r26
    1012:	9f 91       	pop	r25
    1014:	8f 91       	pop	r24
    1016:	2f 91       	pop	r18
    1018:	0f 90       	pop	r0
    101a:	0b be       	out	0x3b, r0	; 59
    101c:	0f 90       	pop	r0
    101e:	0f be       	out	0x3f, r0	; 63
    1020:	0f 90       	pop	r0
    1022:	1f 90       	pop	r1
    1024:	18 95       	reti

00001026 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    1026:	1f 92       	push	r1
    1028:	0f 92       	push	r0
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	0f 92       	push	r0
    102e:	11 24       	eor	r1, r1
    1030:	0b b6       	in	r0, 0x3b	; 59
    1032:	0f 92       	push	r0
    1034:	2f 93       	push	r18
    1036:	3f 93       	push	r19
    1038:	4f 93       	push	r20
    103a:	8f 93       	push	r24
    103c:	9f 93       	push	r25
    103e:	af 93       	push	r26
    1040:	bf 93       	push	r27
    1042:	ef 93       	push	r30
    1044:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    1046:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    104a:	8c 71       	andi	r24, 0x1C	; 28
    104c:	71 f0       	breq	.+28     	; 0x106a <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    104e:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1052:	88 23       	and	r24, r24
    1054:	0c f0       	brlt	.+2      	; 0x1058 <__vector_36+0x32>
    1056:	36 c0       	rjmp	.+108    	; 0x10c4 <__vector_36+0x9e>
    1058:	ae ec       	ldi	r26, 0xCE	; 206
    105a:	b0 e0       	ldi	r27, 0x00	; 0
    105c:	e8 ec       	ldi	r30, 0xC8	; 200
    105e:	f0 e0       	ldi	r31, 0x00	; 0
    1060:	8c 91       	ld	r24, X
    1062:	80 81       	ld	r24, Z
    1064:	88 23       	and	r24, r24
    1066:	e4 f3       	brlt	.-8      	; 0x1060 <__vector_36+0x3a>
    1068:	2d c0       	rjmp	.+90     	; 0x10c4 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    106a:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
	{
	    count = buffer->count;
    1074:	ec e4       	ldi	r30, 0x4C	; 76
    1076:	f3 e0       	ldi	r31, 0x03	; 3
    1078:	21 81       	ldd	r18, Z+1	; 0x01
    107a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    107c:	0f 90       	pop	r0
    107e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    1080:	83 85       	ldd	r24, Z+11	; 0x0b
    1082:	94 85       	ldd	r25, Z+12	; 0x0c
    1084:	28 17       	cp	r18, r24
    1086:	39 07       	cpc	r19, r25
    1088:	e9 f0       	breq	.+58     	; 0x10c4 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    108a:	ed e4       	ldi	r30, 0x4D	; 77
    108c:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    108e:	a2 81       	ldd	r26, Z+2	; 0x02
    1090:	b3 81       	ldd	r27, Z+3	; 0x03
    1092:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1094:	82 81       	ldd	r24, Z+2	; 0x02
    1096:	93 81       	ldd	r25, Z+3	; 0x03
    1098:	01 96       	adiw	r24, 0x01	; 1
    109a:	93 83       	std	Z+3, r25	; 0x03
    109c:	82 83       	std	Z+2, r24	; 0x02
    109e:	20 85       	ldd	r18, Z+8	; 0x08
    10a0:	31 85       	ldd	r19, Z+9	; 0x09
    10a2:	82 17       	cp	r24, r18
    10a4:	93 07       	cpc	r25, r19
    10a6:	21 f4       	brne	.+8      	; 0x10b0 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    10a8:	86 81       	ldd	r24, Z+6	; 0x06
    10aa:	97 81       	ldd	r25, Z+7	; 0x07
    10ac:	93 83       	std	Z+3, r25	; 0x03
    10ae:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    10b0:	0f b6       	in	r0, 0x3f	; 63
    10b2:	f8 94       	cli
    10b4:	0f 92       	push	r0
	{
	    buffer->count++;
    10b6:	80 81       	ld	r24, Z
    10b8:	91 81       	ldd	r25, Z+1	; 0x01
    10ba:	01 96       	adiw	r24, 0x01	; 1
    10bc:	91 83       	std	Z+1, r25	; 0x01
    10be:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    10c0:	0f 90       	pop	r0
    10c2:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    10c4:	ff 91       	pop	r31
    10c6:	ef 91       	pop	r30
    10c8:	bf 91       	pop	r27
    10ca:	af 91       	pop	r26
    10cc:	9f 91       	pop	r25
    10ce:	8f 91       	pop	r24
    10d0:	4f 91       	pop	r20
    10d2:	3f 91       	pop	r19
    10d4:	2f 91       	pop	r18
    10d6:	0f 90       	pop	r0
    10d8:	0b be       	out	0x3b, r0	; 59
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0
    10e0:	1f 90       	pop	r1
    10e2:	18 95       	reti

000010e4 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    10e4:	1f 92       	push	r1
    10e6:	0f 92       	push	r0
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	0f 92       	push	r0
    10ec:	11 24       	eor	r1, r1
    10ee:	0b b6       	in	r0, 0x3b	; 59
    10f0:	0f 92       	push	r0
    10f2:	2f 93       	push	r18
    10f4:	8f 93       	push	r24
    10f6:	9f 93       	push	r25
    10f8:	af 93       	push	r26
    10fa:	bf 93       	push	r27
    10fc:	ef 93       	push	r30
    10fe:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1100:	0f b6       	in	r0, 0x3f	; 63
    1102:	f8 94       	cli
    1104:	0f 92       	push	r0
	{
	    count = buffer->count;
    1106:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <xSerial1Port+0xd>
    110a:	90 91 5a 03 	lds	r25, 0x035A	; 0x80035a <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1112:	89 2b       	or	r24, r25
    1114:	31 f4       	brne	.+12     	; 0x1122 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1116:	e9 ec       	ldi	r30, 0xC9	; 201
    1118:	f0 e0       	ldi	r31, 0x00	; 0
    111a:	80 81       	ld	r24, Z
    111c:	8f 7d       	andi	r24, 0xDF	; 223
    111e:	80 83       	st	Z, r24
    1120:	1c c0       	rjmp	.+56     	; 0x115a <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1122:	e9 e5       	ldi	r30, 0x59	; 89
    1124:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    1126:	a4 81       	ldd	r26, Z+4	; 0x04
    1128:	b5 81       	ldd	r27, Z+5	; 0x05
    112a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    112c:	b5 83       	std	Z+5, r27	; 0x05
    112e:	a4 83       	std	Z+4, r26	; 0x04
    1130:	80 85       	ldd	r24, Z+8	; 0x08
    1132:	91 85       	ldd	r25, Z+9	; 0x09
    1134:	a8 17       	cp	r26, r24
    1136:	b9 07       	cpc	r27, r25
    1138:	21 f4       	brne	.+8      	; 0x1142 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    113a:	86 81       	ldd	r24, Z+6	; 0x06
    113c:	97 81       	ldd	r25, Z+7	; 0x07
    113e:	95 83       	std	Z+5, r25	; 0x05
    1140:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	0f 92       	push	r0
	{
	    buffer->count--;
    1148:	80 81       	ld	r24, Z
    114a:	91 81       	ldd	r25, Z+1	; 0x01
    114c:	01 97       	sbiw	r24, 0x01	; 1
    114e:	91 83       	std	Z+1, r25	; 0x01
    1150:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1152:	0f 90       	pop	r0
    1154:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1156:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    115a:	ff 91       	pop	r31
    115c:	ef 91       	pop	r30
    115e:	bf 91       	pop	r27
    1160:	af 91       	pop	r26
    1162:	9f 91       	pop	r25
    1164:	8f 91       	pop	r24
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	0b b6       	in	r0, 0x3b	; 59
    1182:	0f 92       	push	r0
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	8f 93       	push	r24
    118c:	9f 93       	push	r25
    118e:	af 93       	push	r26
    1190:	bf 93       	push	r27
    1192:	ef 93       	push	r30
    1194:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1196:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    119a:	8c 71       	andi	r24, 0x1C	; 28
    119c:	71 f0       	breq	.+28     	; 0x11ba <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    119e:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    11a2:	88 23       	and	r24, r24
    11a4:	0c f0       	brlt	.+2      	; 0x11a8 <__vector_51+0x32>
    11a6:	36 c0       	rjmp	.+108    	; 0x1214 <__vector_51+0x9e>
    11a8:	a6 ed       	ldi	r26, 0xD6	; 214
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	e0 ed       	ldi	r30, 0xD0	; 208
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	8c 91       	ld	r24, X
    11b2:	80 81       	ld	r24, Z
    11b4:	88 23       	and	r24, r24
    11b6:	e4 f3       	brlt	.-8      	; 0x11b0 <__vector_51+0x3a>
    11b8:	2d c0       	rjmp	.+90     	; 0x1214 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    11ba:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    11be:	0f b6       	in	r0, 0x3f	; 63
    11c0:	f8 94       	cli
    11c2:	0f 92       	push	r0
	{
	    count = buffer->count;
    11c4:	e8 e0       	ldi	r30, 0x08	; 8
    11c6:	f3 e0       	ldi	r31, 0x03	; 3
    11c8:	21 81       	ldd	r18, Z+1	; 0x01
    11ca:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    11cc:	0f 90       	pop	r0
    11ce:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    11d0:	83 85       	ldd	r24, Z+11	; 0x0b
    11d2:	94 85       	ldd	r25, Z+12	; 0x0c
    11d4:	28 17       	cp	r18, r24
    11d6:	39 07       	cpc	r19, r25
    11d8:	e9 f0       	breq	.+58     	; 0x1214 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    11da:	e9 e0       	ldi	r30, 0x09	; 9
    11dc:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    11de:	a2 81       	ldd	r26, Z+2	; 0x02
    11e0:	b3 81       	ldd	r27, Z+3	; 0x03
    11e2:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    11e4:	82 81       	ldd	r24, Z+2	; 0x02
    11e6:	93 81       	ldd	r25, Z+3	; 0x03
    11e8:	01 96       	adiw	r24, 0x01	; 1
    11ea:	93 83       	std	Z+3, r25	; 0x03
    11ec:	82 83       	std	Z+2, r24	; 0x02
    11ee:	20 85       	ldd	r18, Z+8	; 0x08
    11f0:	31 85       	ldd	r19, Z+9	; 0x09
    11f2:	82 17       	cp	r24, r18
    11f4:	93 07       	cpc	r25, r19
    11f6:	21 f4       	brne	.+8      	; 0x1200 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    11f8:	86 81       	ldd	r24, Z+6	; 0x06
    11fa:	97 81       	ldd	r25, Z+7	; 0x07
    11fc:	93 83       	std	Z+3, r25	; 0x03
    11fe:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	0f 92       	push	r0
	{
	    buffer->count++;
    1206:	80 81       	ld	r24, Z
    1208:	91 81       	ldd	r25, Z+1	; 0x01
    120a:	01 96       	adiw	r24, 0x01	; 1
    120c:	91 83       	std	Z+1, r25	; 0x01
    120e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1210:	0f 90       	pop	r0
    1212:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1214:	ff 91       	pop	r31
    1216:	ef 91       	pop	r30
    1218:	bf 91       	pop	r27
    121a:	af 91       	pop	r26
    121c:	9f 91       	pop	r25
    121e:	8f 91       	pop	r24
    1220:	4f 91       	pop	r20
    1222:	3f 91       	pop	r19
    1224:	2f 91       	pop	r18
    1226:	0f 90       	pop	r0
    1228:	0b be       	out	0x3b, r0	; 59
    122a:	0f 90       	pop	r0
    122c:	0f be       	out	0x3f, r0	; 63
    122e:	0f 90       	pop	r0
    1230:	1f 90       	pop	r1
    1232:	18 95       	reti

00001234 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1234:	1f 92       	push	r1
    1236:	0f 92       	push	r0
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	0f 92       	push	r0
    123c:	11 24       	eor	r1, r1
    123e:	0b b6       	in	r0, 0x3b	; 59
    1240:	0f 92       	push	r0
    1242:	2f 93       	push	r18
    1244:	8f 93       	push	r24
    1246:	9f 93       	push	r25
    1248:	af 93       	push	r26
    124a:	bf 93       	push	r27
    124c:	ef 93       	push	r30
    124e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	0f 92       	push	r0
	{
	    count = buffer->count;
    1256:	80 91 15 03 	lds	r24, 0x0315	; 0x800315 <xSerial2Port+0xd>
    125a:	90 91 16 03 	lds	r25, 0x0316	; 0x800316 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    125e:	0f 90       	pop	r0
    1260:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1262:	89 2b       	or	r24, r25
    1264:	31 f4       	brne	.+12     	; 0x1272 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1266:	e1 ed       	ldi	r30, 0xD1	; 209
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	80 81       	ld	r24, Z
    126c:	8f 7d       	andi	r24, 0xDF	; 223
    126e:	80 83       	st	Z, r24
    1270:	1c c0       	rjmp	.+56     	; 0x12aa <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1272:	e5 e1       	ldi	r30, 0x15	; 21
    1274:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    1276:	a4 81       	ldd	r26, Z+4	; 0x04
    1278:	b5 81       	ldd	r27, Z+5	; 0x05
    127a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    127c:	b5 83       	std	Z+5, r27	; 0x05
    127e:	a4 83       	std	Z+4, r26	; 0x04
    1280:	80 85       	ldd	r24, Z+8	; 0x08
    1282:	91 85       	ldd	r25, Z+9	; 0x09
    1284:	a8 17       	cp	r26, r24
    1286:	b9 07       	cpc	r27, r25
    1288:	21 f4       	brne	.+8      	; 0x1292 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    128a:	86 81       	ldd	r24, Z+6	; 0x06
    128c:	97 81       	ldd	r25, Z+7	; 0x07
    128e:	95 83       	std	Z+5, r25	; 0x05
    1290:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	0f 92       	push	r0
	{
	    buffer->count--;
    1298:	80 81       	ld	r24, Z
    129a:	91 81       	ldd	r25, Z+1	; 0x01
    129c:	01 97       	sbiw	r24, 0x01	; 1
    129e:	91 83       	std	Z+1, r25	; 0x01
    12a0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    12a6:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    12aa:	ff 91       	pop	r31
    12ac:	ef 91       	pop	r30
    12ae:	bf 91       	pop	r27
    12b0:	af 91       	pop	r26
    12b2:	9f 91       	pop	r25
    12b4:	8f 91       	pop	r24
    12b6:	2f 91       	pop	r18
    12b8:	0f 90       	pop	r0
    12ba:	0b be       	out	0x3b, r0	; 59
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63
    12c0:	0f 90       	pop	r0
    12c2:	1f 90       	pop	r1
    12c4:	18 95       	reti

000012c6 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    12c6:	1f 92       	push	r1
    12c8:	0f 92       	push	r0
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	0f 92       	push	r0
    12ce:	11 24       	eor	r1, r1
    12d0:	0b b6       	in	r0, 0x3b	; 59
    12d2:	0f 92       	push	r0
    12d4:	2f 93       	push	r18
    12d6:	3f 93       	push	r19
    12d8:	4f 93       	push	r20
    12da:	8f 93       	push	r24
    12dc:	9f 93       	push	r25
    12de:	af 93       	push	r26
    12e0:	bf 93       	push	r27
    12e2:	ef 93       	push	r30
    12e4:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    12e6:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    12ea:	8c 71       	andi	r24, 0x1C	; 28
    12ec:	71 f0       	breq	.+28     	; 0x130a <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    12ee:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    12f2:	88 23       	and	r24, r24
    12f4:	0c f0       	brlt	.+2      	; 0x12f8 <__vector_54+0x32>
    12f6:	36 c0       	rjmp	.+108    	; 0x1364 <__vector_54+0x9e>
    12f8:	a6 e3       	ldi	r26, 0x36	; 54
    12fa:	b1 e0       	ldi	r27, 0x01	; 1
    12fc:	e0 e3       	ldi	r30, 0x30	; 48
    12fe:	f1 e0       	ldi	r31, 0x01	; 1
    1300:	8c 91       	ld	r24, X
    1302:	80 81       	ld	r24, Z
    1304:	88 23       	and	r24, r24
    1306:	e4 f3       	brlt	.-8      	; 0x1300 <__vector_54+0x3a>
    1308:	2d c0       	rjmp	.+90     	; 0x1364 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    130a:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	f8 94       	cli
    1312:	0f 92       	push	r0
	{
	    count = buffer->count;
    1314:	ea e2       	ldi	r30, 0x2A	; 42
    1316:	f3 e0       	ldi	r31, 0x03	; 3
    1318:	21 81       	ldd	r18, Z+1	; 0x01
    131a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    131c:	0f 90       	pop	r0
    131e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1320:	83 85       	ldd	r24, Z+11	; 0x0b
    1322:	94 85       	ldd	r25, Z+12	; 0x0c
    1324:	28 17       	cp	r18, r24
    1326:	39 07       	cpc	r19, r25
    1328:	e9 f0       	breq	.+58     	; 0x1364 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    132a:	eb e2       	ldi	r30, 0x2B	; 43
    132c:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    132e:	a2 81       	ldd	r26, Z+2	; 0x02
    1330:	b3 81       	ldd	r27, Z+3	; 0x03
    1332:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1334:	82 81       	ldd	r24, Z+2	; 0x02
    1336:	93 81       	ldd	r25, Z+3	; 0x03
    1338:	01 96       	adiw	r24, 0x01	; 1
    133a:	93 83       	std	Z+3, r25	; 0x03
    133c:	82 83       	std	Z+2, r24	; 0x02
    133e:	20 85       	ldd	r18, Z+8	; 0x08
    1340:	31 85       	ldd	r19, Z+9	; 0x09
    1342:	82 17       	cp	r24, r18
    1344:	93 07       	cpc	r25, r19
    1346:	21 f4       	brne	.+8      	; 0x1350 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1348:	86 81       	ldd	r24, Z+6	; 0x06
    134a:	97 81       	ldd	r25, Z+7	; 0x07
    134c:	93 83       	std	Z+3, r25	; 0x03
    134e:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1350:	0f b6       	in	r0, 0x3f	; 63
    1352:	f8 94       	cli
    1354:	0f 92       	push	r0
	{
	    buffer->count++;
    1356:	80 81       	ld	r24, Z
    1358:	91 81       	ldd	r25, Z+1	; 0x01
    135a:	01 96       	adiw	r24, 0x01	; 1
    135c:	91 83       	std	Z+1, r25	; 0x01
    135e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1364:	ff 91       	pop	r31
    1366:	ef 91       	pop	r30
    1368:	bf 91       	pop	r27
    136a:	af 91       	pop	r26
    136c:	9f 91       	pop	r25
    136e:	8f 91       	pop	r24
    1370:	4f 91       	pop	r20
    1372:	3f 91       	pop	r19
    1374:	2f 91       	pop	r18
    1376:	0f 90       	pop	r0
    1378:	0b be       	out	0x3b, r0	; 59
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	0f 90       	pop	r0
    1380:	1f 90       	pop	r1
    1382:	18 95       	reti

00001384 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1384:	1f 92       	push	r1
    1386:	0f 92       	push	r0
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	0f 92       	push	r0
    138c:	11 24       	eor	r1, r1
    138e:	0b b6       	in	r0, 0x3b	; 59
    1390:	0f 92       	push	r0
    1392:	2f 93       	push	r18
    1394:	8f 93       	push	r24
    1396:	9f 93       	push	r25
    1398:	af 93       	push	r26
    139a:	bf 93       	push	r27
    139c:	ef 93       	push	r30
    139e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    13a0:	0f b6       	in	r0, 0x3f	; 63
    13a2:	f8 94       	cli
    13a4:	0f 92       	push	r0
	{
	    count = buffer->count;
    13a6:	80 91 37 03 	lds	r24, 0x0337	; 0x800337 <xSerial3Port+0xd>
    13aa:	90 91 38 03 	lds	r25, 0x0338	; 0x800338 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    13ae:	0f 90       	pop	r0
    13b0:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    13b2:	89 2b       	or	r24, r25
    13b4:	31 f4       	brne	.+12     	; 0x13c2 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    13b6:	e1 e3       	ldi	r30, 0x31	; 49
    13b8:	f1 e0       	ldi	r31, 0x01	; 1
    13ba:	80 81       	ld	r24, Z
    13bc:	8f 7d       	andi	r24, 0xDF	; 223
    13be:	80 83       	st	Z, r24
    13c0:	1c c0       	rjmp	.+56     	; 0x13fa <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    13c2:	e7 e3       	ldi	r30, 0x37	; 55
    13c4:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    13c6:	a4 81       	ldd	r26, Z+4	; 0x04
    13c8:	b5 81       	ldd	r27, Z+5	; 0x05
    13ca:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    13cc:	b5 83       	std	Z+5, r27	; 0x05
    13ce:	a4 83       	std	Z+4, r26	; 0x04
    13d0:	80 85       	ldd	r24, Z+8	; 0x08
    13d2:	91 85       	ldd	r25, Z+9	; 0x09
    13d4:	a8 17       	cp	r26, r24
    13d6:	b9 07       	cpc	r27, r25
    13d8:	21 f4       	brne	.+8      	; 0x13e2 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    13da:	86 81       	ldd	r24, Z+6	; 0x06
    13dc:	97 81       	ldd	r25, Z+7	; 0x07
    13de:	95 83       	std	Z+5, r25	; 0x05
    13e0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	0f 92       	push	r0
	{
	    buffer->count--;
    13e8:	80 81       	ld	r24, Z
    13ea:	91 81       	ldd	r25, Z+1	; 0x01
    13ec:	01 97       	sbiw	r24, 0x01	; 1
    13ee:	91 83       	std	Z+1, r25	; 0x01
    13f0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    13f2:	0f 90       	pop	r0
    13f4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    13f6:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    13fa:	ff 91       	pop	r31
    13fc:	ef 91       	pop	r30
    13fe:	bf 91       	pop	r27
    1400:	af 91       	pop	r26
    1402:	9f 91       	pop	r25
    1404:	8f 91       	pop	r24
    1406:	2f 91       	pop	r18
    1408:	0f 90       	pop	r0
    140a:	0b be       	out	0x3b, r0	; 59
    140c:	0f 90       	pop	r0
    140e:	0f be       	out	0x3f, r0	; 63
    1410:	0f 90       	pop	r0
    1412:	1f 90       	pop	r1
    1414:	18 95       	reti

00001416 <prvResetNextTaskUnblockTime>:
    1416:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <pxDelayedTaskList>
    141a:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    141e:	80 81       	ld	r24, Z
    1420:	81 11       	cpse	r24, r1
    1422:	07 c0       	rjmp	.+14     	; 0x1432 <prvResetNextTaskUnblockTime+0x1c>
    1424:	8f ef       	ldi	r24, 0xFF	; 255
    1426:	9f ef       	ldi	r25, 0xFF	; 255
    1428:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <xNextTaskUnblockTime+0x1>
    142c:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <xNextTaskUnblockTime>
    1430:	08 95       	ret
    1432:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <pxDelayedTaskList>
    1436:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    143a:	05 80       	ldd	r0, Z+5	; 0x05
    143c:	f6 81       	ldd	r31, Z+6	; 0x06
    143e:	e0 2d       	mov	r30, r0
    1440:	06 80       	ldd	r0, Z+6	; 0x06
    1442:	f7 81       	ldd	r31, Z+7	; 0x07
    1444:	e0 2d       	mov	r30, r0
    1446:	82 81       	ldd	r24, Z+2	; 0x02
    1448:	93 81       	ldd	r25, Z+3	; 0x03
    144a:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <xNextTaskUnblockTime+0x1>
    144e:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <xNextTaskUnblockTime>
    1452:	08 95       	ret

00001454 <prvAddCurrentTaskToDelayedList>:
    1454:	ff 92       	push	r15
    1456:	0f 93       	push	r16
    1458:	1f 93       	push	r17
    145a:	cf 93       	push	r28
    145c:	df 93       	push	r29
    145e:	ec 01       	movw	r28, r24
    1460:	f6 2e       	mov	r15, r22
    1462:	00 91 7b 02 	lds	r16, 0x027B	; 0x80027b <xTickCount>
    1466:	10 91 7c 02 	lds	r17, 0x027C	; 0x80027c <xTickCount+0x1>
    146a:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    146e:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1472:	02 96       	adiw	r24, 0x02	; 2
    1474:	fd d8       	rcall	.-3590   	; 0x670 <uxListRemove>
    1476:	cf 3f       	cpi	r28, 0xFF	; 255
    1478:	8f ef       	ldi	r24, 0xFF	; 255
    147a:	d8 07       	cpc	r29, r24
    147c:	61 f4       	brne	.+24     	; 0x1496 <prvAddCurrentTaskToDelayedList+0x42>
    147e:	ff 20       	and	r15, r15
    1480:	51 f0       	breq	.+20     	; 0x1496 <prvAddCurrentTaskToDelayedList+0x42>
    1482:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1486:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    148a:	6e 5f       	subi	r22, 0xFE	; 254
    148c:	7f 4f       	sbci	r23, 0xFF	; 255
    148e:	8e e7       	ldi	r24, 0x7E	; 126
    1490:	92 e0       	ldi	r25, 0x02	; 2
    1492:	9c d8       	rcall	.-3784   	; 0x5cc <vListInsertEnd>
    1494:	2d c0       	rjmp	.+90     	; 0x14f0 <prvAddCurrentTaskToDelayedList+0x9c>
    1496:	c0 0f       	add	r28, r16
    1498:	d1 1f       	adc	r29, r17
    149a:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    149e:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    14a2:	d3 83       	std	Z+3, r29	; 0x03
    14a4:	c2 83       	std	Z+2, r28	; 0x02
    14a6:	c0 17       	cp	r28, r16
    14a8:	d1 07       	cpc	r29, r17
    14aa:	60 f4       	brcc	.+24     	; 0x14c4 <prvAddCurrentTaskToDelayedList+0x70>
    14ac:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    14b0:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    14b4:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <pxOverflowDelayedTaskList>
    14b8:	90 91 9b 02 	lds	r25, 0x029B	; 0x80029b <pxOverflowDelayedTaskList+0x1>
    14bc:	6e 5f       	subi	r22, 0xFE	; 254
    14be:	7f 4f       	sbci	r23, 0xFF	; 255
    14c0:	a6 d8       	rcall	.-3764   	; 0x60e <vListInsert>
    14c2:	16 c0       	rjmp	.+44     	; 0x14f0 <prvAddCurrentTaskToDelayedList+0x9c>
    14c4:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    14c8:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    14cc:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <pxDelayedTaskList>
    14d0:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    14d4:	6e 5f       	subi	r22, 0xFE	; 254
    14d6:	7f 4f       	sbci	r23, 0xFF	; 255
    14d8:	9a d8       	rcall	.-3788   	; 0x60e <vListInsert>
    14da:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <xNextTaskUnblockTime>
    14de:	90 91 74 02 	lds	r25, 0x0274	; 0x800274 <xNextTaskUnblockTime+0x1>
    14e2:	c8 17       	cp	r28, r24
    14e4:	d9 07       	cpc	r29, r25
    14e6:	20 f4       	brcc	.+8      	; 0x14f0 <prvAddCurrentTaskToDelayedList+0x9c>
    14e8:	d0 93 74 02 	sts	0x0274, r29	; 0x800274 <xNextTaskUnblockTime+0x1>
    14ec:	c0 93 73 02 	sts	0x0273, r28	; 0x800273 <xNextTaskUnblockTime>
    14f0:	df 91       	pop	r29
    14f2:	cf 91       	pop	r28
    14f4:	1f 91       	pop	r17
    14f6:	0f 91       	pop	r16
    14f8:	ff 90       	pop	r15
    14fa:	08 95       	ret

000014fc <xTaskCreate>:
    14fc:	4f 92       	push	r4
    14fe:	5f 92       	push	r5
    1500:	6f 92       	push	r6
    1502:	7f 92       	push	r7
    1504:	8f 92       	push	r8
    1506:	9f 92       	push	r9
    1508:	af 92       	push	r10
    150a:	bf 92       	push	r11
    150c:	cf 92       	push	r12
    150e:	df 92       	push	r13
    1510:	ef 92       	push	r14
    1512:	ff 92       	push	r15
    1514:	0f 93       	push	r16
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	4c 01       	movw	r8, r24
    151c:	6b 01       	movw	r12, r22
    151e:	5a 01       	movw	r10, r20
    1520:	29 01       	movw	r4, r18
    1522:	ca 01       	movw	r24, r20
    1524:	0e 94 ac 01 	call	0x358	; 0x358 <pvPortMalloc>
    1528:	3c 01       	movw	r6, r24
    152a:	89 2b       	or	r24, r25
    152c:	09 f4       	brne	.+2      	; 0x1530 <xTaskCreate+0x34>
    152e:	e7 c0       	rjmp	.+462    	; 0x16fe <xTaskCreate+0x202>
    1530:	88 e2       	ldi	r24, 0x28	; 40
    1532:	90 e0       	ldi	r25, 0x00	; 0
    1534:	0e 94 ac 01 	call	0x358	; 0x358 <pvPortMalloc>
    1538:	ec 01       	movw	r28, r24
    153a:	89 2b       	or	r24, r25
    153c:	a9 f0       	breq	.+42     	; 0x1568 <xTaskCreate+0x6c>
    153e:	78 8e       	std	Y+24, r7	; 0x18
    1540:	6f 8a       	std	Y+23, r6	; 0x17
    1542:	a5 01       	movw	r20, r10
    1544:	65 ea       	ldi	r22, 0xA5	; 165
    1546:	70 e0       	ldi	r23, 0x00	; 0
    1548:	c3 01       	movw	r24, r6
    154a:	81 d6       	rcall	.+3330   	; 0x224e <memset>
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	a8 1a       	sub	r10, r24
    1550:	b1 08       	sbc	r11, r1
    1552:	8f 89       	ldd	r24, Y+23	; 0x17
    1554:	98 8d       	ldd	r25, Y+24	; 0x18
    1556:	a8 0e       	add	r10, r24
    1558:	b9 1e       	adc	r11, r25
    155a:	d6 01       	movw	r26, r12
    155c:	8c 91       	ld	r24, X
    155e:	89 8f       	std	Y+25, r24	; 0x19
    1560:	8c 91       	ld	r24, X
    1562:	81 11       	cpse	r24, r1
    1564:	05 c0       	rjmp	.+10     	; 0x1570 <xTaskCreate+0x74>
    1566:	18 c0       	rjmp	.+48     	; 0x1598 <xTaskCreate+0x9c>
    1568:	c3 01       	movw	r24, r6
    156a:	0e 94 be 01 	call	0x37c	; 0x37c <vPortFree>
    156e:	c7 c0       	rjmp	.+398    	; 0x16fe <xTaskCreate+0x202>
    1570:	ae 01       	movw	r20, r28
    1572:	46 5e       	subi	r20, 0xE6	; 230
    1574:	5f 4f       	sbci	r21, 0xFF	; 255
    1576:	f6 01       	movw	r30, r12
    1578:	31 96       	adiw	r30, 0x01	; 1
    157a:	b8 e0       	ldi	r27, 0x08	; 8
    157c:	cb 0e       	add	r12, r27
    157e:	d1 1c       	adc	r13, r1
    1580:	cf 01       	movw	r24, r30
    1582:	21 91       	ld	r18, Z+
    1584:	da 01       	movw	r26, r20
    1586:	2d 93       	st	X+, r18
    1588:	ad 01       	movw	r20, r26
    158a:	dc 01       	movw	r26, r24
    158c:	8c 91       	ld	r24, X
    158e:	88 23       	and	r24, r24
    1590:	19 f0       	breq	.+6      	; 0x1598 <xTaskCreate+0x9c>
    1592:	ec 15       	cp	r30, r12
    1594:	fd 05       	cpc	r31, r13
    1596:	a1 f7       	brne	.-24     	; 0x1580 <xTaskCreate+0x84>
    1598:	18 a2       	std	Y+32, r1	; 0x20
    159a:	04 30       	cpi	r16, 0x04	; 4
    159c:	08 f0       	brcs	.+2      	; 0x15a0 <xTaskCreate+0xa4>
    159e:	03 e0       	ldi	r16, 0x03	; 3
    15a0:	0e 8b       	std	Y+22, r16	; 0x16
    15a2:	09 a3       	std	Y+33, r16	; 0x21
    15a4:	1a a2       	std	Y+34, r1	; 0x22
    15a6:	6e 01       	movw	r12, r28
    15a8:	b2 e0       	ldi	r27, 0x02	; 2
    15aa:	cb 0e       	add	r12, r27
    15ac:	d1 1c       	adc	r13, r1
    15ae:	c6 01       	movw	r24, r12
    15b0:	09 d8       	rcall	.-4078   	; 0x5c4 <vListInitialiseItem>
    15b2:	ce 01       	movw	r24, r28
    15b4:	0c 96       	adiw	r24, 0x0c	; 12
    15b6:	06 d8       	rcall	.-4084   	; 0x5c4 <vListInitialiseItem>
    15b8:	d9 87       	std	Y+9, r29	; 0x09
    15ba:	c8 87       	std	Y+8, r28	; 0x08
    15bc:	84 e0       	ldi	r24, 0x04	; 4
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	80 1b       	sub	r24, r16
    15c2:	91 09       	sbc	r25, r1
    15c4:	9d 87       	std	Y+13, r25	; 0x0d
    15c6:	8c 87       	std	Y+12, r24	; 0x0c
    15c8:	db 8b       	std	Y+19, r29	; 0x13
    15ca:	ca 8b       	std	Y+18, r28	; 0x12
    15cc:	1b a2       	std	Y+35, r1	; 0x23
    15ce:	1c a2       	std	Y+36, r1	; 0x24
    15d0:	1d a2       	std	Y+37, r1	; 0x25
    15d2:	1e a2       	std	Y+38, r1	; 0x26
    15d4:	1f a2       	std	Y+39, r1	; 0x27
    15d6:	a2 01       	movw	r20, r4
    15d8:	b4 01       	movw	r22, r8
    15da:	c5 01       	movw	r24, r10
    15dc:	6f d8       	rcall	.-3874   	; 0x6bc <pxPortInitialiseStack>
    15de:	99 83       	std	Y+1, r25	; 0x01
    15e0:	88 83       	st	Y, r24
    15e2:	e1 14       	cp	r14, r1
    15e4:	f1 04       	cpc	r15, r1
    15e6:	19 f0       	breq	.+6      	; 0x15ee <xTaskCreate+0xf2>
    15e8:	f7 01       	movw	r30, r14
    15ea:	d1 83       	std	Z+1, r29	; 0x01
    15ec:	c0 83       	st	Z, r28
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	0f 92       	push	r0
    15f4:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <uxCurrentNumberOfTasks>
    15f8:	8f 5f       	subi	r24, 0xFF	; 255
    15fa:	80 93 7d 02 	sts	0x027D, r24	; 0x80027d <uxCurrentNumberOfTasks>
    15fe:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1602:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1606:	89 2b       	or	r24, r25
    1608:	d1 f5       	brne	.+116    	; 0x167e <xTaskCreate+0x182>
    160a:	d0 93 d5 02 	sts	0x02D5, r29	; 0x8002d5 <pxCurrentTCB+0x1>
    160e:	c0 93 d4 02 	sts	0x02D4, r28	; 0x8002d4 <pxCurrentTCB>
    1612:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <uxCurrentNumberOfTasks>
    1616:	81 30       	cpi	r24, 0x01	; 1
    1618:	09 f0       	breq	.+2      	; 0x161c <xTaskCreate+0x120>
    161a:	41 c0       	rjmp	.+130    	; 0x169e <xTaskCreate+0x1a2>
    161c:	80 eb       	ldi	r24, 0xB0	; 176
    161e:	92 e0       	ldi	r25, 0x02	; 2
    1620:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1624:	89 eb       	ldi	r24, 0xB9	; 185
    1626:	92 e0       	ldi	r25, 0x02	; 2
    1628:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    162c:	82 ec       	ldi	r24, 0xC2	; 194
    162e:	92 e0       	ldi	r25, 0x02	; 2
    1630:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1634:	8b ec       	ldi	r24, 0xCB	; 203
    1636:	92 e0       	ldi	r25, 0x02	; 2
    1638:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    163c:	87 ea       	ldi	r24, 0xA7	; 167
    163e:	92 e0       	ldi	r25, 0x02	; 2
    1640:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1644:	8e e9       	ldi	r24, 0x9E	; 158
    1646:	92 e0       	ldi	r25, 0x02	; 2
    1648:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    164c:	81 e9       	ldi	r24, 0x91	; 145
    164e:	92 e0       	ldi	r25, 0x02	; 2
    1650:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1654:	88 e8       	ldi	r24, 0x88	; 136
    1656:	92 e0       	ldi	r25, 0x02	; 2
    1658:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    165c:	8e e7       	ldi	r24, 0x7E	; 126
    165e:	92 e0       	ldi	r25, 0x02	; 2
    1660:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1664:	87 ea       	ldi	r24, 0xA7	; 167
    1666:	92 e0       	ldi	r25, 0x02	; 2
    1668:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <pxDelayedTaskList+0x1>
    166c:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <pxDelayedTaskList>
    1670:	8e e9       	ldi	r24, 0x9E	; 158
    1672:	92 e0       	ldi	r25, 0x02	; 2
    1674:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <pxOverflowDelayedTaskList+0x1>
    1678:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <pxOverflowDelayedTaskList>
    167c:	10 c0       	rjmp	.+32     	; 0x169e <xTaskCreate+0x1a2>
    167e:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <xSchedulerRunning>
    1682:	81 11       	cpse	r24, r1
    1684:	0c c0       	rjmp	.+24     	; 0x169e <xTaskCreate+0x1a2>
    1686:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    168a:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    168e:	96 89       	ldd	r25, Z+22	; 0x16
    1690:	8e 89       	ldd	r24, Y+22	; 0x16
    1692:	89 17       	cp	r24, r25
    1694:	20 f0       	brcs	.+8      	; 0x169e <xTaskCreate+0x1a2>
    1696:	d0 93 d5 02 	sts	0x02D5, r29	; 0x8002d5 <pxCurrentTCB+0x1>
    169a:	c0 93 d4 02 	sts	0x02D4, r28	; 0x8002d4 <pxCurrentTCB>
    169e:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <uxTaskNumber>
    16a2:	8f 5f       	subi	r24, 0xFF	; 255
    16a4:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <uxTaskNumber>
    16a8:	8e 89       	ldd	r24, Y+22	; 0x16
    16aa:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    16ae:	98 17       	cp	r25, r24
    16b0:	10 f4       	brcc	.+4      	; 0x16b6 <xTaskCreate+0x1ba>
    16b2:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	9c 01       	movw	r18, r24
    16ba:	22 0f       	add	r18, r18
    16bc:	33 1f       	adc	r19, r19
    16be:	22 0f       	add	r18, r18
    16c0:	33 1f       	adc	r19, r19
    16c2:	22 0f       	add	r18, r18
    16c4:	33 1f       	adc	r19, r19
    16c6:	82 0f       	add	r24, r18
    16c8:	93 1f       	adc	r25, r19
    16ca:	b6 01       	movw	r22, r12
    16cc:	80 55       	subi	r24, 0x50	; 80
    16ce:	9d 4f       	sbci	r25, 0xFD	; 253
    16d0:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <xSchedulerRunning>
    16dc:	88 23       	and	r24, r24
    16de:	59 f0       	breq	.+22     	; 0x16f6 <xTaskCreate+0x1fa>
    16e0:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    16e4:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    16e8:	96 89       	ldd	r25, Z+22	; 0x16
    16ea:	8e 89       	ldd	r24, Y+22	; 0x16
    16ec:	98 17       	cp	r25, r24
    16ee:	28 f4       	brcc	.+10     	; 0x16fa <xTaskCreate+0x1fe>
    16f0:	9d d8       	rcall	.-3782   	; 0x82c <vPortYield>
    16f2:	81 e0       	ldi	r24, 0x01	; 1
    16f4:	05 c0       	rjmp	.+10     	; 0x1700 <xTaskCreate+0x204>
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	03 c0       	rjmp	.+6      	; 0x1700 <xTaskCreate+0x204>
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	01 c0       	rjmp	.+2      	; 0x1700 <xTaskCreate+0x204>
    16fe:	8f ef       	ldi	r24, 0xFF	; 255
    1700:	df 91       	pop	r29
    1702:	cf 91       	pop	r28
    1704:	0f 91       	pop	r16
    1706:	ff 90       	pop	r15
    1708:	ef 90       	pop	r14
    170a:	df 90       	pop	r13
    170c:	cf 90       	pop	r12
    170e:	bf 90       	pop	r11
    1710:	af 90       	pop	r10
    1712:	9f 90       	pop	r9
    1714:	8f 90       	pop	r8
    1716:	7f 90       	pop	r7
    1718:	6f 90       	pop	r6
    171a:	5f 90       	pop	r5
    171c:	4f 90       	pop	r4
    171e:	08 95       	ret

00001720 <vTaskStartScheduler>:
    1720:	ef 92       	push	r14
    1722:	ff 92       	push	r15
    1724:	0f 93       	push	r16
    1726:	0f 2e       	mov	r0, r31
    1728:	f1 e7       	ldi	r31, 0x71	; 113
    172a:	ef 2e       	mov	r14, r31
    172c:	f2 e0       	ldi	r31, 0x02	; 2
    172e:	ff 2e       	mov	r15, r31
    1730:	f0 2d       	mov	r31, r0
    1732:	00 e0       	ldi	r16, 0x00	; 0
    1734:	20 e0       	ldi	r18, 0x00	; 0
    1736:	30 e0       	ldi	r19, 0x00	; 0
    1738:	45 e5       	ldi	r20, 0x55	; 85
    173a:	50 e0       	ldi	r21, 0x00	; 0
    173c:	67 e0       	ldi	r22, 0x07	; 7
    173e:	72 e0       	ldi	r23, 0x02	; 2
    1740:	83 e3       	ldi	r24, 0x33	; 51
    1742:	91 e0       	ldi	r25, 0x01	; 1
    1744:	db de       	rcall	.-586    	; 0x14fc <xTaskCreate>
    1746:	81 30       	cpi	r24, 0x01	; 1
    1748:	79 f4       	brne	.+30     	; 0x1768 <vTaskStartScheduler+0x48>
    174a:	f8 94       	cli
    174c:	8f ef       	ldi	r24, 0xFF	; 255
    174e:	9f ef       	ldi	r25, 0xFF	; 255
    1750:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <xNextTaskUnblockTime+0x1>
    1754:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <xNextTaskUnblockTime>
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <xSchedulerRunning>
    175e:	10 92 7c 02 	sts	0x027C, r1	; 0x80027c <xTickCount+0x1>
    1762:	10 92 7b 02 	sts	0x027B, r1	; 0x80027b <xTickCount>
    1766:	1c d8       	rcall	.-4040   	; 0x7a0 <xPortStartScheduler>
    1768:	0f 91       	pop	r16
    176a:	ff 90       	pop	r15
    176c:	ef 90       	pop	r14
    176e:	08 95       	ret

00001770 <vTaskSuspendAll>:
    1770:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    1774:	8f 5f       	subi	r24, 0xFF	; 255
    1776:	80 93 70 02 	sts	0x0270, r24	; 0x800270 <uxSchedulerSuspended>
    177a:	08 95       	ret

0000177c <xTaskGetTickCount>:
    177c:	0f b6       	in	r0, 0x3f	; 63
    177e:	f8 94       	cli
    1780:	0f 92       	push	r0
    1782:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <xTickCount>
    1786:	90 91 7c 02 	lds	r25, 0x027C	; 0x80027c <xTickCount+0x1>
    178a:	0f 90       	pop	r0
    178c:	0f be       	out	0x3f, r0	; 63
    178e:	08 95       	ret

00001790 <xTaskIncrementTick>:
    1790:	cf 92       	push	r12
    1792:	df 92       	push	r13
    1794:	ef 92       	push	r14
    1796:	ff 92       	push	r15
    1798:	0f 93       	push	r16
    179a:	1f 93       	push	r17
    179c:	cf 93       	push	r28
    179e:	df 93       	push	r29
    17a0:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    17a4:	81 11       	cpse	r24, r1
    17a6:	98 c0       	rjmp	.+304    	; 0x18d8 <xTaskIncrementTick+0x148>
    17a8:	e0 90 7b 02 	lds	r14, 0x027B	; 0x80027b <xTickCount>
    17ac:	f0 90 7c 02 	lds	r15, 0x027C	; 0x80027c <xTickCount+0x1>
    17b0:	8f ef       	ldi	r24, 0xFF	; 255
    17b2:	e8 1a       	sub	r14, r24
    17b4:	f8 0a       	sbc	r15, r24
    17b6:	f0 92 7c 02 	sts	0x027C, r15	; 0x80027c <xTickCount+0x1>
    17ba:	e0 92 7b 02 	sts	0x027B, r14	; 0x80027b <xTickCount>
    17be:	e1 14       	cp	r14, r1
    17c0:	f1 04       	cpc	r15, r1
    17c2:	b1 f4       	brne	.+44     	; 0x17f0 <xTaskIncrementTick+0x60>
    17c4:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <pxDelayedTaskList>
    17c8:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    17cc:	20 91 9a 02 	lds	r18, 0x029A	; 0x80029a <pxOverflowDelayedTaskList>
    17d0:	30 91 9b 02 	lds	r19, 0x029B	; 0x80029b <pxOverflowDelayedTaskList+0x1>
    17d4:	30 93 9d 02 	sts	0x029D, r19	; 0x80029d <pxDelayedTaskList+0x1>
    17d8:	20 93 9c 02 	sts	0x029C, r18	; 0x80029c <pxDelayedTaskList>
    17dc:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <pxOverflowDelayedTaskList+0x1>
    17e0:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <pxOverflowDelayedTaskList>
    17e4:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <xNumOfOverflows>
    17e8:	8f 5f       	subi	r24, 0xFF	; 255
    17ea:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <xNumOfOverflows>
    17ee:	13 de       	rcall	.-986    	; 0x1416 <prvResetNextTaskUnblockTime>
    17f0:	80 91 73 02 	lds	r24, 0x0273	; 0x800273 <xNextTaskUnblockTime>
    17f4:	90 91 74 02 	lds	r25, 0x0274	; 0x800274 <xNextTaskUnblockTime+0x1>
    17f8:	e8 16       	cp	r14, r24
    17fa:	f9 06       	cpc	r15, r25
    17fc:	10 f4       	brcc	.+4      	; 0x1802 <xTaskIncrementTick+0x72>
    17fe:	d1 2c       	mov	r13, r1
    1800:	53 c0       	rjmp	.+166    	; 0x18a8 <xTaskIncrementTick+0x118>
    1802:	d1 2c       	mov	r13, r1
    1804:	cc 24       	eor	r12, r12
    1806:	c3 94       	inc	r12
    1808:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <pxDelayedTaskList>
    180c:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    1810:	80 81       	ld	r24, Z
    1812:	81 11       	cpse	r24, r1
    1814:	07 c0       	rjmp	.+14     	; 0x1824 <xTaskIncrementTick+0x94>
    1816:	8f ef       	ldi	r24, 0xFF	; 255
    1818:	9f ef       	ldi	r25, 0xFF	; 255
    181a:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <xNextTaskUnblockTime+0x1>
    181e:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <xNextTaskUnblockTime>
    1822:	42 c0       	rjmp	.+132    	; 0x18a8 <xTaskIncrementTick+0x118>
    1824:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <pxDelayedTaskList>
    1828:	f0 91 9d 02 	lds	r31, 0x029D	; 0x80029d <pxDelayedTaskList+0x1>
    182c:	05 80       	ldd	r0, Z+5	; 0x05
    182e:	f6 81       	ldd	r31, Z+6	; 0x06
    1830:	e0 2d       	mov	r30, r0
    1832:	c6 81       	ldd	r28, Z+6	; 0x06
    1834:	d7 81       	ldd	r29, Z+7	; 0x07
    1836:	8a 81       	ldd	r24, Y+2	; 0x02
    1838:	9b 81       	ldd	r25, Y+3	; 0x03
    183a:	e8 16       	cp	r14, r24
    183c:	f9 06       	cpc	r15, r25
    183e:	28 f4       	brcc	.+10     	; 0x184a <xTaskIncrementTick+0xba>
    1840:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <xNextTaskUnblockTime+0x1>
    1844:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <xNextTaskUnblockTime>
    1848:	2f c0       	rjmp	.+94     	; 0x18a8 <xTaskIncrementTick+0x118>
    184a:	8e 01       	movw	r16, r28
    184c:	0e 5f       	subi	r16, 0xFE	; 254
    184e:	1f 4f       	sbci	r17, 0xFF	; 255
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1856:	8c 89       	ldd	r24, Y+20	; 0x14
    1858:	9d 89       	ldd	r25, Y+21	; 0x15
    185a:	89 2b       	or	r24, r25
    185c:	21 f0       	breq	.+8      	; 0x1866 <xTaskIncrementTick+0xd6>
    185e:	ce 01       	movw	r24, r28
    1860:	0c 96       	adiw	r24, 0x0c	; 12
    1862:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1866:	8e 89       	ldd	r24, Y+22	; 0x16
    1868:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    186c:	98 17       	cp	r25, r24
    186e:	10 f4       	brcc	.+4      	; 0x1874 <xTaskIncrementTick+0xe4>
    1870:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	9c 01       	movw	r18, r24
    1878:	22 0f       	add	r18, r18
    187a:	33 1f       	adc	r19, r19
    187c:	22 0f       	add	r18, r18
    187e:	33 1f       	adc	r19, r19
    1880:	22 0f       	add	r18, r18
    1882:	33 1f       	adc	r19, r19
    1884:	82 0f       	add	r24, r18
    1886:	93 1f       	adc	r25, r19
    1888:	b8 01       	movw	r22, r16
    188a:	80 55       	subi	r24, 0x50	; 80
    188c:	9d 4f       	sbci	r25, 0xFD	; 253
    188e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1892:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1896:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    189a:	9e 89       	ldd	r25, Y+22	; 0x16
    189c:	86 89       	ldd	r24, Z+22	; 0x16
    189e:	98 17       	cp	r25, r24
    18a0:	08 f4       	brcc	.+2      	; 0x18a4 <xTaskIncrementTick+0x114>
    18a2:	b2 cf       	rjmp	.-156    	; 0x1808 <xTaskIncrementTick+0x78>
    18a4:	dc 2c       	mov	r13, r12
    18a6:	b0 cf       	rjmp	.-160    	; 0x1808 <xTaskIncrementTick+0x78>
    18a8:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    18ac:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    18b0:	86 89       	ldd	r24, Z+22	; 0x16
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	fc 01       	movw	r30, r24
    18b6:	ee 0f       	add	r30, r30
    18b8:	ff 1f       	adc	r31, r31
    18ba:	ee 0f       	add	r30, r30
    18bc:	ff 1f       	adc	r31, r31
    18be:	ee 0f       	add	r30, r30
    18c0:	ff 1f       	adc	r31, r31
    18c2:	8e 0f       	add	r24, r30
    18c4:	9f 1f       	adc	r25, r31
    18c6:	fc 01       	movw	r30, r24
    18c8:	e0 55       	subi	r30, 0x50	; 80
    18ca:	fd 4f       	sbci	r31, 0xFD	; 253
    18cc:	80 81       	ld	r24, Z
    18ce:	82 30       	cpi	r24, 0x02	; 2
    18d0:	48 f0       	brcs	.+18     	; 0x18e4 <xTaskIncrementTick+0x154>
    18d2:	dd 24       	eor	r13, r13
    18d4:	d3 94       	inc	r13
    18d6:	06 c0       	rjmp	.+12     	; 0x18e4 <xTaskIncrementTick+0x154>
    18d8:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <uxPendedTicks>
    18dc:	8f 5f       	subi	r24, 0xFF	; 255
    18de:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <uxPendedTicks>
    18e2:	d1 2c       	mov	r13, r1
    18e4:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xYieldPending>
    18e8:	88 23       	and	r24, r24
    18ea:	11 f0       	breq	.+4      	; 0x18f0 <xTaskIncrementTick+0x160>
    18ec:	dd 24       	eor	r13, r13
    18ee:	d3 94       	inc	r13
    18f0:	8d 2d       	mov	r24, r13
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	ff 90       	pop	r15
    18fc:	ef 90       	pop	r14
    18fe:	df 90       	pop	r13
    1900:	cf 90       	pop	r12
    1902:	08 95       	ret

00001904 <xTaskResumeAll>:
    1904:	df 92       	push	r13
    1906:	ef 92       	push	r14
    1908:	ff 92       	push	r15
    190a:	0f 93       	push	r16
    190c:	1f 93       	push	r17
    190e:	cf 93       	push	r28
    1910:	df 93       	push	r29
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	0f 92       	push	r0
    1918:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    191c:	81 50       	subi	r24, 0x01	; 1
    191e:	80 93 70 02 	sts	0x0270, r24	; 0x800270 <uxSchedulerSuspended>
    1922:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    1926:	81 11       	cpse	r24, r1
    1928:	5d c0       	rjmp	.+186    	; 0x19e4 <xTaskResumeAll+0xe0>
    192a:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <uxCurrentNumberOfTasks>
    192e:	81 11       	cpse	r24, r1
    1930:	33 c0       	rjmp	.+102    	; 0x1998 <xTaskResumeAll+0x94>
    1932:	5b c0       	rjmp	.+182    	; 0x19ea <xTaskResumeAll+0xe6>
    1934:	d7 01       	movw	r26, r14
    1936:	15 96       	adiw	r26, 0x05	; 5
    1938:	ed 91       	ld	r30, X+
    193a:	fc 91       	ld	r31, X
    193c:	16 97       	sbiw	r26, 0x06	; 6
    193e:	c6 81       	ldd	r28, Z+6	; 0x06
    1940:	d7 81       	ldd	r29, Z+7	; 0x07
    1942:	ce 01       	movw	r24, r28
    1944:	0c 96       	adiw	r24, 0x0c	; 12
    1946:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    194a:	8e 01       	movw	r16, r28
    194c:	0e 5f       	subi	r16, 0xFE	; 254
    194e:	1f 4f       	sbci	r17, 0xFF	; 255
    1950:	c8 01       	movw	r24, r16
    1952:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1956:	8e 89       	ldd	r24, Y+22	; 0x16
    1958:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    195c:	98 17       	cp	r25, r24
    195e:	10 f4       	brcc	.+4      	; 0x1964 <xTaskResumeAll+0x60>
    1960:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    1964:	90 e0       	ldi	r25, 0x00	; 0
    1966:	9c 01       	movw	r18, r24
    1968:	22 0f       	add	r18, r18
    196a:	33 1f       	adc	r19, r19
    196c:	22 0f       	add	r18, r18
    196e:	33 1f       	adc	r19, r19
    1970:	22 0f       	add	r18, r18
    1972:	33 1f       	adc	r19, r19
    1974:	82 0f       	add	r24, r18
    1976:	93 1f       	adc	r25, r19
    1978:	b8 01       	movw	r22, r16
    197a:	80 55       	subi	r24, 0x50	; 80
    197c:	9d 4f       	sbci	r25, 0xFD	; 253
    197e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1982:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1986:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    198a:	9e 89       	ldd	r25, Y+22	; 0x16
    198c:	86 89       	ldd	r24, Z+22	; 0x16
    198e:	98 17       	cp	r25, r24
    1990:	68 f0       	brcs	.+26     	; 0x19ac <xTaskResumeAll+0xa8>
    1992:	d0 92 77 02 	sts	0x0277, r13	; 0x800277 <xYieldPending>
    1996:	0a c0       	rjmp	.+20     	; 0x19ac <xTaskResumeAll+0xa8>
    1998:	c0 e0       	ldi	r28, 0x00	; 0
    199a:	d0 e0       	ldi	r29, 0x00	; 0
    199c:	0f 2e       	mov	r0, r31
    199e:	f1 e9       	ldi	r31, 0x91	; 145
    19a0:	ef 2e       	mov	r14, r31
    19a2:	f2 e0       	ldi	r31, 0x02	; 2
    19a4:	ff 2e       	mov	r15, r31
    19a6:	f0 2d       	mov	r31, r0
    19a8:	dd 24       	eor	r13, r13
    19aa:	d3 94       	inc	r13
    19ac:	f7 01       	movw	r30, r14
    19ae:	80 81       	ld	r24, Z
    19b0:	81 11       	cpse	r24, r1
    19b2:	c0 cf       	rjmp	.-128    	; 0x1934 <xTaskResumeAll+0x30>
    19b4:	cd 2b       	or	r28, r29
    19b6:	09 f0       	breq	.+2      	; 0x19ba <xTaskResumeAll+0xb6>
    19b8:	2e dd       	rcall	.-1444   	; 0x1416 <prvResetNextTaskUnblockTime>
    19ba:	c0 91 78 02 	lds	r28, 0x0278	; 0x800278 <uxPendedTicks>
    19be:	cc 23       	and	r28, r28
    19c0:	49 f0       	breq	.+18     	; 0x19d4 <xTaskResumeAll+0xd0>
    19c2:	d1 e0       	ldi	r29, 0x01	; 1
    19c4:	e5 de       	rcall	.-566    	; 0x1790 <xTaskIncrementTick>
    19c6:	81 11       	cpse	r24, r1
    19c8:	d0 93 77 02 	sts	0x0277, r29	; 0x800277 <xYieldPending>
    19cc:	c1 50       	subi	r28, 0x01	; 1
    19ce:	d1 f7       	brne	.-12     	; 0x19c4 <xTaskResumeAll+0xc0>
    19d0:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <uxPendedTicks>
    19d4:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <xYieldPending>
    19d8:	88 23       	and	r24, r24
    19da:	31 f0       	breq	.+12     	; 0x19e8 <xTaskResumeAll+0xe4>
    19dc:	0e 94 16 04 	call	0x82c	; 0x82c <vPortYield>
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	03 c0       	rjmp	.+6      	; 0x19ea <xTaskResumeAll+0xe6>
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	01 c0       	rjmp	.+2      	; 0x19ea <xTaskResumeAll+0xe6>
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	df 91       	pop	r29
    19f0:	cf 91       	pop	r28
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	ff 90       	pop	r15
    19f8:	ef 90       	pop	r14
    19fa:	df 90       	pop	r13
    19fc:	08 95       	ret

000019fe <vTaskDelayUntil>:
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	8c 01       	movw	r16, r24
    1a08:	eb 01       	movw	r28, r22
    1a0a:	b2 de       	rcall	.-668    	; 0x1770 <vTaskSuspendAll>
    1a0c:	40 91 7b 02 	lds	r20, 0x027B	; 0x80027b <xTickCount>
    1a10:	50 91 7c 02 	lds	r21, 0x027C	; 0x80027c <xTickCount+0x1>
    1a14:	f8 01       	movw	r30, r16
    1a16:	20 81       	ld	r18, Z
    1a18:	31 81       	ldd	r19, Z+1	; 0x01
    1a1a:	c9 01       	movw	r24, r18
    1a1c:	8c 0f       	add	r24, r28
    1a1e:	9d 1f       	adc	r25, r29
    1a20:	42 17       	cp	r20, r18
    1a22:	53 07       	cpc	r21, r19
    1a24:	48 f4       	brcc	.+18     	; 0x1a38 <vTaskDelayUntil+0x3a>
    1a26:	82 17       	cp	r24, r18
    1a28:	93 07       	cpc	r25, r19
    1a2a:	d8 f4       	brcc	.+54     	; 0x1a62 <vTaskDelayUntil+0x64>
    1a2c:	91 83       	std	Z+1, r25	; 0x01
    1a2e:	80 83       	st	Z, r24
    1a30:	48 17       	cp	r20, r24
    1a32:	59 07       	cpc	r21, r25
    1a34:	60 f4       	brcc	.+24     	; 0x1a4e <vTaskDelayUntil+0x50>
    1a36:	07 c0       	rjmp	.+14     	; 0x1a46 <vTaskDelayUntil+0x48>
    1a38:	82 17       	cp	r24, r18
    1a3a:	93 07       	cpc	r25, r19
    1a3c:	70 f0       	brcs	.+28     	; 0x1a5a <vTaskDelayUntil+0x5c>
    1a3e:	48 17       	cp	r20, r24
    1a40:	59 07       	cpc	r21, r25
    1a42:	58 f0       	brcs	.+22     	; 0x1a5a <vTaskDelayUntil+0x5c>
    1a44:	0e c0       	rjmp	.+28     	; 0x1a62 <vTaskDelayUntil+0x64>
    1a46:	60 e0       	ldi	r22, 0x00	; 0
    1a48:	84 1b       	sub	r24, r20
    1a4a:	95 0b       	sbc	r25, r21
    1a4c:	03 dd       	rcall	.-1530   	; 0x1454 <prvAddCurrentTaskToDelayedList>
    1a4e:	5a df       	rcall	.-332    	; 0x1904 <xTaskResumeAll>
    1a50:	81 11       	cpse	r24, r1
    1a52:	0b c0       	rjmp	.+22     	; 0x1a6a <vTaskDelayUntil+0x6c>
    1a54:	0e 94 16 04 	call	0x82c	; 0x82c <vPortYield>
    1a58:	08 c0       	rjmp	.+16     	; 0x1a6a <vTaskDelayUntil+0x6c>
    1a5a:	f8 01       	movw	r30, r16
    1a5c:	91 83       	std	Z+1, r25	; 0x01
    1a5e:	80 83       	st	Z, r24
    1a60:	f2 cf       	rjmp	.-28     	; 0x1a46 <vTaskDelayUntil+0x48>
    1a62:	f8 01       	movw	r30, r16
    1a64:	91 83       	std	Z+1, r25	; 0x01
    1a66:	80 83       	st	Z, r24
    1a68:	f2 cf       	rjmp	.-28     	; 0x1a4e <vTaskDelayUntil+0x50>
    1a6a:	df 91       	pop	r29
    1a6c:	cf 91       	pop	r28
    1a6e:	1f 91       	pop	r17
    1a70:	0f 91       	pop	r16
    1a72:	08 95       	ret

00001a74 <vTaskSwitchContext>:
    1a74:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    1a78:	88 23       	and	r24, r24
    1a7a:	21 f0       	breq	.+8      	; 0x1a84 <vTaskSwitchContext+0x10>
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <xYieldPending>
    1a82:	08 95       	ret
    1a84:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <xYieldPending>
    1a88:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1a8c:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1a90:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1a94:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1a98:	2d 91       	ld	r18, X+
    1a9a:	3c 91       	ld	r19, X
    1a9c:	87 89       	ldd	r24, Z+23	; 0x17
    1a9e:	90 8d       	ldd	r25, Z+24	; 0x18
    1aa0:	82 17       	cp	r24, r18
    1aa2:	93 07       	cpc	r25, r19
    1aa4:	60 f0       	brcs	.+24     	; 0x1abe <vTaskSwitchContext+0x4a>
    1aa6:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1aaa:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1aae:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1ab2:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1ab6:	67 5e       	subi	r22, 0xE7	; 231
    1ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aba:	0e 94 d7 01 	call	0x3ae	; 0x3ae <vApplicationStackOverflowHook>
    1abe:	20 91 7a 02 	lds	r18, 0x027A	; 0x80027a <uxTopReadyPriority>
    1ac2:	82 2f       	mov	r24, r18
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	fc 01       	movw	r30, r24
    1ac8:	ee 0f       	add	r30, r30
    1aca:	ff 1f       	adc	r31, r31
    1acc:	ee 0f       	add	r30, r30
    1ace:	ff 1f       	adc	r31, r31
    1ad0:	ee 0f       	add	r30, r30
    1ad2:	ff 1f       	adc	r31, r31
    1ad4:	e8 0f       	add	r30, r24
    1ad6:	f9 1f       	adc	r31, r25
    1ad8:	e0 55       	subi	r30, 0x50	; 80
    1ada:	fd 4f       	sbci	r31, 0xFD	; 253
    1adc:	30 81       	ld	r19, Z
    1ade:	31 11       	cpse	r19, r1
    1ae0:	11 c0       	rjmp	.+34     	; 0x1b04 <vTaskSwitchContext+0x90>
    1ae2:	21 50       	subi	r18, 0x01	; 1
    1ae4:	82 2f       	mov	r24, r18
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	fc 01       	movw	r30, r24
    1aea:	ee 0f       	add	r30, r30
    1aec:	ff 1f       	adc	r31, r31
    1aee:	ee 0f       	add	r30, r30
    1af0:	ff 1f       	adc	r31, r31
    1af2:	ee 0f       	add	r30, r30
    1af4:	ff 1f       	adc	r31, r31
    1af6:	e8 0f       	add	r30, r24
    1af8:	f9 1f       	adc	r31, r25
    1afa:	e0 55       	subi	r30, 0x50	; 80
    1afc:	fd 4f       	sbci	r31, 0xFD	; 253
    1afe:	30 81       	ld	r19, Z
    1b00:	33 23       	and	r19, r19
    1b02:	79 f3       	breq	.-34     	; 0x1ae2 <vTaskSwitchContext+0x6e>
    1b04:	ac 01       	movw	r20, r24
    1b06:	44 0f       	add	r20, r20
    1b08:	55 1f       	adc	r21, r21
    1b0a:	44 0f       	add	r20, r20
    1b0c:	55 1f       	adc	r21, r21
    1b0e:	44 0f       	add	r20, r20
    1b10:	55 1f       	adc	r21, r21
    1b12:	48 0f       	add	r20, r24
    1b14:	59 1f       	adc	r21, r25
    1b16:	da 01       	movw	r26, r20
    1b18:	a0 55       	subi	r26, 0x50	; 80
    1b1a:	bd 4f       	sbci	r27, 0xFD	; 253
    1b1c:	11 96       	adiw	r26, 0x01	; 1
    1b1e:	ed 91       	ld	r30, X+
    1b20:	fc 91       	ld	r31, X
    1b22:	12 97       	sbiw	r26, 0x02	; 2
    1b24:	02 80       	ldd	r0, Z+2	; 0x02
    1b26:	f3 81       	ldd	r31, Z+3	; 0x03
    1b28:	e0 2d       	mov	r30, r0
    1b2a:	12 96       	adiw	r26, 0x02	; 2
    1b2c:	fc 93       	st	X, r31
    1b2e:	ee 93       	st	-X, r30
    1b30:	11 97       	sbiw	r26, 0x01	; 1
    1b32:	4d 54       	subi	r20, 0x4D	; 77
    1b34:	5d 4f       	sbci	r21, 0xFD	; 253
    1b36:	e4 17       	cp	r30, r20
    1b38:	f5 07       	cpc	r31, r21
    1b3a:	29 f4       	brne	.+10     	; 0x1b46 <vTaskSwitchContext+0xd2>
    1b3c:	42 81       	ldd	r20, Z+2	; 0x02
    1b3e:	53 81       	ldd	r21, Z+3	; 0x03
    1b40:	fd 01       	movw	r30, r26
    1b42:	52 83       	std	Z+2, r21	; 0x02
    1b44:	41 83       	std	Z+1, r20	; 0x01
    1b46:	fc 01       	movw	r30, r24
    1b48:	ee 0f       	add	r30, r30
    1b4a:	ff 1f       	adc	r31, r31
    1b4c:	ee 0f       	add	r30, r30
    1b4e:	ff 1f       	adc	r31, r31
    1b50:	ee 0f       	add	r30, r30
    1b52:	ff 1f       	adc	r31, r31
    1b54:	8e 0f       	add	r24, r30
    1b56:	9f 1f       	adc	r25, r31
    1b58:	fc 01       	movw	r30, r24
    1b5a:	e0 55       	subi	r30, 0x50	; 80
    1b5c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b5e:	01 80       	ldd	r0, Z+1	; 0x01
    1b60:	f2 81       	ldd	r31, Z+2	; 0x02
    1b62:	e0 2d       	mov	r30, r0
    1b64:	86 81       	ldd	r24, Z+6	; 0x06
    1b66:	97 81       	ldd	r25, Z+7	; 0x07
    1b68:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <pxCurrentTCB+0x1>
    1b6c:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <pxCurrentTCB>
    1b70:	20 93 7a 02 	sts	0x027A, r18	; 0x80027a <uxTopReadyPriority>
    1b74:	08 95       	ret

00001b76 <vTaskPlaceOnEventList>:
    1b76:	cf 93       	push	r28
    1b78:	df 93       	push	r29
    1b7a:	eb 01       	movw	r28, r22
    1b7c:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1b80:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1b84:	64 5f       	subi	r22, 0xF4	; 244
    1b86:	7f 4f       	sbci	r23, 0xFF	; 255
    1b88:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsert>
    1b8c:	61 e0       	ldi	r22, 0x01	; 1
    1b8e:	ce 01       	movw	r24, r28
    1b90:	61 dc       	rcall	.-1854   	; 0x1454 <prvAddCurrentTaskToDelayedList>
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	08 95       	ret

00001b98 <xTaskRemoveFromEventList>:
    1b98:	0f 93       	push	r16
    1b9a:	1f 93       	push	r17
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	dc 01       	movw	r26, r24
    1ba2:	15 96       	adiw	r26, 0x05	; 5
    1ba4:	ed 91       	ld	r30, X+
    1ba6:	fc 91       	ld	r31, X
    1ba8:	16 97       	sbiw	r26, 0x06	; 6
    1baa:	c6 81       	ldd	r28, Z+6	; 0x06
    1bac:	d7 81       	ldd	r29, Z+7	; 0x07
    1bae:	8e 01       	movw	r16, r28
    1bb0:	04 5f       	subi	r16, 0xF4	; 244
    1bb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1bba:	80 91 70 02 	lds	r24, 0x0270	; 0x800270 <uxSchedulerSuspended>
    1bbe:	81 11       	cpse	r24, r1
    1bc0:	1c c0       	rjmp	.+56     	; 0x1bfa <xTaskRemoveFromEventList+0x62>
    1bc2:	0a 50       	subi	r16, 0x0A	; 10
    1bc4:	11 09       	sbc	r17, r1
    1bc6:	c8 01       	movw	r24, r16
    1bc8:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1bcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1bce:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    1bd2:	98 17       	cp	r25, r24
    1bd4:	10 f4       	brcc	.+4      	; 0x1bda <xTaskRemoveFromEventList+0x42>
    1bd6:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	9c 01       	movw	r18, r24
    1bde:	22 0f       	add	r18, r18
    1be0:	33 1f       	adc	r19, r19
    1be2:	22 0f       	add	r18, r18
    1be4:	33 1f       	adc	r19, r19
    1be6:	22 0f       	add	r18, r18
    1be8:	33 1f       	adc	r19, r19
    1bea:	82 0f       	add	r24, r18
    1bec:	93 1f       	adc	r25, r19
    1bee:	b8 01       	movw	r22, r16
    1bf0:	80 55       	subi	r24, 0x50	; 80
    1bf2:	9d 4f       	sbci	r25, 0xFD	; 253
    1bf4:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1bf8:	05 c0       	rjmp	.+10     	; 0x1c04 <xTaskRemoveFromEventList+0x6c>
    1bfa:	b8 01       	movw	r22, r16
    1bfc:	81 e9       	ldi	r24, 0x91	; 145
    1bfe:	92 e0       	ldi	r25, 0x02	; 2
    1c00:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1c04:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1c08:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1c0c:	9e 89       	ldd	r25, Y+22	; 0x16
    1c0e:	86 89       	ldd	r24, Z+22	; 0x16
    1c10:	89 17       	cp	r24, r25
    1c12:	20 f4       	brcc	.+8      	; 0x1c1c <xTaskRemoveFromEventList+0x84>
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <xYieldPending>
    1c1a:	01 c0       	rjmp	.+2      	; 0x1c1e <xTaskRemoveFromEventList+0x86>
    1c1c:	80 e0       	ldi	r24, 0x00	; 0
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	1f 91       	pop	r17
    1c24:	0f 91       	pop	r16
    1c26:	08 95       	ret

00001c28 <vTaskSetTimeOutState>:
    1c28:	20 91 76 02 	lds	r18, 0x0276	; 0x800276 <xNumOfOverflows>
    1c2c:	fc 01       	movw	r30, r24
    1c2e:	20 83       	st	Z, r18
    1c30:	20 91 7b 02 	lds	r18, 0x027B	; 0x80027b <xTickCount>
    1c34:	30 91 7c 02 	lds	r19, 0x027C	; 0x80027c <xTickCount+0x1>
    1c38:	32 83       	std	Z+2, r19	; 0x02
    1c3a:	21 83       	std	Z+1, r18	; 0x01
    1c3c:	08 95       	ret

00001c3e <xTaskCheckForTimeOut>:
    1c3e:	0f b6       	in	r0, 0x3f	; 63
    1c40:	f8 94       	cli
    1c42:	0f 92       	push	r0
    1c44:	40 91 7b 02 	lds	r20, 0x027B	; 0x80027b <xTickCount>
    1c48:	50 91 7c 02 	lds	r21, 0x027C	; 0x80027c <xTickCount+0x1>
    1c4c:	db 01       	movw	r26, r22
    1c4e:	2d 91       	ld	r18, X+
    1c50:	3c 91       	ld	r19, X
    1c52:	2f 3f       	cpi	r18, 0xFF	; 255
    1c54:	bf ef       	ldi	r27, 0xFF	; 255
    1c56:	3b 07       	cpc	r19, r27
    1c58:	11 f1       	breq	.+68     	; 0x1c9e <xTaskCheckForTimeOut+0x60>
    1c5a:	e0 91 76 02 	lds	r30, 0x0276	; 0x800276 <xNumOfOverflows>
    1c5e:	dc 01       	movw	r26, r24
    1c60:	fc 91       	ld	r31, X
    1c62:	fe 17       	cp	r31, r30
    1c64:	39 f0       	breq	.+14     	; 0x1c74 <xTaskCheckForTimeOut+0x36>
    1c66:	11 96       	adiw	r26, 0x01	; 1
    1c68:	ed 91       	ld	r30, X+
    1c6a:	fc 91       	ld	r31, X
    1c6c:	12 97       	sbiw	r26, 0x02	; 2
    1c6e:	4e 17       	cp	r20, r30
    1c70:	5f 07       	cpc	r21, r31
    1c72:	b8 f4       	brcc	.+46     	; 0x1ca2 <xTaskCheckForTimeOut+0x64>
    1c74:	dc 01       	movw	r26, r24
    1c76:	11 96       	adiw	r26, 0x01	; 1
    1c78:	ed 91       	ld	r30, X+
    1c7a:	fc 91       	ld	r31, X
    1c7c:	12 97       	sbiw	r26, 0x02	; 2
    1c7e:	da 01       	movw	r26, r20
    1c80:	ae 1b       	sub	r26, r30
    1c82:	bf 0b       	sbc	r27, r31
    1c84:	a2 17       	cp	r26, r18
    1c86:	b3 07       	cpc	r27, r19
    1c88:	70 f4       	brcc	.+28     	; 0x1ca6 <xTaskCheckForTimeOut+0x68>
    1c8a:	db 01       	movw	r26, r22
    1c8c:	e4 1b       	sub	r30, r20
    1c8e:	f5 0b       	sbc	r31, r21
    1c90:	2e 0f       	add	r18, r30
    1c92:	3f 1f       	adc	r19, r31
    1c94:	2d 93       	st	X+, r18
    1c96:	3c 93       	st	X, r19
    1c98:	c7 df       	rcall	.-114    	; 0x1c28 <vTaskSetTimeOutState>
    1c9a:	80 e0       	ldi	r24, 0x00	; 0
    1c9c:	05 c0       	rjmp	.+10     	; 0x1ca8 <xTaskCheckForTimeOut+0x6a>
    1c9e:	80 e0       	ldi	r24, 0x00	; 0
    1ca0:	03 c0       	rjmp	.+6      	; 0x1ca8 <xTaskCheckForTimeOut+0x6a>
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	01 c0       	rjmp	.+2      	; 0x1ca8 <xTaskCheckForTimeOut+0x6a>
    1ca6:	81 e0       	ldi	r24, 0x01	; 1
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	08 95       	ret

00001cae <vTaskMissedYield>:
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <xYieldPending>
    1cb4:	08 95       	ret

00001cb6 <vTaskPriorityInherit>:
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	fc 01       	movw	r30, r24
    1cc0:	89 2b       	or	r24, r25
    1cc2:	09 f4       	brne	.+2      	; 0x1cc6 <vTaskPriorityInherit+0x10>
    1cc4:	55 c0       	rjmp	.+170    	; 0x1d70 <vTaskPriorityInherit+0xba>
    1cc6:	26 89       	ldd	r18, Z+22	; 0x16
    1cc8:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1ccc:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1cd0:	56 96       	adiw	r26, 0x16	; 22
    1cd2:	8c 91       	ld	r24, X
    1cd4:	28 17       	cp	r18, r24
    1cd6:	08 f0       	brcs	.+2      	; 0x1cda <vTaskPriorityInherit+0x24>
    1cd8:	4b c0       	rjmp	.+150    	; 0x1d70 <vTaskPriorityInherit+0xba>
    1cda:	84 85       	ldd	r24, Z+12	; 0x0c
    1cdc:	95 85       	ldd	r25, Z+13	; 0x0d
    1cde:	99 23       	and	r25, r25
    1ce0:	64 f0       	brlt	.+24     	; 0x1cfa <vTaskPriorityInherit+0x44>
    1ce2:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1ce6:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1cea:	56 96       	adiw	r26, 0x16	; 22
    1cec:	3c 91       	ld	r19, X
    1cee:	84 e0       	ldi	r24, 0x04	; 4
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	83 1b       	sub	r24, r19
    1cf4:	91 09       	sbc	r25, r1
    1cf6:	95 87       	std	Z+13, r25	; 0x0d
    1cf8:	84 87       	std	Z+12, r24	; 0x0c
    1cfa:	30 e0       	ldi	r19, 0x00	; 0
    1cfc:	c9 01       	movw	r24, r18
    1cfe:	88 0f       	add	r24, r24
    1d00:	99 1f       	adc	r25, r25
    1d02:	88 0f       	add	r24, r24
    1d04:	99 1f       	adc	r25, r25
    1d06:	88 0f       	add	r24, r24
    1d08:	99 1f       	adc	r25, r25
    1d0a:	28 0f       	add	r18, r24
    1d0c:	39 1f       	adc	r19, r25
    1d0e:	20 55       	subi	r18, 0x50	; 80
    1d10:	3d 4f       	sbci	r19, 0xFD	; 253
    1d12:	82 85       	ldd	r24, Z+10	; 0x0a
    1d14:	93 85       	ldd	r25, Z+11	; 0x0b
    1d16:	82 17       	cp	r24, r18
    1d18:	93 07       	cpc	r25, r19
    1d1a:	19 f5       	brne	.+70     	; 0x1d62 <vTaskPriorityInherit+0xac>
    1d1c:	8f 01       	movw	r16, r30
    1d1e:	ef 01       	movw	r28, r30
    1d20:	22 96       	adiw	r28, 0x02	; 2
    1d22:	ce 01       	movw	r24, r28
    1d24:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1d28:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1d2c:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1d30:	86 89       	ldd	r24, Z+22	; 0x16
    1d32:	f8 01       	movw	r30, r16
    1d34:	86 8b       	std	Z+22, r24	; 0x16
    1d36:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    1d3a:	98 17       	cp	r25, r24
    1d3c:	10 f4       	brcc	.+4      	; 0x1d42 <vTaskPriorityInherit+0x8c>
    1d3e:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	9c 01       	movw	r18, r24
    1d46:	22 0f       	add	r18, r18
    1d48:	33 1f       	adc	r19, r19
    1d4a:	22 0f       	add	r18, r18
    1d4c:	33 1f       	adc	r19, r19
    1d4e:	22 0f       	add	r18, r18
    1d50:	33 1f       	adc	r19, r19
    1d52:	82 0f       	add	r24, r18
    1d54:	93 1f       	adc	r25, r19
    1d56:	be 01       	movw	r22, r28
    1d58:	80 55       	subi	r24, 0x50	; 80
    1d5a:	9d 4f       	sbci	r25, 0xFD	; 253
    1d5c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1d60:	07 c0       	rjmp	.+14     	; 0x1d70 <vTaskPriorityInherit+0xba>
    1d62:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1d66:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1d6a:	56 96       	adiw	r26, 0x16	; 22
    1d6c:	8c 91       	ld	r24, X
    1d6e:	86 8b       	std	Z+22, r24	; 0x16
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
    1d74:	1f 91       	pop	r17
    1d76:	0f 91       	pop	r16
    1d78:	08 95       	ret

00001d7a <xTaskPriorityDisinherit>:
    1d7a:	0f 93       	push	r16
    1d7c:	1f 93       	push	r17
    1d7e:	cf 93       	push	r28
    1d80:	df 93       	push	r29
    1d82:	fc 01       	movw	r30, r24
    1d84:	89 2b       	or	r24, r25
    1d86:	79 f1       	breq	.+94     	; 0x1de6 <xTaskPriorityDisinherit+0x6c>
    1d88:	82 a1       	ldd	r24, Z+34	; 0x22
    1d8a:	81 50       	subi	r24, 0x01	; 1
    1d8c:	82 a3       	std	Z+34, r24	; 0x22
    1d8e:	26 89       	ldd	r18, Z+22	; 0x16
    1d90:	91 a1       	ldd	r25, Z+33	; 0x21
    1d92:	29 17       	cp	r18, r25
    1d94:	51 f1       	breq	.+84     	; 0x1dea <xTaskPriorityDisinherit+0x70>
    1d96:	81 11       	cpse	r24, r1
    1d98:	2a c0       	rjmp	.+84     	; 0x1dee <xTaskPriorityDisinherit+0x74>
    1d9a:	ef 01       	movw	r28, r30
    1d9c:	8f 01       	movw	r16, r30
    1d9e:	0e 5f       	subi	r16, 0xFE	; 254
    1da0:	1f 4f       	sbci	r17, 0xFF	; 255
    1da2:	c8 01       	movw	r24, r16
    1da4:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1da8:	89 a1       	ldd	r24, Y+33	; 0x21
    1daa:	8e 8b       	std	Y+22, r24	; 0x16
    1dac:	24 e0       	ldi	r18, 0x04	; 4
    1dae:	30 e0       	ldi	r19, 0x00	; 0
    1db0:	28 1b       	sub	r18, r24
    1db2:	31 09       	sbc	r19, r1
    1db4:	3d 87       	std	Y+13, r19	; 0x0d
    1db6:	2c 87       	std	Y+12, r18	; 0x0c
    1db8:	90 91 7a 02 	lds	r25, 0x027A	; 0x80027a <uxTopReadyPriority>
    1dbc:	98 17       	cp	r25, r24
    1dbe:	10 f4       	brcc	.+4      	; 0x1dc4 <xTaskPriorityDisinherit+0x4a>
    1dc0:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <uxTopReadyPriority>
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	9c 01       	movw	r18, r24
    1dc8:	22 0f       	add	r18, r18
    1dca:	33 1f       	adc	r19, r19
    1dcc:	22 0f       	add	r18, r18
    1dce:	33 1f       	adc	r19, r19
    1dd0:	22 0f       	add	r18, r18
    1dd2:	33 1f       	adc	r19, r19
    1dd4:	82 0f       	add	r24, r18
    1dd6:	93 1f       	adc	r25, r19
    1dd8:	b8 01       	movw	r22, r16
    1dda:	80 55       	subi	r24, 0x50	; 80
    1ddc:	9d 4f       	sbci	r25, 0xFD	; 253
    1dde:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	05 c0       	rjmp	.+10     	; 0x1df0 <xTaskPriorityDisinherit+0x76>
    1de6:	80 e0       	ldi	r24, 0x00	; 0
    1de8:	03 c0       	rjmp	.+6      	; 0x1df0 <xTaskPriorityDisinherit+0x76>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	01 c0       	rjmp	.+2      	; 0x1df0 <xTaskPriorityDisinherit+0x76>
    1dee:	80 e0       	ldi	r24, 0x00	; 0
    1df0:	df 91       	pop	r29
    1df2:	cf 91       	pop	r28
    1df4:	1f 91       	pop	r17
    1df6:	0f 91       	pop	r16
    1df8:	08 95       	ret

00001dfa <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1dfa:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1dfe:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1e02:	89 2b       	or	r24, r25
    1e04:	39 f0       	breq	.+14     	; 0x1e14 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1e06:	e0 91 d4 02 	lds	r30, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1e0a:	f0 91 d5 02 	lds	r31, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
    1e0e:	82 a1       	ldd	r24, Z+34	; 0x22
    1e10:	8f 5f       	subi	r24, 0xFF	; 255
    1e12:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1e14:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxCurrentTCB>
    1e18:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxCurrentTCB+0x1>
	}
    1e1c:	08 95       	ret

00001e1e <initUsart0>:
void writeInt(int16_t nr)
{
	char buffer[8];
	itoa(nr,buffer,10);
	writeString(buffer);
}
    1e1e:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1e22:	88 e1       	ldi	r24, 0x18	; 24
    1e24:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1e28:	86 e0       	ldi	r24, 0x06	; 6
    1e2a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1e2e:	87 e6       	ldi	r24, 0x67	; 103
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1e36:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1e3a:	08 95       	ret

00001e3c <main>:
    1e3c:	ef 92       	push	r14
    1e3e:	ff 92       	push	r15
    1e40:	0f 93       	push	r16
    1e42:	43 e0       	ldi	r20, 0x03	; 3
    1e44:	60 e0       	ldi	r22, 0x00	; 0
    1e46:	81 e0       	ldi	r24, 0x01	; 1
    1e48:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <xQueueGenericCreate>
    1e4c:	90 93 6f 03 	sts	0x036F, r25	; 0x80036f <sem+0x1>
    1e50:	80 93 6e 03 	sts	0x036E, r24	; 0x80036e <sem>
    1e54:	20 e0       	ldi	r18, 0x00	; 0
    1e56:	40 e0       	ldi	r20, 0x00	; 0
    1e58:	50 e0       	ldi	r21, 0x00	; 0
    1e5a:	60 e0       	ldi	r22, 0x00	; 0
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	0e 94 25 06 	call	0xc4a	; 0xc4a <xQueueGenericSend>
    1e62:	dd df       	rcall	.-70     	; 0x1e1e <initUsart0>
    1e64:	0f 2e       	mov	r0, r31
    1e66:	fc ed       	ldi	r31, 0xDC	; 220
    1e68:	ef 2e       	mov	r14, r31
    1e6a:	f2 e0       	ldi	r31, 0x02	; 2
    1e6c:	ff 2e       	mov	r15, r31
    1e6e:	f0 2d       	mov	r31, r0
    1e70:	03 e0       	ldi	r16, 0x03	; 3
    1e72:	20 e0       	ldi	r18, 0x00	; 0
    1e74:	30 e0       	ldi	r19, 0x00	; 0
    1e76:	40 e0       	ldi	r20, 0x00	; 0
    1e78:	51 e0       	ldi	r21, 0x01	; 1
    1e7a:	6c e0       	ldi	r22, 0x0C	; 12
    1e7c:	72 e0       	ldi	r23, 0x02	; 2
    1e7e:	8d e9       	ldi	r24, 0x9D	; 157
    1e80:	9f e0       	ldi	r25, 0x0F	; 15
    1e82:	3c db       	rcall	.-2440   	; 0x14fc <xTaskCreate>
    1e84:	0f 2e       	mov	r0, r31
    1e86:	fa ed       	ldi	r31, 0xDA	; 218
    1e88:	ef 2e       	mov	r14, r31
    1e8a:	f2 e0       	ldi	r31, 0x02	; 2
    1e8c:	ff 2e       	mov	r15, r31
    1e8e:	f0 2d       	mov	r31, r0
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	40 e0       	ldi	r20, 0x00	; 0
    1e96:	51 e0       	ldi	r21, 0x01	; 1
    1e98:	63 e1       	ldi	r22, 0x13	; 19
    1e9a:	72 e0       	ldi	r23, 0x02	; 2
    1e9c:	84 e8       	ldi	r24, 0x84	; 132
    1e9e:	9f e0       	ldi	r25, 0x0F	; 15
    1ea0:	2d db       	rcall	.-2470   	; 0x14fc <xTaskCreate>
    1ea2:	3e dc       	rcall	.-1924   	; 0x1720 <vTaskStartScheduler>
    1ea4:	80 e0       	ldi	r24, 0x00	; 0
    1ea6:	90 e0       	ldi	r25, 0x00	; 0
    1ea8:	0f 91       	pop	r16
    1eaa:	ff 90       	pop	r15
    1eac:	ef 90       	pop	r14
    1eae:	08 95       	ret

00001eb0 <writeChar>:
    1eb0:	e0 ec       	ldi	r30, 0xC0	; 192
    1eb2:	f0 e0       	ldi	r31, 0x00	; 0
    1eb4:	90 81       	ld	r25, Z
    1eb6:	95 ff       	sbrs	r25, 5
    1eb8:	fd cf       	rjmp	.-6      	; 0x1eb4 <writeChar+0x4>
    1eba:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1ebe:	08 95       	ret

00001ec0 <writeString>:
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	ec 01       	movw	r28, r24
    1ec6:	20 e0       	ldi	r18, 0x00	; 0
    1ec8:	4f ef       	ldi	r20, 0xFF	; 255
    1eca:	5f ef       	ldi	r21, 0xFF	; 255
    1ecc:	60 e0       	ldi	r22, 0x00	; 0
    1ece:	70 e0       	ldi	r23, 0x00	; 0
    1ed0:	80 91 6e 03 	lds	r24, 0x036E	; 0x80036e <sem>
    1ed4:	90 91 6f 03 	lds	r25, 0x036F	; 0x80036f <sem+0x1>
    1ed8:	0e 94 b7 06 	call	0xd6e	; 0xd6e <xQueueGenericReceive>
    1edc:	88 81       	ld	r24, Y
    1ede:	88 23       	and	r24, r24
    1ee0:	29 f0       	breq	.+10     	; 0x1eec <writeString+0x2c>
    1ee2:	21 96       	adiw	r28, 0x01	; 1
    1ee4:	e5 df       	rcall	.-54     	; 0x1eb0 <writeChar>
    1ee6:	89 91       	ld	r24, Y+
    1ee8:	81 11       	cpse	r24, r1
    1eea:	fc cf       	rjmp	.-8      	; 0x1ee4 <writeString+0x24>
    1eec:	20 e0       	ldi	r18, 0x00	; 0
    1eee:	40 e0       	ldi	r20, 0x00	; 0
    1ef0:	50 e0       	ldi	r21, 0x00	; 0
    1ef2:	60 e0       	ldi	r22, 0x00	; 0
    1ef4:	70 e0       	ldi	r23, 0x00	; 0
    1ef6:	80 91 6e 03 	lds	r24, 0x036E	; 0x80036e <sem>
    1efa:	90 91 6f 03 	lds	r25, 0x036F	; 0x80036f <sem+0x1>
    1efe:	0e 94 25 06 	call	0xc4a	; 0xc4a <xQueueGenericSend>
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	08 95       	ret

00001f08 <TaakKleineletter>:
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
    1f0c:	1f 92       	push	r1
    1f0e:	1f 92       	push	r1
    1f10:	cd b7       	in	r28, 0x3d	; 61
    1f12:	de b7       	in	r29, 0x3e	; 62
    1f14:	33 dc       	rcall	.-1946   	; 0x177c <xTaskGetTickCount>
    1f16:	9a 83       	std	Y+2, r25	; 0x02
    1f18:	89 83       	std	Y+1, r24	; 0x01
    1f1a:	00 e0       	ldi	r16, 0x00	; 0
    1f1c:	10 e0       	ldi	r17, 0x00	; 0
    1f1e:	8a e1       	ldi	r24, 0x1A	; 26
    1f20:	92 e0       	ldi	r25, 0x02	; 2
    1f22:	ce df       	rcall	.-100    	; 0x1ec0 <writeString>
    1f24:	0f 5f       	subi	r16, 0xFF	; 255
    1f26:	1f 4f       	sbci	r17, 0xFF	; 255
    1f28:	0a 30       	cpi	r16, 0x0A	; 10
    1f2a:	11 05       	cpc	r17, r1
    1f2c:	c1 f7       	brne	.-16     	; 0x1f1e <TaakKleineletter+0x16>
    1f2e:	68 ee       	ldi	r22, 0xE8	; 232
    1f30:	73 e0       	ldi	r23, 0x03	; 3
    1f32:	ce 01       	movw	r24, r28
    1f34:	01 96       	adiw	r24, 0x01	; 1
    1f36:	63 dd       	rcall	.-1338   	; 0x19fe <vTaskDelayUntil>
    1f38:	f0 cf       	rjmp	.-32     	; 0x1f1a <TaakKleineletter+0x12>

00001f3a <TaakHoofdletter>:
    1f3a:	cf 93       	push	r28
    1f3c:	df 93       	push	r29
    1f3e:	1f 92       	push	r1
    1f40:	1f 92       	push	r1
    1f42:	cd b7       	in	r28, 0x3d	; 61
    1f44:	de b7       	in	r29, 0x3e	; 62
    1f46:	1a dc       	rcall	.-1996   	; 0x177c <xTaskGetTickCount>
    1f48:	9a 83       	std	Y+2, r25	; 0x02
    1f4a:	89 83       	std	Y+1, r24	; 0x01
    1f4c:	00 e0       	ldi	r16, 0x00	; 0
    1f4e:	10 e0       	ldi	r17, 0x00	; 0
    1f50:	85 e3       	ldi	r24, 0x35	; 53
    1f52:	92 e0       	ldi	r25, 0x02	; 2
    1f54:	b5 df       	rcall	.-150    	; 0x1ec0 <writeString>
    1f56:	0f 5f       	subi	r16, 0xFF	; 255
    1f58:	1f 4f       	sbci	r17, 0xFF	; 255
    1f5a:	0a 30       	cpi	r16, 0x0A	; 10
    1f5c:	11 05       	cpc	r17, r1
    1f5e:	c1 f7       	brne	.-16     	; 0x1f50 <TaakHoofdletter+0x16>
    1f60:	68 ee       	ldi	r22, 0xE8	; 232
    1f62:	73 e0       	ldi	r23, 0x03	; 3
    1f64:	ce 01       	movw	r24, r28
    1f66:	01 96       	adiw	r24, 0x01	; 1
    1f68:	4a dd       	rcall	.-1388   	; 0x19fe <vTaskDelayUntil>
    1f6a:	f0 cf       	rjmp	.-32     	; 0x1f4c <TaakHoofdletter+0x12>

00001f6c <writeULong>:

void writeULong(unsigned long nr)
{
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
    1f70:	cd b7       	in	r28, 0x3d	; 61
    1f72:	de b7       	in	r29, 0x3e	; 62
    1f74:	68 97       	sbiw	r28, 0x18	; 24
    1f76:	0f b6       	in	r0, 0x3f	; 63
    1f78:	f8 94       	cli
    1f7a:	de bf       	out	0x3e, r29	; 62
    1f7c:	0f be       	out	0x3f, r0	; 63
    1f7e:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__ultoa_ncheck (unsigned long, char *, unsigned char);
	return __ultoa_ncheck (__val, __s, __radix);
    1f80:	2a e0       	ldi	r18, 0x0A	; 10
    1f82:	ae 01       	movw	r20, r28
    1f84:	4f 5f       	subi	r20, 0xFF	; 255
    1f86:	5f 4f       	sbci	r21, 0xFF	; 255
    1f88:	69 d1       	rcall	.+722    	; 0x225c <__ultoa_ncheck>
	char buffer[24];
	ultoa(nr,buffer,10);
	writeString(buffer);
    1f8a:	ce 01       	movw	r24, r28
    1f8c:	01 96       	adiw	r24, 0x01	; 1
    1f8e:	98 df       	rcall	.-208    	; 0x1ec0 <writeString>
}
    1f90:	68 96       	adiw	r28, 0x18	; 24
    1f92:	0f b6       	in	r0, 0x3f	; 63
    1f94:	f8 94       	cli
    1f96:	de bf       	out	0x3e, r29	; 62
    1f98:	0f be       	out	0x3f, r0	; 63
    1f9a:	cd bf       	out	0x3d, r28	; 61
    1f9c:	df 91       	pop	r29
    1f9e:	cf 91       	pop	r28
    1fa0:	08 95       	ret

00001fa2 <vApplicationIdleHook>:
TaskHandle_t hoofdHandle = NULL;
TaskHandle_t kleineHandle = NULL;
unsigned long waarde=0;

void vApplicationIdleHook( void ) {
	DDRL = 1 << PL2;  //pin 47
    1fa2:	84 e0       	ldi	r24, 0x04	; 4
    1fa4:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__TEXT_REGION_LENGTH__+0x70010a>
	
	while(1) {
		writeULong(waarde);
		writeString("\n\r");
		for(int x=0;x<20;x++) {
		     PORTL ^= (1 << PL2);
    1fa8:	cb e0       	ldi	r28, 0x0B	; 11
    1faa:	d1 e0       	ldi	r29, 0x01	; 1
    1fac:	14 e0       	ldi	r17, 0x04	; 4

void vApplicationIdleHook( void ) {
	DDRL = 1 << PL2;  //pin 47
	
	while(1) {
		writeULong(waarde);
    1fae:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <waarde>
    1fb2:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <waarde+0x1>
    1fb6:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <waarde+0x2>
    1fba:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <waarde+0x3>
    1fbe:	d6 df       	rcall	.-84     	; 0x1f6c <writeULong>
		writeString("\n\r");
    1fc0:	80 e5       	ldi	r24, 0x50	; 80
    1fc2:	92 e0       	ldi	r25, 0x02	; 2
    1fc4:	7d df       	rcall	.-262    	; 0x1ec0 <writeString>
    1fc6:	24 e1       	ldi	r18, 0x14	; 20
    1fc8:	30 e0       	ldi	r19, 0x00	; 0
		for(int x=0;x<20;x++) {
		     PORTL ^= (1 << PL2);
    1fca:	88 81       	ld	r24, Y
    1fcc:	81 27       	eor	r24, r17
    1fce:	88 83       	st	Y, r24
    1fd0:	4f ef       	ldi	r20, 0xFF	; 255
    1fd2:	83 ed       	ldi	r24, 0xD3	; 211
    1fd4:	90 e3       	ldi	r25, 0x30	; 48
    1fd6:	41 50       	subi	r20, 0x01	; 1
    1fd8:	80 40       	sbci	r24, 0x00	; 0
    1fda:	90 40       	sbci	r25, 0x00	; 0
    1fdc:	e1 f7       	brne	.-8      	; 0x1fd6 <vApplicationIdleHook+0x34>
    1fde:	00 c0       	rjmp	.+0      	; 0x1fe0 <vApplicationIdleHook+0x3e>
    1fe0:	00 00       	nop
    1fe2:	21 50       	subi	r18, 0x01	; 1
    1fe4:	31 09       	sbc	r19, r1
	DDRL = 1 << PL2;  //pin 47
	
	while(1) {
		writeULong(waarde);
		writeString("\n\r");
		for(int x=0;x<20;x++) {
    1fe6:	89 f7       	brne	.-30     	; 0x1fca <vApplicationIdleHook+0x28>
    1fe8:	e2 cf       	rjmp	.-60     	; 0x1fae <vApplicationIdleHook+0xc>

00001fea <__tablejump2__>:
    1fea:	ee 0f       	add	r30, r30
    1fec:	ff 1f       	adc	r31, r31
    1fee:	88 1f       	adc	r24, r24
    1ff0:	8b bf       	out	0x3b, r24	; 59
    1ff2:	07 90       	elpm	r0, Z+
    1ff4:	f6 91       	elpm	r31, Z
    1ff6:	e0 2d       	mov	r30, r0
    1ff8:	19 94       	eijmp

00001ffa <malloc>:
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	82 30       	cpi	r24, 0x02	; 2
    2004:	91 05       	cpc	r25, r1
    2006:	10 f4       	brcc	.+4      	; 0x200c <malloc+0x12>
    2008:	82 e0       	ldi	r24, 0x02	; 2
    200a:	90 e0       	ldi	r25, 0x00	; 0
    200c:	e0 91 72 03 	lds	r30, 0x0372	; 0x800372 <__flp>
    2010:	f0 91 73 03 	lds	r31, 0x0373	; 0x800373 <__flp+0x1>
    2014:	20 e0       	ldi	r18, 0x00	; 0
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	a0 e0       	ldi	r26, 0x00	; 0
    201a:	b0 e0       	ldi	r27, 0x00	; 0
    201c:	30 97       	sbiw	r30, 0x00	; 0
    201e:	19 f1       	breq	.+70     	; 0x2066 <malloc+0x6c>
    2020:	40 81       	ld	r20, Z
    2022:	51 81       	ldd	r21, Z+1	; 0x01
    2024:	02 81       	ldd	r16, Z+2	; 0x02
    2026:	13 81       	ldd	r17, Z+3	; 0x03
    2028:	48 17       	cp	r20, r24
    202a:	59 07       	cpc	r21, r25
    202c:	c8 f0       	brcs	.+50     	; 0x2060 <malloc+0x66>
    202e:	84 17       	cp	r24, r20
    2030:	95 07       	cpc	r25, r21
    2032:	69 f4       	brne	.+26     	; 0x204e <malloc+0x54>
    2034:	10 97       	sbiw	r26, 0x00	; 0
    2036:	31 f0       	breq	.+12     	; 0x2044 <malloc+0x4a>
    2038:	12 96       	adiw	r26, 0x02	; 2
    203a:	0c 93       	st	X, r16
    203c:	12 97       	sbiw	r26, 0x02	; 2
    203e:	13 96       	adiw	r26, 0x03	; 3
    2040:	1c 93       	st	X, r17
    2042:	27 c0       	rjmp	.+78     	; 0x2092 <malloc+0x98>
    2044:	00 93 72 03 	sts	0x0372, r16	; 0x800372 <__flp>
    2048:	10 93 73 03 	sts	0x0373, r17	; 0x800373 <__flp+0x1>
    204c:	22 c0       	rjmp	.+68     	; 0x2092 <malloc+0x98>
    204e:	21 15       	cp	r18, r1
    2050:	31 05       	cpc	r19, r1
    2052:	19 f0       	breq	.+6      	; 0x205a <malloc+0x60>
    2054:	42 17       	cp	r20, r18
    2056:	53 07       	cpc	r21, r19
    2058:	18 f4       	brcc	.+6      	; 0x2060 <malloc+0x66>
    205a:	9a 01       	movw	r18, r20
    205c:	bd 01       	movw	r22, r26
    205e:	ef 01       	movw	r28, r30
    2060:	df 01       	movw	r26, r30
    2062:	f8 01       	movw	r30, r16
    2064:	db cf       	rjmp	.-74     	; 0x201c <malloc+0x22>
    2066:	21 15       	cp	r18, r1
    2068:	31 05       	cpc	r19, r1
    206a:	f9 f0       	breq	.+62     	; 0x20aa <malloc+0xb0>
    206c:	28 1b       	sub	r18, r24
    206e:	39 0b       	sbc	r19, r25
    2070:	24 30       	cpi	r18, 0x04	; 4
    2072:	31 05       	cpc	r19, r1
    2074:	80 f4       	brcc	.+32     	; 0x2096 <malloc+0x9c>
    2076:	8a 81       	ldd	r24, Y+2	; 0x02
    2078:	9b 81       	ldd	r25, Y+3	; 0x03
    207a:	61 15       	cp	r22, r1
    207c:	71 05       	cpc	r23, r1
    207e:	21 f0       	breq	.+8      	; 0x2088 <malloc+0x8e>
    2080:	fb 01       	movw	r30, r22
    2082:	93 83       	std	Z+3, r25	; 0x03
    2084:	82 83       	std	Z+2, r24	; 0x02
    2086:	04 c0       	rjmp	.+8      	; 0x2090 <malloc+0x96>
    2088:	90 93 73 03 	sts	0x0373, r25	; 0x800373 <__flp+0x1>
    208c:	80 93 72 03 	sts	0x0372, r24	; 0x800372 <__flp>
    2090:	fe 01       	movw	r30, r28
    2092:	32 96       	adiw	r30, 0x02	; 2
    2094:	44 c0       	rjmp	.+136    	; 0x211e <malloc+0x124>
    2096:	fe 01       	movw	r30, r28
    2098:	e2 0f       	add	r30, r18
    209a:	f3 1f       	adc	r31, r19
    209c:	81 93       	st	Z+, r24
    209e:	91 93       	st	Z+, r25
    20a0:	22 50       	subi	r18, 0x02	; 2
    20a2:	31 09       	sbc	r19, r1
    20a4:	39 83       	std	Y+1, r19	; 0x01
    20a6:	28 83       	st	Y, r18
    20a8:	3a c0       	rjmp	.+116    	; 0x211e <malloc+0x124>
    20aa:	20 91 70 03 	lds	r18, 0x0370	; 0x800370 <__brkval>
    20ae:	30 91 71 03 	lds	r19, 0x0371	; 0x800371 <__brkval+0x1>
    20b2:	23 2b       	or	r18, r19
    20b4:	41 f4       	brne	.+16     	; 0x20c6 <malloc+0xcc>
    20b6:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    20ba:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    20be:	30 93 71 03 	sts	0x0371, r19	; 0x800371 <__brkval+0x1>
    20c2:	20 93 70 03 	sts	0x0370, r18	; 0x800370 <__brkval>
    20c6:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    20ca:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    20ce:	21 15       	cp	r18, r1
    20d0:	31 05       	cpc	r19, r1
    20d2:	41 f4       	brne	.+16     	; 0x20e4 <malloc+0xea>
    20d4:	2d b7       	in	r18, 0x3d	; 61
    20d6:	3e b7       	in	r19, 0x3e	; 62
    20d8:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    20dc:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    20e0:	24 1b       	sub	r18, r20
    20e2:	35 0b       	sbc	r19, r21
    20e4:	e0 91 70 03 	lds	r30, 0x0370	; 0x800370 <__brkval>
    20e8:	f0 91 71 03 	lds	r31, 0x0371	; 0x800371 <__brkval+0x1>
    20ec:	e2 17       	cp	r30, r18
    20ee:	f3 07       	cpc	r31, r19
    20f0:	a0 f4       	brcc	.+40     	; 0x211a <malloc+0x120>
    20f2:	2e 1b       	sub	r18, r30
    20f4:	3f 0b       	sbc	r19, r31
    20f6:	28 17       	cp	r18, r24
    20f8:	39 07       	cpc	r19, r25
    20fa:	78 f0       	brcs	.+30     	; 0x211a <malloc+0x120>
    20fc:	ac 01       	movw	r20, r24
    20fe:	4e 5f       	subi	r20, 0xFE	; 254
    2100:	5f 4f       	sbci	r21, 0xFF	; 255
    2102:	24 17       	cp	r18, r20
    2104:	35 07       	cpc	r19, r21
    2106:	48 f0       	brcs	.+18     	; 0x211a <malloc+0x120>
    2108:	4e 0f       	add	r20, r30
    210a:	5f 1f       	adc	r21, r31
    210c:	50 93 71 03 	sts	0x0371, r21	; 0x800371 <__brkval+0x1>
    2110:	40 93 70 03 	sts	0x0370, r20	; 0x800370 <__brkval>
    2114:	81 93       	st	Z+, r24
    2116:	91 93       	st	Z+, r25
    2118:	02 c0       	rjmp	.+4      	; 0x211e <malloc+0x124>
    211a:	e0 e0       	ldi	r30, 0x00	; 0
    211c:	f0 e0       	ldi	r31, 0x00	; 0
    211e:	cf 01       	movw	r24, r30
    2120:	df 91       	pop	r29
    2122:	cf 91       	pop	r28
    2124:	1f 91       	pop	r17
    2126:	0f 91       	pop	r16
    2128:	08 95       	ret

0000212a <free>:
    212a:	cf 93       	push	r28
    212c:	df 93       	push	r29
    212e:	00 97       	sbiw	r24, 0x00	; 0
    2130:	09 f4       	brne	.+2      	; 0x2134 <free+0xa>
    2132:	81 c0       	rjmp	.+258    	; 0x2236 <__stack+0x37>
    2134:	fc 01       	movw	r30, r24
    2136:	32 97       	sbiw	r30, 0x02	; 2
    2138:	13 82       	std	Z+3, r1	; 0x03
    213a:	12 82       	std	Z+2, r1	; 0x02
    213c:	a0 91 72 03 	lds	r26, 0x0372	; 0x800372 <__flp>
    2140:	b0 91 73 03 	lds	r27, 0x0373	; 0x800373 <__flp+0x1>
    2144:	10 97       	sbiw	r26, 0x00	; 0
    2146:	81 f4       	brne	.+32     	; 0x2168 <free+0x3e>
    2148:	20 81       	ld	r18, Z
    214a:	31 81       	ldd	r19, Z+1	; 0x01
    214c:	82 0f       	add	r24, r18
    214e:	93 1f       	adc	r25, r19
    2150:	20 91 70 03 	lds	r18, 0x0370	; 0x800370 <__brkval>
    2154:	30 91 71 03 	lds	r19, 0x0371	; 0x800371 <__brkval+0x1>
    2158:	28 17       	cp	r18, r24
    215a:	39 07       	cpc	r19, r25
    215c:	51 f5       	brne	.+84     	; 0x21b2 <free+0x88>
    215e:	f0 93 71 03 	sts	0x0371, r31	; 0x800371 <__brkval+0x1>
    2162:	e0 93 70 03 	sts	0x0370, r30	; 0x800370 <__brkval>
    2166:	67 c0       	rjmp	.+206    	; 0x2236 <__stack+0x37>
    2168:	ed 01       	movw	r28, r26
    216a:	20 e0       	ldi	r18, 0x00	; 0
    216c:	30 e0       	ldi	r19, 0x00	; 0
    216e:	ce 17       	cp	r28, r30
    2170:	df 07       	cpc	r29, r31
    2172:	40 f4       	brcc	.+16     	; 0x2184 <free+0x5a>
    2174:	4a 81       	ldd	r20, Y+2	; 0x02
    2176:	5b 81       	ldd	r21, Y+3	; 0x03
    2178:	9e 01       	movw	r18, r28
    217a:	41 15       	cp	r20, r1
    217c:	51 05       	cpc	r21, r1
    217e:	f1 f0       	breq	.+60     	; 0x21bc <free+0x92>
    2180:	ea 01       	movw	r28, r20
    2182:	f5 cf       	rjmp	.-22     	; 0x216e <free+0x44>
    2184:	d3 83       	std	Z+3, r29	; 0x03
    2186:	c2 83       	std	Z+2, r28	; 0x02
    2188:	40 81       	ld	r20, Z
    218a:	51 81       	ldd	r21, Z+1	; 0x01
    218c:	84 0f       	add	r24, r20
    218e:	95 1f       	adc	r25, r21
    2190:	c8 17       	cp	r28, r24
    2192:	d9 07       	cpc	r29, r25
    2194:	59 f4       	brne	.+22     	; 0x21ac <free+0x82>
    2196:	88 81       	ld	r24, Y
    2198:	99 81       	ldd	r25, Y+1	; 0x01
    219a:	84 0f       	add	r24, r20
    219c:	95 1f       	adc	r25, r21
    219e:	02 96       	adiw	r24, 0x02	; 2
    21a0:	91 83       	std	Z+1, r25	; 0x01
    21a2:	80 83       	st	Z, r24
    21a4:	8a 81       	ldd	r24, Y+2	; 0x02
    21a6:	9b 81       	ldd	r25, Y+3	; 0x03
    21a8:	93 83       	std	Z+3, r25	; 0x03
    21aa:	82 83       	std	Z+2, r24	; 0x02
    21ac:	21 15       	cp	r18, r1
    21ae:	31 05       	cpc	r19, r1
    21b0:	29 f4       	brne	.+10     	; 0x21bc <free+0x92>
    21b2:	f0 93 73 03 	sts	0x0373, r31	; 0x800373 <__flp+0x1>
    21b6:	e0 93 72 03 	sts	0x0372, r30	; 0x800372 <__flp>
    21ba:	3d c0       	rjmp	.+122    	; 0x2236 <__stack+0x37>
    21bc:	e9 01       	movw	r28, r18
    21be:	fb 83       	std	Y+3, r31	; 0x03
    21c0:	ea 83       	std	Y+2, r30	; 0x02
    21c2:	49 91       	ld	r20, Y+
    21c4:	59 91       	ld	r21, Y+
    21c6:	c4 0f       	add	r28, r20
    21c8:	d5 1f       	adc	r29, r21
    21ca:	ec 17       	cp	r30, r28
    21cc:	fd 07       	cpc	r31, r29
    21ce:	61 f4       	brne	.+24     	; 0x21e8 <free+0xbe>
    21d0:	80 81       	ld	r24, Z
    21d2:	91 81       	ldd	r25, Z+1	; 0x01
    21d4:	84 0f       	add	r24, r20
    21d6:	95 1f       	adc	r25, r21
    21d8:	02 96       	adiw	r24, 0x02	; 2
    21da:	e9 01       	movw	r28, r18
    21dc:	99 83       	std	Y+1, r25	; 0x01
    21de:	88 83       	st	Y, r24
    21e0:	82 81       	ldd	r24, Z+2	; 0x02
    21e2:	93 81       	ldd	r25, Z+3	; 0x03
    21e4:	9b 83       	std	Y+3, r25	; 0x03
    21e6:	8a 83       	std	Y+2, r24	; 0x02
    21e8:	e0 e0       	ldi	r30, 0x00	; 0
    21ea:	f0 e0       	ldi	r31, 0x00	; 0
    21ec:	12 96       	adiw	r26, 0x02	; 2
    21ee:	8d 91       	ld	r24, X+
    21f0:	9c 91       	ld	r25, X
    21f2:	13 97       	sbiw	r26, 0x03	; 3
    21f4:	00 97       	sbiw	r24, 0x00	; 0
    21f6:	19 f0       	breq	.+6      	; 0x21fe <free+0xd4>
    21f8:	fd 01       	movw	r30, r26
    21fa:	dc 01       	movw	r26, r24
    21fc:	f7 cf       	rjmp	.-18     	; 0x21ec <free+0xc2>
    21fe:	8d 91       	ld	r24, X+
    2200:	9c 91       	ld	r25, X
    2202:	11 97       	sbiw	r26, 0x01	; 1
    2204:	9d 01       	movw	r18, r26
    2206:	2e 5f       	subi	r18, 0xFE	; 254
    2208:	3f 4f       	sbci	r19, 0xFF	; 255
    220a:	82 0f       	add	r24, r18
    220c:	93 1f       	adc	r25, r19
    220e:	20 91 70 03 	lds	r18, 0x0370	; 0x800370 <__brkval>
    2212:	30 91 71 03 	lds	r19, 0x0371	; 0x800371 <__brkval+0x1>
    2216:	28 17       	cp	r18, r24
    2218:	39 07       	cpc	r19, r25
    221a:	69 f4       	brne	.+26     	; 0x2236 <__stack+0x37>
    221c:	30 97       	sbiw	r30, 0x00	; 0
    221e:	29 f4       	brne	.+10     	; 0x222a <__stack+0x2b>
    2220:	10 92 73 03 	sts	0x0373, r1	; 0x800373 <__flp+0x1>
    2224:	10 92 72 03 	sts	0x0372, r1	; 0x800372 <__flp>
    2228:	02 c0       	rjmp	.+4      	; 0x222e <__stack+0x2f>
    222a:	13 82       	std	Z+3, r1	; 0x03
    222c:	12 82       	std	Z+2, r1	; 0x02
    222e:	b0 93 71 03 	sts	0x0371, r27	; 0x800371 <__brkval+0x1>
    2232:	a0 93 70 03 	sts	0x0370, r26	; 0x800370 <__brkval>
    2236:	df 91       	pop	r29
    2238:	cf 91       	pop	r28
    223a:	08 95       	ret

0000223c <memcpy>:
    223c:	fb 01       	movw	r30, r22
    223e:	dc 01       	movw	r26, r24
    2240:	02 c0       	rjmp	.+4      	; 0x2246 <memcpy+0xa>
    2242:	01 90       	ld	r0, Z+
    2244:	0d 92       	st	X+, r0
    2246:	41 50       	subi	r20, 0x01	; 1
    2248:	50 40       	sbci	r21, 0x00	; 0
    224a:	d8 f7       	brcc	.-10     	; 0x2242 <memcpy+0x6>
    224c:	08 95       	ret

0000224e <memset>:
    224e:	dc 01       	movw	r26, r24
    2250:	01 c0       	rjmp	.+2      	; 0x2254 <memset+0x6>
    2252:	6d 93       	st	X+, r22
    2254:	41 50       	subi	r20, 0x01	; 1
    2256:	50 40       	sbci	r21, 0x00	; 0
    2258:	e0 f7       	brcc	.-8      	; 0x2252 <memset+0x4>
    225a:	08 95       	ret

0000225c <__ultoa_ncheck>:
    225c:	bb 27       	eor	r27, r27

0000225e <__ultoa_common>:
    225e:	fa 01       	movw	r30, r20
    2260:	a6 2f       	mov	r26, r22
    2262:	62 17       	cp	r22, r18
    2264:	71 05       	cpc	r23, r1
    2266:	81 05       	cpc	r24, r1
    2268:	91 05       	cpc	r25, r1
    226a:	33 0b       	sbc	r19, r19
    226c:	30 fb       	bst	r19, 0
    226e:	66 f0       	brts	.+24     	; 0x2288 <__ultoa_common+0x2a>
    2270:	aa 27       	eor	r26, r26
    2272:	66 0f       	add	r22, r22
    2274:	77 1f       	adc	r23, r23
    2276:	88 1f       	adc	r24, r24
    2278:	99 1f       	adc	r25, r25
    227a:	aa 1f       	adc	r26, r26
    227c:	a2 17       	cp	r26, r18
    227e:	10 f0       	brcs	.+4      	; 0x2284 <__ultoa_common+0x26>
    2280:	a2 1b       	sub	r26, r18
    2282:	63 95       	inc	r22
    2284:	38 50       	subi	r19, 0x08	; 8
    2286:	a9 f7       	brne	.-22     	; 0x2272 <__ultoa_common+0x14>
    2288:	a0 5d       	subi	r26, 0xD0	; 208
    228a:	aa 33       	cpi	r26, 0x3A	; 58
    228c:	08 f0       	brcs	.+2      	; 0x2290 <__ultoa_common+0x32>
    228e:	a9 5d       	subi	r26, 0xD9	; 217
    2290:	a1 93       	st	Z+, r26
    2292:	36 f7       	brtc	.-52     	; 0x2260 <__ultoa_common+0x2>
    2294:	b1 11       	cpse	r27, r1
    2296:	b1 93       	st	Z+, r27
    2298:	10 82       	st	Z, r1
    229a:	ca 01       	movw	r24, r20
    229c:	00 c0       	rjmp	.+0      	; 0x229e <strrev>

0000229e <strrev>:
    229e:	dc 01       	movw	r26, r24
    22a0:	fc 01       	movw	r30, r24
    22a2:	67 2f       	mov	r22, r23
    22a4:	71 91       	ld	r23, Z+
    22a6:	77 23       	and	r23, r23
    22a8:	e1 f7       	brne	.-8      	; 0x22a2 <strrev+0x4>
    22aa:	32 97       	sbiw	r30, 0x02	; 2
    22ac:	04 c0       	rjmp	.+8      	; 0x22b6 <strrev+0x18>
    22ae:	7c 91       	ld	r23, X
    22b0:	6d 93       	st	X+, r22
    22b2:	70 83       	st	Z, r23
    22b4:	62 91       	ld	r22, -Z
    22b6:	ae 17       	cp	r26, r30
    22b8:	bf 07       	cpc	r27, r31
    22ba:	c8 f3       	brcs	.-14     	; 0x22ae <strrev+0x10>
    22bc:	08 95       	ret

000022be <_exit>:
    22be:	f8 94       	cli

000022c0 <__stop_program>:
    22c0:	ff cf       	rjmp	.-2      	; 0x22c0 <__stop_program>
