
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a0  00800200  00002a0e  00002aa2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a0e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000263  008002a0  008002a0  00002b42  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002b42  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002b74  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005e8  00000000  00000000  00002bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008134  00000000  00000000  0000319c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ee7  00000000  00000000  0000b2d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004cca  00000000  00000000  0000d1b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001558  00000000  00000000  00011e84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002108  00000000  00000000  000133dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000780e  00000000  00000000  000154e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008c0  00000000  00000000  0001ccf2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8a c1       	rjmp	.+788    	; 0x31a <__bad_interrupt>
       6:	00 00       	nop
       8:	88 c1       	rjmp	.+784    	; 0x31a <__bad_interrupt>
       a:	00 00       	nop
       c:	86 c1       	rjmp	.+780    	; 0x31a <__bad_interrupt>
       e:	00 00       	nop
      10:	84 c1       	rjmp	.+776    	; 0x31a <__bad_interrupt>
      12:	00 00       	nop
      14:	82 c1       	rjmp	.+772    	; 0x31a <__bad_interrupt>
      16:	00 00       	nop
      18:	80 c1       	rjmp	.+768    	; 0x31a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7e c1       	rjmp	.+764    	; 0x31a <__bad_interrupt>
      1e:	00 00       	nop
      20:	7c c1       	rjmp	.+760    	; 0x31a <__bad_interrupt>
      22:	00 00       	nop
      24:	6e c4       	rjmp	.+2268   	; 0x902 <__vector_9>
      26:	00 00       	nop
      28:	78 c1       	rjmp	.+752    	; 0x31a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	76 c1       	rjmp	.+748    	; 0x31a <__bad_interrupt>
      2e:	00 00       	nop
      30:	74 c1       	rjmp	.+744    	; 0x31a <__bad_interrupt>
      32:	00 00       	nop
      34:	72 c1       	rjmp	.+740    	; 0x31a <__bad_interrupt>
      36:	00 00       	nop
      38:	70 c1       	rjmp	.+736    	; 0x31a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6e c1       	rjmp	.+732    	; 0x31a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6c c1       	rjmp	.+728    	; 0x31a <__bad_interrupt>
      42:	00 00       	nop
      44:	2f c7       	rjmp	.+3678   	; 0xea4 <__vector_17>
      46:	00 00       	nop
      48:	68 c1       	rjmp	.+720    	; 0x31a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	66 c1       	rjmp	.+716    	; 0x31a <__bad_interrupt>
      4e:	00 00       	nop
      50:	64 c1       	rjmp	.+712    	; 0x31a <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 05 0a 	jmp	0x140a	; 0x140a <__vector_21>
      58:	60 c1       	rjmp	.+704    	; 0x31a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5e c1       	rjmp	.+700    	; 0x31a <__bad_interrupt>
      5e:	00 00       	nop
      60:	5c c1       	rjmp	.+696    	; 0x31a <__bad_interrupt>
      62:	00 00       	nop
      64:	5a c1       	rjmp	.+692    	; 0x31a <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 a5 0b 	jmp	0x174a	; 0x174a <__vector_26>
      6c:	56 c1       	rjmp	.+684    	; 0x31a <__bad_interrupt>
      6e:	00 00       	nop
      70:	54 c1       	rjmp	.+680    	; 0x31a <__bad_interrupt>
      72:	00 00       	nop
      74:	52 c1       	rjmp	.+676    	; 0x31a <__bad_interrupt>
      76:	00 00       	nop
      78:	50 c1       	rjmp	.+672    	; 0x31a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4e c1       	rjmp	.+668    	; 0x31a <__bad_interrupt>
      7e:	00 00       	nop
      80:	4c c1       	rjmp	.+664    	; 0x31a <__bad_interrupt>
      82:	00 00       	nop
      84:	4a c1       	rjmp	.+660    	; 0x31a <__bad_interrupt>
      86:	00 00       	nop
      88:	48 c1       	rjmp	.+656    	; 0x31a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	dd c4       	rjmp	.+2490   	; 0xa48 <__vector_35>
      8e:	00 00       	nop
      90:	68 c3       	rjmp	.+1744   	; 0x762 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 ee 0b 	jmp	0x17dc	; 0x17dc <__vector_37>
      98:	40 c1       	rjmp	.+640    	; 0x31a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ac c1       	rjmp	.+856    	; 0x3f6 <__vector_39>
      9e:	00 00       	nop
      a0:	3c c1       	rjmp	.+632    	; 0x31a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	38 c1       	rjmp	.+624    	; 0x31a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	36 c1       	rjmp	.+620    	; 0x31a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	34 c1       	rjmp	.+616    	; 0x31a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	32 c1       	rjmp	.+612    	; 0x31a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	30 c1       	rjmp	.+608    	; 0x31a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2e c1       	rjmp	.+604    	; 0x31a <__bad_interrupt>
      be:	00 00       	nop
      c0:	2c c1       	rjmp	.+600    	; 0x31a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2a c1       	rjmp	.+596    	; 0x31a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	28 c1       	rjmp	.+592    	; 0x31a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 37 0c 	jmp	0x186e	; 0x186e <__vector_51>
      d0:	0c 94 96 0c 	jmp	0x192c	; 0x192c <__vector_52>
      d4:	22 c1       	rjmp	.+580    	; 0x31a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 df 0c 	jmp	0x19be	; 0x19be <__vector_54>
      dc:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <__vector_55>
      e0:	1c c1       	rjmp	.+568    	; 0x31a <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1a 02       	muls	r17, r26
      e6:	d5 02       	muls	r29, r21
      e8:	d5 02       	muls	r29, r21
      ea:	d5 02       	muls	r29, r21
      ec:	d5 02       	muls	r29, r21
      ee:	d5 02       	muls	r29, r21
      f0:	d5 02       	muls	r29, r21
      f2:	d5 02       	muls	r29, r21
      f4:	1a 02       	muls	r17, r26
      f6:	d5 02       	muls	r29, r21
      f8:	d5 02       	muls	r29, r21
      fa:	d5 02       	muls	r29, r21
      fc:	d5 02       	muls	r29, r21
      fe:	d5 02       	muls	r29, r21
     100:	d5 02       	muls	r29, r21
     102:	d5 02       	muls	r29, r21
     104:	1c 02       	muls	r17, r28
     106:	d5 02       	muls	r29, r21
     108:	d5 02       	muls	r29, r21
     10a:	d5 02       	muls	r29, r21
     10c:	d5 02       	muls	r29, r21
     10e:	d5 02       	muls	r29, r21
     110:	d5 02       	muls	r29, r21
     112:	d5 02       	muls	r29, r21
     114:	39 02       	muls	r19, r25
     116:	d5 02       	muls	r29, r21
     118:	d5 02       	muls	r29, r21
     11a:	d5 02       	muls	r29, r21
     11c:	d5 02       	muls	r29, r21
     11e:	d5 02       	muls	r29, r21
     120:	d5 02       	muls	r29, r21
     122:	d5 02       	muls	r29, r21
     124:	1c 02       	muls	r17, r28
     126:	d5 02       	muls	r29, r21
     128:	d5 02       	muls	r29, r21
     12a:	d5 02       	muls	r29, r21
     12c:	d5 02       	muls	r29, r21
     12e:	d5 02       	muls	r29, r21
     130:	d5 02       	muls	r29, r21
     132:	d5 02       	muls	r29, r21
     134:	39 02       	muls	r19, r25
     136:	d5 02       	muls	r29, r21
     138:	d5 02       	muls	r29, r21
     13a:	d5 02       	muls	r29, r21
     13c:	d5 02       	muls	r29, r21
     13e:	d5 02       	muls	r29, r21
     140:	d5 02       	muls	r29, r21
     142:	d5 02       	muls	r29, r21
     144:	d1 02       	muls	r29, r17
     146:	d5 02       	muls	r29, r21
     148:	d5 02       	muls	r29, r21
     14a:	d5 02       	muls	r29, r21
     14c:	d5 02       	muls	r29, r21
     14e:	d5 02       	muls	r29, r21
     150:	d5 02       	muls	r29, r21
     152:	d5 02       	muls	r29, r21
     154:	4d 02       	muls	r20, r29
     156:	d5 02       	muls	r29, r21
     158:	d5 02       	muls	r29, r21
     15a:	d5 02       	muls	r29, r21
     15c:	d5 02       	muls	r29, r21
     15e:	d5 02       	muls	r29, r21
     160:	d5 02       	muls	r29, r21
     162:	d5 02       	muls	r29, r21
     164:	70 02       	muls	r23, r16
     166:	d5 02       	muls	r29, r21
     168:	d5 02       	muls	r29, r21
     16a:	d5 02       	muls	r29, r21
     16c:	d5 02       	muls	r29, r21
     16e:	d5 02       	muls	r29, r21
     170:	d5 02       	muls	r29, r21
     172:	d5 02       	muls	r29, r21
     174:	41 02       	muls	r20, r17
     176:	d5 02       	muls	r29, r21
     178:	d5 02       	muls	r29, r21
     17a:	d5 02       	muls	r29, r21
     17c:	d5 02       	muls	r29, r21
     17e:	d5 02       	muls	r29, r21
     180:	d5 02       	muls	r29, r21
     182:	d5 02       	muls	r29, r21
     184:	5f 02       	muls	r21, r31
     186:	d5 02       	muls	r29, r21
     188:	d5 02       	muls	r29, r21
     18a:	d5 02       	muls	r29, r21
     18c:	d5 02       	muls	r29, r21
     18e:	d5 02       	muls	r29, r21
     190:	d5 02       	muls	r29, r21
     192:	d5 02       	muls	r29, r21
     194:	a7 02       	muls	r26, r23
     196:	d5 02       	muls	r29, r21
     198:	d5 02       	muls	r29, r21
     19a:	d5 02       	muls	r29, r21
     19c:	d5 02       	muls	r29, r21
     19e:	d5 02       	muls	r29, r21
     1a0:	d5 02       	muls	r29, r21
     1a2:	d5 02       	muls	r29, r21
     1a4:	a7 02       	muls	r26, r23
     1a6:	d5 02       	muls	r29, r21
     1a8:	d5 02       	muls	r29, r21
     1aa:	d5 02       	muls	r29, r21
     1ac:	d5 02       	muls	r29, r21
     1ae:	d5 02       	muls	r29, r21
     1b0:	d5 02       	muls	r29, r21
     1b2:	d5 02       	muls	r29, r21
     1b4:	a2 02       	muls	r26, r18
     1b6:	d5 02       	muls	r29, r21
     1b8:	d5 02       	muls	r29, r21
     1ba:	d5 02       	muls	r29, r21
     1bc:	d5 02       	muls	r29, r21
     1be:	d5 02       	muls	r29, r21
     1c0:	d5 02       	muls	r29, r21
     1c2:	d5 02       	muls	r29, r21
     1c4:	a2 02       	muls	r26, r18
     1c6:	d5 02       	muls	r29, r21
     1c8:	d5 02       	muls	r29, r21
     1ca:	d5 02       	muls	r29, r21
     1cc:	d5 02       	muls	r29, r21
     1ce:	d5 02       	muls	r29, r21
     1d0:	d5 02       	muls	r29, r21
     1d2:	d5 02       	muls	r29, r21
     1d4:	b2 02       	muls	r27, r18
     1d6:	d5 02       	muls	r29, r21
     1d8:	d5 02       	muls	r29, r21
     1da:	d5 02       	muls	r29, r21
     1dc:	d5 02       	muls	r29, r21
     1de:	d5 02       	muls	r29, r21
     1e0:	d5 02       	muls	r29, r21
     1e2:	d5 02       	muls	r29, r21
     1e4:	c7 02       	muls	r28, r23
     1e6:	d5 02       	muls	r29, r21
     1e8:	d5 02       	muls	r29, r21
     1ea:	d5 02       	muls	r29, r21
     1ec:	d5 02       	muls	r29, r21
     1ee:	d5 02       	muls	r29, r21
     1f0:	d5 02       	muls	r29, r21
     1f2:	d5 02       	muls	r29, r21
     1f4:	b2 02       	muls	r27, r18
     1f6:	d5 02       	muls	r29, r21
     1f8:	d5 02       	muls	r29, r21
     1fa:	d5 02       	muls	r29, r21
     1fc:	d5 02       	muls	r29, r21
     1fe:	d5 02       	muls	r29, r21
     200:	d5 02       	muls	r29, r21
     202:	d5 02       	muls	r29, r21
     204:	c7 02       	muls	r28, r23
     206:	d5 02       	muls	r29, r21
     208:	d5 02       	muls	r29, r21
     20a:	d5 02       	muls	r29, r21
     20c:	d5 02       	muls	r29, r21
     20e:	d5 02       	muls	r29, r21
     210:	d5 02       	muls	r29, r21
     212:	d5 02       	muls	r29, r21
     214:	cb 02       	muls	r28, r27
     216:	d5 02       	muls	r29, r21
     218:	d5 02       	muls	r29, r21
     21a:	d5 02       	muls	r29, r21
     21c:	d5 02       	muls	r29, r21
     21e:	d5 02       	muls	r29, r21
     220:	d5 02       	muls	r29, r21
     222:	d5 02       	muls	r29, r21
     224:	78 02       	muls	r23, r24
     226:	d5 02       	muls	r29, r21
     228:	d5 02       	muls	r29, r21
     22a:	d5 02       	muls	r29, r21
     22c:	d5 02       	muls	r29, r21
     22e:	d5 02       	muls	r29, r21
     230:	d5 02       	muls	r29, r21
     232:	d5 02       	muls	r29, r21
     234:	78 02       	muls	r23, r24
     236:	d5 02       	muls	r29, r21
     238:	d5 02       	muls	r29, r21
     23a:	d5 02       	muls	r29, r21
     23c:	d5 02       	muls	r29, r21
     23e:	d5 02       	muls	r29, r21
     240:	d5 02       	muls	r29, r21
     242:	d5 02       	muls	r29, r21
     244:	7a 02       	muls	r23, r26
     246:	d5 02       	muls	r29, r21
     248:	d5 02       	muls	r29, r21
     24a:	d5 02       	muls	r29, r21
     24c:	d5 02       	muls	r29, r21
     24e:	d5 02       	muls	r29, r21
     250:	d5 02       	muls	r29, r21
     252:	d5 02       	muls	r29, r21
     254:	8a 02       	muls	r24, r26
     256:	d5 02       	muls	r29, r21
     258:	d5 02       	muls	r29, r21
     25a:	d5 02       	muls	r29, r21
     25c:	d5 02       	muls	r29, r21
     25e:	d5 02       	muls	r29, r21
     260:	d5 02       	muls	r29, r21
     262:	d5 02       	muls	r29, r21
     264:	9e 02       	muls	r25, r30

00000266 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     266:	0e ed       	ldi	r16, 0xDE	; 222
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	f6 e0       	ldi	r31, 0x06	; 6
     26e:	ef 2e       	mov	r14, r31
     270:	f3 e0       	ldi	r31, 0x03	; 3
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	fe d1       	rcall	.+1020   	; 0x69e <uxListRemove>
     2a2:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxCurrentNumberOfTasks>
     2ac:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 dd 02 	sts	0x02DD, r24	; 0x8002dd <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5c d0       	rcall	.+184    	; 0x378 <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5a d0       	rcall	.+180    	; 0x378 <vPortFree>
     2c4:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	c2 d7       	rcall	.+3972   	; 0x125a <vPortYield>
     2d6:	5f d0       	rcall	.+190    	; 0x396 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	ee e0       	ldi	r30, 0x0E	; 14
     2f2:	fa e2       	ldi	r31, 0x2A	; 42
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	a0 3a       	cpi	r26, 0xA0	; 160
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	25 e0       	ldi	r18, 0x05	; 5
     306:	a0 ea       	ldi	r26, 0xA0	; 160
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a3 30       	cpi	r26, 0x03	; 3
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	06 d6       	rcall	.+3084   	; 0xf22 <main>
     316:	0c 94 05 15 	jmp	0x2a0a	; 0x2a0a <_exit>

0000031a <__bad_interrupt>:
     31a:	72 ce       	rjmp	.-796    	; 0x0 <__vectors>

0000031c <system_tick>:
     31c:	8f 93       	push	r24
     31e:	8f b7       	in	r24, 0x3f	; 63
     320:	8f 93       	push	r24
     322:	f8 94       	cli
     324:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <__system_time>
     328:	8f 5f       	subi	r24, 0xFF	; 255
     32a:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <__system_time>
     32e:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <__system_time+0x1>
     332:	8f 4f       	sbci	r24, 0xFF	; 255
     334:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <__system_time+0x1>
     338:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <__system_time+0x2>
     33c:	8f 4f       	sbci	r24, 0xFF	; 255
     33e:	80 93 01 05 	sts	0x0501, r24	; 0x800501 <__system_time+0x2>
     342:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <__system_time+0x3>
     346:	8f 4f       	sbci	r24, 0xFF	; 255
     348:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <__system_time+0x3>
     34c:	8f 91       	pop	r24
     34e:	8f bf       	out	0x3f, r24	; 63
     350:	8f 91       	pop	r24
     352:	08 95       	ret

00000354 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35a:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     35e:	ce 01       	movw	r24, r28
     360:	0e 94 a1 13 	call	0x2742	; 0x2742 <malloc>
     364:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     366:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36a:	20 97       	sbiw	r28, 0x00	; 0
     36c:	09 f4       	brne	.+2      	; 0x370 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     36e:	2c d0       	rcall	.+88     	; 0x3c8 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     370:	ce 01       	movw	r24, r28
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
	if( pv )
     37c:	00 97       	sbiw	r24, 0x00	; 0
     37e:	41 f0       	breq	.+16     	; 0x390 <vPortFree+0x18>
     380:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     382:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <vTaskSuspendAll>
		{
			free( pv );
     386:	ce 01       	movw	r24, r28
     388:	0e 94 39 14 	call	0x2872	; 0x2872 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38c:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskResumeAll>
	}
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39c:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a0:	80 b7       	in	r24, 0x30	; 48
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a6:	80 b7       	in	r24, 0x30	; 48
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ac:	83 b7       	in	r24, 0x33	; 51
     3ae:	81 7f       	andi	r24, 0xF1	; 241
     3b0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0

	sleep_enable();
     3b8:	83 b7       	in	r24, 0x33	; 51
     3ba:	81 60       	ori	r24, 0x01	; 1
     3bc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3be:	0f 90       	pop	r0
     3c0:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c2:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c4:	13 be       	out	0x33, r1	; 51
     3c6:	08 95       	ret

000003c8 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3ca:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3cc:	83 ed       	ldi	r24, 0xD3	; 211
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <vApplicationMallocFailedHook+0x8>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <vApplicationMallocFailedHook+0xe>
     3d6:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3d8:	1f 9a       	sbi	0x03, 7	; 3
     3da:	f8 cf       	rjmp	.-16     	; 0x3cc <vApplicationMallocFailedHook+0x4>

000003dc <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3dc:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3de:	2f 9a       	sbi	0x05, 7	; 5
     3e0:	2f e7       	ldi	r18, 0x7F	; 127
     3e2:	8a e1       	ldi	r24, 0x1A	; 26
     3e4:	96 e0       	ldi	r25, 0x06	; 6
     3e6:	21 50       	subi	r18, 0x01	; 1
     3e8:	80 40       	sbci	r24, 0x00	; 0
     3ea:	90 40       	sbci	r25, 0x00	; 0
     3ec:	e1 f7       	brne	.-8      	; 0x3e6 <vApplicationStackOverflowHook+0xa>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <vApplicationStackOverflowHook+0x14>
     3f0:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f2:	1f 9a       	sbi	0x03, 7	; 3
     3f4:	f5 cf       	rjmp	.-22     	; 0x3e0 <vApplicationStackOverflowHook+0x4>

000003f6 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f6:	1f 92       	push	r1
     3f8:	0f 92       	push	r0
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	0b b6       	in	r0, 0x3b	; 59
     402:	0f 92       	push	r0
     404:	2f 93       	push	r18
     406:	3f 93       	push	r19
     408:	8f 93       	push	r24
     40a:	9f 93       	push	r25
     40c:	af 93       	push	r26
     40e:	bf 93       	push	r27
     410:	ef 93       	push	r30
     412:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     414:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     418:	8e 2f       	mov	r24, r30
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	38 97       	sbiw	r30, 0x08	; 8
     420:	e1 3c       	cpi	r30, 0xC1	; 193
     422:	f1 05       	cpc	r31, r1
     424:	08 f0       	brcs	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	c1 c0       	rjmp	.+386    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     428:	88 27       	eor	r24, r24
     42a:	ee 58       	subi	r30, 0x8E	; 142
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	8f 4f       	sbci	r24, 0xFF	; 255
     430:	0c 94 80 13 	jmp	0x2700	; 0x2700 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     434:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     438:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <__data_end>
     43c:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <I2C_msgSize>
     440:	e8 17       	cp	r30, r24
     442:	70 f4       	brcc	.+28     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	8e 0f       	add	r24, r30
     448:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <__data_end>
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	ec 55       	subi	r30, 0x5C	; 92
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     458:	85 e8       	ldi	r24, 0x85	; 133
     45a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     45e:	ac c0       	rjmp	.+344    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     460:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     464:	81 60       	ori	r24, 0x01	; 1
     466:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46a:	84 e9       	ldi	r24, 0x94	; 148
     46c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     470:	a3 c0       	rjmp	.+326    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     476:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47a:	85 ee       	ldi	r24, 0xE5	; 229
     47c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     480:	9b c0       	rjmp	.+310    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     482:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <__data_end>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e 0f       	add	r24, r30
     48a:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <__data_end>
     48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     492:	f0 e0       	ldi	r31, 0x00	; 0
     494:	ec 55       	subi	r30, 0x5C	; 92
     496:	fd 4f       	sbci	r31, 0xFD	; 253
     498:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49a:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <__data_end>
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <I2C_msgSize>
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	28 17       	cp	r18, r24
     4aa:	39 07       	cpc	r19, r25
     4ac:	24 f4       	brge	.+8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4ae:	85 ec       	ldi	r24, 0xC5	; 197
     4b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b4:	81 c0       	rjmp	.+258    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b6:	85 e8       	ldi	r24, 0x85	; 133
     4b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4bc:	7d c0       	rjmp	.+250    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4be:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c2:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <__data_end>
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	ec 55       	subi	r30, 0x5C	; 92
     4ca:	fd 4f       	sbci	r31, 0xFD	; 253
     4cc:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4ce:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     4d2:	81 60       	ori	r24, 0x01	; 1
     4d4:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4de:	6c c0       	rjmp	.+216    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e4:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4e8:	85 ed       	ldi	r24, 0xD5	; 213
     4ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4ee:	64 c0       	rjmp	.+200    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f0:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f4:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <__data_end>
     4f8:	81 e0       	ldi	r24, 0x01	; 1
     4fa:	8e 0f       	add	r24, r30
     4fc:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <__data_end>
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	ec 55       	subi	r30, 0x5C	; 92
     504:	fd 4f       	sbci	r31, 0xFD	; 253
     506:	80 81       	ld	r24, Z
     508:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50c:	85 ec       	ldi	r24, 0xC5	; 197
     50e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     512:	52 c0       	rjmp	.+164    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     514:	90 91 a0 02 	lds	r25, 0x02A0	; 0x8002a0 <__data_end>
     518:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <I2C_msgSize>
     51c:	98 13       	cpse	r25, r24
     51e:	06 c0       	rjmp	.+12     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     520:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     524:	81 60       	ori	r24, 0x01	; 1
     526:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     530:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53a:	3e c0       	rjmp	.+124    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53c:	85 ec       	ldi	r24, 0xC5	; 197
     53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     544:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     548:	84 60       	ori	r24, 0x04	; 4
     54a:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     54e:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     558:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55c:	85 ec       	ldi	r24, 0xC5	; 197
     55e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     564:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <__data_end>
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e 0f       	add	r24, r30
     56c:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <__data_end>
     570:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	ec 55       	subi	r30, 0x5C	; 92
     578:	fd 4f       	sbci	r31, 0xFD	; 253
     57a:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57c:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <I2C_statusReg>
     580:	81 60       	ori	r24, 0x01	; 1
     582:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     586:	85 ec       	ldi	r24, 0xC5	; 197
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58c:	15 c0       	rjmp	.+42     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     58e:	85 e8       	ldi	r24, 0x85	; 133
     590:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     594:	11 c0       	rjmp	.+34     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     596:	84 e0       	ldi	r24, 0x04	; 4
     598:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a2:	85 ee       	ldi	r24, 0xE5	; 229
     5a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5a8:	07 c0       	rjmp	.+14     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5aa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ae:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b2:	85 ed       	ldi	r24, 0xD5	; 213
     5b4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	3f 91       	pop	r19
     5c6:	2f 91       	pop	r18
     5c8:	0f 90       	pop	r0
     5ca:	0b be       	out	0x3b, r0	; 59
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	03 96       	adiw	r24, 0x03	; 3
     5da:	92 83       	std	Z+2, r25	; 0x02
     5dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5de:	2f ef       	ldi	r18, 0xFF	; 255
     5e0:	3f ef       	ldi	r19, 0xFF	; 255
     5e2:	34 83       	std	Z+4, r19	; 0x04
     5e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e6:	96 83       	std	Z+6, r25	; 0x06
     5e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ea:	90 87       	std	Z+8, r25	; 0x08
     5ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5ee:	10 82       	st	Z, r1
     5f0:	08 95       	ret

000005f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f2:	fc 01       	movw	r30, r24
     5f4:	11 86       	std	Z+9, r1	; 0x09
     5f6:	10 86       	std	Z+8, r1	; 0x08
     5f8:	08 95       	ret

000005fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	9c 01       	movw	r18, r24
     600:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     602:	dc 01       	movw	r26, r24
     604:	11 96       	adiw	r26, 0x01	; 1
     606:	cd 91       	ld	r28, X+
     608:	dc 91       	ld	r29, X
     60a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60c:	d3 83       	std	Z+3, r29	; 0x03
     60e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     610:	8c 81       	ldd	r24, Y+4	; 0x04
     612:	9d 81       	ldd	r25, Y+5	; 0x05
     614:	95 83       	std	Z+5, r25	; 0x05
     616:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	dc 01       	movw	r26, r24
     61e:	13 96       	adiw	r26, 0x03	; 3
     620:	7c 93       	st	X, r23
     622:	6e 93       	st	-X, r22
     624:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     626:	7d 83       	std	Y+5, r23	; 0x05
     628:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	31 87       	std	Z+9, r19	; 0x09
     62c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	f9 01       	movw	r30, r18
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     642:	48 81       	ld	r20, Y
     644:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     646:	4f 3f       	cpi	r20, 0xFF	; 255
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	52 07       	cpc	r21, r18
     64c:	21 f4       	brne	.+8      	; 0x656 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     64e:	fc 01       	movw	r30, r24
     650:	a7 81       	ldd	r26, Z+7	; 0x07
     652:	b0 85       	ldd	r27, Z+8	; 0x08
     654:	0d c0       	rjmp	.+26     	; 0x670 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     656:	dc 01       	movw	r26, r24
     658:	13 96       	adiw	r26, 0x03	; 3
     65a:	01 c0       	rjmp	.+2      	; 0x65e <vListInsert+0x22>
     65c:	df 01       	movw	r26, r30
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	ed 91       	ld	r30, X+
     662:	fc 91       	ld	r31, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	20 81       	ld	r18, Z
     668:	31 81       	ldd	r19, Z+1	; 0x01
     66a:	42 17       	cp	r20, r18
     66c:	53 07       	cpc	r21, r19
     66e:	b0 f7       	brcc	.-20     	; 0x65c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     670:	12 96       	adiw	r26, 0x02	; 2
     672:	ed 91       	ld	r30, X+
     674:	fc 91       	ld	r31, X
     676:	13 97       	sbiw	r26, 0x03	; 3
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67c:	d5 83       	std	Z+5, r29	; 0x05
     67e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     680:	bd 83       	std	Y+5, r27	; 0x05
     682:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     684:	13 96       	adiw	r26, 0x03	; 3
     686:	dc 93       	st	X, r29
     688:	ce 93       	st	-X, r28
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68c:	99 87       	std	Y+9, r25	; 0x09
     68e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     690:	fc 01       	movw	r30, r24
     692:	20 81       	ld	r18, Z
     694:	2f 5f       	subi	r18, 0xFF	; 255
     696:	20 83       	st	Z, r18
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a4:	a0 85       	ldd	r26, Z+8	; 0x08
     6a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6a8:	c2 81       	ldd	r28, Z+2	; 0x02
     6aa:	d3 81       	ldd	r29, Z+3	; 0x03
     6ac:	84 81       	ldd	r24, Z+4	; 0x04
     6ae:	95 81       	ldd	r25, Z+5	; 0x05
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b4:	c4 81       	ldd	r28, Z+4	; 0x04
     6b6:	d5 81       	ldd	r29, Z+5	; 0x05
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	9b 83       	std	Y+3, r25	; 0x03
     6be:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2
     6c8:	e8 17       	cp	r30, r24
     6ca:	f9 07       	cpc	r31, r25
     6cc:	31 f4       	brne	.+12     	; 0x6da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6ce:	84 81       	ldd	r24, Z+4	; 0x04
     6d0:	95 81       	ldd	r25, Z+5	; 0x05
     6d2:	12 96       	adiw	r26, 0x02	; 2
     6d4:	9c 93       	st	X, r25
     6d6:	8e 93       	st	-X, r24
     6d8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6da:	11 86       	std	Z+9, r1	; 0x09
     6dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6de:	8c 91       	ld	r24, X
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <watchdogTaak>:

void motorLinks()
{
	motorStop();
	PORTG |= (1 << R_PLUS);
	PORTD |= (1 << L_MIN);
     6ea:	8f e9       	ldi	r24, 0x9F	; 159
     6ec:	9f e0       	ldi	r25, 0x0F	; 15
     6ee:	01 97       	sbiw	r24, 0x01	; 1
     6f0:	f1 f7       	brne	.-4      	; 0x6ee <watchdogTaak+0x4>
     6f2:	00 c0       	rjmp	.+0      	; 0x6f4 <watchdogTaak+0xa>
     6f4:	00 00       	nop
     6f6:	80 91 34 03 	lds	r24, 0x0334	; 0x800334 <watchdogSonar>
     6fa:	90 91 35 03 	lds	r25, 0x0335	; 0x800335 <watchdogSonar+0x1>
     6fe:	89 2b       	or	r24, r25
     700:	a1 f3       	breq	.-24     	; 0x6ea <watchdogTaak>
     702:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <watchdogServo>
     706:	90 91 5f 04 	lds	r25, 0x045F	; 0x80045f <watchdogServo+0x1>
     70a:	89 2b       	or	r24, r25
     70c:	71 f3       	breq	.-36     	; 0x6ea <watchdogTaak>
     70e:	80 91 32 03 	lds	r24, 0x0332	; 0x800332 <watchdogGyro>
     712:	90 91 33 03 	lds	r25, 0x0333	; 0x800333 <watchdogGyro+0x1>
     716:	89 2b       	or	r24, r25
     718:	41 f3       	breq	.-48     	; 0x6ea <watchdogTaak>
     71a:	a8 95       	wdr
     71c:	10 92 35 03 	sts	0x0335, r1	; 0x800335 <watchdogSonar+0x1>
     720:	10 92 34 03 	sts	0x0334, r1	; 0x800334 <watchdogSonar>
     724:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <watchdogServo+0x1>
     728:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <watchdogServo>
     72c:	10 92 33 03 	sts	0x0333, r1	; 0x800333 <watchdogGyro+0x1>
     730:	10 92 32 03 	sts	0x0332, r1	; 0x800332 <watchdogGyro>
     734:	da cf       	rjmp	.-76     	; 0x6ea <watchdogTaak>

00000736 <UART_Init>:
     736:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     73a:	87 e6       	ldi	r24, 0x67	; 103
     73c:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     740:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     744:	86 e0       	ldi	r24, 0x06	; 6
     746:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     74a:	88 e1       	ldi	r24, 0x18	; 24
     74c:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     750:	08 95       	ret

00000752 <UART_Transmit>:
     752:	e8 ec       	ldi	r30, 0xC8	; 200
     754:	f0 e0       	ldi	r31, 0x00	; 0
     756:	90 81       	ld	r25, Z
     758:	95 ff       	sbrs	r25, 5
     75a:	fd cf       	rjmp	.-6      	; 0x756 <UART_Transmit+0x4>
     75c:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     760:	08 95       	ret

00000762 <__vector_36>:
     762:	1f 92       	push	r1
     764:	0f 92       	push	r0
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	0f 92       	push	r0
     76a:	11 24       	eor	r1, r1
     76c:	0f 90       	pop	r0
     76e:	0f be       	out	0x3f, r0	; 63
     770:	0f 90       	pop	r0
     772:	1f 90       	pop	r1
     774:	18 95       	reti

00000776 <UART_Transmit_String>:
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	ec 01       	movw	r28, r24
     77c:	88 81       	ld	r24, Y
     77e:	88 23       	and	r24, r24
     780:	29 f0       	breq	.+10     	; 0x78c <UART_Transmit_String+0x16>
     782:	21 96       	adiw	r28, 0x01	; 1
     784:	e6 df       	rcall	.-52     	; 0x752 <UART_Transmit>
     786:	89 91       	ld	r24, Y+
     788:	81 11       	cpse	r24, r1
     78a:	fc cf       	rjmp	.-8      	; 0x784 <UART_Transmit_String+0xe>
     78c:	df 91       	pop	r29
     78e:	cf 91       	pop	r28
     790:	08 95       	ret

00000792 <UART_Transmit_Integer>:
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	cd b7       	in	r28, 0x3d	; 61
     798:	de b7       	in	r29, 0x3e	; 62
     79a:	61 97       	sbiw	r28, 0x11	; 17
     79c:	0f b6       	in	r0, 0x3f	; 63
     79e:	f8 94       	cli
     7a0:	de bf       	out	0x3e, r29	; 62
     7a2:	0f be       	out	0x3f, r0	; 63
     7a4:	cd bf       	out	0x3d, r28	; 61
     7a6:	dc 01       	movw	r26, r24
     7a8:	cb 01       	movw	r24, r22
     7aa:	4a e0       	ldi	r20, 0x0A	; 10
     7ac:	be 01       	movw	r22, r28
     7ae:	6f 5f       	subi	r22, 0xFF	; 255
     7b0:	7f 4f       	sbci	r23, 0xFF	; 255
     7b2:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <__itoa_ncheck>
     7b6:	ce 01       	movw	r24, r28
     7b8:	01 96       	adiw	r24, 0x01	; 1
     7ba:	dd df       	rcall	.-70     	; 0x776 <UART_Transmit_String>
     7bc:	61 96       	adiw	r28, 0x11	; 17
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <servoTaak>:
     7ce:	0a e8       	ldi	r16, 0x8A	; 138
     7d0:	10 e0       	ldi	r17, 0x00	; 0
     7d2:	c1 e0       	ldi	r28, 0x01	; 1
     7d4:	d0 e0       	ldi	r29, 0x00	; 0
     7d6:	e1 2c       	mov	r14, r1
     7d8:	f1 2c       	mov	r15, r1
     7da:	f0 92 59 04 	sts	0x0459, r15	; 0x800459 <hoek+0x1>
     7de:	e0 92 58 04 	sts	0x0458, r14	; 0x800458 <hoek>
     7e2:	c7 01       	movw	r24, r14
     7e4:	99 27       	eor	r25, r25
     7e6:	9c 01       	movw	r18, r24
     7e8:	22 0f       	add	r18, r18
     7ea:	33 1f       	adc	r19, r19
     7ec:	22 0f       	add	r18, r18
     7ee:	33 1f       	adc	r19, r19
     7f0:	22 0f       	add	r18, r18
     7f2:	33 1f       	adc	r19, r19
     7f4:	82 1b       	sub	r24, r18
     7f6:	93 0b       	sbc	r25, r19
     7f8:	95 5b       	subi	r25, 0xB5	; 181
     7fa:	f8 01       	movw	r30, r16
     7fc:	91 83       	std	Z+1, r25	; 0x01
     7fe:	80 83       	st	Z, r24
     800:	ff ef       	ldi	r31, 0xFF	; 255
     802:	24 e3       	ldi	r18, 0x34	; 52
     804:	8c e0       	ldi	r24, 0x0C	; 12
     806:	f1 50       	subi	r31, 0x01	; 1
     808:	20 40       	sbci	r18, 0x00	; 0
     80a:	80 40       	sbci	r24, 0x00	; 0
     80c:	e1 f7       	brne	.-8      	; 0x806 <servoTaak+0x38>
     80e:	00 c0       	rjmp	.+0      	; 0x810 <servoTaak+0x42>
     810:	00 00       	nop
     812:	87 e0       	ldi	r24, 0x07	; 7
     814:	92 e0       	ldi	r25, 0x02	; 2
     816:	af df       	rcall	.-162    	; 0x776 <UART_Transmit_String>
     818:	60 91 58 04 	lds	r22, 0x0458	; 0x800458 <hoek>
     81c:	70 91 59 04 	lds	r23, 0x0459	; 0x800459 <hoek+0x1>
     820:	07 2e       	mov	r0, r23
     822:	00 0c       	add	r0, r0
     824:	88 0b       	sbc	r24, r24
     826:	99 0b       	sbc	r25, r25
     828:	b4 df       	rcall	.-152    	; 0x792 <UART_Transmit_Integer>
     82a:	80 e1       	ldi	r24, 0x10	; 16
     82c:	92 e0       	ldi	r25, 0x02	; 2
     82e:	a3 df       	rcall	.-186    	; 0x776 <UART_Transmit_String>
     830:	60 91 63 04 	lds	r22, 0x0463	; 0x800463 <afstand>
     834:	70 91 64 04 	lds	r23, 0x0464	; 0x800464 <afstand+0x1>
     838:	07 2e       	mov	r0, r23
     83a:	00 0c       	add	r0, r0
     83c:	88 0b       	sbc	r24, r24
     83e:	99 0b       	sbc	r25, r25
     840:	a8 df       	rcall	.-176    	; 0x792 <UART_Transmit_Integer>
     842:	8b e1       	ldi	r24, 0x1B	; 27
     844:	92 e0       	ldi	r25, 0x02	; 2
     846:	97 df       	rcall	.-210    	; 0x776 <UART_Transmit_String>
     848:	60 91 36 03 	lds	r22, 0x0336	; 0x800336 <gyroX>
     84c:	70 91 37 03 	lds	r23, 0x0337	; 0x800337 <gyroX+0x1>
     850:	07 2e       	mov	r0, r23
     852:	00 0c       	add	r0, r0
     854:	88 0b       	sbc	r24, r24
     856:	99 0b       	sbc	r25, r25
     858:	9c df       	rcall	.-200    	; 0x792 <UART_Transmit_Integer>
     85a:	85 e2       	ldi	r24, 0x25	; 37
     85c:	92 e0       	ldi	r25, 0x02	; 2
     85e:	8b df       	rcall	.-234    	; 0x776 <UART_Transmit_String>
     860:	60 91 69 04 	lds	r22, 0x0469	; 0x800469 <gyroY>
     864:	70 91 6a 04 	lds	r23, 0x046A	; 0x80046a <gyroY+0x1>
     868:	07 2e       	mov	r0, r23
     86a:	00 0c       	add	r0, r0
     86c:	88 0b       	sbc	r24, r24
     86e:	99 0b       	sbc	r25, r25
     870:	90 df       	rcall	.-224    	; 0x792 <UART_Transmit_Integer>
     872:	8a e2       	ldi	r24, 0x2A	; 42
     874:	92 e0       	ldi	r25, 0x02	; 2
     876:	7f df       	rcall	.-258    	; 0x776 <UART_Transmit_String>
     878:	60 91 50 04 	lds	r22, 0x0450	; 0x800450 <gyroZ>
     87c:	70 91 51 04 	lds	r23, 0x0451	; 0x800451 <gyroZ+0x1>
     880:	07 2e       	mov	r0, r23
     882:	00 0c       	add	r0, r0
     884:	88 0b       	sbc	r24, r24
     886:	99 0b       	sbc	r25, r25
     888:	84 df       	rcall	.-248    	; 0x792 <UART_Transmit_Integer>
     88a:	8f e2       	ldi	r24, 0x2F	; 47
     88c:	92 e0       	ldi	r25, 0x02	; 2
     88e:	73 df       	rcall	.-282    	; 0x776 <UART_Transmit_String>
     890:	60 91 30 03 	lds	r22, 0x0330	; 0x800330 <accelX>
     894:	70 91 31 03 	lds	r23, 0x0331	; 0x800331 <accelX+0x1>
     898:	07 2e       	mov	r0, r23
     89a:	00 0c       	add	r0, r0
     89c:	88 0b       	sbc	r24, r24
     89e:	99 0b       	sbc	r25, r25
     8a0:	78 df       	rcall	.-272    	; 0x792 <UART_Transmit_Integer>
     8a2:	85 e2       	ldi	r24, 0x25	; 37
     8a4:	92 e0       	ldi	r25, 0x02	; 2
     8a6:	67 df       	rcall	.-306    	; 0x776 <UART_Transmit_String>
     8a8:	60 91 2c 03 	lds	r22, 0x032C	; 0x80032c <accelY>
     8ac:	70 91 2d 03 	lds	r23, 0x032D	; 0x80032d <accelY+0x1>
     8b0:	07 2e       	mov	r0, r23
     8b2:	00 0c       	add	r0, r0
     8b4:	88 0b       	sbc	r24, r24
     8b6:	99 0b       	sbc	r25, r25
     8b8:	6c df       	rcall	.-296    	; 0x792 <UART_Transmit_Integer>
     8ba:	8a e2       	ldi	r24, 0x2A	; 42
     8bc:	92 e0       	ldi	r25, 0x02	; 2
     8be:	5b df       	rcall	.-330    	; 0x776 <UART_Transmit_String>
     8c0:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <accelZ>
     8c4:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <accelZ+0x1>
     8c8:	07 2e       	mov	r0, r23
     8ca:	00 0c       	add	r0, r0
     8cc:	88 0b       	sbc	r24, r24
     8ce:	99 0b       	sbc	r25, r25
     8d0:	60 df       	rcall	.-320    	; 0x792 <UART_Transmit_Integer>
     8d2:	d0 93 5f 04 	sts	0x045F, r29	; 0x80045f <watchdogServo+0x1>
     8d6:	c0 93 5e 04 	sts	0x045E, r28	; 0x80045e <watchdogServo>
     8da:	9b e1       	ldi	r25, 0x1B	; 27
     8dc:	e9 0e       	add	r14, r25
     8de:	f1 1c       	adc	r15, r1
     8e0:	e8 ed       	ldi	r30, 0xD8	; 216
     8e2:	ee 16       	cp	r14, r30
     8e4:	f1 04       	cpc	r15, r1
     8e6:	09 f0       	breq	.+2      	; 0x8ea <servoTaak+0x11c>
     8e8:	78 cf       	rjmp	.-272    	; 0x7da <servoTaak+0xc>
     8ea:	75 cf       	rjmp	.-278    	; 0x7d6 <servoTaak+0x8>

000008ec <INT1_init>:
     8ec:	e8 e6       	ldi	r30, 0x68	; 104
     8ee:	f0 e0       	ldi	r31, 0x00	; 0
     8f0:	80 81       	ld	r24, Z
     8f2:	81 60       	ori	r24, 0x01	; 1
     8f4:	80 83       	st	Z, r24
     8f6:	eb e6       	ldi	r30, 0x6B	; 107
     8f8:	f0 e0       	ldi	r31, 0x00	; 0
     8fa:	80 81       	ld	r24, Z
     8fc:	82 60       	ori	r24, 0x02	; 2
     8fe:	80 83       	st	Z, r24
     900:	08 95       	ret

00000902 <__vector_9>:
     902:	1f 92       	push	r1
     904:	0f 92       	push	r0
     906:	0f b6       	in	r0, 0x3f	; 63
     908:	0f 92       	push	r0
     90a:	11 24       	eor	r1, r1
     90c:	0b b6       	in	r0, 0x3b	; 59
     90e:	0f 92       	push	r0
     910:	2f 93       	push	r18
     912:	3f 93       	push	r19
     914:	4f 93       	push	r20
     916:	5f 93       	push	r21
     918:	6f 93       	push	r22
     91a:	7f 93       	push	r23
     91c:	8f 93       	push	r24
     91e:	9f 93       	push	r25
     920:	af 93       	push	r26
     922:	bf 93       	push	r27
     924:	ef 93       	push	r30
     926:	ff 93       	push	r31
     928:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <running>
     92c:	88 23       	and	r24, r24
     92e:	d1 f1       	breq	.+116    	; 0x9a4 <__vector_9+0xa2>
     930:	80 91 c4 02 	lds	r24, 0x02C4	; 0x8002c4 <up>
     934:	81 11       	cpse	r24, r1
     936:	10 c0       	rjmp	.+32     	; 0x958 <__vector_9+0x56>
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <up>
     93e:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <timerCounter>
     942:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <timerCounter+0x1>
     946:	10 92 c2 02 	sts	0x02C2, r1	; 0x8002c2 <timerCounter+0x2>
     94a:	10 92 c3 02 	sts	0x02C3, r1	; 0x8002c3 <timerCounter+0x3>
     94e:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     952:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     956:	26 c0       	rjmp	.+76     	; 0x9a4 <__vector_9+0xa2>
     958:	10 92 c4 02 	sts	0x02C4, r1	; 0x8002c4 <up>
     95c:	20 91 c0 02 	lds	r18, 0x02C0	; 0x8002c0 <timerCounter>
     960:	30 91 c1 02 	lds	r19, 0x02C1	; 0x8002c1 <timerCounter+0x1>
     964:	40 91 c2 02 	lds	r20, 0x02C2	; 0x8002c2 <timerCounter+0x2>
     968:	50 91 c3 02 	lds	r21, 0x02C3	; 0x8002c3 <timerCounter+0x3>
     96c:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     970:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     974:	af ef       	ldi	r26, 0xFF	; 255
     976:	bf ef       	ldi	r27, 0xFF	; 255
     978:	0e 94 97 13 	call	0x272e	; 0x272e <__muluhisi3>
     97c:	6e 0f       	add	r22, r30
     97e:	7f 1f       	adc	r23, r31
     980:	81 1d       	adc	r24, r1
     982:	91 1d       	adc	r25, r1
     984:	24 e7       	ldi	r18, 0x74	; 116
     986:	30 e0       	ldi	r19, 0x00	; 0
     988:	40 e0       	ldi	r20, 0x00	; 0
     98a:	50 e0       	ldi	r21, 0x00	; 0
     98c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <__udivmodsi4>
     990:	20 93 bc 02 	sts	0x02BC, r18	; 0x8002bc <result>
     994:	30 93 bd 02 	sts	0x02BD, r19	; 0x8002bd <result+0x1>
     998:	40 93 be 02 	sts	0x02BE, r20	; 0x8002be <result+0x2>
     99c:	50 93 bf 02 	sts	0x02BF, r21	; 0x8002bf <result+0x3>
     9a0:	10 92 c5 02 	sts	0x02C5, r1	; 0x8002c5 <running>
     9a4:	ff 91       	pop	r31
     9a6:	ef 91       	pop	r30
     9a8:	bf 91       	pop	r27
     9aa:	af 91       	pop	r26
     9ac:	9f 91       	pop	r25
     9ae:	8f 91       	pop	r24
     9b0:	7f 91       	pop	r23
     9b2:	6f 91       	pop	r22
     9b4:	5f 91       	pop	r21
     9b6:	4f 91       	pop	r20
     9b8:	3f 91       	pop	r19
     9ba:	2f 91       	pop	r18
     9bc:	0f 90       	pop	r0
     9be:	0b be       	out	0x3b, r0	; 59
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63
     9c4:	0f 90       	pop	r0
     9c6:	1f 90       	pop	r1
     9c8:	18 95       	reti

000009ca <pulse>:
     9ca:	28 98       	cbi	0x05, 0	; 5
     9cc:	85 e0       	ldi	r24, 0x05	; 5
     9ce:	8a 95       	dec	r24
     9d0:	f1 f7       	brne	.-4      	; 0x9ce <pulse+0x4>
     9d2:	00 00       	nop
     9d4:	28 9a       	sbi	0x05, 0	; 5
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <running>
     9dc:	85 e3       	ldi	r24, 0x35	; 53
     9de:	8a 95       	dec	r24
     9e0:	f1 f7       	brne	.-4      	; 0x9de <pulse+0x14>
     9e2:	00 00       	nop
     9e4:	28 98       	cbi	0x05, 0	; 5
     9e6:	08 95       	ret

000009e8 <sonarTaak>:
     9e8:	c1 e0       	ldi	r28, 0x01	; 1
     9ea:	d0 e0       	ldi	r29, 0x00	; 0
     9ec:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <running>
     9f0:	81 11       	cpse	r24, r1
     9f2:	16 c0       	rjmp	.+44     	; 0xa20 <sonarTaak+0x38>
     9f4:	2f ef       	ldi	r18, 0xFF	; 255
     9f6:	80 e7       	ldi	r24, 0x70	; 112
     9f8:	92 e0       	ldi	r25, 0x02	; 2
     9fa:	21 50       	subi	r18, 0x01	; 1
     9fc:	80 40       	sbci	r24, 0x00	; 0
     9fe:	90 40       	sbci	r25, 0x00	; 0
     a00:	e1 f7       	brne	.-8      	; 0x9fa <sonarTaak+0x12>
     a02:	00 c0       	rjmp	.+0      	; 0xa04 <sonarTaak+0x1c>
     a04:	00 00       	nop
     a06:	e1 df       	rcall	.-62     	; 0x9ca <pulse>
     a08:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <result>
     a0c:	90 91 bd 02 	lds	r25, 0x02BD	; 0x8002bd <result+0x1>
     a10:	a0 91 be 02 	lds	r26, 0x02BE	; 0x8002be <result+0x2>
     a14:	b0 91 bf 02 	lds	r27, 0x02BF	; 0x8002bf <result+0x3>
     a18:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <afstand+0x1>
     a1c:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <afstand>
     a20:	d0 93 35 03 	sts	0x0335, r29	; 0x800335 <watchdogSonar+0x1>
     a24:	c0 93 34 03 	sts	0x0334, r28	; 0x800334 <watchdogSonar>
     a28:	e1 cf       	rjmp	.-62     	; 0x9ec <sonarTaak+0x4>

00000a2a <timer3_init>:
     a2a:	e1 e9       	ldi	r30, 0x91	; 145
     a2c:	f0 e0       	ldi	r31, 0x00	; 0
     a2e:	80 81       	ld	r24, Z
     a30:	82 60       	ori	r24, 0x02	; 2
     a32:	80 83       	st	Z, r24
     a34:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a38:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a3c:	e1 e7       	ldi	r30, 0x71	; 113
     a3e:	f0 e0       	ldi	r31, 0x00	; 0
     a40:	80 81       	ld	r24, Z
     a42:	81 60       	ori	r24, 0x01	; 1
     a44:	80 83       	st	Z, r24
     a46:	08 95       	ret

00000a48 <__vector_35>:
     a48:	1f 92       	push	r1
     a4a:	0f 92       	push	r0
     a4c:	0f b6       	in	r0, 0x3f	; 63
     a4e:	0f 92       	push	r0
     a50:	11 24       	eor	r1, r1
     a52:	0b b6       	in	r0, 0x3b	; 59
     a54:	0f 92       	push	r0
     a56:	2f 93       	push	r18
     a58:	3f 93       	push	r19
     a5a:	4f 93       	push	r20
     a5c:	5f 93       	push	r21
     a5e:	6f 93       	push	r22
     a60:	7f 93       	push	r23
     a62:	8f 93       	push	r24
     a64:	9f 93       	push	r25
     a66:	af 93       	push	r26
     a68:	bf 93       	push	r27
     a6a:	ef 93       	push	r30
     a6c:	ff 93       	push	r31
     a6e:	80 91 c4 02 	lds	r24, 0x02C4	; 0x8002c4 <up>
     a72:	88 23       	and	r24, r24
     a74:	e9 f1       	breq	.+122    	; 0xaf0 <__vector_35+0xa8>
     a76:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <timerCounter>
     a7a:	90 91 c1 02 	lds	r25, 0x02C1	; 0x8002c1 <timerCounter+0x1>
     a7e:	a0 91 c2 02 	lds	r26, 0x02C2	; 0x8002c2 <timerCounter+0x2>
     a82:	b0 91 c3 02 	lds	r27, 0x02C3	; 0x8002c3 <timerCounter+0x3>
     a86:	01 96       	adiw	r24, 0x01	; 1
     a88:	a1 1d       	adc	r26, r1
     a8a:	b1 1d       	adc	r27, r1
     a8c:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <timerCounter>
     a90:	90 93 c1 02 	sts	0x02C1, r25	; 0x8002c1 <timerCounter+0x1>
     a94:	a0 93 c2 02 	sts	0x02C2, r26	; 0x8002c2 <timerCounter+0x2>
     a98:	b0 93 c3 02 	sts	0x02C3, r27	; 0x8002c3 <timerCounter+0x3>
     a9c:	20 91 c0 02 	lds	r18, 0x02C0	; 0x8002c0 <timerCounter>
     aa0:	30 91 c1 02 	lds	r19, 0x02C1	; 0x8002c1 <timerCounter+0x1>
     aa4:	40 91 c2 02 	lds	r20, 0x02C2	; 0x8002c2 <timerCounter+0x2>
     aa8:	50 91 c3 02 	lds	r21, 0x02C3	; 0x8002c3 <timerCounter+0x3>
     aac:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     ab0:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     ab4:	af ef       	ldi	r26, 0xFF	; 255
     ab6:	bf ef       	ldi	r27, 0xFF	; 255
     ab8:	0e 94 97 13 	call	0x272e	; 0x272e <__muluhisi3>
     abc:	dc 01       	movw	r26, r24
     abe:	cb 01       	movw	r24, r22
     ac0:	8e 0f       	add	r24, r30
     ac2:	9f 1f       	adc	r25, r31
     ac4:	a1 1d       	adc	r26, r1
     ac6:	b1 1d       	adc	r27, r1
     ac8:	81 30       	cpi	r24, 0x01	; 1
     aca:	94 4d       	sbci	r25, 0xD4	; 212
     acc:	a0 43       	sbci	r26, 0x30	; 48
     ace:	b1 05       	cpc	r27, r1
     ad0:	78 f0       	brcs	.+30     	; 0xaf0 <__vector_35+0xa8>
     ad2:	10 92 c4 02 	sts	0x02C4, r1	; 0x8002c4 <up>
     ad6:	10 92 c5 02 	sts	0x02C5, r1	; 0x8002c5 <running>
     ada:	8f ef       	ldi	r24, 0xFF	; 255
     adc:	9f ef       	ldi	r25, 0xFF	; 255
     ade:	dc 01       	movw	r26, r24
     ae0:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <result>
     ae4:	90 93 bd 02 	sts	0x02BD, r25	; 0x8002bd <result+0x1>
     ae8:	a0 93 be 02 	sts	0x02BE, r26	; 0x8002be <result+0x2>
     aec:	b0 93 bf 02 	sts	0x02BF, r27	; 0x8002bf <result+0x3>
     af0:	ff 91       	pop	r31
     af2:	ef 91       	pop	r30
     af4:	bf 91       	pop	r27
     af6:	af 91       	pop	r26
     af8:	9f 91       	pop	r25
     afa:	8f 91       	pop	r24
     afc:	7f 91       	pop	r23
     afe:	6f 91       	pop	r22
     b00:	5f 91       	pop	r21
     b02:	4f 91       	pop	r20
     b04:	3f 91       	pop	r19
     b06:	2f 91       	pop	r18
     b08:	0f 90       	pop	r0
     b0a:	0b be       	out	0x3b, r0	; 59
     b0c:	0f 90       	pop	r0
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	0f 90       	pop	r0
     b12:	1f 90       	pop	r1
     b14:	18 95       	reti

00000b16 <initServo>:
     b16:	26 9a       	sbi	0x04, 6	; 4
     b18:	82 e3       	ldi	r24, 0x32	; 50
     b1a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     b1e:	82 e1       	ldi	r24, 0x12	; 18
     b20:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
     b24:	80 e2       	ldi	r24, 0x20	; 32
     b26:	9e e4       	ldi	r25, 0x4E	; 78
     b28:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     b2c:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     b30:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     b34:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	9b e4       	ldi	r25, 0x4B	; 75
     b3c:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     b40:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     b44:	ef e6       	ldi	r30, 0x6F	; 111
     b46:	f0 e0       	ldi	r31, 0x00	; 0
     b48:	80 81       	ld	r24, Z
     b4a:	82 60       	ori	r24, 0x02	; 2
     b4c:	80 83       	st	Z, r24
     b4e:	08 95       	ret

00000b50 <init_master>:
     b50:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     b54:	88 e4       	ldi	r24, 0x48	; 72
     b56:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
     b5a:	84 e0       	ldi	r24, 0x04	; 4
     b5c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     b60:	08 95       	ret

00000b62 <ontvangen>:
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	0f 93       	push	r16
     b68:	1f 93       	push	r17
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	ec eb       	ldi	r30, 0xBC	; 188
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	90 81       	ld	r25, Z
     b74:	90 62       	ori	r25, 0x20	; 32
     b76:	90 83       	st	Z, r25
     b78:	90 81       	ld	r25, Z
     b7a:	99 23       	and	r25, r25
     b7c:	ec f7       	brge	.-6      	; 0xb78 <ontvangen+0x16>
     b7e:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     b82:	88 0f       	add	r24, r24
     b84:	8f 5f       	subi	r24, 0xFF	; 255
     b86:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     b8a:	84 e8       	ldi	r24, 0x84	; 132
     b8c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     b90:	ec eb       	ldi	r30, 0xBC	; 188
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	88 23       	and	r24, r24
     b98:	ec f7       	brge	.-6      	; 0xb94 <ontvangen+0x32>
     b9a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     b9e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     ba2:	db 01       	movw	r26, r22
     ba4:	8c 93       	st	X, r24
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	50 e0       	ldi	r21, 0x00	; 0
     baa:	41 50       	subi	r20, 0x01	; 1
     bac:	51 09       	sbc	r21, r1
     bae:	ec eb       	ldi	r30, 0xBC	; 188
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	0f 2e       	mov	r0, r31
     bb4:	f4 ec       	ldi	r31, 0xC4	; 196
     bb6:	ff 2e       	mov	r15, r31
     bb8:	f0 2d       	mov	r31, r0
     bba:	0f 2e       	mov	r0, r31
     bbc:	f4 e8       	ldi	r31, 0x84	; 132
     bbe:	ef 2e       	mov	r14, r31
     bc0:	f0 2d       	mov	r31, r0
     bc2:	09 eb       	ldi	r16, 0xB9	; 185
     bc4:	10 e0       	ldi	r17, 0x00	; 0
     bc6:	cb eb       	ldi	r28, 0xBB	; 187
     bc8:	d0 e0       	ldi	r29, 0x00	; 0
     bca:	29 2f       	mov	r18, r25
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	24 17       	cp	r18, r20
     bd0:	35 07       	cpc	r19, r21
     bd2:	11 f4       	brne	.+4      	; 0xbd8 <ontvangen+0x76>
     bd4:	e0 82       	st	Z, r14
     bd6:	01 c0       	rjmp	.+2      	; 0xbda <ontvangen+0x78>
     bd8:	f0 82       	st	Z, r15
     bda:	80 81       	ld	r24, Z
     bdc:	88 23       	and	r24, r24
     bde:	ec f7       	brge	.-6      	; 0xbda <ontvangen+0x78>
     be0:	d8 01       	movw	r26, r16
     be2:	8c 91       	ld	r24, X
     be4:	28 81       	ld	r18, Y
     be6:	db 01       	movw	r26, r22
     be8:	a9 0f       	add	r26, r25
     bea:	b1 1d       	adc	r27, r1
     bec:	2c 93       	st	X, r18
     bee:	9f 5f       	subi	r25, 0xFF	; 255
     bf0:	80 35       	cpi	r24, 0x50	; 80
     bf2:	59 f3       	breq	.-42     	; 0xbca <ontvangen+0x68>
     bf4:	84 e9       	ldi	r24, 0x94	; 148
     bf6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     bfa:	df 91       	pop	r29
     bfc:	cf 91       	pop	r28
     bfe:	1f 91       	pop	r17
     c00:	0f 91       	pop	r16
     c02:	ff 90       	pop	r15
     c04:	ef 90       	pop	r14
     c06:	08 95       	ret

00000c08 <verzenden>:
     c08:	ec eb       	ldi	r30, 0xBC	; 188
     c0a:	f0 e0       	ldi	r31, 0x00	; 0
     c0c:	90 81       	ld	r25, Z
     c0e:	90 62       	ori	r25, 0x20	; 32
     c10:	90 83       	st	Z, r25
     c12:	90 81       	ld	r25, Z
     c14:	99 23       	and	r25, r25
     c16:	ec f7       	brge	.-6      	; 0xc12 <verzenden+0xa>
     c18:	88 0f       	add	r24, r24
     c1a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c1e:	84 e8       	ldi	r24, 0x84	; 132
     c20:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c24:	ec eb       	ldi	r30, 0xBC	; 188
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	80 81       	ld	r24, Z
     c2a:	88 23       	and	r24, r24
     c2c:	ec f7       	brge	.-6      	; 0xc28 <verzenden+0x20>
     c2e:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c32:	84 e8       	ldi	r24, 0x84	; 132
     c34:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c38:	ec eb       	ldi	r30, 0xBC	; 188
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
     c3e:	88 23       	and	r24, r24
     c40:	ec f7       	brge	.-6      	; 0xc3c <verzenden+0x34>
     c42:	84 e9       	ldi	r24, 0x94	; 148
     c44:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c48:	08 95       	ret

00000c4a <gyroTaak>:
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	1f 92       	push	r1
     c50:	1f 92       	push	r1
     c52:	cd b7       	in	r28, 0x3d	; 61
     c54:	de b7       	in	r29, 0x3e	; 62
     c56:	01 e0       	ldi	r16, 0x01	; 1
     c58:	10 e0       	ldi	r17, 0x00	; 0
     c5a:	6b e3       	ldi	r22, 0x3B	; 59
     c5c:	88 e6       	ldi	r24, 0x68	; 104
     c5e:	d4 df       	rcall	.-88     	; 0xc08 <verzenden>
     c60:	41 e0       	ldi	r20, 0x01	; 1
     c62:	be 01       	movw	r22, r28
     c64:	6f 5f       	subi	r22, 0xFF	; 255
     c66:	7f 4f       	sbci	r23, 0xFF	; 255
     c68:	88 e6       	ldi	r24, 0x68	; 104
     c6a:	7b df       	rcall	.-266    	; 0xb62 <ontvangen>
     c6c:	f9 80       	ldd	r15, Y+1	; 0x01
     c6e:	6c e3       	ldi	r22, 0x3C	; 60
     c70:	88 e6       	ldi	r24, 0x68	; 104
     c72:	ca df       	rcall	.-108    	; 0xc08 <verzenden>
     c74:	41 e0       	ldi	r20, 0x01	; 1
     c76:	be 01       	movw	r22, r28
     c78:	6f 5f       	subi	r22, 0xFF	; 255
     c7a:	7f 4f       	sbci	r23, 0xFF	; 255
     c7c:	88 e6       	ldi	r24, 0x68	; 104
     c7e:	71 df       	rcall	.-286    	; 0xb62 <ontvangen>
     c80:	6f 2d       	mov	r22, r15
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	76 2f       	mov	r23, r22
     c86:	66 27       	eor	r22, r22
     c88:	89 81       	ldd	r24, Y+1	; 0x01
     c8a:	68 2b       	or	r22, r24
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     c94:	20 91 6b 04 	lds	r18, 0x046B	; 0x80046b <_gyroScale>
     c98:	30 91 6c 04 	lds	r19, 0x046C	; 0x80046c <_gyroScale+0x1>
     c9c:	40 91 6d 04 	lds	r20, 0x046D	; 0x80046d <_gyroScale+0x2>
     ca0:	50 91 6e 04 	lds	r21, 0x046E	; 0x80046e <_gyroScale+0x3>
     ca4:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	4a e8       	ldi	r20, 0x8A	; 138
     cae:	52 e4       	ldi	r21, 0x42	; 66
     cb0:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__subsf3>
     cb4:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     cb8:	70 93 37 03 	sts	0x0337, r23	; 0x800337 <gyroX+0x1>
     cbc:	60 93 36 03 	sts	0x0336, r22	; 0x800336 <gyroX>
     cc0:	6d e3       	ldi	r22, 0x3D	; 61
     cc2:	88 e6       	ldi	r24, 0x68	; 104
     cc4:	a1 df       	rcall	.-190    	; 0xc08 <verzenden>
     cc6:	41 e0       	ldi	r20, 0x01	; 1
     cc8:	be 01       	movw	r22, r28
     cca:	6f 5f       	subi	r22, 0xFF	; 255
     ccc:	7f 4f       	sbci	r23, 0xFF	; 255
     cce:	88 e6       	ldi	r24, 0x68	; 104
     cd0:	48 df       	rcall	.-368    	; 0xb62 <ontvangen>
     cd2:	f9 80       	ldd	r15, Y+1	; 0x01
     cd4:	6e e3       	ldi	r22, 0x3E	; 62
     cd6:	88 e6       	ldi	r24, 0x68	; 104
     cd8:	97 df       	rcall	.-210    	; 0xc08 <verzenden>
     cda:	41 e0       	ldi	r20, 0x01	; 1
     cdc:	be 01       	movw	r22, r28
     cde:	6f 5f       	subi	r22, 0xFF	; 255
     ce0:	7f 4f       	sbci	r23, 0xFF	; 255
     ce2:	88 e6       	ldi	r24, 0x68	; 104
     ce4:	3e df       	rcall	.-388    	; 0xb62 <ontvangen>
     ce6:	6f 2d       	mov	r22, r15
     ce8:	70 e0       	ldi	r23, 0x00	; 0
     cea:	76 2f       	mov	r23, r22
     cec:	66 27       	eor	r22, r22
     cee:	89 81       	ldd	r24, Y+1	; 0x01
     cf0:	68 2b       	or	r22, r24
     cf2:	80 e0       	ldi	r24, 0x00	; 0
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     cfa:	20 91 6b 04 	lds	r18, 0x046B	; 0x80046b <_gyroScale>
     cfe:	30 91 6c 04 	lds	r19, 0x046C	; 0x80046c <_gyroScale+0x1>
     d02:	40 91 6d 04 	lds	r20, 0x046D	; 0x80046d <_gyroScale+0x2>
     d06:	50 91 6e 04 	lds	r21, 0x046E	; 0x80046e <_gyroScale+0x3>
     d0a:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     d0e:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     d12:	70 93 6a 04 	sts	0x046A, r23	; 0x80046a <gyroY+0x1>
     d16:	60 93 69 04 	sts	0x0469, r22	; 0x800469 <gyroY>
     d1a:	6f e3       	ldi	r22, 0x3F	; 63
     d1c:	88 e6       	ldi	r24, 0x68	; 104
     d1e:	74 df       	rcall	.-280    	; 0xc08 <verzenden>
     d20:	41 e0       	ldi	r20, 0x01	; 1
     d22:	be 01       	movw	r22, r28
     d24:	6f 5f       	subi	r22, 0xFF	; 255
     d26:	7f 4f       	sbci	r23, 0xFF	; 255
     d28:	88 e6       	ldi	r24, 0x68	; 104
     d2a:	1b df       	rcall	.-458    	; 0xb62 <ontvangen>
     d2c:	f9 80       	ldd	r15, Y+1	; 0x01
     d2e:	60 e4       	ldi	r22, 0x40	; 64
     d30:	88 e6       	ldi	r24, 0x68	; 104
     d32:	6a df       	rcall	.-300    	; 0xc08 <verzenden>
     d34:	41 e0       	ldi	r20, 0x01	; 1
     d36:	be 01       	movw	r22, r28
     d38:	6f 5f       	subi	r22, 0xFF	; 255
     d3a:	7f 4f       	sbci	r23, 0xFF	; 255
     d3c:	88 e6       	ldi	r24, 0x68	; 104
     d3e:	11 df       	rcall	.-478    	; 0xb62 <ontvangen>
     d40:	6f 2d       	mov	r22, r15
     d42:	70 e0       	ldi	r23, 0x00	; 0
     d44:	76 2f       	mov	r23, r22
     d46:	66 27       	eor	r22, r22
     d48:	89 81       	ldd	r24, Y+1	; 0x01
     d4a:	68 2b       	or	r22, r24
     d4c:	80 e0       	ldi	r24, 0x00	; 0
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     d54:	20 91 6b 04 	lds	r18, 0x046B	; 0x80046b <_gyroScale>
     d58:	30 91 6c 04 	lds	r19, 0x046C	; 0x80046c <_gyroScale+0x1>
     d5c:	40 91 6d 04 	lds	r20, 0x046D	; 0x80046d <_gyroScale+0x2>
     d60:	50 91 6e 04 	lds	r21, 0x046E	; 0x80046e <_gyroScale+0x3>
     d64:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     d68:	20 e0       	ldi	r18, 0x00	; 0
     d6a:	30 e0       	ldi	r19, 0x00	; 0
     d6c:	40 e8       	ldi	r20, 0x80	; 128
     d6e:	51 e4       	ldi	r21, 0x41	; 65
     d70:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__subsf3>
     d74:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     d78:	70 93 51 04 	sts	0x0451, r23	; 0x800451 <gyroZ+0x1>
     d7c:	60 93 50 04 	sts	0x0450, r22	; 0x800450 <gyroZ>
     d80:	63 e4       	ldi	r22, 0x43	; 67
     d82:	88 e6       	ldi	r24, 0x68	; 104
     d84:	41 df       	rcall	.-382    	; 0xc08 <verzenden>
     d86:	41 e0       	ldi	r20, 0x01	; 1
     d88:	be 01       	movw	r22, r28
     d8a:	6f 5f       	subi	r22, 0xFF	; 255
     d8c:	7f 4f       	sbci	r23, 0xFF	; 255
     d8e:	88 e6       	ldi	r24, 0x68	; 104
     d90:	e8 de       	rcall	.-560    	; 0xb62 <ontvangen>
     d92:	f9 80       	ldd	r15, Y+1	; 0x01
     d94:	64 e4       	ldi	r22, 0x44	; 68
     d96:	88 e6       	ldi	r24, 0x68	; 104
     d98:	37 df       	rcall	.-402    	; 0xc08 <verzenden>
     d9a:	41 e0       	ldi	r20, 0x01	; 1
     d9c:	be 01       	movw	r22, r28
     d9e:	6f 5f       	subi	r22, 0xFF	; 255
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	88 e6       	ldi	r24, 0x68	; 104
     da4:	de de       	rcall	.-580    	; 0xb62 <ontvangen>
     da6:	6f 2d       	mov	r22, r15
     da8:	70 e0       	ldi	r23, 0x00	; 0
     daa:	76 2f       	mov	r23, r22
     dac:	66 27       	eor	r22, r22
     dae:	89 81       	ldd	r24, Y+1	; 0x01
     db0:	68 2b       	or	r22, r24
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     dba:	20 91 65 04 	lds	r18, 0x0465	; 0x800465 <_accelScale>
     dbe:	30 91 66 04 	lds	r19, 0x0466	; 0x800466 <_accelScale+0x1>
     dc2:	40 91 67 04 	lds	r20, 0x0467	; 0x800467 <_accelScale+0x2>
     dc6:	50 91 68 04 	lds	r21, 0x0468	; 0x800468 <_accelScale+0x3>
     dca:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     dce:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     dd2:	70 93 31 03 	sts	0x0331, r23	; 0x800331 <accelX+0x1>
     dd6:	60 93 30 03 	sts	0x0330, r22	; 0x800330 <accelX>
     dda:	65 e4       	ldi	r22, 0x45	; 69
     ddc:	88 e6       	ldi	r24, 0x68	; 104
     dde:	14 df       	rcall	.-472    	; 0xc08 <verzenden>
     de0:	41 e0       	ldi	r20, 0x01	; 1
     de2:	be 01       	movw	r22, r28
     de4:	6f 5f       	subi	r22, 0xFF	; 255
     de6:	7f 4f       	sbci	r23, 0xFF	; 255
     de8:	88 e6       	ldi	r24, 0x68	; 104
     dea:	bb de       	rcall	.-650    	; 0xb62 <ontvangen>
     dec:	f9 80       	ldd	r15, Y+1	; 0x01
     dee:	66 e4       	ldi	r22, 0x46	; 70
     df0:	88 e6       	ldi	r24, 0x68	; 104
     df2:	0a df       	rcall	.-492    	; 0xc08 <verzenden>
     df4:	41 e0       	ldi	r20, 0x01	; 1
     df6:	be 01       	movw	r22, r28
     df8:	6f 5f       	subi	r22, 0xFF	; 255
     dfa:	7f 4f       	sbci	r23, 0xFF	; 255
     dfc:	88 e6       	ldi	r24, 0x68	; 104
     dfe:	b1 de       	rcall	.-670    	; 0xb62 <ontvangen>
     e00:	6f 2d       	mov	r22, r15
     e02:	70 e0       	ldi	r23, 0x00	; 0
     e04:	76 2f       	mov	r23, r22
     e06:	66 27       	eor	r22, r22
     e08:	89 81       	ldd	r24, Y+1	; 0x01
     e0a:	68 2b       	or	r22, r24
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     e14:	20 91 65 04 	lds	r18, 0x0465	; 0x800465 <_accelScale>
     e18:	30 91 66 04 	lds	r19, 0x0466	; 0x800466 <_accelScale+0x1>
     e1c:	40 91 67 04 	lds	r20, 0x0467	; 0x800467 <_accelScale+0x2>
     e20:	50 91 68 04 	lds	r21, 0x0468	; 0x800468 <_accelScale+0x3>
     e24:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     e28:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     e2c:	70 93 2d 03 	sts	0x032D, r23	; 0x80032d <accelY+0x1>
     e30:	60 93 2c 03 	sts	0x032C, r22	; 0x80032c <accelY>
     e34:	67 e4       	ldi	r22, 0x47	; 71
     e36:	88 e6       	ldi	r24, 0x68	; 104
     e38:	e7 de       	rcall	.-562    	; 0xc08 <verzenden>
     e3a:	41 e0       	ldi	r20, 0x01	; 1
     e3c:	be 01       	movw	r22, r28
     e3e:	6f 5f       	subi	r22, 0xFF	; 255
     e40:	7f 4f       	sbci	r23, 0xFF	; 255
     e42:	88 e6       	ldi	r24, 0x68	; 104
     e44:	8e de       	rcall	.-740    	; 0xb62 <ontvangen>
     e46:	f9 80       	ldd	r15, Y+1	; 0x01
     e48:	68 e4       	ldi	r22, 0x48	; 72
     e4a:	88 e6       	ldi	r24, 0x68	; 104
     e4c:	dd de       	rcall	.-582    	; 0xc08 <verzenden>
     e4e:	41 e0       	ldi	r20, 0x01	; 1
     e50:	be 01       	movw	r22, r28
     e52:	6f 5f       	subi	r22, 0xFF	; 255
     e54:	7f 4f       	sbci	r23, 0xFF	; 255
     e56:	88 e6       	ldi	r24, 0x68	; 104
     e58:	84 de       	rcall	.-760    	; 0xb62 <ontvangen>
     e5a:	6f 2d       	mov	r22, r15
     e5c:	70 e0       	ldi	r23, 0x00	; 0
     e5e:	76 2f       	mov	r23, r22
     e60:	66 27       	eor	r22, r22
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	68 2b       	or	r22, r24
     e66:	80 e0       	ldi	r24, 0x00	; 0
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	0e 94 6d 12 	call	0x24da	; 0x24da <__floatunsisf>
     e6e:	20 91 65 04 	lds	r18, 0x0465	; 0x800465 <_accelScale>
     e72:	30 91 66 04 	lds	r19, 0x0466	; 0x800466 <_accelScale+0x1>
     e76:	40 91 67 04 	lds	r20, 0x0467	; 0x800467 <_accelScale+0x2>
     e7a:	50 91 68 04 	lds	r21, 0x0468	; 0x800468 <_accelScale+0x3>
     e7e:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <__mulsf3>
     e82:	20 e0       	ldi	r18, 0x00	; 0
     e84:	30 e8       	ldi	r19, 0x80	; 128
     e86:	4c e9       	ldi	r20, 0x9C	; 156
     e88:	53 e4       	ldi	r21, 0x43	; 67
     e8a:	0e 94 d7 11 	call	0x23ae	; 0x23ae <__subsf3>
     e8e:	0e 94 3c 12 	call	0x2478	; 0x2478 <__fixsfsi>
     e92:	70 93 62 04 	sts	0x0462, r23	; 0x800462 <accelZ+0x1>
     e96:	60 93 61 04 	sts	0x0461, r22	; 0x800461 <accelZ>
     e9a:	10 93 33 03 	sts	0x0333, r17	; 0x800333 <watchdogGyro+0x1>
     e9e:	00 93 32 03 	sts	0x0332, r16	; 0x800332 <watchdogGyro>
     ea2:	db ce       	rjmp	.-586    	; 0xc5a <gyroTaak+0x10>

00000ea4 <__vector_17>:
     ea4:	1f 92       	push	r1
     ea6:	0f 92       	push	r0
     ea8:	0f b6       	in	r0, 0x3f	; 63
     eaa:	0f 92       	push	r0
     eac:	11 24       	eor	r1, r1
     eae:	8f 93       	push	r24
     eb0:	9f 93       	push	r25
     eb2:	95 b1       	in	r25, 0x05	; 5
     eb4:	80 e4       	ldi	r24, 0x40	; 64
     eb6:	89 27       	eor	r24, r25
     eb8:	85 b9       	out	0x05, r24	; 5
     eba:	9f 91       	pop	r25
     ebc:	8f 91       	pop	r24
     ebe:	0f 90       	pop	r0
     ec0:	0f be       	out	0x3f, r0	; 63
     ec2:	0f 90       	pop	r0
     ec4:	1f 90       	pop	r1
     ec6:	18 95       	reti

00000ec8 <motorStop>:
     ec8:	a1 98       	cbi	0x14, 1	; 20
     eca:	eb e0       	ldi	r30, 0x0B	; 11
     ecc:	f1 e0       	ldi	r31, 0x01	; 1
     ece:	80 81       	ld	r24, Z
     ed0:	8f 77       	andi	r24, 0x7F	; 127
     ed2:	80 83       	st	Z, r24
     ed4:	41 98       	cbi	0x08, 1	; 8
     ed6:	5f 98       	cbi	0x0b, 7	; 11
     ed8:	08 95       	ret

00000eda <motorEnable>:
}

void motorEnable()
{
	motorStop();
     eda:	f6 df       	rcall	.-20     	; 0xec8 <motorStop>
	PORTL |= (1 << R_EN);
     edc:	eb e0       	ldi	r30, 0x0B	; 11
     ede:	f1 e0       	ldi	r31, 0x01	; 1
     ee0:	80 81       	ld	r24, Z
     ee2:	88 60       	ori	r24, 0x08	; 8
     ee4:	80 83       	st	Z, r24
	PORTL |= (1 << L_EN);
     ee6:	80 81       	ld	r24, Z
     ee8:	80 62       	ori	r24, 0x20	; 32
     eea:	80 83       	st	Z, r24
     eec:	08 95       	ret

00000eee <initMotor>:

#define R_PLUS PG1
#define R_MIN PL7
#define R_EN PL3 -> pwm
*/
	DDRC |= (1 << L_PLUS);
     eee:	39 9a       	sbi	0x07, 1	; 7
	DDRD |= (1 << L_MIN);
     ef0:	57 9a       	sbi	0x0a, 7	; 10
	DDRL |= (1 << L_EN) | (1 << R_MIN) | (1 << R_EN);
     ef2:	ea e0       	ldi	r30, 0x0A	; 10
     ef4:	f1 e0       	ldi	r31, 0x01	; 1
     ef6:	80 81       	ld	r24, Z
     ef8:	88 6a       	ori	r24, 0xA8	; 168
     efa:	80 83       	st	Z, r24
	DDRG |= (1 << R_PLUS);
     efc:	99 9a       	sbi	0x13, 1	; 19

	TCCR5A = (1 << WGM51) | (1 << COM5A0) | (1 << COM5A1) |
     efe:	8e ec       	ldi	r24, 0xCE	; 206
     f00:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	(1 << COM5C0) | (1 << COM5C1);
	TCCR5B = (1 << WGM53) | (1 << CS51);
     f04:	82 e1       	ldi	r24, 0x12	; 18
     f06:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	ICR5 = 20000;
     f0a:	80 e2       	ldi	r24, 0x20	; 32
     f0c:	9e e4       	ldi	r25, 0x4E	; 78
     f0e:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     f12:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	TCNT5 = 0;
     f16:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     f1a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>

	motorEnable();
     f1e:	dd cf       	rjmp	.-70     	; 0xeda <motorEnable>
     f20:	08 95       	ret

00000f22 <main>:
//trigger = digital pin 53
//echo = digital pin 52
//servo = digital pin 12

int main() 
{
     f22:	ef 92       	push	r14
     f24:	ff 92       	push	r15
     f26:	0f 93       	push	r16
	sem = xSemaphoreCreateBinary();
     f28:	43 e0       	ldi	r20, 0x03	; 3
     f2a:	60 e0       	ldi	r22, 0x00	; 0
     f2c:	81 e0       	ldi	r24, 0x01	; 1
     f2e:	4f d3       	rcall	.+1694   	; 0x15ce <xQueueGenericCreate>
     f30:	90 93 2f 03 	sts	0x032F, r25	; 0x80032f <sem+0x1>
     f34:	80 93 2e 03 	sts	0x032E, r24	; 0x80032e <sem>
	xSemaphoreGive(sem);
     f38:	20 e0       	ldi	r18, 0x00	; 0
     f3a:	40 e0       	ldi	r20, 0x00	; 0
     f3c:	50 e0       	ldi	r21, 0x00	; 0
     f3e:	60 e0       	ldi	r22, 0x00	; 0
     f40:	70 e0       	ldi	r23, 0x00	; 0
     f42:	71 d3       	rcall	.+1762   	; 0x1626 <xQueueGenericSend>
	DDRD|= 0x03;
     f44:	8a b1       	in	r24, 0x0a	; 10
     f46:	83 60       	ori	r24, 0x03	; 3
	DDRB |= (1 << TRIGGER);											// Trigger pin
     f48:	8a b9       	out	0x0a, r24	; 10
	initMotor();
     f4a:	20 9a       	sbi	0x04, 0	; 4
     f4c:	d0 df       	rcall	.-96     	; 0xeee <initMotor>
	motorCommand = xQueueCreate(10, sizeof(uint8_t));
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	61 e0       	ldi	r22, 0x01	; 1
     f52:	8a e0       	ldi	r24, 0x0A	; 10
     f54:	3c d3       	rcall	.+1656   	; 0x15ce <xQueueGenericCreate>
     f56:	90 93 3b 04 	sts	0x043B, r25	; 0x80043b <motorCommand+0x1>
	UART_Init();
     f5a:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <motorCommand>
	INT1_init();
     f5e:	eb db       	rcall	.-2090   	; 0x736 <UART_Init>
	timer3_init();
     f60:	c5 dc       	rcall	.-1654   	; 0x8ec <INT1_init>
     f62:	63 dd       	rcall	.-1338   	; 0xa2a <timer3_init>
	initServo();
     f64:	d8 dd       	rcall	.-1104   	; 0xb16 <initServo>
     f66:	78 94       	sei
	sei();
     f68:	f3 dd       	rcall	.-1050   	; 0xb50 <init_master>
	//initQ();
	init_master();
     f6a:	10 92 35 03 	sts	0x0335, r1	; 0x800335 <watchdogSonar+0x1>
	watchdogSonar=0;
     f6e:	10 92 34 03 	sts	0x0334, r1	; 0x800334 <watchdogSonar>
     f72:	10 92 5f 04 	sts	0x045F, r1	; 0x80045f <watchdogServo+0x1>
	watchdogServo=0;
     f76:	10 92 5e 04 	sts	0x045E, r1	; 0x80045e <watchdogServo>
     f7a:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <watchdogTemp+0x1>
	watchdogTemp=0;
     f7e:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <watchdogTemp>
     f82:	86 e1       	ldi	r24, 0x16	; 22
     f84:	9a ee       	ldi	r25, 0xEA	; 234
	//wdt_enable(WDTO_4S);
	_accelScale = G * 16.0f/32767.5f;
     f86:	ac e9       	ldi	r26, 0x9C	; 156
     f88:	bb e3       	ldi	r27, 0x3B	; 59
     f8a:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <_accelScale>
     f8e:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <_accelScale+0x1>
     f92:	a0 93 67 04 	sts	0x0467, r26	; 0x800467 <_accelScale+0x2>
     f96:	b0 93 68 04 	sts	0x0468, r27	; 0x800468 <_accelScale+0x3>
     f9a:	83 ee       	ldi	r24, 0xE3	; 227
     f9c:	90 ea       	ldi	r25, 0xA0	; 160
	_gyroScale = 2000.0f/32767.5f * _d2r;
     f9e:	ab e8       	ldi	r26, 0x8B	; 139
     fa0:	ba e3       	ldi	r27, 0x3A	; 58
     fa2:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <_gyroScale>
     fa6:	90 93 6c 04 	sts	0x046C, r25	; 0x80046c <_gyroScale+0x1>
     faa:	a0 93 6d 04 	sts	0x046D, r26	; 0x80046d <_gyroScale+0x2>
     fae:	b0 93 6e 04 	sts	0x046E, r27	; 0x80046e <_gyroScale+0x3>
     fb2:	8a e3       	ldi	r24, 0x3A	; 58

	// Replace with your application code
//	UART_Transmit('a');
	UART_Transmit_String("\n\rsetup done\n\r");
     fb4:	92 e0       	ldi	r25, 0x02	; 2
     fb6:	df db       	rcall	.-2114   	; 0x776 <UART_Transmit_String>
     fb8:	e1 2c       	mov	r14, r1
     fba:	f1 2c       	mov	r15, r1
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,3,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
     fbc:	03 e0       	ldi	r16, 0x03	; 3
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	40 e0       	ldi	r20, 0x00	; 0
     fc4:	51 e0       	ldi	r21, 0x01	; 1
     fc6:	69 e4       	ldi	r22, 0x49	; 73
     fc8:	72 e0       	ldi	r23, 0x02	; 2
     fca:	84 ef       	ldi	r24, 0xF4	; 244
     fcc:	94 e0       	ldi	r25, 0x04	; 4
     fce:	16 d6       	rcall	.+3116   	; 0x1bfc <xTaskCreate>
     fd0:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,3,NULL);			//code van Joris & Benjamin
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	40 e0       	ldi	r20, 0x00	; 0
     fd6:	51 e0       	ldi	r21, 0x01	; 1
     fd8:	66 e5       	ldi	r22, 0x56	; 86
     fda:	72 e0       	ldi	r23, 0x02	; 2
     fdc:	87 ee       	ldi	r24, 0xE7	; 231
     fde:	93 e0       	ldi	r25, 0x03	; 3
     fe0:	0d d6       	rcall	.+3098   	; 0x1bfc <xTaskCreate>
     fe2:	20 e0       	ldi	r18, 0x00	; 0
	//xTaskCreate(temperatuurTaak,"temperatuur Sensor",256,NULL,3,NULL);
	xTaskCreate(gyroTaak,"Gyroscoop Sensor",256,NULL,3,NULL);
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	40 e0       	ldi	r20, 0x00	; 0
     fe8:	51 e0       	ldi	r21, 0x01	; 1
     fea:	62 e6       	ldi	r22, 0x62	; 98
     fec:	72 e0       	ldi	r23, 0x02	; 2
     fee:	85 e2       	ldi	r24, 0x25	; 37
     ff0:	96 e0       	ldi	r25, 0x06	; 6
     ff2:	04 d6       	rcall	.+3080   	; 0x1bfc <xTaskCreate>
     ff4:	20 e0       	ldi	r18, 0x00	; 0
	//xTaskCreate(motorTaak,"Motor Taak met input",256,NULL,3,NULL);
	xTaskCreate(motorTaak2,"Motor Taak zonder input",256,NULL,3,NULL);
     ff6:	30 e0       	ldi	r19, 0x00	; 0
     ff8:	40 e0       	ldi	r20, 0x00	; 0
     ffa:	51 e0       	ldi	r21, 0x01	; 1
     ffc:	63 e7       	ldi	r22, 0x73	; 115
     ffe:	72 e0       	ldi	r23, 0x02	; 2
    1000:	82 e4       	ldi	r24, 0x42	; 66
    1002:	98 e0       	ldi	r25, 0x08	; 8
    1004:	fb d5       	rcall	.+3062   	; 0x1bfc <xTaskCreate>
	xTaskCreate(watchdogTaak,"watchdog reset",256,NULL,4,NULL);
    1006:	04 e0       	ldi	r16, 0x04	; 4
    1008:	20 e0       	ldi	r18, 0x00	; 0
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	40 e0       	ldi	r20, 0x00	; 0
    100e:	51 e0       	ldi	r21, 0x01	; 1
    1010:	6b e8       	ldi	r22, 0x8B	; 139
    1012:	72 e0       	ldi	r23, 0x02	; 2
    1014:	85 e7       	ldi	r24, 0x75	; 117
    1016:	93 e0       	ldi	r25, 0x03	; 3
    1018:	f1 d5       	rcall	.+3042   	; 0x1bfc <xTaskCreate>
    101a:	04 d7       	rcall	.+3592   	; 0x1e24 <vTaskStartScheduler>

	vTaskStartScheduler();
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	90 e0       	ldi	r25, 0x00	; 0
}
    1020:	0f 91       	pop	r16
    1022:	ff 90       	pop	r15
    1024:	ef 90       	pop	r14
    1026:	08 95       	ret

00001028 <setSpeed>:
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
	PORTC &= ~(1 << L_PLUS);
	PORTD &= ~(1 << L_MIN);
}

void setSpeed(uint8_t speed)
{
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
	itoa(speed, send, 10);
    1030:	08 2f       	mov	r16, r24
    1032:	10 e0       	ldi	r17, 0x00	; 0
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1034:	4a e0       	ldi	r20, 0x0A	; 10
    1036:	6c e3       	ldi	r22, 0x3C	; 60
    1038:	74 e0       	ldi	r23, 0x04	; 4
    103a:	c8 01       	movw	r24, r16
    103c:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <__itoa_ncheck>
	UART_Transmit_String(send);
    1040:	8c e3       	ldi	r24, 0x3C	; 60
    1042:	94 e0       	ldi	r25, 0x04	; 4
    1044:	98 db       	rcall	.-2256   	; 0x776 <UART_Transmit_String>
	uint16_t newSpeed = 20000 - (20000 / 100 * speed);
    1046:	88 e3       	ldi	r24, 0x38	; 56
    1048:	80 9f       	mul	r24, r16
    104a:	e0 01       	movw	r28, r0
    104c:	81 9f       	mul	r24, r17
    104e:	d0 0d       	add	r29, r0
    1050:	d0 1b       	sub	r29, r16
    1052:	11 24       	eor	r1, r1
    1054:	c0 5e       	subi	r28, 0xE0	; 224
    1056:	d1 4b       	sbci	r29, 0xB1	; 177
    1058:	4a e0       	ldi	r20, 0x0A	; 10
    105a:	6c e3       	ldi	r22, 0x3C	; 60
    105c:	74 e0       	ldi	r23, 0x04	; 4
    105e:	ce 01       	movw	r24, r28
    1060:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <__itoa_ncheck>
	itoa(newSpeed, send, 10);
	UART_Transmit_String(send);
    1064:	8c e3       	ldi	r24, 0x3C	; 60
    1066:	94 e0       	ldi	r25, 0x04	; 4
    1068:	86 db       	rcall	.-2292   	; 0x776 <UART_Transmit_String>
	OCR5A = newSpeed;
    106a:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    106e:	c0 93 28 01 	sts	0x0128, r28	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5C = newSpeed;
    1072:	d0 93 2d 01 	sts	0x012D, r29	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1076:	c0 93 2c 01 	sts	0x012C, r28	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
}
    107a:	df 91       	pop	r29
    107c:	cf 91       	pop	r28
    107e:	1f 91       	pop	r17
    1080:	0f 91       	pop	r16
    1082:	08 95       	ret

00001084 <motorTaak2>:

	vTaskStartScheduler();
}

void motorTaak2(){
	setSpeed(10);
    1084:	8a e0       	ldi	r24, 0x0A	; 10
    1086:	d0 df       	rcall	.-96     	; 0x1028 <setSpeed>
	while(1){
		motorStop();
		PORTL |= (1 << R_MIN);
    1088:	cb e0       	ldi	r28, 0x0B	; 11
}

void motorTaak2(){
	setSpeed(10);
	while(1){
		motorStop();
    108a:	d1 e0       	ldi	r29, 0x01	; 1
    108c:	1d df       	rcall	.-454    	; 0xec8 <motorStop>
		PORTL |= (1 << R_MIN);
    108e:	88 81       	ld	r24, Y
    1090:	80 68       	ori	r24, 0x80	; 128
    1092:	88 83       	st	Y, r24
    1094:	2f ef       	ldi	r18, 0xFF	; 255
    1096:	83 ed       	ldi	r24, 0xD3	; 211
    1098:	90 e3       	ldi	r25, 0x30	; 48
    109a:	21 50       	subi	r18, 0x01	; 1
    109c:	80 40       	sbci	r24, 0x00	; 0
    109e:	90 40       	sbci	r25, 0x00	; 0
    10a0:	e1 f7       	brne	.-8      	; 0x109a <motorTaak2+0x16>
    10a2:	00 c0       	rjmp	.+0      	; 0x10a4 <motorTaak2+0x20>
		//vTaskDelay(1000);
		_delay_ms(1000);
		motorStop();
    10a4:	00 00       	nop
    10a6:	10 df       	rcall	.-480    	; 0xec8 <motorStop>
		PORTG |= (1 << R_PLUS);
    10a8:	a1 9a       	sbi	0x14, 1	; 20
    10aa:	2f ef       	ldi	r18, 0xFF	; 255
    10ac:	83 ed       	ldi	r24, 0xD3	; 211
    10ae:	90 e3       	ldi	r25, 0x30	; 48
    10b0:	21 50       	subi	r18, 0x01	; 1
    10b2:	80 40       	sbci	r24, 0x00	; 0
    10b4:	90 40       	sbci	r25, 0x00	; 0
    10b6:	e1 f7       	brne	.-8      	; 0x10b0 <motorTaak2+0x2c>
    10b8:	00 c0       	rjmp	.+0      	; 0x10ba <motorTaak2+0x36>
		_delay_ms(1000);
		motorStop();
    10ba:	00 00       	nop
    10bc:	05 df       	rcall	.-502    	; 0xec8 <motorStop>
		PORTD |= (1 << L_MIN);
    10be:	5f 9a       	sbi	0x0b, 7	; 11
    10c0:	2f ef       	ldi	r18, 0xFF	; 255
    10c2:	83 ed       	ldi	r24, 0xD3	; 211
    10c4:	90 e3       	ldi	r25, 0x30	; 48
    10c6:	21 50       	subi	r18, 0x01	; 1
    10c8:	80 40       	sbci	r24, 0x00	; 0
    10ca:	90 40       	sbci	r25, 0x00	; 0
    10cc:	e1 f7       	brne	.-8      	; 0x10c6 <motorTaak2+0x42>
    10ce:	00 c0       	rjmp	.+0      	; 0x10d0 <motorTaak2+0x4c>
		_delay_ms(1000);
		motorStop();
    10d0:	00 00       	nop
    10d2:	fa de       	rcall	.-524    	; 0xec8 <motorStop>
		PORTC |= (1 << L_PLUS);
    10d4:	41 9a       	sbi	0x08, 1	; 8
    10d6:	2f ef       	ldi	r18, 0xFF	; 255
    10d8:	83 ed       	ldi	r24, 0xD3	; 211
    10da:	90 e3       	ldi	r25, 0x30	; 48
    10dc:	21 50       	subi	r18, 0x01	; 1
    10de:	80 40       	sbci	r24, 0x00	; 0
    10e0:	90 40       	sbci	r25, 0x00	; 0
    10e2:	e1 f7       	brne	.-8      	; 0x10dc <motorTaak2+0x58>
    10e4:	00 c0       	rjmp	.+0      	; 0x10e6 <motorTaak2+0x62>
    10e6:	00 00       	nop
    10e8:	d1 cf       	rjmp	.-94     	; 0x108c <motorTaak2+0x8>

000010ea <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
    10ea:	31 e1       	ldi	r19, 0x11	; 17
    10ec:	fc 01       	movw	r30, r24
    10ee:	30 83       	st	Z, r19
    10f0:	31 97       	sbiw	r30, 0x01	; 1
    10f2:	22 e2       	ldi	r18, 0x22	; 34
    10f4:	20 83       	st	Z, r18
    10f6:	31 97       	sbiw	r30, 0x01	; 1
    10f8:	a3 e3       	ldi	r26, 0x33	; 51
    10fa:	a0 83       	st	Z, r26
    10fc:	31 97       	sbiw	r30, 0x01	; 1
    10fe:	60 83       	st	Z, r22
    1100:	31 97       	sbiw	r30, 0x01	; 1
    1102:	70 83       	st	Z, r23
    1104:	31 97       	sbiw	r30, 0x01	; 1
    1106:	10 82       	st	Z, r1
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	10 82       	st	Z, r1
    110c:	31 97       	sbiw	r30, 0x01	; 1
    110e:	60 e8       	ldi	r22, 0x80	; 128
    1110:	60 83       	st	Z, r22
    1112:	31 97       	sbiw	r30, 0x01	; 1
    1114:	10 82       	st	Z, r1
    1116:	31 97       	sbiw	r30, 0x01	; 1
    1118:	10 82       	st	Z, r1
    111a:	31 97       	sbiw	r30, 0x01	; 1
    111c:	10 82       	st	Z, r1
    111e:	31 97       	sbiw	r30, 0x01	; 1
    1120:	62 e0       	ldi	r22, 0x02	; 2
    1122:	60 83       	st	Z, r22
    1124:	31 97       	sbiw	r30, 0x01	; 1
    1126:	63 e0       	ldi	r22, 0x03	; 3
    1128:	60 83       	st	Z, r22
    112a:	31 97       	sbiw	r30, 0x01	; 1
    112c:	64 e0       	ldi	r22, 0x04	; 4
    112e:	60 83       	st	Z, r22
    1130:	31 97       	sbiw	r30, 0x01	; 1
    1132:	65 e0       	ldi	r22, 0x05	; 5
    1134:	60 83       	st	Z, r22
    1136:	31 97       	sbiw	r30, 0x01	; 1
    1138:	66 e0       	ldi	r22, 0x06	; 6
    113a:	60 83       	st	Z, r22
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	67 e0       	ldi	r22, 0x07	; 7
    1140:	60 83       	st	Z, r22
    1142:	31 97       	sbiw	r30, 0x01	; 1
    1144:	68 e0       	ldi	r22, 0x08	; 8
    1146:	60 83       	st	Z, r22
    1148:	31 97       	sbiw	r30, 0x01	; 1
    114a:	69 e0       	ldi	r22, 0x09	; 9
    114c:	60 83       	st	Z, r22
    114e:	31 97       	sbiw	r30, 0x01	; 1
    1150:	60 e1       	ldi	r22, 0x10	; 16
    1152:	60 83       	st	Z, r22
    1154:	31 97       	sbiw	r30, 0x01	; 1
    1156:	30 83       	st	Z, r19
    1158:	31 97       	sbiw	r30, 0x01	; 1
    115a:	32 e1       	ldi	r19, 0x12	; 18
    115c:	30 83       	st	Z, r19
    115e:	31 97       	sbiw	r30, 0x01	; 1
    1160:	33 e1       	ldi	r19, 0x13	; 19
    1162:	30 83       	st	Z, r19
    1164:	31 97       	sbiw	r30, 0x01	; 1
    1166:	34 e1       	ldi	r19, 0x14	; 20
    1168:	30 83       	st	Z, r19
    116a:	31 97       	sbiw	r30, 0x01	; 1
    116c:	35 e1       	ldi	r19, 0x15	; 21
    116e:	30 83       	st	Z, r19
    1170:	31 97       	sbiw	r30, 0x01	; 1
    1172:	36 e1       	ldi	r19, 0x16	; 22
    1174:	30 83       	st	Z, r19
    1176:	31 97       	sbiw	r30, 0x01	; 1
    1178:	37 e1       	ldi	r19, 0x17	; 23
    117a:	30 83       	st	Z, r19
    117c:	31 97       	sbiw	r30, 0x01	; 1
    117e:	38 e1       	ldi	r19, 0x18	; 24
    1180:	30 83       	st	Z, r19
    1182:	31 97       	sbiw	r30, 0x01	; 1
    1184:	39 e1       	ldi	r19, 0x19	; 25
    1186:	30 83       	st	Z, r19
    1188:	31 97       	sbiw	r30, 0x01	; 1
    118a:	30 e2       	ldi	r19, 0x20	; 32
    118c:	30 83       	st	Z, r19
    118e:	31 97       	sbiw	r30, 0x01	; 1
    1190:	31 e2       	ldi	r19, 0x21	; 33
    1192:	30 83       	st	Z, r19
    1194:	31 97       	sbiw	r30, 0x01	; 1
    1196:	20 83       	st	Z, r18
    1198:	31 97       	sbiw	r30, 0x01	; 1
    119a:	23 e2       	ldi	r18, 0x23	; 35
    119c:	20 83       	st	Z, r18
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	40 83       	st	Z, r20
    11a2:	31 97       	sbiw	r30, 0x01	; 1
    11a4:	50 83       	st	Z, r21
    11a6:	31 97       	sbiw	r30, 0x01	; 1
    11a8:	26 e2       	ldi	r18, 0x26	; 38
    11aa:	20 83       	st	Z, r18
    11ac:	31 97       	sbiw	r30, 0x01	; 1
    11ae:	27 e2       	ldi	r18, 0x27	; 39
    11b0:	20 83       	st	Z, r18
    11b2:	31 97       	sbiw	r30, 0x01	; 1
    11b4:	28 e2       	ldi	r18, 0x28	; 40
    11b6:	20 83       	st	Z, r18
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	29 e2       	ldi	r18, 0x29	; 41
    11bc:	20 83       	st	Z, r18
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	20 e3       	ldi	r18, 0x30	; 48
    11c2:	20 83       	st	Z, r18
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	21 e3       	ldi	r18, 0x31	; 49
    11c8:	20 83       	st	Z, r18
    11ca:	89 97       	sbiw	r24, 0x29	; 41
    11cc:	08 95       	ret

000011ce <xPortStartScheduler>:
    11ce:	88 ec       	ldi	r24, 0xC8	; 200
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <portTickRateHz+0x1>
    11d6:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <portTickRateHz>
    11da:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <ticksRemainingInSec+0x1>
    11de:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <ticksRemainingInSec>
    11e2:	8d e4       	ldi	r24, 0x4D	; 77
    11e4:	87 bd       	out	0x27, r24	; 39
    11e6:	82 e0       	ldi	r24, 0x02	; 2
    11e8:	84 bd       	out	0x24, r24	; 36
    11ea:	85 e0       	ldi	r24, 0x05	; 5
    11ec:	85 bd       	out	0x25, r24	; 37
    11ee:	ee e6       	ldi	r30, 0x6E	; 110
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	82 60       	ori	r24, 0x02	; 2
    11f6:	80 83       	st	Z, r24
    11f8:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
    11fc:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1200:	cd 91       	ld	r28, X+
    1202:	cd bf       	out	0x3d, r28	; 61
    1204:	dd 91       	ld	r29, X+
    1206:	de bf       	out	0x3e, r29	; 62
    1208:	ff 91       	pop	r31
    120a:	ef 91       	pop	r30
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	bf 91       	pop	r27
    1212:	af 91       	pop	r26
    1214:	9f 91       	pop	r25
    1216:	8f 91       	pop	r24
    1218:	7f 91       	pop	r23
    121a:	6f 91       	pop	r22
    121c:	5f 91       	pop	r21
    121e:	4f 91       	pop	r20
    1220:	3f 91       	pop	r19
    1222:	2f 91       	pop	r18
    1224:	1f 91       	pop	r17
    1226:	0f 91       	pop	r16
    1228:	ff 90       	pop	r15
    122a:	ef 90       	pop	r14
    122c:	df 90       	pop	r13
    122e:	cf 90       	pop	r12
    1230:	bf 90       	pop	r11
    1232:	af 90       	pop	r10
    1234:	9f 90       	pop	r9
    1236:	8f 90       	pop	r8
    1238:	7f 90       	pop	r7
    123a:	6f 90       	pop	r6
    123c:	5f 90       	pop	r5
    123e:	4f 90       	pop	r4
    1240:	3f 90       	pop	r3
    1242:	2f 90       	pop	r2
    1244:	1f 90       	pop	r1
    1246:	0f 90       	pop	r0
    1248:	0c be       	out	0x3c, r0	; 60
    124a:	0f 90       	pop	r0
    124c:	0b be       	out	0x3b, r0	; 59
    124e:	0f 90       	pop	r0
    1250:	0f be       	out	0x3f, r0	; 63
    1252:	0f 90       	pop	r0
    1254:	08 95       	ret
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	08 95       	ret

0000125a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    125a:	0f 92       	push	r0
    125c:	0f b6       	in	r0, 0x3f	; 63
    125e:	f8 94       	cli
    1260:	0f 92       	push	r0
    1262:	0b b6       	in	r0, 0x3b	; 59
    1264:	0f 92       	push	r0
    1266:	0c b6       	in	r0, 0x3c	; 60
    1268:	0f 92       	push	r0
    126a:	1f 92       	push	r1
    126c:	11 24       	eor	r1, r1
    126e:	2f 92       	push	r2
    1270:	3f 92       	push	r3
    1272:	4f 92       	push	r4
    1274:	5f 92       	push	r5
    1276:	6f 92       	push	r6
    1278:	7f 92       	push	r7
    127a:	8f 92       	push	r8
    127c:	9f 92       	push	r9
    127e:	af 92       	push	r10
    1280:	bf 92       	push	r11
    1282:	cf 92       	push	r12
    1284:	df 92       	push	r13
    1286:	ef 92       	push	r14
    1288:	ff 92       	push	r15
    128a:	0f 93       	push	r16
    128c:	1f 93       	push	r17
    128e:	2f 93       	push	r18
    1290:	3f 93       	push	r19
    1292:	4f 93       	push	r20
    1294:	5f 93       	push	r21
    1296:	6f 93       	push	r22
    1298:	7f 93       	push	r23
    129a:	8f 93       	push	r24
    129c:	9f 93       	push	r25
    129e:	af 93       	push	r26
    12a0:	bf 93       	push	r27
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	ef 93       	push	r30
    12a8:	ff 93       	push	r31
    12aa:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
    12ae:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    12b2:	0d b6       	in	r0, 0x3d	; 61
    12b4:	0d 92       	st	X+, r0
    12b6:	0e b6       	in	r0, 0x3e	; 62
    12b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12ba:	18 d7       	rcall	.+3632   	; 0x20ec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12bc:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
    12c0:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    12c4:	cd 91       	ld	r28, X+
    12c6:	cd bf       	out	0x3d, r28	; 61
    12c8:	dd 91       	ld	r29, X+
    12ca:	de bf       	out	0x3e, r29	; 62
    12cc:	ff 91       	pop	r31
    12ce:	ef 91       	pop	r30
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	bf 91       	pop	r27
    12d6:	af 91       	pop	r26
    12d8:	9f 91       	pop	r25
    12da:	8f 91       	pop	r24
    12dc:	7f 91       	pop	r23
    12de:	6f 91       	pop	r22
    12e0:	5f 91       	pop	r21
    12e2:	4f 91       	pop	r20
    12e4:	3f 91       	pop	r19
    12e6:	2f 91       	pop	r18
    12e8:	1f 91       	pop	r17
    12ea:	0f 91       	pop	r16
    12ec:	ff 90       	pop	r15
    12ee:	ef 90       	pop	r14
    12f0:	df 90       	pop	r13
    12f2:	cf 90       	pop	r12
    12f4:	bf 90       	pop	r11
    12f6:	af 90       	pop	r10
    12f8:	9f 90       	pop	r9
    12fa:	8f 90       	pop	r8
    12fc:	7f 90       	pop	r7
    12fe:	6f 90       	pop	r6
    1300:	5f 90       	pop	r5
    1302:	4f 90       	pop	r4
    1304:	3f 90       	pop	r3
    1306:	2f 90       	pop	r2
    1308:	1f 90       	pop	r1
    130a:	0f 90       	pop	r0
    130c:	0c be       	out	0x3c, r0	; 60
    130e:	0f 90       	pop	r0
    1310:	0b be       	out	0x3b, r0	; 59
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1318:	08 95       	ret

0000131a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    131a:	0f 92       	push	r0
    131c:	0f b6       	in	r0, 0x3f	; 63
    131e:	f8 94       	cli
    1320:	0f 92       	push	r0
    1322:	0b b6       	in	r0, 0x3b	; 59
    1324:	0f 92       	push	r0
    1326:	0c b6       	in	r0, 0x3c	; 60
    1328:	0f 92       	push	r0
    132a:	1f 92       	push	r1
    132c:	11 24       	eor	r1, r1
    132e:	2f 92       	push	r2
    1330:	3f 92       	push	r3
    1332:	4f 92       	push	r4
    1334:	5f 92       	push	r5
    1336:	6f 92       	push	r6
    1338:	7f 92       	push	r7
    133a:	8f 92       	push	r8
    133c:	9f 92       	push	r9
    133e:	af 92       	push	r10
    1340:	bf 92       	push	r11
    1342:	cf 92       	push	r12
    1344:	df 92       	push	r13
    1346:	ef 92       	push	r14
    1348:	ff 92       	push	r15
    134a:	0f 93       	push	r16
    134c:	1f 93       	push	r17
    134e:	2f 93       	push	r18
    1350:	3f 93       	push	r19
    1352:	4f 93       	push	r20
    1354:	5f 93       	push	r21
    1356:	6f 93       	push	r22
    1358:	7f 93       	push	r23
    135a:	8f 93       	push	r24
    135c:	9f 93       	push	r25
    135e:	af 93       	push	r26
    1360:	bf 93       	push	r27
    1362:	cf 93       	push	r28
    1364:	df 93       	push	r29
    1366:	ef 93       	push	r30
    1368:	ff 93       	push	r31
    136a:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
    136e:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1372:	0d b6       	in	r0, 0x3d	; 61
    1374:	0d 92       	st	X+, r0
    1376:	0e b6       	in	r0, 0x3e	; 62
    1378:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    137a:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    137c:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <ticksRemainingInSec>
    1380:	90 91 72 04 	lds	r25, 0x0472	; 0x800472 <ticksRemainingInSec+0x1>
    1384:	01 97       	sbiw	r24, 0x01	; 1
    1386:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <ticksRemainingInSec+0x1>
    138a:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <ticksRemainingInSec>
    138e:	89 2b       	or	r24, r25
    1390:	51 f4       	brne	.+20     	; 0x13a6 <vPortYieldFromTick+0x8c>
	{
		system_tick();
    1392:	0e 94 8e 01 	call	0x31c	; 0x31c <system_tick>
		ticksRemainingInSec = portTickRateHz;
    1396:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <portTickRateHz>
    139a:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <portTickRateHz+0x1>
    139e:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <ticksRemainingInSec+0x1>
    13a2:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    13a6:	6c d5       	rcall	.+2776   	; 0x1e80 <xTaskIncrementTick>
    13a8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    13aa:	a0 d6       	rcall	.+3392   	; 0x20ec <vTaskSwitchContext>
    13ac:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    13b0:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    13b4:	cd 91       	ld	r28, X+
    13b6:	cd bf       	out	0x3d, r28	; 61
    13b8:	dd 91       	ld	r29, X+
    13ba:	de bf       	out	0x3e, r29	; 62
    13bc:	ff 91       	pop	r31
    13be:	ef 91       	pop	r30
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	bf 91       	pop	r27
    13c6:	af 91       	pop	r26
    13c8:	9f 91       	pop	r25
    13ca:	8f 91       	pop	r24
    13cc:	7f 91       	pop	r23
    13ce:	6f 91       	pop	r22
    13d0:	5f 91       	pop	r21
    13d2:	4f 91       	pop	r20
    13d4:	3f 91       	pop	r19
    13d6:	2f 91       	pop	r18
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	ff 90       	pop	r15
    13de:	ef 90       	pop	r14
    13e0:	df 90       	pop	r13
    13e2:	cf 90       	pop	r12
    13e4:	bf 90       	pop	r11
    13e6:	af 90       	pop	r10
    13e8:	9f 90       	pop	r9
    13ea:	8f 90       	pop	r8
    13ec:	7f 90       	pop	r7
    13ee:	6f 90       	pop	r6
    13f0:	5f 90       	pop	r5
    13f2:	4f 90       	pop	r4
    13f4:	3f 90       	pop	r3
    13f6:	2f 90       	pop	r2
    13f8:	1f 90       	pop	r1
    13fa:	0f 90       	pop	r0
    13fc:	0c be       	out	0x3c, r0	; 60
    13fe:	0f 90       	pop	r0
    1400:	0b be       	out	0x3b, r0	; 59
    1402:	0f 90       	pop	r0
    1404:	0f be       	out	0x3f, r0	; 63
    1406:	0f 90       	pop	r0
    1408:	08 95       	ret

0000140a <__vector_21>:

	__asm__ __volatile__ ( "ret" );
    140a:	87 df       	rcall	.-242    	; 0x131a <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    140c:	18 95       	reti

0000140e <prvCopyDataToQueue>:
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	ec 01       	movw	r28, r24
    1418:	04 2f       	mov	r16, r20
    141a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    141c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    141e:	41 11       	cpse	r20, r1
    1420:	0b c0       	rjmp	.+22     	; 0x1438 <prvCopyDataToQueue+0x2a>
    1422:	88 81       	ld	r24, Y
    1424:	99 81       	ldd	r25, Y+1	; 0x01
    1426:	89 2b       	or	r24, r25
    1428:	09 f0       	breq	.+2      	; 0x142c <prvCopyDataToQueue+0x1e>
    142a:	41 c0       	rjmp	.+130    	; 0x14ae <prvCopyDataToQueue+0xa0>
    142c:	8a 81       	ldd	r24, Y+2	; 0x02
    142e:	9b 81       	ldd	r25, Y+3	; 0x03
    1430:	7e d7       	rcall	.+3836   	; 0x232e <xTaskPriorityDisinherit>
    1432:	1b 82       	std	Y+3, r1	; 0x03
    1434:	1a 82       	std	Y+2, r1	; 0x02
    1436:	42 c0       	rjmp	.+132    	; 0x14bc <prvCopyDataToQueue+0xae>
    1438:	01 11       	cpse	r16, r1
    143a:	17 c0       	rjmp	.+46     	; 0x146a <prvCopyDataToQueue+0x5c>
    143c:	50 e0       	ldi	r21, 0x00	; 0
    143e:	8c 81       	ldd	r24, Y+4	; 0x04
    1440:	9d 81       	ldd	r25, Y+5	; 0x05
    1442:	0e 94 c2 14 	call	0x2984	; 0x2984 <memcpy>
    1446:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1448:	8c 81       	ldd	r24, Y+4	; 0x04
    144a:	9d 81       	ldd	r25, Y+5	; 0x05
    144c:	82 0f       	add	r24, r18
    144e:	91 1d       	adc	r25, r1
    1450:	9d 83       	std	Y+5, r25	; 0x05
    1452:	8c 83       	std	Y+4, r24	; 0x04
    1454:	2a 81       	ldd	r18, Y+2	; 0x02
    1456:	3b 81       	ldd	r19, Y+3	; 0x03
    1458:	82 17       	cp	r24, r18
    145a:	93 07       	cpc	r25, r19
    145c:	50 f1       	brcs	.+84     	; 0x14b2 <prvCopyDataToQueue+0xa4>
    145e:	88 81       	ld	r24, Y
    1460:	99 81       	ldd	r25, Y+1	; 0x01
    1462:	9d 83       	std	Y+5, r25	; 0x05
    1464:	8c 83       	std	Y+4, r24	; 0x04
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	29 c0       	rjmp	.+82     	; 0x14bc <prvCopyDataToQueue+0xae>
    146a:	50 e0       	ldi	r21, 0x00	; 0
    146c:	8e 81       	ldd	r24, Y+6	; 0x06
    146e:	9f 81       	ldd	r25, Y+7	; 0x07
    1470:	0e 94 c2 14 	call	0x2984	; 0x2984 <memcpy>
    1474:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	91 95       	neg	r25
    147a:	81 95       	neg	r24
    147c:	91 09       	sbc	r25, r1
    147e:	2e 81       	ldd	r18, Y+6	; 0x06
    1480:	3f 81       	ldd	r19, Y+7	; 0x07
    1482:	28 0f       	add	r18, r24
    1484:	39 1f       	adc	r19, r25
    1486:	3f 83       	std	Y+7, r19	; 0x07
    1488:	2e 83       	std	Y+6, r18	; 0x06
    148a:	48 81       	ld	r20, Y
    148c:	59 81       	ldd	r21, Y+1	; 0x01
    148e:	24 17       	cp	r18, r20
    1490:	35 07       	cpc	r19, r21
    1492:	30 f4       	brcc	.+12     	; 0x14a0 <prvCopyDataToQueue+0x92>
    1494:	2a 81       	ldd	r18, Y+2	; 0x02
    1496:	3b 81       	ldd	r19, Y+3	; 0x03
    1498:	82 0f       	add	r24, r18
    149a:	93 1f       	adc	r25, r19
    149c:	9f 83       	std	Y+7, r25	; 0x07
    149e:	8e 83       	std	Y+6, r24	; 0x06
    14a0:	02 30       	cpi	r16, 0x02	; 2
    14a2:	49 f4       	brne	.+18     	; 0x14b6 <prvCopyDataToQueue+0xa8>
    14a4:	11 23       	and	r17, r17
    14a6:	49 f0       	breq	.+18     	; 0x14ba <prvCopyDataToQueue+0xac>
    14a8:	11 50       	subi	r17, 0x01	; 1
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	07 c0       	rjmp	.+14     	; 0x14bc <prvCopyDataToQueue+0xae>
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <prvCopyDataToQueue+0xae>
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	03 c0       	rjmp	.+6      	; 0x14bc <prvCopyDataToQueue+0xae>
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <prvCopyDataToQueue+0xae>
    14ba:	80 e0       	ldi	r24, 0x00	; 0
    14bc:	1f 5f       	subi	r17, 0xFF	; 255
    14be:	1a 8f       	std	Y+26, r17	; 0x1a
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	08 95       	ret

000014ca <prvUnlockQueue>:
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	8c 01       	movw	r16, r24
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	f8 94       	cli
    14da:	0f 92       	push	r0
    14dc:	fc 01       	movw	r30, r24
    14de:	c6 8d       	ldd	r28, Z+30	; 0x1e
    14e0:	1c 16       	cp	r1, r28
    14e2:	9c f4       	brge	.+38     	; 0x150a <prvUnlockQueue+0x40>
    14e4:	81 89       	ldd	r24, Z+17	; 0x11
    14e6:	81 11       	cpse	r24, r1
    14e8:	06 c0       	rjmp	.+12     	; 0x14f6 <prvUnlockQueue+0x2c>
    14ea:	0f c0       	rjmp	.+30     	; 0x150a <prvUnlockQueue+0x40>
    14ec:	f8 01       	movw	r30, r16
    14ee:	81 89       	ldd	r24, Z+17	; 0x11
    14f0:	81 11       	cpse	r24, r1
    14f2:	05 c0       	rjmp	.+10     	; 0x14fe <prvUnlockQueue+0x34>
    14f4:	0a c0       	rjmp	.+20     	; 0x150a <prvUnlockQueue+0x40>
    14f6:	78 01       	movw	r14, r16
    14f8:	f1 e1       	ldi	r31, 0x11	; 17
    14fa:	ef 0e       	add	r14, r31
    14fc:	f1 1c       	adc	r15, r1
    14fe:	c7 01       	movw	r24, r14
    1500:	87 d6       	rcall	.+3342   	; 0x2210 <xTaskRemoveFromEventList>
    1502:	81 11       	cpse	r24, r1
    1504:	10 d7       	rcall	.+3616   	; 0x2326 <vTaskMissedYield>
    1506:	c1 50       	subi	r28, 0x01	; 1
    1508:	89 f7       	brne	.-30     	; 0x14ec <prvUnlockQueue+0x22>
    150a:	8f ef       	ldi	r24, 0xFF	; 255
    150c:	f8 01       	movw	r30, r16
    150e:	86 8f       	std	Z+30, r24	; 0x1e
    1510:	0f 90       	pop	r0
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	0f 92       	push	r0
    151a:	c5 8d       	ldd	r28, Z+29	; 0x1d
    151c:	1c 16       	cp	r1, r28
    151e:	9c f4       	brge	.+38     	; 0x1546 <prvUnlockQueue+0x7c>
    1520:	80 85       	ldd	r24, Z+8	; 0x08
    1522:	81 11       	cpse	r24, r1
    1524:	06 c0       	rjmp	.+12     	; 0x1532 <prvUnlockQueue+0x68>
    1526:	0f c0       	rjmp	.+30     	; 0x1546 <prvUnlockQueue+0x7c>
    1528:	f8 01       	movw	r30, r16
    152a:	80 85       	ldd	r24, Z+8	; 0x08
    152c:	81 11       	cpse	r24, r1
    152e:	05 c0       	rjmp	.+10     	; 0x153a <prvUnlockQueue+0x70>
    1530:	0a c0       	rjmp	.+20     	; 0x1546 <prvUnlockQueue+0x7c>
    1532:	78 01       	movw	r14, r16
    1534:	f8 e0       	ldi	r31, 0x08	; 8
    1536:	ef 0e       	add	r14, r31
    1538:	f1 1c       	adc	r15, r1
    153a:	c7 01       	movw	r24, r14
    153c:	69 d6       	rcall	.+3282   	; 0x2210 <xTaskRemoveFromEventList>
    153e:	81 11       	cpse	r24, r1
    1540:	f2 d6       	rcall	.+3556   	; 0x2326 <vTaskMissedYield>
    1542:	c1 50       	subi	r28, 0x01	; 1
    1544:	89 f7       	brne	.-30     	; 0x1528 <prvUnlockQueue+0x5e>
    1546:	8f ef       	ldi	r24, 0xFF	; 255
    1548:	f8 01       	movw	r30, r16
    154a:	85 8f       	std	Z+29, r24	; 0x1d
    154c:	0f 90       	pop	r0
    154e:	0f be       	out	0x3f, r0	; 63
    1550:	cf 91       	pop	r28
    1552:	1f 91       	pop	r17
    1554:	0f 91       	pop	r16
    1556:	ff 90       	pop	r15
    1558:	ef 90       	pop	r14
    155a:	08 95       	ret

0000155c <xQueueGenericReset>:
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    1560:	ec 01       	movw	r28, r24
    1562:	0f b6       	in	r0, 0x3f	; 63
    1564:	f8 94       	cli
    1566:	0f 92       	push	r0
    1568:	48 81       	ld	r20, Y
    156a:	59 81       	ldd	r21, Y+1	; 0x01
    156c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1572:	72 9f       	mul	r23, r18
    1574:	c0 01       	movw	r24, r0
    1576:	73 9f       	mul	r23, r19
    1578:	90 0d       	add	r25, r0
    157a:	11 24       	eor	r1, r1
    157c:	fa 01       	movw	r30, r20
    157e:	e8 0f       	add	r30, r24
    1580:	f9 1f       	adc	r31, r25
    1582:	fb 83       	std	Y+3, r31	; 0x03
    1584:	ea 83       	std	Y+2, r30	; 0x02
    1586:	1a 8e       	std	Y+26, r1	; 0x1a
    1588:	5d 83       	std	Y+5, r21	; 0x05
    158a:	4c 83       	std	Y+4, r20	; 0x04
    158c:	82 1b       	sub	r24, r18
    158e:	93 0b       	sbc	r25, r19
    1590:	84 0f       	add	r24, r20
    1592:	95 1f       	adc	r25, r21
    1594:	9f 83       	std	Y+7, r25	; 0x07
    1596:	8e 83       	std	Y+6, r24	; 0x06
    1598:	8f ef       	ldi	r24, 0xFF	; 255
    159a:	8d 8f       	std	Y+29, r24	; 0x1d
    159c:	8e 8f       	std	Y+30, r24	; 0x1e
    159e:	61 11       	cpse	r22, r1
    15a0:	0a c0       	rjmp	.+20     	; 0x15b6 <xQueueGenericReset+0x5a>
    15a2:	88 85       	ldd	r24, Y+8	; 0x08
    15a4:	88 23       	and	r24, r24
    15a6:	69 f0       	breq	.+26     	; 0x15c2 <xQueueGenericReset+0x66>
    15a8:	ce 01       	movw	r24, r28
    15aa:	08 96       	adiw	r24, 0x08	; 8
    15ac:	31 d6       	rcall	.+3170   	; 0x2210 <xTaskRemoveFromEventList>
    15ae:	88 23       	and	r24, r24
    15b0:	41 f0       	breq	.+16     	; 0x15c2 <xQueueGenericReset+0x66>
    15b2:	53 de       	rcall	.-858    	; 0x125a <vPortYield>
    15b4:	06 c0       	rjmp	.+12     	; 0x15c2 <xQueueGenericReset+0x66>
    15b6:	ce 01       	movw	r24, r28
    15b8:	08 96       	adiw	r24, 0x08	; 8
    15ba:	0d d8       	rcall	.-4070   	; 0x5d6 <vListInitialise>
    15bc:	ce 01       	movw	r24, r28
    15be:	41 96       	adiw	r24, 0x11	; 17
    15c0:	0a d8       	rcall	.-4076   	; 0x5d6 <vListInitialise>
    15c2:	0f 90       	pop	r0
    15c4:	0f be       	out	0x3f, r0	; 63
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	08 95       	ret

000015ce <xQueueGenericCreate>:
    15ce:	0f 93       	push	r16
    15d0:	1f 93       	push	r17
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	08 2f       	mov	r16, r24
    15d8:	16 2f       	mov	r17, r22
    15da:	66 23       	and	r22, r22
    15dc:	b9 f0       	breq	.+46     	; 0x160c <xQueueGenericCreate+0x3e>
    15de:	86 9f       	mul	r24, r22
    15e0:	c0 01       	movw	r24, r0
    15e2:	11 24       	eor	r1, r1
    15e4:	4f 96       	adiw	r24, 0x1f	; 31
    15e6:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    15ea:	ec 01       	movw	r28, r24
    15ec:	00 97       	sbiw	r24, 0x00	; 0
    15ee:	39 f4       	brne	.+14     	; 0x15fe <xQueueGenericCreate+0x30>
    15f0:	14 c0       	rjmp	.+40     	; 0x161a <xQueueGenericCreate+0x4c>
    15f2:	0b 8f       	std	Y+27, r16	; 0x1b
    15f4:	1c 8f       	std	Y+28, r17	; 0x1c
    15f6:	61 e0       	ldi	r22, 0x01	; 1
    15f8:	ce 01       	movw	r24, r28
    15fa:	b0 df       	rcall	.-160    	; 0x155c <xQueueGenericReset>
    15fc:	0e c0       	rjmp	.+28     	; 0x161a <xQueueGenericCreate+0x4c>
    15fe:	4f 96       	adiw	r24, 0x1f	; 31
    1600:	99 83       	std	Y+1, r25	; 0x01
    1602:	88 83       	st	Y, r24
    1604:	f6 cf       	rjmp	.-20     	; 0x15f2 <xQueueGenericCreate+0x24>
    1606:	d9 83       	std	Y+1, r29	; 0x01
    1608:	c8 83       	st	Y, r28
    160a:	f3 cf       	rjmp	.-26     	; 0x15f2 <xQueueGenericCreate+0x24>
    160c:	8f e1       	ldi	r24, 0x1F	; 31
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1614:	ec 01       	movw	r28, r24
    1616:	89 2b       	or	r24, r25
    1618:	b1 f7       	brne	.-20     	; 0x1606 <xQueueGenericCreate+0x38>
    161a:	ce 01       	movw	r24, r28
    161c:	df 91       	pop	r29
    161e:	cf 91       	pop	r28
    1620:	1f 91       	pop	r17
    1622:	0f 91       	pop	r16
    1624:	08 95       	ret

00001626 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1626:	9f 92       	push	r9
    1628:	af 92       	push	r10
    162a:	bf 92       	push	r11
    162c:	cf 92       	push	r12
    162e:	df 92       	push	r13
    1630:	ef 92       	push	r14
    1632:	ff 92       	push	r15
    1634:	0f 93       	push	r16
    1636:	1f 93       	push	r17
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	00 d0       	rcall	.+0      	; 0x163e <xQueueGenericSend+0x18>
    163e:	1f 92       	push	r1
    1640:	1f 92       	push	r1
    1642:	cd b7       	in	r28, 0x3d	; 61
    1644:	de b7       	in	r29, 0x3e	; 62
    1646:	8c 01       	movw	r16, r24
    1648:	6b 01       	movw	r12, r22
    164a:	5d 83       	std	Y+5, r21	; 0x05
    164c:	4c 83       	std	Y+4, r20	; 0x04
    164e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1650:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1652:	99 24       	eor	r9, r9
    1654:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1656:	7c 01       	movw	r14, r24
    1658:	88 e0       	ldi	r24, 0x08	; 8
    165a:	e8 0e       	add	r14, r24
    165c:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1664:	f8 01       	movw	r30, r16
    1666:	92 8d       	ldd	r25, Z+26	; 0x1a
    1668:	83 8d       	ldd	r24, Z+27	; 0x1b
    166a:	98 17       	cp	r25, r24
    166c:	18 f0       	brcs	.+6      	; 0x1674 <xQueueGenericSend+0x4e>
    166e:	f2 e0       	ldi	r31, 0x02	; 2
    1670:	af 12       	cpse	r10, r31
    1672:	15 c0       	rjmp	.+42     	; 0x169e <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1674:	4a 2d       	mov	r20, r10
    1676:	b6 01       	movw	r22, r12
    1678:	c8 01       	movw	r24, r16
    167a:	c9 de       	rcall	.-622    	; 0x140e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    167c:	f8 01       	movw	r30, r16
    167e:	91 89       	ldd	r25, Z+17	; 0x11
    1680:	99 23       	and	r25, r25
    1682:	39 f0       	breq	.+14     	; 0x1692 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1684:	c8 01       	movw	r24, r16
    1686:	41 96       	adiw	r24, 0x11	; 17
    1688:	c3 d5       	rcall	.+2950   	; 0x2210 <xTaskRemoveFromEventList>
    168a:	88 23       	and	r24, r24
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    168c:	21 f0       	breq	.+8      	; 0x1696 <xQueueGenericSend+0x70>
    168e:	e5 dd       	rcall	.-1078   	; 0x125a <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1690:	02 c0       	rjmp	.+4      	; 0x1696 <xQueueGenericSend+0x70>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1692:	81 11       	cpse	r24, r1
    1694:	e2 dd       	rcall	.-1084   	; 0x125a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1696:	0f 90       	pop	r0
    1698:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	45 c0       	rjmp	.+138    	; 0x1728 <xQueueGenericSend+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    169e:	8c 81       	ldd	r24, Y+4	; 0x04
    16a0:	9d 81       	ldd	r25, Y+5	; 0x05
    16a2:	89 2b       	or	r24, r25
    16a4:	21 f4       	brne	.+8      	; 0x16ae <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	3d c0       	rjmp	.+122    	; 0x1728 <xQueueGenericSend+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    16ae:	b1 10       	cpse	r11, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16b0:	04 c0       	rjmp	.+8      	; 0x16ba <xQueueGenericSend+0x94>
    16b2:	ce 01       	movw	r24, r28
    16b4:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    16b6:	f4 d5       	rcall	.+3048   	; 0x22a0 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16b8:	b9 2c       	mov	r11, r9
    16ba:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	da d3       	rcall	.+1972   	; 0x1e74 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16c0:	0f b6       	in	r0, 0x3f	; 63
    16c2:	f8 94       	cli
    16c4:	0f 92       	push	r0
    16c6:	f8 01       	movw	r30, r16
    16c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    16ca:	8f 3f       	cpi	r24, 0xFF	; 255
    16cc:	09 f4       	brne	.+2      	; 0x16d0 <xQueueGenericSend+0xaa>
    16ce:	15 8e       	std	Z+29, r1	; 0x1d
    16d0:	f8 01       	movw	r30, r16
    16d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16d4:	8f 3f       	cpi	r24, 0xFF	; 255
    16d6:	09 f4       	brne	.+2      	; 0x16da <xQueueGenericSend+0xb4>
    16d8:	16 8e       	std	Z+30, r1	; 0x1e
    16da:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16dc:	0f be       	out	0x3f, r0	; 63
    16de:	be 01       	movw	r22, r28
    16e0:	6c 5f       	subi	r22, 0xFC	; 252
    16e2:	7f 4f       	sbci	r23, 0xFF	; 255
    16e4:	ce 01       	movw	r24, r28
    16e6:	01 96       	adiw	r24, 0x01	; 1
    16e8:	e6 d5       	rcall	.+3020   	; 0x22b6 <xTaskCheckForTimeOut>
    16ea:	81 11       	cpse	r24, r1
    16ec:	19 c0       	rjmp	.+50     	; 0x1720 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    16ee:	0f b6       	in	r0, 0x3f	; 63
    16f0:	f8 94       	cli
    16f2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    16f4:	f8 01       	movw	r30, r16
    16f6:	92 8d       	ldd	r25, Z+26	; 0x1a
    16f8:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16fa:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16fc:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16fe:	98 13       	cpse	r25, r24
    1700:	0b c0       	rjmp	.+22     	; 0x1718 <xQueueGenericSend+0xf2>
    1702:	6c 81       	ldd	r22, Y+4	; 0x04
    1704:	7d 81       	ldd	r23, Y+5	; 0x05
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1706:	c7 01       	movw	r24, r14
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1708:	72 d5       	rcall	.+2788   	; 0x21ee <vTaskPlaceOnEventList>
    170a:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    170c:	de de       	rcall	.-580    	; 0x14ca <prvUnlockQueue>
    170e:	72 d4       	rcall	.+2276   	; 0x1ff4 <xTaskResumeAll>
    1710:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1712:	a5 cf       	rjmp	.-182    	; 0x165e <xQueueGenericSend+0x38>
    1714:	a2 dd       	rcall	.-1212   	; 0x125a <vPortYield>
    1716:	a3 cf       	rjmp	.-186    	; 0x165e <xQueueGenericSend+0x38>
				( void ) xTaskResumeAll();
    1718:	c8 01       	movw	r24, r16
    171a:	d7 de       	rcall	.-594    	; 0x14ca <prvUnlockQueue>
    171c:	6b d4       	rcall	.+2262   	; 0x1ff4 <xTaskResumeAll>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    171e:	9f cf       	rjmp	.-194    	; 0x165e <xQueueGenericSend+0x38>
    1720:	c8 01       	movw	r24, r16
    1722:	d3 de       	rcall	.-602    	; 0x14ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1724:	67 d4       	rcall	.+2254   	; 0x1ff4 <xTaskResumeAll>
    1726:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1728:	0f 90       	pop	r0
		}
	}
}
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	1f 91       	pop	r17
    1738:	0f 91       	pop	r16
    173a:	ff 90       	pop	r15
    173c:	ef 90       	pop	r14
    173e:	df 90       	pop	r13
    1740:	cf 90       	pop	r12
    1742:	bf 90       	pop	r11
    1744:	af 90       	pop	r10
    1746:	9f 90       	pop	r9
    1748:	08 95       	ret

0000174a <__vector_26>:
    174a:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    174c:	0f 92       	push	r0
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	0f 92       	push	r0
    1752:	11 24       	eor	r1, r1
    1754:	0b b6       	in	r0, 0x3b	; 59
    1756:	0f 92       	push	r0
    1758:	2f 93       	push	r18
    175a:	8f 93       	push	r24
    175c:	9f 93       	push	r25
    175e:	af 93       	push	r26
    1760:	bf 93       	push	r27
    1762:	ef 93       	push	r30
    1764:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	0f 92       	push	r0
	{
	    count = buffer->count;
    176c:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <xSerialPort+0xd>
    1770:	90 91 81 04 	lds	r25, 0x0481	; 0x800481 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    1774:	0f 90       	pop	r0
    1776:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    1778:	89 2b       	or	r24, r25
    177a:	31 f4       	brne	.+12     	; 0x1788 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    177c:	e1 ec       	ldi	r30, 0xC1	; 193
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	80 81       	ld	r24, Z
    1782:	8f 7d       	andi	r24, 0xDF	; 223
    1784:	80 83       	st	Z, r24
    1786:	1c c0       	rjmp	.+56     	; 0x17c0 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1788:	e0 e8       	ldi	r30, 0x80	; 128
    178a:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    178c:	a4 81       	ldd	r26, Z+4	; 0x04
    178e:	b5 81       	ldd	r27, Z+5	; 0x05
    1790:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1792:	b5 83       	std	Z+5, r27	; 0x05
    1794:	a4 83       	std	Z+4, r26	; 0x04
    1796:	80 85       	ldd	r24, Z+8	; 0x08
    1798:	91 85       	ldd	r25, Z+9	; 0x09
    179a:	a8 17       	cp	r26, r24
    179c:	b9 07       	cpc	r27, r25
    179e:	21 f4       	brne	.+8      	; 0x17a8 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    17a0:	86 81       	ldd	r24, Z+6	; 0x06
    17a2:	97 81       	ldd	r25, Z+7	; 0x07
    17a4:	95 83       	std	Z+5, r25	; 0x05
    17a6:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	0f 92       	push	r0
	{
	    buffer->count--;
    17ae:	80 81       	ld	r24, Z
    17b0:	91 81       	ldd	r25, Z+1	; 0x01
    17b2:	01 97       	sbiw	r24, 0x01	; 1
    17b4:	91 83       	std	Z+1, r25	; 0x01
    17b6:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    17b8:	0f 90       	pop	r0
    17ba:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    17bc:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    17c0:	ff 91       	pop	r31
    17c2:	ef 91       	pop	r30
    17c4:	bf 91       	pop	r27
    17c6:	af 91       	pop	r26
    17c8:	9f 91       	pop	r25
    17ca:	8f 91       	pop	r24
    17cc:	2f 91       	pop	r18
    17ce:	0f 90       	pop	r0
    17d0:	0b be       	out	0x3b, r0	; 59
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63
    17d6:	0f 90       	pop	r0
    17d8:	1f 90       	pop	r1
    17da:	18 95       	reti

000017dc <__vector_37>:
//}
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    17dc:	1f 92       	push	r1
    17de:	0f 92       	push	r0
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	0f 92       	push	r0
    17e4:	11 24       	eor	r1, r1
    17e6:	0b b6       	in	r0, 0x3b	; 59
    17e8:	0f 92       	push	r0
    17ea:	2f 93       	push	r18
    17ec:	8f 93       	push	r24
    17ee:	9f 93       	push	r25
    17f0:	af 93       	push	r26
    17f2:	bf 93       	push	r27
    17f4:	ef 93       	push	r30
    17f6:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    17f8:	0f b6       	in	r0, 0x3f	; 63
    17fa:	f8 94       	cli
    17fc:	0f 92       	push	r0
	{
	    count = buffer->count;
    17fe:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <xSerial1Port+0xd>
    1802:	90 91 e7 04 	lds	r25, 0x04E7	; 0x8004e7 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1806:	0f 90       	pop	r0
    1808:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    180a:	89 2b       	or	r24, r25
    180c:	31 f4       	brne	.+12     	; 0x181a <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    180e:	e9 ec       	ldi	r30, 0xC9	; 201
    1810:	f0 e0       	ldi	r31, 0x00	; 0
    1812:	80 81       	ld	r24, Z
    1814:	8f 7d       	andi	r24, 0xDF	; 223
    1816:	80 83       	st	Z, r24
    1818:	1c c0       	rjmp	.+56     	; 0x1852 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    181a:	e6 ee       	ldi	r30, 0xE6	; 230
    181c:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    181e:	a4 81       	ldd	r26, Z+4	; 0x04
    1820:	b5 81       	ldd	r27, Z+5	; 0x05
    1822:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1824:	b5 83       	std	Z+5, r27	; 0x05
    1826:	a4 83       	std	Z+4, r26	; 0x04
    1828:	80 85       	ldd	r24, Z+8	; 0x08
    182a:	91 85       	ldd	r25, Z+9	; 0x09
    182c:	a8 17       	cp	r26, r24
    182e:	b9 07       	cpc	r27, r25
    1830:	21 f4       	brne	.+8      	; 0x183a <__vector_37+0x5e>
	  buffer->out = buffer->start;
    1832:	86 81       	ldd	r24, Z+6	; 0x06
    1834:	97 81       	ldd	r25, Z+7	; 0x07
    1836:	95 83       	std	Z+5, r25	; 0x05
    1838:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	0f 92       	push	r0
	{
	    buffer->count--;
    1840:	80 81       	ld	r24, Z
    1842:	91 81       	ldd	r25, Z+1	; 0x01
    1844:	01 97       	sbiw	r24, 0x01	; 1
    1846:	91 83       	std	Z+1, r25	; 0x01
    1848:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    184a:	0f 90       	pop	r0
    184c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    184e:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    1852:	ff 91       	pop	r31
    1854:	ef 91       	pop	r30
    1856:	bf 91       	pop	r27
    1858:	af 91       	pop	r26
    185a:	9f 91       	pop	r25
    185c:	8f 91       	pop	r24
    185e:	2f 91       	pop	r18
    1860:	0f 90       	pop	r0
    1862:	0b be       	out	0x3b, r0	; 59
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
    1868:	0f 90       	pop	r0
    186a:	1f 90       	pop	r1
    186c:	18 95       	reti

0000186e <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    186e:	1f 92       	push	r1
    1870:	0f 92       	push	r0
    1872:	0f b6       	in	r0, 0x3f	; 63
    1874:	0f 92       	push	r0
    1876:	11 24       	eor	r1, r1
    1878:	0b b6       	in	r0, 0x3b	; 59
    187a:	0f 92       	push	r0
    187c:	2f 93       	push	r18
    187e:	3f 93       	push	r19
    1880:	4f 93       	push	r20
    1882:	8f 93       	push	r24
    1884:	9f 93       	push	r25
    1886:	af 93       	push	r26
    1888:	bf 93       	push	r27
    188a:	ef 93       	push	r30
    188c:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    188e:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1892:	8c 71       	andi	r24, 0x1C	; 28
    1894:	71 f0       	breq	.+28     	; 0x18b2 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1896:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    189a:	88 23       	and	r24, r24
    189c:	0c f0       	brlt	.+2      	; 0x18a0 <__vector_51+0x32>
    189e:	36 c0       	rjmp	.+108    	; 0x190c <__vector_51+0x9e>
    18a0:	a6 ed       	ldi	r26, 0xD6	; 214
    18a2:	b0 e0       	ldi	r27, 0x00	; 0
    18a4:	e0 ed       	ldi	r30, 0xD0	; 208
    18a6:	f0 e0       	ldi	r31, 0x00	; 0
    18a8:	8c 91       	ld	r24, X
    18aa:	80 81       	ld	r24, Z
    18ac:	88 23       	and	r24, r24
    18ae:	e4 f3       	brlt	.-8      	; 0x18a8 <__vector_51+0x3a>
    18b0:	2d c0       	rjmp	.+90     	; 0x190c <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    18b2:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	f8 94       	cli
    18ba:	0f 92       	push	r0
	{
	    count = buffer->count;
    18bc:	e5 e9       	ldi	r30, 0x95	; 149
    18be:	f4 e0       	ldi	r31, 0x04	; 4
    18c0:	21 81       	ldd	r18, Z+1	; 0x01
    18c2:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    18c4:	0f 90       	pop	r0
    18c6:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    18c8:	83 85       	ldd	r24, Z+11	; 0x0b
    18ca:	94 85       	ldd	r25, Z+12	; 0x0c
    18cc:	28 17       	cp	r18, r24
    18ce:	39 07       	cpc	r19, r25
    18d0:	e9 f0       	breq	.+58     	; 0x190c <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    18d2:	e6 e9       	ldi	r30, 0x96	; 150
    18d4:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    18d6:	a2 81       	ldd	r26, Z+2	; 0x02
    18d8:	b3 81       	ldd	r27, Z+3	; 0x03
    18da:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    18dc:	82 81       	ldd	r24, Z+2	; 0x02
    18de:	93 81       	ldd	r25, Z+3	; 0x03
    18e0:	01 96       	adiw	r24, 0x01	; 1
    18e2:	93 83       	std	Z+3, r25	; 0x03
    18e4:	82 83       	std	Z+2, r24	; 0x02
    18e6:	20 85       	ldd	r18, Z+8	; 0x08
    18e8:	31 85       	ldd	r19, Z+9	; 0x09
    18ea:	82 17       	cp	r24, r18
    18ec:	93 07       	cpc	r25, r19
    18ee:	21 f4       	brne	.+8      	; 0x18f8 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    18f0:	86 81       	ldd	r24, Z+6	; 0x06
    18f2:	97 81       	ldd	r25, Z+7	; 0x07
    18f4:	93 83       	std	Z+3, r25	; 0x03
    18f6:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    18f8:	0f b6       	in	r0, 0x3f	; 63
    18fa:	f8 94       	cli
    18fc:	0f 92       	push	r0
	{
	    buffer->count++;
    18fe:	80 81       	ld	r24, Z
    1900:	91 81       	ldd	r25, Z+1	; 0x01
    1902:	01 96       	adiw	r24, 0x01	; 1
    1904:	91 83       	std	Z+1, r25	; 0x01
    1906:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1908:	0f 90       	pop	r0
    190a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    190c:	ff 91       	pop	r31
    190e:	ef 91       	pop	r30
    1910:	bf 91       	pop	r27
    1912:	af 91       	pop	r26
    1914:	9f 91       	pop	r25
    1916:	8f 91       	pop	r24
    1918:	4f 91       	pop	r20
    191a:	3f 91       	pop	r19
    191c:	2f 91       	pop	r18
    191e:	0f 90       	pop	r0
    1920:	0b be       	out	0x3b, r0	; 59
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	0f 90       	pop	r0
    1928:	1f 90       	pop	r1
    192a:	18 95       	reti

0000192c <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    192c:	1f 92       	push	r1
    192e:	0f 92       	push	r0
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	0f 92       	push	r0
    1934:	11 24       	eor	r1, r1
    1936:	0b b6       	in	r0, 0x3b	; 59
    1938:	0f 92       	push	r0
    193a:	2f 93       	push	r18
    193c:	8f 93       	push	r24
    193e:	9f 93       	push	r25
    1940:	af 93       	push	r26
    1942:	bf 93       	push	r27
    1944:	ef 93       	push	r30
    1946:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1948:	0f b6       	in	r0, 0x3f	; 63
    194a:	f8 94       	cli
    194c:	0f 92       	push	r0
	{
	    count = buffer->count;
    194e:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <xSerial2Port+0xd>
    1952:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1956:	0f 90       	pop	r0
    1958:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    195a:	89 2b       	or	r24, r25
    195c:	31 f4       	brne	.+12     	; 0x196a <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    195e:	e1 ed       	ldi	r30, 0xD1	; 209
    1960:	f0 e0       	ldi	r31, 0x00	; 0
    1962:	80 81       	ld	r24, Z
    1964:	8f 7d       	andi	r24, 0xDF	; 223
    1966:	80 83       	st	Z, r24
    1968:	1c c0       	rjmp	.+56     	; 0x19a2 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    196a:	e2 ea       	ldi	r30, 0xA2	; 162
    196c:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    196e:	a4 81       	ldd	r26, Z+4	; 0x04
    1970:	b5 81       	ldd	r27, Z+5	; 0x05
    1972:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1974:	b5 83       	std	Z+5, r27	; 0x05
    1976:	a4 83       	std	Z+4, r26	; 0x04
    1978:	80 85       	ldd	r24, Z+8	; 0x08
    197a:	91 85       	ldd	r25, Z+9	; 0x09
    197c:	a8 17       	cp	r26, r24
    197e:	b9 07       	cpc	r27, r25
    1980:	21 f4       	brne	.+8      	; 0x198a <__vector_52+0x5e>
	  buffer->out = buffer->start;
    1982:	86 81       	ldd	r24, Z+6	; 0x06
    1984:	97 81       	ldd	r25, Z+7	; 0x07
    1986:	95 83       	std	Z+5, r25	; 0x05
    1988:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	f8 94       	cli
    198e:	0f 92       	push	r0
	{
	    buffer->count--;
    1990:	80 81       	ld	r24, Z
    1992:	91 81       	ldd	r25, Z+1	; 0x01
    1994:	01 97       	sbiw	r24, 0x01	; 1
    1996:	91 83       	std	Z+1, r25	; 0x01
    1998:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    199a:	0f 90       	pop	r0
    199c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    199e:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    19a2:	ff 91       	pop	r31
    19a4:	ef 91       	pop	r30
    19a6:	bf 91       	pop	r27
    19a8:	af 91       	pop	r26
    19aa:	9f 91       	pop	r25
    19ac:	8f 91       	pop	r24
    19ae:	2f 91       	pop	r18
    19b0:	0f 90       	pop	r0
    19b2:	0b be       	out	0x3b, r0	; 59
    19b4:	0f 90       	pop	r0
    19b6:	0f be       	out	0x3f, r0	; 63
    19b8:	0f 90       	pop	r0
    19ba:	1f 90       	pop	r1
    19bc:	18 95       	reti

000019be <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    19be:	1f 92       	push	r1
    19c0:	0f 92       	push	r0
    19c2:	0f b6       	in	r0, 0x3f	; 63
    19c4:	0f 92       	push	r0
    19c6:	11 24       	eor	r1, r1
    19c8:	0b b6       	in	r0, 0x3b	; 59
    19ca:	0f 92       	push	r0
    19cc:	2f 93       	push	r18
    19ce:	3f 93       	push	r19
    19d0:	4f 93       	push	r20
    19d2:	8f 93       	push	r24
    19d4:	9f 93       	push	r25
    19d6:	af 93       	push	r26
    19d8:	bf 93       	push	r27
    19da:	ef 93       	push	r30
    19dc:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    19de:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    19e2:	8c 71       	andi	r24, 0x1C	; 28
    19e4:	71 f0       	breq	.+28     	; 0x1a02 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    19e6:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    19ea:	88 23       	and	r24, r24
    19ec:	0c f0       	brlt	.+2      	; 0x19f0 <__vector_54+0x32>
    19ee:	36 c0       	rjmp	.+108    	; 0x1a5c <__vector_54+0x9e>
    19f0:	a6 e3       	ldi	r26, 0x36	; 54
    19f2:	b1 e0       	ldi	r27, 0x01	; 1
    19f4:	e0 e3       	ldi	r30, 0x30	; 48
    19f6:	f1 e0       	ldi	r31, 0x01	; 1
    19f8:	8c 91       	ld	r24, X
    19fa:	80 81       	ld	r24, Z
    19fc:	88 23       	and	r24, r24
    19fe:	e4 f3       	brlt	.-8      	; 0x19f8 <__vector_54+0x3a>
    1a00:	2d c0       	rjmp	.+90     	; 0x1a5c <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1a02:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a06:	0f b6       	in	r0, 0x3f	; 63
    1a08:	f8 94       	cli
    1a0a:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a0c:	e7 eb       	ldi	r30, 0xB7	; 183
    1a0e:	f4 e0       	ldi	r31, 0x04	; 4
    1a10:	21 81       	ldd	r18, Z+1	; 0x01
    1a12:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1a18:	83 85       	ldd	r24, Z+11	; 0x0b
    1a1a:	94 85       	ldd	r25, Z+12	; 0x0c
    1a1c:	28 17       	cp	r18, r24
    1a1e:	39 07       	cpc	r19, r25
    1a20:	e9 f0       	breq	.+58     	; 0x1a5c <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a22:	e8 eb       	ldi	r30, 0xB8	; 184
    1a24:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1a26:	a2 81       	ldd	r26, Z+2	; 0x02
    1a28:	b3 81       	ldd	r27, Z+3	; 0x03
    1a2a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1a2c:	82 81       	ldd	r24, Z+2	; 0x02
    1a2e:	93 81       	ldd	r25, Z+3	; 0x03
    1a30:	01 96       	adiw	r24, 0x01	; 1
    1a32:	93 83       	std	Z+3, r25	; 0x03
    1a34:	82 83       	std	Z+2, r24	; 0x02
    1a36:	20 85       	ldd	r18, Z+8	; 0x08
    1a38:	31 85       	ldd	r19, Z+9	; 0x09
    1a3a:	82 17       	cp	r24, r18
    1a3c:	93 07       	cpc	r25, r19
    1a3e:	21 f4       	brne	.+8      	; 0x1a48 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1a40:	86 81       	ldd	r24, Z+6	; 0x06
    1a42:	97 81       	ldd	r25, Z+7	; 0x07
    1a44:	93 83       	std	Z+3, r25	; 0x03
    1a46:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
	{
	    buffer->count++;
    1a4e:	80 81       	ld	r24, Z
    1a50:	91 81       	ldd	r25, Z+1	; 0x01
    1a52:	01 96       	adiw	r24, 0x01	; 1
    1a54:	91 83       	std	Z+1, r25	; 0x01
    1a56:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a58:	0f 90       	pop	r0
    1a5a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1a5c:	ff 91       	pop	r31
    1a5e:	ef 91       	pop	r30
    1a60:	bf 91       	pop	r27
    1a62:	af 91       	pop	r26
    1a64:	9f 91       	pop	r25
    1a66:	8f 91       	pop	r24
    1a68:	4f 91       	pop	r20
    1a6a:	3f 91       	pop	r19
    1a6c:	2f 91       	pop	r18
    1a6e:	0f 90       	pop	r0
    1a70:	0b be       	out	0x3b, r0	; 59
    1a72:	0f 90       	pop	r0
    1a74:	0f be       	out	0x3f, r0	; 63
    1a76:	0f 90       	pop	r0
    1a78:	1f 90       	pop	r1
    1a7a:	18 95       	reti

00001a7c <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1a7c:	1f 92       	push	r1
    1a7e:	0f 92       	push	r0
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	0f 92       	push	r0
    1a84:	11 24       	eor	r1, r1
    1a86:	0b b6       	in	r0, 0x3b	; 59
    1a88:	0f 92       	push	r0
    1a8a:	2f 93       	push	r18
    1a8c:	8f 93       	push	r24
    1a8e:	9f 93       	push	r25
    1a90:	af 93       	push	r26
    1a92:	bf 93       	push	r27
    1a94:	ef 93       	push	r30
    1a96:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a98:	0f b6       	in	r0, 0x3f	; 63
    1a9a:	f8 94       	cli
    1a9c:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a9e:	80 91 c4 04 	lds	r24, 0x04C4	; 0x8004c4 <xSerial3Port+0xd>
    1aa2:	90 91 c5 04 	lds	r25, 0x04C5	; 0x8004c5 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1aa6:	0f 90       	pop	r0
    1aa8:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1aaa:	89 2b       	or	r24, r25
    1aac:	31 f4       	brne	.+12     	; 0x1aba <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1aae:	e1 e3       	ldi	r30, 0x31	; 49
    1ab0:	f1 e0       	ldi	r31, 0x01	; 1
    1ab2:	80 81       	ld	r24, Z
    1ab4:	8f 7d       	andi	r24, 0xDF	; 223
    1ab6:	80 83       	st	Z, r24
    1ab8:	1c c0       	rjmp	.+56     	; 0x1af2 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1aba:	e4 ec       	ldi	r30, 0xC4	; 196
    1abc:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1abe:	a4 81       	ldd	r26, Z+4	; 0x04
    1ac0:	b5 81       	ldd	r27, Z+5	; 0x05
    1ac2:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1ac4:	b5 83       	std	Z+5, r27	; 0x05
    1ac6:	a4 83       	std	Z+4, r26	; 0x04
    1ac8:	80 85       	ldd	r24, Z+8	; 0x08
    1aca:	91 85       	ldd	r25, Z+9	; 0x09
    1acc:	a8 17       	cp	r26, r24
    1ace:	b9 07       	cpc	r27, r25
    1ad0:	21 f4       	brne	.+8      	; 0x1ada <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1ad2:	86 81       	ldd	r24, Z+6	; 0x06
    1ad4:	97 81       	ldd	r25, Z+7	; 0x07
    1ad6:	95 83       	std	Z+5, r25	; 0x05
    1ad8:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1ada:	0f b6       	in	r0, 0x3f	; 63
    1adc:	f8 94       	cli
    1ade:	0f 92       	push	r0
	{
	    buffer->count--;
    1ae0:	80 81       	ld	r24, Z
    1ae2:	91 81       	ldd	r25, Z+1	; 0x01
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	91 83       	std	Z+1, r25	; 0x01
    1ae8:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1aea:	0f 90       	pop	r0
    1aec:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1aee:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1af2:	ff 91       	pop	r31
    1af4:	ef 91       	pop	r30
    1af6:	bf 91       	pop	r27
    1af8:	af 91       	pop	r26
    1afa:	9f 91       	pop	r25
    1afc:	8f 91       	pop	r24
    1afe:	2f 91       	pop	r18
    1b00:	0f 90       	pop	r0
    1b02:	0b be       	out	0x3b, r0	; 59
    1b04:	0f 90       	pop	r0
    1b06:	0f be       	out	0x3f, r0	; 63
    1b08:	0f 90       	pop	r0
    1b0a:	1f 90       	pop	r1
    1b0c:	18 95       	reti

00001b0e <prvResetNextTaskUnblockTime>:
    1b0e:	e0 91 f2 02 	lds	r30, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1b12:	f0 91 f3 02 	lds	r31, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1b16:	80 81       	ld	r24, Z
    1b18:	81 11       	cpse	r24, r1
    1b1a:	07 c0       	rjmp	.+14     	; 0x1b2a <prvResetNextTaskUnblockTime+0x1c>
    1b1c:	8f ef       	ldi	r24, 0xFF	; 255
    1b1e:	9f ef       	ldi	r25, 0xFF	; 255
    1b20:	90 93 ca 02 	sts	0x02CA, r25	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1b24:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xNextTaskUnblockTime>
    1b28:	08 95       	ret
    1b2a:	e0 91 f2 02 	lds	r30, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1b2e:	f0 91 f3 02 	lds	r31, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1b32:	05 80       	ldd	r0, Z+5	; 0x05
    1b34:	f6 81       	ldd	r31, Z+6	; 0x06
    1b36:	e0 2d       	mov	r30, r0
    1b38:	06 80       	ldd	r0, Z+6	; 0x06
    1b3a:	f7 81       	ldd	r31, Z+7	; 0x07
    1b3c:	e0 2d       	mov	r30, r0
    1b3e:	82 81       	ldd	r24, Z+2	; 0x02
    1b40:	93 81       	ldd	r25, Z+3	; 0x03
    1b42:	90 93 ca 02 	sts	0x02CA, r25	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1b46:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xNextTaskUnblockTime>
    1b4a:	08 95       	ret

00001b4c <prvAddCurrentTaskToDelayedList>:
    1b4c:	ff 92       	push	r15
    1b4e:	0f 93       	push	r16
    1b50:	1f 93       	push	r17
    1b52:	cf 93       	push	r28
    1b54:	df 93       	push	r29
    1b56:	ec 01       	movw	r28, r24
    1b58:	f6 2e       	mov	r15, r22
    1b5a:	00 91 d1 02 	lds	r16, 0x02D1	; 0x8002d1 <xTickCount>
    1b5e:	10 91 d2 02 	lds	r17, 0x02D2	; 0x8002d2 <xTickCount+0x1>
    1b62:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <pxCurrentTCB>
    1b66:	90 91 2b 03 	lds	r25, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1b6a:	02 96       	adiw	r24, 0x02	; 2
    1b6c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1b70:	cf 3f       	cpi	r28, 0xFF	; 255
    1b72:	8f ef       	ldi	r24, 0xFF	; 255
    1b74:	d8 07       	cpc	r29, r24
    1b76:	69 f4       	brne	.+26     	; 0x1b92 <prvAddCurrentTaskToDelayedList+0x46>
    1b78:	ff 20       	and	r15, r15
    1b7a:	59 f0       	breq	.+22     	; 0x1b92 <prvAddCurrentTaskToDelayedList+0x46>
    1b7c:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <pxCurrentTCB>
    1b80:	70 91 2b 03 	lds	r23, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1b84:	6e 5f       	subi	r22, 0xFE	; 254
    1b86:	7f 4f       	sbci	r23, 0xFF	; 255
    1b88:	84 ed       	ldi	r24, 0xD4	; 212
    1b8a:	92 e0       	ldi	r25, 0x02	; 2
    1b8c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1b90:	2f c0       	rjmp	.+94     	; 0x1bf0 <prvAddCurrentTaskToDelayedList+0xa4>
    1b92:	c0 0f       	add	r28, r16
    1b94:	d1 1f       	adc	r29, r17
    1b96:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    1b9a:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1b9e:	d3 83       	std	Z+3, r29	; 0x03
    1ba0:	c2 83       	std	Z+2, r28	; 0x02
    1ba2:	c0 17       	cp	r28, r16
    1ba4:	d1 07       	cpc	r29, r17
    1ba6:	68 f4       	brcc	.+26     	; 0x1bc2 <prvAddCurrentTaskToDelayedList+0x76>
    1ba8:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <pxCurrentTCB>
    1bac:	70 91 2b 03 	lds	r23, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1bb0:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <pxOverflowDelayedTaskList>
    1bb4:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <pxOverflowDelayedTaskList+0x1>
    1bb8:	6e 5f       	subi	r22, 0xFE	; 254
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1bc0:	17 c0       	rjmp	.+46     	; 0x1bf0 <prvAddCurrentTaskToDelayedList+0xa4>
    1bc2:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <pxCurrentTCB>
    1bc6:	70 91 2b 03 	lds	r23, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1bca:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1bce:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1bd2:	6e 5f       	subi	r22, 0xFE	; 254
    1bd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd6:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1bda:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xNextTaskUnblockTime>
    1bde:	90 91 ca 02 	lds	r25, 0x02CA	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1be2:	c8 17       	cp	r28, r24
    1be4:	d9 07       	cpc	r29, r25
    1be6:	20 f4       	brcc	.+8      	; 0x1bf0 <prvAddCurrentTaskToDelayedList+0xa4>
    1be8:	d0 93 ca 02 	sts	0x02CA, r29	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1bec:	c0 93 c9 02 	sts	0x02C9, r28	; 0x8002c9 <xNextTaskUnblockTime>
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	08 95       	ret

00001bfc <xTaskCreate>:
    1bfc:	4f 92       	push	r4
    1bfe:	5f 92       	push	r5
    1c00:	6f 92       	push	r6
    1c02:	7f 92       	push	r7
    1c04:	8f 92       	push	r8
    1c06:	9f 92       	push	r9
    1c08:	af 92       	push	r10
    1c0a:	bf 92       	push	r11
    1c0c:	cf 92       	push	r12
    1c0e:	df 92       	push	r13
    1c10:	ef 92       	push	r14
    1c12:	ff 92       	push	r15
    1c14:	0f 93       	push	r16
    1c16:	cf 93       	push	r28
    1c18:	df 93       	push	r29
    1c1a:	4c 01       	movw	r8, r24
    1c1c:	6b 01       	movw	r12, r22
    1c1e:	5a 01       	movw	r10, r20
    1c20:	29 01       	movw	r4, r18
    1c22:	ca 01       	movw	r24, r20
    1c24:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1c28:	3c 01       	movw	r6, r24
    1c2a:	89 2b       	or	r24, r25
    1c2c:	09 f4       	brne	.+2      	; 0x1c30 <xTaskCreate+0x34>
    1c2e:	e9 c0       	rjmp	.+466    	; 0x1e02 <xTaskCreate+0x206>
    1c30:	88 e2       	ldi	r24, 0x28	; 40
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1c38:	ec 01       	movw	r28, r24
    1c3a:	89 2b       	or	r24, r25
    1c3c:	a9 f0       	breq	.+42     	; 0x1c68 <xTaskCreate+0x6c>
    1c3e:	78 8e       	std	Y+24, r7	; 0x18
    1c40:	6f 8a       	std	Y+23, r6	; 0x17
    1c42:	a5 01       	movw	r20, r10
    1c44:	65 ea       	ldi	r22, 0xA5	; 165
    1c46:	70 e0       	ldi	r23, 0x00	; 0
    1c48:	c3 01       	movw	r24, r6
    1c4a:	a5 d6       	rcall	.+3402   	; 0x2996 <memset>
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	a8 1a       	sub	r10, r24
    1c50:	b1 08       	sbc	r11, r1
    1c52:	8f 89       	ldd	r24, Y+23	; 0x17
    1c54:	98 8d       	ldd	r25, Y+24	; 0x18
    1c56:	a8 0e       	add	r10, r24
    1c58:	b9 1e       	adc	r11, r25
    1c5a:	d6 01       	movw	r26, r12
    1c5c:	8c 91       	ld	r24, X
    1c5e:	89 8f       	std	Y+25, r24	; 0x19
    1c60:	8c 91       	ld	r24, X
    1c62:	81 11       	cpse	r24, r1
    1c64:	05 c0       	rjmp	.+10     	; 0x1c70 <xTaskCreate+0x74>
    1c66:	18 c0       	rjmp	.+48     	; 0x1c98 <xTaskCreate+0x9c>
    1c68:	c3 01       	movw	r24, r6
    1c6a:	0e 94 bc 01 	call	0x378	; 0x378 <vPortFree>
    1c6e:	c9 c0       	rjmp	.+402    	; 0x1e02 <xTaskCreate+0x206>
    1c70:	ae 01       	movw	r20, r28
    1c72:	46 5e       	subi	r20, 0xE6	; 230
    1c74:	5f 4f       	sbci	r21, 0xFF	; 255
    1c76:	f6 01       	movw	r30, r12
    1c78:	31 96       	adiw	r30, 0x01	; 1
    1c7a:	b8 e0       	ldi	r27, 0x08	; 8
    1c7c:	cb 0e       	add	r12, r27
    1c7e:	d1 1c       	adc	r13, r1
    1c80:	cf 01       	movw	r24, r30
    1c82:	21 91       	ld	r18, Z+
    1c84:	da 01       	movw	r26, r20
    1c86:	2d 93       	st	X+, r18
    1c88:	ad 01       	movw	r20, r26
    1c8a:	dc 01       	movw	r26, r24
    1c8c:	8c 91       	ld	r24, X
    1c8e:	88 23       	and	r24, r24
    1c90:	19 f0       	breq	.+6      	; 0x1c98 <xTaskCreate+0x9c>
    1c92:	ec 15       	cp	r30, r12
    1c94:	fd 05       	cpc	r31, r13
    1c96:	a1 f7       	brne	.-24     	; 0x1c80 <xTaskCreate+0x84>
    1c98:	18 a2       	std	Y+32, r1	; 0x20
    1c9a:	04 30       	cpi	r16, 0x04	; 4
    1c9c:	08 f0       	brcs	.+2      	; 0x1ca0 <xTaskCreate+0xa4>
    1c9e:	03 e0       	ldi	r16, 0x03	; 3
    1ca0:	0e 8b       	std	Y+22, r16	; 0x16
    1ca2:	09 a3       	std	Y+33, r16	; 0x21
    1ca4:	1a a2       	std	Y+34, r1	; 0x22
    1ca6:	6e 01       	movw	r12, r28
    1ca8:	b2 e0       	ldi	r27, 0x02	; 2
    1caa:	cb 0e       	add	r12, r27
    1cac:	d1 1c       	adc	r13, r1
    1cae:	c6 01       	movw	r24, r12
    1cb0:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1cb4:	ce 01       	movw	r24, r28
    1cb6:	0c 96       	adiw	r24, 0x0c	; 12
    1cb8:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1cbc:	d9 87       	std	Y+9, r29	; 0x09
    1cbe:	c8 87       	std	Y+8, r28	; 0x08
    1cc0:	84 e0       	ldi	r24, 0x04	; 4
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	80 1b       	sub	r24, r16
    1cc6:	91 09       	sbc	r25, r1
    1cc8:	9d 87       	std	Y+13, r25	; 0x0d
    1cca:	8c 87       	std	Y+12, r24	; 0x0c
    1ccc:	db 8b       	std	Y+19, r29	; 0x13
    1cce:	ca 8b       	std	Y+18, r28	; 0x12
    1cd0:	1b a2       	std	Y+35, r1	; 0x23
    1cd2:	1c a2       	std	Y+36, r1	; 0x24
    1cd4:	1d a2       	std	Y+37, r1	; 0x25
    1cd6:	1e a2       	std	Y+38, r1	; 0x26
    1cd8:	1f a2       	std	Y+39, r1	; 0x27
    1cda:	a2 01       	movw	r20, r4
    1cdc:	b4 01       	movw	r22, r8
    1cde:	c5 01       	movw	r24, r10
    1ce0:	04 da       	rcall	.-3064   	; 0x10ea <pxPortInitialiseStack>
    1ce2:	99 83       	std	Y+1, r25	; 0x01
    1ce4:	88 83       	st	Y, r24
    1ce6:	e1 14       	cp	r14, r1
    1ce8:	f1 04       	cpc	r15, r1
    1cea:	19 f0       	breq	.+6      	; 0x1cf2 <xTaskCreate+0xf6>
    1cec:	f7 01       	movw	r30, r14
    1cee:	d1 83       	std	Z+1, r29	; 0x01
    1cf0:	c0 83       	st	Z, r28
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
    1cf8:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <uxCurrentNumberOfTasks>
    1cfc:	8f 5f       	subi	r24, 0xFF	; 255
    1cfe:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <uxCurrentNumberOfTasks>
    1d02:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <pxCurrentTCB>
    1d06:	90 91 2b 03 	lds	r25, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1d0a:	89 2b       	or	r24, r25
    1d0c:	d1 f5       	brne	.+116    	; 0x1d82 <xTaskCreate+0x186>
    1d0e:	d0 93 2b 03 	sts	0x032B, r29	; 0x80032b <pxCurrentTCB+0x1>
    1d12:	c0 93 2a 03 	sts	0x032A, r28	; 0x80032a <pxCurrentTCB>
    1d16:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <uxCurrentNumberOfTasks>
    1d1a:	81 30       	cpi	r24, 0x01	; 1
    1d1c:	09 f0       	breq	.+2      	; 0x1d20 <xTaskCreate+0x124>
    1d1e:	41 c0       	rjmp	.+130    	; 0x1da2 <xTaskCreate+0x1a6>
    1d20:	86 e0       	ldi	r24, 0x06	; 6
    1d22:	93 e0       	ldi	r25, 0x03	; 3
    1d24:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d28:	8f e0       	ldi	r24, 0x0F	; 15
    1d2a:	93 e0       	ldi	r25, 0x03	; 3
    1d2c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d30:	88 e1       	ldi	r24, 0x18	; 24
    1d32:	93 e0       	ldi	r25, 0x03	; 3
    1d34:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d38:	81 e2       	ldi	r24, 0x21	; 33
    1d3a:	93 e0       	ldi	r25, 0x03	; 3
    1d3c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d40:	8d ef       	ldi	r24, 0xFD	; 253
    1d42:	92 e0       	ldi	r25, 0x02	; 2
    1d44:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d48:	84 ef       	ldi	r24, 0xF4	; 244
    1d4a:	92 e0       	ldi	r25, 0x02	; 2
    1d4c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d50:	87 ee       	ldi	r24, 0xE7	; 231
    1d52:	92 e0       	ldi	r25, 0x02	; 2
    1d54:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d58:	8e ed       	ldi	r24, 0xDE	; 222
    1d5a:	92 e0       	ldi	r25, 0x02	; 2
    1d5c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d60:	84 ed       	ldi	r24, 0xD4	; 212
    1d62:	92 e0       	ldi	r25, 0x02	; 2
    1d64:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d68:	8d ef       	ldi	r24, 0xFD	; 253
    1d6a:	92 e0       	ldi	r25, 0x02	; 2
    1d6c:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <pxDelayedTaskList+0x1>
    1d70:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <pxDelayedTaskList>
    1d74:	84 ef       	ldi	r24, 0xF4	; 244
    1d76:	92 e0       	ldi	r25, 0x02	; 2
    1d78:	90 93 f1 02 	sts	0x02F1, r25	; 0x8002f1 <pxOverflowDelayedTaskList+0x1>
    1d7c:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <pxOverflowDelayedTaskList>
    1d80:	10 c0       	rjmp	.+32     	; 0x1da2 <xTaskCreate+0x1a6>
    1d82:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xSchedulerRunning>
    1d86:	81 11       	cpse	r24, r1
    1d88:	0c c0       	rjmp	.+24     	; 0x1da2 <xTaskCreate+0x1a6>
    1d8a:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    1d8e:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1d92:	96 89       	ldd	r25, Z+22	; 0x16
    1d94:	8e 89       	ldd	r24, Y+22	; 0x16
    1d96:	89 17       	cp	r24, r25
    1d98:	20 f0       	brcs	.+8      	; 0x1da2 <xTaskCreate+0x1a6>
    1d9a:	d0 93 2b 03 	sts	0x032B, r29	; 0x80032b <pxCurrentTCB+0x1>
    1d9e:	c0 93 2a 03 	sts	0x032A, r28	; 0x80032a <pxCurrentTCB>
    1da2:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <uxTaskNumber>
    1da6:	8f 5f       	subi	r24, 0xFF	; 255
    1da8:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <uxTaskNumber>
    1dac:	8e 89       	ldd	r24, Y+22	; 0x16
    1dae:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    1db2:	98 17       	cp	r25, r24
    1db4:	10 f4       	brcc	.+4      	; 0x1dba <xTaskCreate+0x1be>
    1db6:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxTopReadyPriority>
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	9c 01       	movw	r18, r24
    1dbe:	22 0f       	add	r18, r18
    1dc0:	33 1f       	adc	r19, r19
    1dc2:	22 0f       	add	r18, r18
    1dc4:	33 1f       	adc	r19, r19
    1dc6:	22 0f       	add	r18, r18
    1dc8:	33 1f       	adc	r19, r19
    1dca:	82 0f       	add	r24, r18
    1dcc:	93 1f       	adc	r25, r19
    1dce:	b6 01       	movw	r22, r12
    1dd0:	8a 5f       	subi	r24, 0xFA	; 250
    1dd2:	9c 4f       	sbci	r25, 0xFC	; 252
    1dd4:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1dd8:	0f 90       	pop	r0
    1dda:	0f be       	out	0x3f, r0	; 63
    1ddc:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <xSchedulerRunning>
    1de0:	88 23       	and	r24, r24
    1de2:	59 f0       	breq	.+22     	; 0x1dfa <xTaskCreate+0x1fe>
    1de4:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    1de8:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1dec:	96 89       	ldd	r25, Z+22	; 0x16
    1dee:	8e 89       	ldd	r24, Y+22	; 0x16
    1df0:	98 17       	cp	r25, r24
    1df2:	28 f4       	brcc	.+10     	; 0x1dfe <xTaskCreate+0x202>
    1df4:	32 da       	rcall	.-2972   	; 0x125a <vPortYield>
    1df6:	81 e0       	ldi	r24, 0x01	; 1
    1df8:	05 c0       	rjmp	.+10     	; 0x1e04 <xTaskCreate+0x208>
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	03 c0       	rjmp	.+6      	; 0x1e04 <xTaskCreate+0x208>
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	01 c0       	rjmp	.+2      	; 0x1e04 <xTaskCreate+0x208>
    1e02:	8f ef       	ldi	r24, 0xFF	; 255
    1e04:	df 91       	pop	r29
    1e06:	cf 91       	pop	r28
    1e08:	0f 91       	pop	r16
    1e0a:	ff 90       	pop	r15
    1e0c:	ef 90       	pop	r14
    1e0e:	df 90       	pop	r13
    1e10:	cf 90       	pop	r12
    1e12:	bf 90       	pop	r11
    1e14:	af 90       	pop	r10
    1e16:	9f 90       	pop	r9
    1e18:	8f 90       	pop	r8
    1e1a:	7f 90       	pop	r7
    1e1c:	6f 90       	pop	r6
    1e1e:	5f 90       	pop	r5
    1e20:	4f 90       	pop	r4
    1e22:	08 95       	ret

00001e24 <vTaskStartScheduler>:
    1e24:	ef 92       	push	r14
    1e26:	ff 92       	push	r15
    1e28:	0f 93       	push	r16
    1e2a:	0f 2e       	mov	r0, r31
    1e2c:	f7 ec       	ldi	r31, 0xC7	; 199
    1e2e:	ef 2e       	mov	r14, r31
    1e30:	f2 e0       	ldi	r31, 0x02	; 2
    1e32:	ff 2e       	mov	r15, r31
    1e34:	f0 2d       	mov	r31, r0
    1e36:	00 e0       	ldi	r16, 0x00	; 0
    1e38:	20 e0       	ldi	r18, 0x00	; 0
    1e3a:	30 e0       	ldi	r19, 0x00	; 0
    1e3c:	45 e5       	ldi	r20, 0x55	; 85
    1e3e:	50 e0       	ldi	r21, 0x00	; 0
    1e40:	6a e9       	ldi	r22, 0x9A	; 154
    1e42:	72 e0       	ldi	r23, 0x02	; 2
    1e44:	83 e3       	ldi	r24, 0x33	; 51
    1e46:	91 e0       	ldi	r25, 0x01	; 1
    1e48:	d9 de       	rcall	.-590    	; 0x1bfc <xTaskCreate>
    1e4a:	81 30       	cpi	r24, 0x01	; 1
    1e4c:	79 f4       	brne	.+30     	; 0x1e6c <vTaskStartScheduler+0x48>
    1e4e:	f8 94       	cli
    1e50:	8f ef       	ldi	r24, 0xFF	; 255
    1e52:	9f ef       	ldi	r25, 0xFF	; 255
    1e54:	90 93 ca 02 	sts	0x02CA, r25	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1e58:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xNextTaskUnblockTime>
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <xSchedulerRunning>
    1e62:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <xTickCount+0x1>
    1e66:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <xTickCount>
    1e6a:	b1 d9       	rcall	.-3230   	; 0x11ce <xPortStartScheduler>
    1e6c:	0f 91       	pop	r16
    1e6e:	ff 90       	pop	r15
    1e70:	ef 90       	pop	r14
    1e72:	08 95       	ret

00001e74 <vTaskSuspendAll>:
    1e74:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    1e78:	8f 5f       	subi	r24, 0xFF	; 255
    1e7a:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <uxSchedulerSuspended>
    1e7e:	08 95       	ret

00001e80 <xTaskIncrementTick>:
    1e80:	cf 92       	push	r12
    1e82:	df 92       	push	r13
    1e84:	ef 92       	push	r14
    1e86:	ff 92       	push	r15
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    1e94:	81 11       	cpse	r24, r1
    1e96:	98 c0       	rjmp	.+304    	; 0x1fc8 <xTaskIncrementTick+0x148>
    1e98:	e0 90 d1 02 	lds	r14, 0x02D1	; 0x8002d1 <xTickCount>
    1e9c:	f0 90 d2 02 	lds	r15, 0x02D2	; 0x8002d2 <xTickCount+0x1>
    1ea0:	8f ef       	ldi	r24, 0xFF	; 255
    1ea2:	e8 1a       	sub	r14, r24
    1ea4:	f8 0a       	sbc	r15, r24
    1ea6:	f0 92 d2 02 	sts	0x02D2, r15	; 0x8002d2 <xTickCount+0x1>
    1eaa:	e0 92 d1 02 	sts	0x02D1, r14	; 0x8002d1 <xTickCount>
    1eae:	e1 14       	cp	r14, r1
    1eb0:	f1 04       	cpc	r15, r1
    1eb2:	b1 f4       	brne	.+44     	; 0x1ee0 <xTaskIncrementTick+0x60>
    1eb4:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1eb8:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1ebc:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <pxOverflowDelayedTaskList>
    1ec0:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <pxOverflowDelayedTaskList+0x1>
    1ec4:	30 93 f3 02 	sts	0x02F3, r19	; 0x8002f3 <pxDelayedTaskList+0x1>
    1ec8:	20 93 f2 02 	sts	0x02F2, r18	; 0x8002f2 <pxDelayedTaskList>
    1ecc:	90 93 f1 02 	sts	0x02F1, r25	; 0x8002f1 <pxOverflowDelayedTaskList+0x1>
    1ed0:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <pxOverflowDelayedTaskList>
    1ed4:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xNumOfOverflows>
    1ed8:	8f 5f       	subi	r24, 0xFF	; 255
    1eda:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xNumOfOverflows>
    1ede:	17 de       	rcall	.-978    	; 0x1b0e <prvResetNextTaskUnblockTime>
    1ee0:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xNextTaskUnblockTime>
    1ee4:	90 91 ca 02 	lds	r25, 0x02CA	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1ee8:	e8 16       	cp	r14, r24
    1eea:	f9 06       	cpc	r15, r25
    1eec:	10 f4       	brcc	.+4      	; 0x1ef2 <xTaskIncrementTick+0x72>
    1eee:	d1 2c       	mov	r13, r1
    1ef0:	53 c0       	rjmp	.+166    	; 0x1f98 <xTaskIncrementTick+0x118>
    1ef2:	d1 2c       	mov	r13, r1
    1ef4:	cc 24       	eor	r12, r12
    1ef6:	c3 94       	inc	r12
    1ef8:	e0 91 f2 02 	lds	r30, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1efc:	f0 91 f3 02 	lds	r31, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1f00:	80 81       	ld	r24, Z
    1f02:	81 11       	cpse	r24, r1
    1f04:	07 c0       	rjmp	.+14     	; 0x1f14 <xTaskIncrementTick+0x94>
    1f06:	8f ef       	ldi	r24, 0xFF	; 255
    1f08:	9f ef       	ldi	r25, 0xFF	; 255
    1f0a:	90 93 ca 02 	sts	0x02CA, r25	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1f0e:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xNextTaskUnblockTime>
    1f12:	42 c0       	rjmp	.+132    	; 0x1f98 <xTaskIncrementTick+0x118>
    1f14:	e0 91 f2 02 	lds	r30, 0x02F2	; 0x8002f2 <pxDelayedTaskList>
    1f18:	f0 91 f3 02 	lds	r31, 0x02F3	; 0x8002f3 <pxDelayedTaskList+0x1>
    1f1c:	05 80       	ldd	r0, Z+5	; 0x05
    1f1e:	f6 81       	ldd	r31, Z+6	; 0x06
    1f20:	e0 2d       	mov	r30, r0
    1f22:	c6 81       	ldd	r28, Z+6	; 0x06
    1f24:	d7 81       	ldd	r29, Z+7	; 0x07
    1f26:	8a 81       	ldd	r24, Y+2	; 0x02
    1f28:	9b 81       	ldd	r25, Y+3	; 0x03
    1f2a:	e8 16       	cp	r14, r24
    1f2c:	f9 06       	cpc	r15, r25
    1f2e:	28 f4       	brcc	.+10     	; 0x1f3a <xTaskIncrementTick+0xba>
    1f30:	90 93 ca 02 	sts	0x02CA, r25	; 0x8002ca <xNextTaskUnblockTime+0x1>
    1f34:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xNextTaskUnblockTime>
    1f38:	2f c0       	rjmp	.+94     	; 0x1f98 <xTaskIncrementTick+0x118>
    1f3a:	8e 01       	movw	r16, r28
    1f3c:	0e 5f       	subi	r16, 0xFE	; 254
    1f3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f40:	c8 01       	movw	r24, r16
    1f42:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f46:	8c 89       	ldd	r24, Y+20	; 0x14
    1f48:	9d 89       	ldd	r25, Y+21	; 0x15
    1f4a:	89 2b       	or	r24, r25
    1f4c:	21 f0       	breq	.+8      	; 0x1f56 <xTaskIncrementTick+0xd6>
    1f4e:	ce 01       	movw	r24, r28
    1f50:	0c 96       	adiw	r24, 0x0c	; 12
    1f52:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f56:	8e 89       	ldd	r24, Y+22	; 0x16
    1f58:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    1f5c:	98 17       	cp	r25, r24
    1f5e:	10 f4       	brcc	.+4      	; 0x1f64 <xTaskIncrementTick+0xe4>
    1f60:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxTopReadyPriority>
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	9c 01       	movw	r18, r24
    1f68:	22 0f       	add	r18, r18
    1f6a:	33 1f       	adc	r19, r19
    1f6c:	22 0f       	add	r18, r18
    1f6e:	33 1f       	adc	r19, r19
    1f70:	22 0f       	add	r18, r18
    1f72:	33 1f       	adc	r19, r19
    1f74:	82 0f       	add	r24, r18
    1f76:	93 1f       	adc	r25, r19
    1f78:	b8 01       	movw	r22, r16
    1f7a:	8a 5f       	subi	r24, 0xFA	; 250
    1f7c:	9c 4f       	sbci	r25, 0xFC	; 252
    1f7e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1f82:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    1f86:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1f8a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f8c:	86 89       	ldd	r24, Z+22	; 0x16
    1f8e:	98 17       	cp	r25, r24
    1f90:	08 f4       	brcc	.+2      	; 0x1f94 <xTaskIncrementTick+0x114>
    1f92:	b2 cf       	rjmp	.-156    	; 0x1ef8 <xTaskIncrementTick+0x78>
    1f94:	dc 2c       	mov	r13, r12
    1f96:	b0 cf       	rjmp	.-160    	; 0x1ef8 <xTaskIncrementTick+0x78>
    1f98:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    1f9c:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    1fa0:	86 89       	ldd	r24, Z+22	; 0x16
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	fc 01       	movw	r30, r24
    1fa6:	ee 0f       	add	r30, r30
    1fa8:	ff 1f       	adc	r31, r31
    1faa:	ee 0f       	add	r30, r30
    1fac:	ff 1f       	adc	r31, r31
    1fae:	ee 0f       	add	r30, r30
    1fb0:	ff 1f       	adc	r31, r31
    1fb2:	8e 0f       	add	r24, r30
    1fb4:	9f 1f       	adc	r25, r31
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	ea 5f       	subi	r30, 0xFA	; 250
    1fba:	fc 4f       	sbci	r31, 0xFC	; 252
    1fbc:	80 81       	ld	r24, Z
    1fbe:	82 30       	cpi	r24, 0x02	; 2
    1fc0:	48 f0       	brcs	.+18     	; 0x1fd4 <xTaskIncrementTick+0x154>
    1fc2:	dd 24       	eor	r13, r13
    1fc4:	d3 94       	inc	r13
    1fc6:	06 c0       	rjmp	.+12     	; 0x1fd4 <xTaskIncrementTick+0x154>
    1fc8:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <uxPendedTicks>
    1fcc:	8f 5f       	subi	r24, 0xFF	; 255
    1fce:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <uxPendedTicks>
    1fd2:	d1 2c       	mov	r13, r1
    1fd4:	80 91 cd 02 	lds	r24, 0x02CD	; 0x8002cd <xYieldPending>
    1fd8:	88 23       	and	r24, r24
    1fda:	11 f0       	breq	.+4      	; 0x1fe0 <xTaskIncrementTick+0x160>
    1fdc:	dd 24       	eor	r13, r13
    1fde:	d3 94       	inc	r13
    1fe0:	8d 2d       	mov	r24, r13
    1fe2:	df 91       	pop	r29
    1fe4:	cf 91       	pop	r28
    1fe6:	1f 91       	pop	r17
    1fe8:	0f 91       	pop	r16
    1fea:	ff 90       	pop	r15
    1fec:	ef 90       	pop	r14
    1fee:	df 90       	pop	r13
    1ff0:	cf 90       	pop	r12
    1ff2:	08 95       	ret

00001ff4 <xTaskResumeAll>:
    1ff4:	df 92       	push	r13
    1ff6:	ef 92       	push	r14
    1ff8:	ff 92       	push	r15
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
    2008:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    200c:	81 50       	subi	r24, 0x01	; 1
    200e:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <uxSchedulerSuspended>
    2012:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    2016:	81 11       	cpse	r24, r1
    2018:	5c c0       	rjmp	.+184    	; 0x20d2 <xTaskResumeAll+0xde>
    201a:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <uxCurrentNumberOfTasks>
    201e:	81 11       	cpse	r24, r1
    2020:	33 c0       	rjmp	.+102    	; 0x2088 <xTaskResumeAll+0x94>
    2022:	5a c0       	rjmp	.+180    	; 0x20d8 <xTaskResumeAll+0xe4>
    2024:	d7 01       	movw	r26, r14
    2026:	15 96       	adiw	r26, 0x05	; 5
    2028:	ed 91       	ld	r30, X+
    202a:	fc 91       	ld	r31, X
    202c:	16 97       	sbiw	r26, 0x06	; 6
    202e:	c6 81       	ldd	r28, Z+6	; 0x06
    2030:	d7 81       	ldd	r29, Z+7	; 0x07
    2032:	ce 01       	movw	r24, r28
    2034:	0c 96       	adiw	r24, 0x0c	; 12
    2036:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    203a:	8e 01       	movw	r16, r28
    203c:	0e 5f       	subi	r16, 0xFE	; 254
    203e:	1f 4f       	sbci	r17, 0xFF	; 255
    2040:	c8 01       	movw	r24, r16
    2042:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2046:	8e 89       	ldd	r24, Y+22	; 0x16
    2048:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    204c:	98 17       	cp	r25, r24
    204e:	10 f4       	brcc	.+4      	; 0x2054 <xTaskResumeAll+0x60>
    2050:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxTopReadyPriority>
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	9c 01       	movw	r18, r24
    2058:	22 0f       	add	r18, r18
    205a:	33 1f       	adc	r19, r19
    205c:	22 0f       	add	r18, r18
    205e:	33 1f       	adc	r19, r19
    2060:	22 0f       	add	r18, r18
    2062:	33 1f       	adc	r19, r19
    2064:	82 0f       	add	r24, r18
    2066:	93 1f       	adc	r25, r19
    2068:	b8 01       	movw	r22, r16
    206a:	8a 5f       	subi	r24, 0xFA	; 250
    206c:	9c 4f       	sbci	r25, 0xFC	; 252
    206e:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2072:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    2076:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    207a:	9e 89       	ldd	r25, Y+22	; 0x16
    207c:	86 89       	ldd	r24, Z+22	; 0x16
    207e:	98 17       	cp	r25, r24
    2080:	68 f0       	brcs	.+26     	; 0x209c <xTaskResumeAll+0xa8>
    2082:	d0 92 cd 02 	sts	0x02CD, r13	; 0x8002cd <xYieldPending>
    2086:	0a c0       	rjmp	.+20     	; 0x209c <xTaskResumeAll+0xa8>
    2088:	c0 e0       	ldi	r28, 0x00	; 0
    208a:	d0 e0       	ldi	r29, 0x00	; 0
    208c:	0f 2e       	mov	r0, r31
    208e:	f7 ee       	ldi	r31, 0xE7	; 231
    2090:	ef 2e       	mov	r14, r31
    2092:	f2 e0       	ldi	r31, 0x02	; 2
    2094:	ff 2e       	mov	r15, r31
    2096:	f0 2d       	mov	r31, r0
    2098:	dd 24       	eor	r13, r13
    209a:	d3 94       	inc	r13
    209c:	f7 01       	movw	r30, r14
    209e:	80 81       	ld	r24, Z
    20a0:	81 11       	cpse	r24, r1
    20a2:	c0 cf       	rjmp	.-128    	; 0x2024 <xTaskResumeAll+0x30>
    20a4:	cd 2b       	or	r28, r29
    20a6:	09 f0       	breq	.+2      	; 0x20aa <xTaskResumeAll+0xb6>
    20a8:	32 dd       	rcall	.-1436   	; 0x1b0e <prvResetNextTaskUnblockTime>
    20aa:	c0 91 ce 02 	lds	r28, 0x02CE	; 0x8002ce <uxPendedTicks>
    20ae:	cc 23       	and	r28, r28
    20b0:	49 f0       	breq	.+18     	; 0x20c4 <xTaskResumeAll+0xd0>
    20b2:	d1 e0       	ldi	r29, 0x01	; 1
    20b4:	e5 de       	rcall	.-566    	; 0x1e80 <xTaskIncrementTick>
    20b6:	81 11       	cpse	r24, r1
    20b8:	d0 93 cd 02 	sts	0x02CD, r29	; 0x8002cd <xYieldPending>
    20bc:	c1 50       	subi	r28, 0x01	; 1
    20be:	d1 f7       	brne	.-12     	; 0x20b4 <xTaskResumeAll+0xc0>
    20c0:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <uxPendedTicks>
    20c4:	80 91 cd 02 	lds	r24, 0x02CD	; 0x8002cd <xYieldPending>
    20c8:	88 23       	and	r24, r24
    20ca:	29 f0       	breq	.+10     	; 0x20d6 <xTaskResumeAll+0xe2>
    20cc:	c6 d8       	rcall	.-3700   	; 0x125a <vPortYield>
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	03 c0       	rjmp	.+6      	; 0x20d8 <xTaskResumeAll+0xe4>
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	01 c0       	rjmp	.+2      	; 0x20d8 <xTaskResumeAll+0xe4>
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	0f 90       	pop	r0
    20da:	0f be       	out	0x3f, r0	; 63
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	1f 91       	pop	r17
    20e2:	0f 91       	pop	r16
    20e4:	ff 90       	pop	r15
    20e6:	ef 90       	pop	r14
    20e8:	df 90       	pop	r13
    20ea:	08 95       	ret

000020ec <vTaskSwitchContext>:
    20ec:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    20f0:	88 23       	and	r24, r24
    20f2:	21 f0       	breq	.+8      	; 0x20fc <vTaskSwitchContext+0x10>
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <xYieldPending>
    20fa:	08 95       	ret
    20fc:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <xYieldPending>
    2100:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <pxCurrentTCB>
    2104:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    2108:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    210c:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    2110:	2d 91       	ld	r18, X+
    2112:	3c 91       	ld	r19, X
    2114:	87 89       	ldd	r24, Z+23	; 0x17
    2116:	90 8d       	ldd	r25, Z+24	; 0x18
    2118:	82 17       	cp	r24, r18
    211a:	93 07       	cpc	r25, r19
    211c:	60 f0       	brcs	.+24     	; 0x2136 <vTaskSwitchContext+0x4a>
    211e:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <pxCurrentTCB>
    2122:	70 91 2b 03 	lds	r23, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    2126:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <pxCurrentTCB>
    212a:	90 91 2b 03 	lds	r25, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    212e:	67 5e       	subi	r22, 0xE7	; 231
    2130:	7f 4f       	sbci	r23, 0xFF	; 255
    2132:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vApplicationStackOverflowHook>
    2136:	20 91 d0 02 	lds	r18, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    213a:	82 2f       	mov	r24, r18
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	fc 01       	movw	r30, r24
    2140:	ee 0f       	add	r30, r30
    2142:	ff 1f       	adc	r31, r31
    2144:	ee 0f       	add	r30, r30
    2146:	ff 1f       	adc	r31, r31
    2148:	ee 0f       	add	r30, r30
    214a:	ff 1f       	adc	r31, r31
    214c:	e8 0f       	add	r30, r24
    214e:	f9 1f       	adc	r31, r25
    2150:	ea 5f       	subi	r30, 0xFA	; 250
    2152:	fc 4f       	sbci	r31, 0xFC	; 252
    2154:	30 81       	ld	r19, Z
    2156:	31 11       	cpse	r19, r1
    2158:	11 c0       	rjmp	.+34     	; 0x217c <vTaskSwitchContext+0x90>
    215a:	21 50       	subi	r18, 0x01	; 1
    215c:	82 2f       	mov	r24, r18
    215e:	90 e0       	ldi	r25, 0x00	; 0
    2160:	fc 01       	movw	r30, r24
    2162:	ee 0f       	add	r30, r30
    2164:	ff 1f       	adc	r31, r31
    2166:	ee 0f       	add	r30, r30
    2168:	ff 1f       	adc	r31, r31
    216a:	ee 0f       	add	r30, r30
    216c:	ff 1f       	adc	r31, r31
    216e:	e8 0f       	add	r30, r24
    2170:	f9 1f       	adc	r31, r25
    2172:	ea 5f       	subi	r30, 0xFA	; 250
    2174:	fc 4f       	sbci	r31, 0xFC	; 252
    2176:	30 81       	ld	r19, Z
    2178:	33 23       	and	r19, r19
    217a:	79 f3       	breq	.-34     	; 0x215a <vTaskSwitchContext+0x6e>
    217c:	ac 01       	movw	r20, r24
    217e:	44 0f       	add	r20, r20
    2180:	55 1f       	adc	r21, r21
    2182:	44 0f       	add	r20, r20
    2184:	55 1f       	adc	r21, r21
    2186:	44 0f       	add	r20, r20
    2188:	55 1f       	adc	r21, r21
    218a:	48 0f       	add	r20, r24
    218c:	59 1f       	adc	r21, r25
    218e:	da 01       	movw	r26, r20
    2190:	aa 5f       	subi	r26, 0xFA	; 250
    2192:	bc 4f       	sbci	r27, 0xFC	; 252
    2194:	11 96       	adiw	r26, 0x01	; 1
    2196:	ed 91       	ld	r30, X+
    2198:	fc 91       	ld	r31, X
    219a:	12 97       	sbiw	r26, 0x02	; 2
    219c:	02 80       	ldd	r0, Z+2	; 0x02
    219e:	f3 81       	ldd	r31, Z+3	; 0x03
    21a0:	e0 2d       	mov	r30, r0
    21a2:	12 96       	adiw	r26, 0x02	; 2
    21a4:	fc 93       	st	X, r31
    21a6:	ee 93       	st	-X, r30
    21a8:	11 97       	sbiw	r26, 0x01	; 1
    21aa:	47 5f       	subi	r20, 0xF7	; 247
    21ac:	5c 4f       	sbci	r21, 0xFC	; 252
    21ae:	e4 17       	cp	r30, r20
    21b0:	f5 07       	cpc	r31, r21
    21b2:	29 f4       	brne	.+10     	; 0x21be <vTaskSwitchContext+0xd2>
    21b4:	42 81       	ldd	r20, Z+2	; 0x02
    21b6:	53 81       	ldd	r21, Z+3	; 0x03
    21b8:	fd 01       	movw	r30, r26
    21ba:	52 83       	std	Z+2, r21	; 0x02
    21bc:	41 83       	std	Z+1, r20	; 0x01
    21be:	fc 01       	movw	r30, r24
    21c0:	ee 0f       	add	r30, r30
    21c2:	ff 1f       	adc	r31, r31
    21c4:	ee 0f       	add	r30, r30
    21c6:	ff 1f       	adc	r31, r31
    21c8:	ee 0f       	add	r30, r30
    21ca:	ff 1f       	adc	r31, r31
    21cc:	8e 0f       	add	r24, r30
    21ce:	9f 1f       	adc	r25, r31
    21d0:	fc 01       	movw	r30, r24
    21d2:	ea 5f       	subi	r30, 0xFA	; 250
    21d4:	fc 4f       	sbci	r31, 0xFC	; 252
    21d6:	01 80       	ldd	r0, Z+1	; 0x01
    21d8:	f2 81       	ldd	r31, Z+2	; 0x02
    21da:	e0 2d       	mov	r30, r0
    21dc:	86 81       	ldd	r24, Z+6	; 0x06
    21de:	97 81       	ldd	r25, Z+7	; 0x07
    21e0:	90 93 2b 03 	sts	0x032B, r25	; 0x80032b <pxCurrentTCB+0x1>
    21e4:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <pxCurrentTCB>
    21e8:	20 93 d0 02 	sts	0x02D0, r18	; 0x8002d0 <uxTopReadyPriority>
    21ec:	08 95       	ret

000021ee <vTaskPlaceOnEventList>:
    21ee:	cf 93       	push	r28
    21f0:	df 93       	push	r29
    21f2:	eb 01       	movw	r28, r22
    21f4:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <pxCurrentTCB>
    21f8:	70 91 2b 03 	lds	r23, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    21fc:	64 5f       	subi	r22, 0xF4	; 244
    21fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2200:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    2204:	61 e0       	ldi	r22, 0x01	; 1
    2206:	ce 01       	movw	r24, r28
    2208:	a1 dc       	rcall	.-1726   	; 0x1b4c <prvAddCurrentTaskToDelayedList>
    220a:	df 91       	pop	r29
    220c:	cf 91       	pop	r28
    220e:	08 95       	ret

00002210 <xTaskRemoveFromEventList>:
    2210:	0f 93       	push	r16
    2212:	1f 93       	push	r17
    2214:	cf 93       	push	r28
    2216:	df 93       	push	r29
    2218:	dc 01       	movw	r26, r24
    221a:	15 96       	adiw	r26, 0x05	; 5
    221c:	ed 91       	ld	r30, X+
    221e:	fc 91       	ld	r31, X
    2220:	16 97       	sbiw	r26, 0x06	; 6
    2222:	c6 81       	ldd	r28, Z+6	; 0x06
    2224:	d7 81       	ldd	r29, Z+7	; 0x07
    2226:	8e 01       	movw	r16, r28
    2228:	04 5f       	subi	r16, 0xF4	; 244
    222a:	1f 4f       	sbci	r17, 0xFF	; 255
    222c:	c8 01       	movw	r24, r16
    222e:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2232:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <uxSchedulerSuspended>
    2236:	81 11       	cpse	r24, r1
    2238:	1c c0       	rjmp	.+56     	; 0x2272 <xTaskRemoveFromEventList+0x62>
    223a:	0a 50       	subi	r16, 0x0A	; 10
    223c:	11 09       	sbc	r17, r1
    223e:	c8 01       	movw	r24, r16
    2240:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2244:	8e 89       	ldd	r24, Y+22	; 0x16
    2246:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    224a:	98 17       	cp	r25, r24
    224c:	10 f4       	brcc	.+4      	; 0x2252 <xTaskRemoveFromEventList+0x42>
    224e:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxTopReadyPriority>
    2252:	90 e0       	ldi	r25, 0x00	; 0
    2254:	9c 01       	movw	r18, r24
    2256:	22 0f       	add	r18, r18
    2258:	33 1f       	adc	r19, r19
    225a:	22 0f       	add	r18, r18
    225c:	33 1f       	adc	r19, r19
    225e:	22 0f       	add	r18, r18
    2260:	33 1f       	adc	r19, r19
    2262:	82 0f       	add	r24, r18
    2264:	93 1f       	adc	r25, r19
    2266:	b8 01       	movw	r22, r16
    2268:	8a 5f       	subi	r24, 0xFA	; 250
    226a:	9c 4f       	sbci	r25, 0xFC	; 252
    226c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2270:	05 c0       	rjmp	.+10     	; 0x227c <xTaskRemoveFromEventList+0x6c>
    2272:	b8 01       	movw	r22, r16
    2274:	87 ee       	ldi	r24, 0xE7	; 231
    2276:	92 e0       	ldi	r25, 0x02	; 2
    2278:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    227c:	e0 91 2a 03 	lds	r30, 0x032A	; 0x80032a <pxCurrentTCB>
    2280:	f0 91 2b 03 	lds	r31, 0x032B	; 0x80032b <pxCurrentTCB+0x1>
    2284:	9e 89       	ldd	r25, Y+22	; 0x16
    2286:	86 89       	ldd	r24, Z+22	; 0x16
    2288:	89 17       	cp	r24, r25
    228a:	20 f4       	brcc	.+8      	; 0x2294 <xTaskRemoveFromEventList+0x84>
    228c:	81 e0       	ldi	r24, 0x01	; 1
    228e:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <xYieldPending>
    2292:	01 c0       	rjmp	.+2      	; 0x2296 <xTaskRemoveFromEventList+0x86>
    2294:	80 e0       	ldi	r24, 0x00	; 0
    2296:	df 91       	pop	r29
    2298:	cf 91       	pop	r28
    229a:	1f 91       	pop	r17
    229c:	0f 91       	pop	r16
    229e:	08 95       	ret

000022a0 <vTaskSetTimeOutState>:
    22a0:	20 91 cc 02 	lds	r18, 0x02CC	; 0x8002cc <xNumOfOverflows>
    22a4:	fc 01       	movw	r30, r24
    22a6:	20 83       	st	Z, r18
    22a8:	20 91 d1 02 	lds	r18, 0x02D1	; 0x8002d1 <xTickCount>
    22ac:	30 91 d2 02 	lds	r19, 0x02D2	; 0x8002d2 <xTickCount+0x1>
    22b0:	32 83       	std	Z+2, r19	; 0x02
    22b2:	21 83       	std	Z+1, r18	; 0x01
    22b4:	08 95       	ret

000022b6 <xTaskCheckForTimeOut>:
    22b6:	0f b6       	in	r0, 0x3f	; 63
    22b8:	f8 94       	cli
    22ba:	0f 92       	push	r0
    22bc:	40 91 d1 02 	lds	r20, 0x02D1	; 0x8002d1 <xTickCount>
    22c0:	50 91 d2 02 	lds	r21, 0x02D2	; 0x8002d2 <xTickCount+0x1>
    22c4:	db 01       	movw	r26, r22
    22c6:	2d 91       	ld	r18, X+
    22c8:	3c 91       	ld	r19, X
    22ca:	2f 3f       	cpi	r18, 0xFF	; 255
    22cc:	bf ef       	ldi	r27, 0xFF	; 255
    22ce:	3b 07       	cpc	r19, r27
    22d0:	11 f1       	breq	.+68     	; 0x2316 <xTaskCheckForTimeOut+0x60>
    22d2:	e0 91 cc 02 	lds	r30, 0x02CC	; 0x8002cc <xNumOfOverflows>
    22d6:	dc 01       	movw	r26, r24
    22d8:	fc 91       	ld	r31, X
    22da:	fe 17       	cp	r31, r30
    22dc:	39 f0       	breq	.+14     	; 0x22ec <xTaskCheckForTimeOut+0x36>
    22de:	11 96       	adiw	r26, 0x01	; 1
    22e0:	ed 91       	ld	r30, X+
    22e2:	fc 91       	ld	r31, X
    22e4:	12 97       	sbiw	r26, 0x02	; 2
    22e6:	4e 17       	cp	r20, r30
    22e8:	5f 07       	cpc	r21, r31
    22ea:	b8 f4       	brcc	.+46     	; 0x231a <xTaskCheckForTimeOut+0x64>
    22ec:	dc 01       	movw	r26, r24
    22ee:	11 96       	adiw	r26, 0x01	; 1
    22f0:	ed 91       	ld	r30, X+
    22f2:	fc 91       	ld	r31, X
    22f4:	12 97       	sbiw	r26, 0x02	; 2
    22f6:	da 01       	movw	r26, r20
    22f8:	ae 1b       	sub	r26, r30
    22fa:	bf 0b       	sbc	r27, r31
    22fc:	a2 17       	cp	r26, r18
    22fe:	b3 07       	cpc	r27, r19
    2300:	70 f4       	brcc	.+28     	; 0x231e <xTaskCheckForTimeOut+0x68>
    2302:	db 01       	movw	r26, r22
    2304:	e4 1b       	sub	r30, r20
    2306:	f5 0b       	sbc	r31, r21
    2308:	2e 0f       	add	r18, r30
    230a:	3f 1f       	adc	r19, r31
    230c:	2d 93       	st	X+, r18
    230e:	3c 93       	st	X, r19
    2310:	c7 df       	rcall	.-114    	; 0x22a0 <vTaskSetTimeOutState>
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	05 c0       	rjmp	.+10     	; 0x2320 <xTaskCheckForTimeOut+0x6a>
    2316:	80 e0       	ldi	r24, 0x00	; 0
    2318:	03 c0       	rjmp	.+6      	; 0x2320 <xTaskCheckForTimeOut+0x6a>
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	01 c0       	rjmp	.+2      	; 0x2320 <xTaskCheckForTimeOut+0x6a>
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	0f 90       	pop	r0
    2322:	0f be       	out	0x3f, r0	; 63
    2324:	08 95       	ret

00002326 <vTaskMissedYield>:
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <xYieldPending>
    232c:	08 95       	ret

0000232e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    232e:	0f 93       	push	r16
    2330:	1f 93       	push	r17
    2332:	cf 93       	push	r28
    2334:	df 93       	push	r29
    2336:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2338:	89 2b       	or	r24, r25
    233a:	79 f1       	breq	.+94     	; 0x239a <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    233c:	82 a1       	ldd	r24, Z+34	; 0x22
    233e:	81 50       	subi	r24, 0x01	; 1
    2340:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2342:	26 89       	ldd	r18, Z+22	; 0x16
    2344:	91 a1       	ldd	r25, Z+33	; 0x21
    2346:	29 17       	cp	r18, r25
    2348:	51 f1       	breq	.+84     	; 0x239e <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    234a:	81 11       	cpse	r24, r1
    234c:	2a c0       	rjmp	.+84     	; 0x23a2 <xTaskPriorityDisinherit+0x74>
    234e:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2350:	8f 01       	movw	r16, r30
    2352:	0e 5f       	subi	r16, 0xFE	; 254
    2354:	1f 4f       	sbci	r17, 0xFF	; 255
    2356:	c8 01       	movw	r24, r16
    2358:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    235c:	89 a1       	ldd	r24, Y+33	; 0x21
    235e:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2360:	24 e0       	ldi	r18, 0x04	; 4
    2362:	30 e0       	ldi	r19, 0x00	; 0
    2364:	28 1b       	sub	r18, r24
    2366:	31 09       	sbc	r19, r1
    2368:	3d 87       	std	Y+13, r19	; 0x0d
    236a:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    236c:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <uxTopReadyPriority>
    2370:	98 17       	cp	r25, r24
    2372:	10 f4       	brcc	.+4      	; 0x2378 <xTaskPriorityDisinherit+0x4a>
    2374:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxTopReadyPriority>
    2378:	90 e0       	ldi	r25, 0x00	; 0
    237a:	9c 01       	movw	r18, r24
    237c:	22 0f       	add	r18, r18
    237e:	33 1f       	adc	r19, r19
    2380:	22 0f       	add	r18, r18
    2382:	33 1f       	adc	r19, r19
    2384:	22 0f       	add	r18, r18
    2386:	33 1f       	adc	r19, r19
    2388:	82 0f       	add	r24, r18
    238a:	93 1f       	adc	r25, r19
    238c:	b8 01       	movw	r22, r16
    238e:	8a 5f       	subi	r24, 0xFA	; 250
    2390:	9c 4f       	sbci	r25, 0xFC	; 252
    2392:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	05 c0       	rjmp	.+10     	; 0x23a4 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    239a:	80 e0       	ldi	r24, 0x00	; 0
    239c:	03 c0       	rjmp	.+6      	; 0x23a4 <xTaskPriorityDisinherit+0x76>
    239e:	80 e0       	ldi	r24, 0x00	; 0
    23a0:	01 c0       	rjmp	.+2      	; 0x23a4 <xTaskPriorityDisinherit+0x76>
    23a2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    23a4:	df 91       	pop	r29
    23a6:	cf 91       	pop	r28
    23a8:	1f 91       	pop	r17
    23aa:	0f 91       	pop	r16
    23ac:	08 95       	ret

000023ae <__subsf3>:
    23ae:	50 58       	subi	r21, 0x80	; 128

000023b0 <__addsf3>:
    23b0:	bb 27       	eor	r27, r27
    23b2:	aa 27       	eor	r26, r26
    23b4:	0e d0       	rcall	.+28     	; 0x23d2 <__addsf3x>
    23b6:	e5 c0       	rjmp	.+458    	; 0x2582 <__fp_round>
    23b8:	d6 d0       	rcall	.+428    	; 0x2566 <__fp_pscA>
    23ba:	30 f0       	brcs	.+12     	; 0x23c8 <__addsf3+0x18>
    23bc:	db d0       	rcall	.+438    	; 0x2574 <__fp_pscB>
    23be:	20 f0       	brcs	.+8      	; 0x23c8 <__addsf3+0x18>
    23c0:	31 f4       	brne	.+12     	; 0x23ce <__addsf3+0x1e>
    23c2:	9f 3f       	cpi	r25, 0xFF	; 255
    23c4:	11 f4       	brne	.+4      	; 0x23ca <__addsf3+0x1a>
    23c6:	1e f4       	brtc	.+6      	; 0x23ce <__addsf3+0x1e>
    23c8:	cb c0       	rjmp	.+406    	; 0x2560 <__fp_nan>
    23ca:	0e f4       	brtc	.+2      	; 0x23ce <__addsf3+0x1e>
    23cc:	e0 95       	com	r30
    23ce:	e7 fb       	bst	r30, 7
    23d0:	c1 c0       	rjmp	.+386    	; 0x2554 <__fp_inf>

000023d2 <__addsf3x>:
    23d2:	e9 2f       	mov	r30, r25
    23d4:	e7 d0       	rcall	.+462    	; 0x25a4 <__fp_split3>
    23d6:	80 f3       	brcs	.-32     	; 0x23b8 <__addsf3+0x8>
    23d8:	ba 17       	cp	r27, r26
    23da:	62 07       	cpc	r22, r18
    23dc:	73 07       	cpc	r23, r19
    23de:	84 07       	cpc	r24, r20
    23e0:	95 07       	cpc	r25, r21
    23e2:	18 f0       	brcs	.+6      	; 0x23ea <__addsf3x+0x18>
    23e4:	71 f4       	brne	.+28     	; 0x2402 <__addsf3x+0x30>
    23e6:	9e f5       	brtc	.+102    	; 0x244e <__addsf3x+0x7c>
    23e8:	ff c0       	rjmp	.+510    	; 0x25e8 <__fp_zero>
    23ea:	0e f4       	brtc	.+2      	; 0x23ee <__addsf3x+0x1c>
    23ec:	e0 95       	com	r30
    23ee:	0b 2e       	mov	r0, r27
    23f0:	ba 2f       	mov	r27, r26
    23f2:	a0 2d       	mov	r26, r0
    23f4:	0b 01       	movw	r0, r22
    23f6:	b9 01       	movw	r22, r18
    23f8:	90 01       	movw	r18, r0
    23fa:	0c 01       	movw	r0, r24
    23fc:	ca 01       	movw	r24, r20
    23fe:	a0 01       	movw	r20, r0
    2400:	11 24       	eor	r1, r1
    2402:	ff 27       	eor	r31, r31
    2404:	59 1b       	sub	r21, r25
    2406:	99 f0       	breq	.+38     	; 0x242e <__addsf3x+0x5c>
    2408:	59 3f       	cpi	r21, 0xF9	; 249
    240a:	50 f4       	brcc	.+20     	; 0x2420 <__addsf3x+0x4e>
    240c:	50 3e       	cpi	r21, 0xE0	; 224
    240e:	68 f1       	brcs	.+90     	; 0x246a <__addsf3x+0x98>
    2410:	1a 16       	cp	r1, r26
    2412:	f0 40       	sbci	r31, 0x00	; 0
    2414:	a2 2f       	mov	r26, r18
    2416:	23 2f       	mov	r18, r19
    2418:	34 2f       	mov	r19, r20
    241a:	44 27       	eor	r20, r20
    241c:	58 5f       	subi	r21, 0xF8	; 248
    241e:	f3 cf       	rjmp	.-26     	; 0x2406 <__addsf3x+0x34>
    2420:	46 95       	lsr	r20
    2422:	37 95       	ror	r19
    2424:	27 95       	ror	r18
    2426:	a7 95       	ror	r26
    2428:	f0 40       	sbci	r31, 0x00	; 0
    242a:	53 95       	inc	r21
    242c:	c9 f7       	brne	.-14     	; 0x2420 <__addsf3x+0x4e>
    242e:	7e f4       	brtc	.+30     	; 0x244e <__addsf3x+0x7c>
    2430:	1f 16       	cp	r1, r31
    2432:	ba 0b       	sbc	r27, r26
    2434:	62 0b       	sbc	r22, r18
    2436:	73 0b       	sbc	r23, r19
    2438:	84 0b       	sbc	r24, r20
    243a:	ba f0       	brmi	.+46     	; 0x246a <__addsf3x+0x98>
    243c:	91 50       	subi	r25, 0x01	; 1
    243e:	a1 f0       	breq	.+40     	; 0x2468 <__addsf3x+0x96>
    2440:	ff 0f       	add	r31, r31
    2442:	bb 1f       	adc	r27, r27
    2444:	66 1f       	adc	r22, r22
    2446:	77 1f       	adc	r23, r23
    2448:	88 1f       	adc	r24, r24
    244a:	c2 f7       	brpl	.-16     	; 0x243c <__addsf3x+0x6a>
    244c:	0e c0       	rjmp	.+28     	; 0x246a <__addsf3x+0x98>
    244e:	ba 0f       	add	r27, r26
    2450:	62 1f       	adc	r22, r18
    2452:	73 1f       	adc	r23, r19
    2454:	84 1f       	adc	r24, r20
    2456:	48 f4       	brcc	.+18     	; 0x246a <__addsf3x+0x98>
    2458:	87 95       	ror	r24
    245a:	77 95       	ror	r23
    245c:	67 95       	ror	r22
    245e:	b7 95       	ror	r27
    2460:	f7 95       	ror	r31
    2462:	9e 3f       	cpi	r25, 0xFE	; 254
    2464:	08 f0       	brcs	.+2      	; 0x2468 <__addsf3x+0x96>
    2466:	b3 cf       	rjmp	.-154    	; 0x23ce <__addsf3+0x1e>
    2468:	93 95       	inc	r25
    246a:	88 0f       	add	r24, r24
    246c:	08 f0       	brcs	.+2      	; 0x2470 <__addsf3x+0x9e>
    246e:	99 27       	eor	r25, r25
    2470:	ee 0f       	add	r30, r30
    2472:	97 95       	ror	r25
    2474:	87 95       	ror	r24
    2476:	08 95       	ret

00002478 <__fixsfsi>:
    2478:	04 d0       	rcall	.+8      	; 0x2482 <__fixunssfsi>
    247a:	68 94       	set
    247c:	b1 11       	cpse	r27, r1
    247e:	b5 c0       	rjmp	.+362    	; 0x25ea <__fp_szero>
    2480:	08 95       	ret

00002482 <__fixunssfsi>:
    2482:	98 d0       	rcall	.+304    	; 0x25b4 <__fp_splitA>
    2484:	88 f0       	brcs	.+34     	; 0x24a8 <__fixunssfsi+0x26>
    2486:	9f 57       	subi	r25, 0x7F	; 127
    2488:	90 f0       	brcs	.+36     	; 0x24ae <__fixunssfsi+0x2c>
    248a:	b9 2f       	mov	r27, r25
    248c:	99 27       	eor	r25, r25
    248e:	b7 51       	subi	r27, 0x17	; 23
    2490:	a0 f0       	brcs	.+40     	; 0x24ba <__fixunssfsi+0x38>
    2492:	d1 f0       	breq	.+52     	; 0x24c8 <__fixunssfsi+0x46>
    2494:	66 0f       	add	r22, r22
    2496:	77 1f       	adc	r23, r23
    2498:	88 1f       	adc	r24, r24
    249a:	99 1f       	adc	r25, r25
    249c:	1a f0       	brmi	.+6      	; 0x24a4 <__fixunssfsi+0x22>
    249e:	ba 95       	dec	r27
    24a0:	c9 f7       	brne	.-14     	; 0x2494 <__fixunssfsi+0x12>
    24a2:	12 c0       	rjmp	.+36     	; 0x24c8 <__fixunssfsi+0x46>
    24a4:	b1 30       	cpi	r27, 0x01	; 1
    24a6:	81 f0       	breq	.+32     	; 0x24c8 <__fixunssfsi+0x46>
    24a8:	9f d0       	rcall	.+318    	; 0x25e8 <__fp_zero>
    24aa:	b1 e0       	ldi	r27, 0x01	; 1
    24ac:	08 95       	ret
    24ae:	9c c0       	rjmp	.+312    	; 0x25e8 <__fp_zero>
    24b0:	67 2f       	mov	r22, r23
    24b2:	78 2f       	mov	r23, r24
    24b4:	88 27       	eor	r24, r24
    24b6:	b8 5f       	subi	r27, 0xF8	; 248
    24b8:	39 f0       	breq	.+14     	; 0x24c8 <__fixunssfsi+0x46>
    24ba:	b9 3f       	cpi	r27, 0xF9	; 249
    24bc:	cc f3       	brlt	.-14     	; 0x24b0 <__fixunssfsi+0x2e>
    24be:	86 95       	lsr	r24
    24c0:	77 95       	ror	r23
    24c2:	67 95       	ror	r22
    24c4:	b3 95       	inc	r27
    24c6:	d9 f7       	brne	.-10     	; 0x24be <__fixunssfsi+0x3c>
    24c8:	3e f4       	brtc	.+14     	; 0x24d8 <__fixunssfsi+0x56>
    24ca:	90 95       	com	r25
    24cc:	80 95       	com	r24
    24ce:	70 95       	com	r23
    24d0:	61 95       	neg	r22
    24d2:	7f 4f       	sbci	r23, 0xFF	; 255
    24d4:	8f 4f       	sbci	r24, 0xFF	; 255
    24d6:	9f 4f       	sbci	r25, 0xFF	; 255
    24d8:	08 95       	ret

000024da <__floatunsisf>:
    24da:	e8 94       	clt
    24dc:	09 c0       	rjmp	.+18     	; 0x24f0 <__floatsisf+0x12>

000024de <__floatsisf>:
    24de:	97 fb       	bst	r25, 7
    24e0:	3e f4       	brtc	.+14     	; 0x24f0 <__floatsisf+0x12>
    24e2:	90 95       	com	r25
    24e4:	80 95       	com	r24
    24e6:	70 95       	com	r23
    24e8:	61 95       	neg	r22
    24ea:	7f 4f       	sbci	r23, 0xFF	; 255
    24ec:	8f 4f       	sbci	r24, 0xFF	; 255
    24ee:	9f 4f       	sbci	r25, 0xFF	; 255
    24f0:	99 23       	and	r25, r25
    24f2:	a9 f0       	breq	.+42     	; 0x251e <__floatsisf+0x40>
    24f4:	f9 2f       	mov	r31, r25
    24f6:	96 e9       	ldi	r25, 0x96	; 150
    24f8:	bb 27       	eor	r27, r27
    24fa:	93 95       	inc	r25
    24fc:	f6 95       	lsr	r31
    24fe:	87 95       	ror	r24
    2500:	77 95       	ror	r23
    2502:	67 95       	ror	r22
    2504:	b7 95       	ror	r27
    2506:	f1 11       	cpse	r31, r1
    2508:	f8 cf       	rjmp	.-16     	; 0x24fa <__floatsisf+0x1c>
    250a:	fa f4       	brpl	.+62     	; 0x254a <__floatsisf+0x6c>
    250c:	bb 0f       	add	r27, r27
    250e:	11 f4       	brne	.+4      	; 0x2514 <__floatsisf+0x36>
    2510:	60 ff       	sbrs	r22, 0
    2512:	1b c0       	rjmp	.+54     	; 0x254a <__floatsisf+0x6c>
    2514:	6f 5f       	subi	r22, 0xFF	; 255
    2516:	7f 4f       	sbci	r23, 0xFF	; 255
    2518:	8f 4f       	sbci	r24, 0xFF	; 255
    251a:	9f 4f       	sbci	r25, 0xFF	; 255
    251c:	16 c0       	rjmp	.+44     	; 0x254a <__floatsisf+0x6c>
    251e:	88 23       	and	r24, r24
    2520:	11 f0       	breq	.+4      	; 0x2526 <__floatsisf+0x48>
    2522:	96 e9       	ldi	r25, 0x96	; 150
    2524:	11 c0       	rjmp	.+34     	; 0x2548 <__floatsisf+0x6a>
    2526:	77 23       	and	r23, r23
    2528:	21 f0       	breq	.+8      	; 0x2532 <__floatsisf+0x54>
    252a:	9e e8       	ldi	r25, 0x8E	; 142
    252c:	87 2f       	mov	r24, r23
    252e:	76 2f       	mov	r23, r22
    2530:	05 c0       	rjmp	.+10     	; 0x253c <__floatsisf+0x5e>
    2532:	66 23       	and	r22, r22
    2534:	71 f0       	breq	.+28     	; 0x2552 <__floatsisf+0x74>
    2536:	96 e8       	ldi	r25, 0x86	; 134
    2538:	86 2f       	mov	r24, r22
    253a:	70 e0       	ldi	r23, 0x00	; 0
    253c:	60 e0       	ldi	r22, 0x00	; 0
    253e:	2a f0       	brmi	.+10     	; 0x254a <__floatsisf+0x6c>
    2540:	9a 95       	dec	r25
    2542:	66 0f       	add	r22, r22
    2544:	77 1f       	adc	r23, r23
    2546:	88 1f       	adc	r24, r24
    2548:	da f7       	brpl	.-10     	; 0x2540 <__floatsisf+0x62>
    254a:	88 0f       	add	r24, r24
    254c:	96 95       	lsr	r25
    254e:	87 95       	ror	r24
    2550:	97 f9       	bld	r25, 7
    2552:	08 95       	ret

00002554 <__fp_inf>:
    2554:	97 f9       	bld	r25, 7
    2556:	9f 67       	ori	r25, 0x7F	; 127
    2558:	80 e8       	ldi	r24, 0x80	; 128
    255a:	70 e0       	ldi	r23, 0x00	; 0
    255c:	60 e0       	ldi	r22, 0x00	; 0
    255e:	08 95       	ret

00002560 <__fp_nan>:
    2560:	9f ef       	ldi	r25, 0xFF	; 255
    2562:	80 ec       	ldi	r24, 0xC0	; 192
    2564:	08 95       	ret

00002566 <__fp_pscA>:
    2566:	00 24       	eor	r0, r0
    2568:	0a 94       	dec	r0
    256a:	16 16       	cp	r1, r22
    256c:	17 06       	cpc	r1, r23
    256e:	18 06       	cpc	r1, r24
    2570:	09 06       	cpc	r0, r25
    2572:	08 95       	ret

00002574 <__fp_pscB>:
    2574:	00 24       	eor	r0, r0
    2576:	0a 94       	dec	r0
    2578:	12 16       	cp	r1, r18
    257a:	13 06       	cpc	r1, r19
    257c:	14 06       	cpc	r1, r20
    257e:	05 06       	cpc	r0, r21
    2580:	08 95       	ret

00002582 <__fp_round>:
    2582:	09 2e       	mov	r0, r25
    2584:	03 94       	inc	r0
    2586:	00 0c       	add	r0, r0
    2588:	11 f4       	brne	.+4      	; 0x258e <__fp_round+0xc>
    258a:	88 23       	and	r24, r24
    258c:	52 f0       	brmi	.+20     	; 0x25a2 <__fp_round+0x20>
    258e:	bb 0f       	add	r27, r27
    2590:	40 f4       	brcc	.+16     	; 0x25a2 <__fp_round+0x20>
    2592:	bf 2b       	or	r27, r31
    2594:	11 f4       	brne	.+4      	; 0x259a <__fp_round+0x18>
    2596:	60 ff       	sbrs	r22, 0
    2598:	04 c0       	rjmp	.+8      	; 0x25a2 <__fp_round+0x20>
    259a:	6f 5f       	subi	r22, 0xFF	; 255
    259c:	7f 4f       	sbci	r23, 0xFF	; 255
    259e:	8f 4f       	sbci	r24, 0xFF	; 255
    25a0:	9f 4f       	sbci	r25, 0xFF	; 255
    25a2:	08 95       	ret

000025a4 <__fp_split3>:
    25a4:	57 fd       	sbrc	r21, 7
    25a6:	90 58       	subi	r25, 0x80	; 128
    25a8:	44 0f       	add	r20, r20
    25aa:	55 1f       	adc	r21, r21
    25ac:	59 f0       	breq	.+22     	; 0x25c4 <__fp_splitA+0x10>
    25ae:	5f 3f       	cpi	r21, 0xFF	; 255
    25b0:	71 f0       	breq	.+28     	; 0x25ce <__fp_splitA+0x1a>
    25b2:	47 95       	ror	r20

000025b4 <__fp_splitA>:
    25b4:	88 0f       	add	r24, r24
    25b6:	97 fb       	bst	r25, 7
    25b8:	99 1f       	adc	r25, r25
    25ba:	61 f0       	breq	.+24     	; 0x25d4 <__fp_splitA+0x20>
    25bc:	9f 3f       	cpi	r25, 0xFF	; 255
    25be:	79 f0       	breq	.+30     	; 0x25de <__fp_splitA+0x2a>
    25c0:	87 95       	ror	r24
    25c2:	08 95       	ret
    25c4:	12 16       	cp	r1, r18
    25c6:	13 06       	cpc	r1, r19
    25c8:	14 06       	cpc	r1, r20
    25ca:	55 1f       	adc	r21, r21
    25cc:	f2 cf       	rjmp	.-28     	; 0x25b2 <__fp_split3+0xe>
    25ce:	46 95       	lsr	r20
    25d0:	f1 df       	rcall	.-30     	; 0x25b4 <__fp_splitA>
    25d2:	08 c0       	rjmp	.+16     	; 0x25e4 <__fp_splitA+0x30>
    25d4:	16 16       	cp	r1, r22
    25d6:	17 06       	cpc	r1, r23
    25d8:	18 06       	cpc	r1, r24
    25da:	99 1f       	adc	r25, r25
    25dc:	f1 cf       	rjmp	.-30     	; 0x25c0 <__fp_splitA+0xc>
    25de:	86 95       	lsr	r24
    25e0:	71 05       	cpc	r23, r1
    25e2:	61 05       	cpc	r22, r1
    25e4:	08 94       	sec
    25e6:	08 95       	ret

000025e8 <__fp_zero>:
    25e8:	e8 94       	clt

000025ea <__fp_szero>:
    25ea:	bb 27       	eor	r27, r27
    25ec:	66 27       	eor	r22, r22
    25ee:	77 27       	eor	r23, r23
    25f0:	cb 01       	movw	r24, r22
    25f2:	97 f9       	bld	r25, 7
    25f4:	08 95       	ret

000025f6 <__mulsf3>:
    25f6:	0b d0       	rcall	.+22     	; 0x260e <__mulsf3x>
    25f8:	c4 cf       	rjmp	.-120    	; 0x2582 <__fp_round>
    25fa:	b5 df       	rcall	.-150    	; 0x2566 <__fp_pscA>
    25fc:	28 f0       	brcs	.+10     	; 0x2608 <__mulsf3+0x12>
    25fe:	ba df       	rcall	.-140    	; 0x2574 <__fp_pscB>
    2600:	18 f0       	brcs	.+6      	; 0x2608 <__mulsf3+0x12>
    2602:	95 23       	and	r25, r21
    2604:	09 f0       	breq	.+2      	; 0x2608 <__mulsf3+0x12>
    2606:	a6 cf       	rjmp	.-180    	; 0x2554 <__fp_inf>
    2608:	ab cf       	rjmp	.-170    	; 0x2560 <__fp_nan>
    260a:	11 24       	eor	r1, r1
    260c:	ee cf       	rjmp	.-36     	; 0x25ea <__fp_szero>

0000260e <__mulsf3x>:
    260e:	ca df       	rcall	.-108    	; 0x25a4 <__fp_split3>
    2610:	a0 f3       	brcs	.-24     	; 0x25fa <__mulsf3+0x4>

00002612 <__mulsf3_pse>:
    2612:	95 9f       	mul	r25, r21
    2614:	d1 f3       	breq	.-12     	; 0x260a <__mulsf3+0x14>
    2616:	95 0f       	add	r25, r21
    2618:	50 e0       	ldi	r21, 0x00	; 0
    261a:	55 1f       	adc	r21, r21
    261c:	62 9f       	mul	r22, r18
    261e:	f0 01       	movw	r30, r0
    2620:	72 9f       	mul	r23, r18
    2622:	bb 27       	eor	r27, r27
    2624:	f0 0d       	add	r31, r0
    2626:	b1 1d       	adc	r27, r1
    2628:	63 9f       	mul	r22, r19
    262a:	aa 27       	eor	r26, r26
    262c:	f0 0d       	add	r31, r0
    262e:	b1 1d       	adc	r27, r1
    2630:	aa 1f       	adc	r26, r26
    2632:	64 9f       	mul	r22, r20
    2634:	66 27       	eor	r22, r22
    2636:	b0 0d       	add	r27, r0
    2638:	a1 1d       	adc	r26, r1
    263a:	66 1f       	adc	r22, r22
    263c:	82 9f       	mul	r24, r18
    263e:	22 27       	eor	r18, r18
    2640:	b0 0d       	add	r27, r0
    2642:	a1 1d       	adc	r26, r1
    2644:	62 1f       	adc	r22, r18
    2646:	73 9f       	mul	r23, r19
    2648:	b0 0d       	add	r27, r0
    264a:	a1 1d       	adc	r26, r1
    264c:	62 1f       	adc	r22, r18
    264e:	83 9f       	mul	r24, r19
    2650:	a0 0d       	add	r26, r0
    2652:	61 1d       	adc	r22, r1
    2654:	22 1f       	adc	r18, r18
    2656:	74 9f       	mul	r23, r20
    2658:	33 27       	eor	r19, r19
    265a:	a0 0d       	add	r26, r0
    265c:	61 1d       	adc	r22, r1
    265e:	23 1f       	adc	r18, r19
    2660:	84 9f       	mul	r24, r20
    2662:	60 0d       	add	r22, r0
    2664:	21 1d       	adc	r18, r1
    2666:	82 2f       	mov	r24, r18
    2668:	76 2f       	mov	r23, r22
    266a:	6a 2f       	mov	r22, r26
    266c:	11 24       	eor	r1, r1
    266e:	9f 57       	subi	r25, 0x7F	; 127
    2670:	50 40       	sbci	r21, 0x00	; 0
    2672:	8a f0       	brmi	.+34     	; 0x2696 <__mulsf3_pse+0x84>
    2674:	e1 f0       	breq	.+56     	; 0x26ae <__mulsf3_pse+0x9c>
    2676:	88 23       	and	r24, r24
    2678:	4a f0       	brmi	.+18     	; 0x268c <__mulsf3_pse+0x7a>
    267a:	ee 0f       	add	r30, r30
    267c:	ff 1f       	adc	r31, r31
    267e:	bb 1f       	adc	r27, r27
    2680:	66 1f       	adc	r22, r22
    2682:	77 1f       	adc	r23, r23
    2684:	88 1f       	adc	r24, r24
    2686:	91 50       	subi	r25, 0x01	; 1
    2688:	50 40       	sbci	r21, 0x00	; 0
    268a:	a9 f7       	brne	.-22     	; 0x2676 <__mulsf3_pse+0x64>
    268c:	9e 3f       	cpi	r25, 0xFE	; 254
    268e:	51 05       	cpc	r21, r1
    2690:	70 f0       	brcs	.+28     	; 0x26ae <__mulsf3_pse+0x9c>
    2692:	60 cf       	rjmp	.-320    	; 0x2554 <__fp_inf>
    2694:	aa cf       	rjmp	.-172    	; 0x25ea <__fp_szero>
    2696:	5f 3f       	cpi	r21, 0xFF	; 255
    2698:	ec f3       	brlt	.-6      	; 0x2694 <__mulsf3_pse+0x82>
    269a:	98 3e       	cpi	r25, 0xE8	; 232
    269c:	dc f3       	brlt	.-10     	; 0x2694 <__mulsf3_pse+0x82>
    269e:	86 95       	lsr	r24
    26a0:	77 95       	ror	r23
    26a2:	67 95       	ror	r22
    26a4:	b7 95       	ror	r27
    26a6:	f7 95       	ror	r31
    26a8:	e7 95       	ror	r30
    26aa:	9f 5f       	subi	r25, 0xFF	; 255
    26ac:	c1 f7       	brne	.-16     	; 0x269e <__mulsf3_pse+0x8c>
    26ae:	fe 2b       	or	r31, r30
    26b0:	88 0f       	add	r24, r24
    26b2:	91 1d       	adc	r25, r1
    26b4:	96 95       	lsr	r25
    26b6:	87 95       	ror	r24
    26b8:	97 f9       	bld	r25, 7
    26ba:	08 95       	ret

000026bc <__udivmodsi4>:
    26bc:	a1 e2       	ldi	r26, 0x21	; 33
    26be:	1a 2e       	mov	r1, r26
    26c0:	aa 1b       	sub	r26, r26
    26c2:	bb 1b       	sub	r27, r27
    26c4:	fd 01       	movw	r30, r26
    26c6:	0d c0       	rjmp	.+26     	; 0x26e2 <__udivmodsi4_ep>

000026c8 <__udivmodsi4_loop>:
    26c8:	aa 1f       	adc	r26, r26
    26ca:	bb 1f       	adc	r27, r27
    26cc:	ee 1f       	adc	r30, r30
    26ce:	ff 1f       	adc	r31, r31
    26d0:	a2 17       	cp	r26, r18
    26d2:	b3 07       	cpc	r27, r19
    26d4:	e4 07       	cpc	r30, r20
    26d6:	f5 07       	cpc	r31, r21
    26d8:	20 f0       	brcs	.+8      	; 0x26e2 <__udivmodsi4_ep>
    26da:	a2 1b       	sub	r26, r18
    26dc:	b3 0b       	sbc	r27, r19
    26de:	e4 0b       	sbc	r30, r20
    26e0:	f5 0b       	sbc	r31, r21

000026e2 <__udivmodsi4_ep>:
    26e2:	66 1f       	adc	r22, r22
    26e4:	77 1f       	adc	r23, r23
    26e6:	88 1f       	adc	r24, r24
    26e8:	99 1f       	adc	r25, r25
    26ea:	1a 94       	dec	r1
    26ec:	69 f7       	brne	.-38     	; 0x26c8 <__udivmodsi4_loop>
    26ee:	60 95       	com	r22
    26f0:	70 95       	com	r23
    26f2:	80 95       	com	r24
    26f4:	90 95       	com	r25
    26f6:	9b 01       	movw	r18, r22
    26f8:	ac 01       	movw	r20, r24
    26fa:	bd 01       	movw	r22, r26
    26fc:	cf 01       	movw	r24, r30
    26fe:	08 95       	ret

00002700 <__tablejump2__>:
    2700:	ee 0f       	add	r30, r30
    2702:	ff 1f       	adc	r31, r31
    2704:	88 1f       	adc	r24, r24
    2706:	8b bf       	out	0x3b, r24	; 59
    2708:	07 90       	elpm	r0, Z+
    270a:	f6 91       	elpm	r31, Z
    270c:	e0 2d       	mov	r30, r0
    270e:	19 94       	eijmp

00002710 <__umulhisi3>:
    2710:	a2 9f       	mul	r26, r18
    2712:	b0 01       	movw	r22, r0
    2714:	b3 9f       	mul	r27, r19
    2716:	c0 01       	movw	r24, r0
    2718:	a3 9f       	mul	r26, r19
    271a:	70 0d       	add	r23, r0
    271c:	81 1d       	adc	r24, r1
    271e:	11 24       	eor	r1, r1
    2720:	91 1d       	adc	r25, r1
    2722:	b2 9f       	mul	r27, r18
    2724:	70 0d       	add	r23, r0
    2726:	81 1d       	adc	r24, r1
    2728:	11 24       	eor	r1, r1
    272a:	91 1d       	adc	r25, r1
    272c:	08 95       	ret

0000272e <__muluhisi3>:
    272e:	f0 df       	rcall	.-32     	; 0x2710 <__umulhisi3>
    2730:	a5 9f       	mul	r26, r21
    2732:	90 0d       	add	r25, r0
    2734:	b4 9f       	mul	r27, r20
    2736:	90 0d       	add	r25, r0
    2738:	a4 9f       	mul	r26, r20
    273a:	80 0d       	add	r24, r0
    273c:	91 1d       	adc	r25, r1
    273e:	11 24       	eor	r1, r1
    2740:	08 95       	ret

00002742 <malloc>:
    2742:	0f 93       	push	r16
    2744:	1f 93       	push	r17
    2746:	cf 93       	push	r28
    2748:	df 93       	push	r29
    274a:	82 30       	cpi	r24, 0x02	; 2
    274c:	91 05       	cpc	r25, r1
    274e:	10 f4       	brcc	.+4      	; 0x2754 <malloc+0x12>
    2750:	82 e0       	ldi	r24, 0x02	; 2
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	e0 91 fd 04 	lds	r30, 0x04FD	; 0x8004fd <__flp>
    2758:	f0 91 fe 04 	lds	r31, 0x04FE	; 0x8004fe <__flp+0x1>
    275c:	20 e0       	ldi	r18, 0x00	; 0
    275e:	30 e0       	ldi	r19, 0x00	; 0
    2760:	a0 e0       	ldi	r26, 0x00	; 0
    2762:	b0 e0       	ldi	r27, 0x00	; 0
    2764:	30 97       	sbiw	r30, 0x00	; 0
    2766:	19 f1       	breq	.+70     	; 0x27ae <malloc+0x6c>
    2768:	40 81       	ld	r20, Z
    276a:	51 81       	ldd	r21, Z+1	; 0x01
    276c:	02 81       	ldd	r16, Z+2	; 0x02
    276e:	13 81       	ldd	r17, Z+3	; 0x03
    2770:	48 17       	cp	r20, r24
    2772:	59 07       	cpc	r21, r25
    2774:	c8 f0       	brcs	.+50     	; 0x27a8 <malloc+0x66>
    2776:	84 17       	cp	r24, r20
    2778:	95 07       	cpc	r25, r21
    277a:	69 f4       	brne	.+26     	; 0x2796 <malloc+0x54>
    277c:	10 97       	sbiw	r26, 0x00	; 0
    277e:	31 f0       	breq	.+12     	; 0x278c <malloc+0x4a>
    2780:	12 96       	adiw	r26, 0x02	; 2
    2782:	0c 93       	st	X, r16
    2784:	12 97       	sbiw	r26, 0x02	; 2
    2786:	13 96       	adiw	r26, 0x03	; 3
    2788:	1c 93       	st	X, r17
    278a:	27 c0       	rjmp	.+78     	; 0x27da <malloc+0x98>
    278c:	00 93 fd 04 	sts	0x04FD, r16	; 0x8004fd <__flp>
    2790:	10 93 fe 04 	sts	0x04FE, r17	; 0x8004fe <__flp+0x1>
    2794:	22 c0       	rjmp	.+68     	; 0x27da <malloc+0x98>
    2796:	21 15       	cp	r18, r1
    2798:	31 05       	cpc	r19, r1
    279a:	19 f0       	breq	.+6      	; 0x27a2 <malloc+0x60>
    279c:	42 17       	cp	r20, r18
    279e:	53 07       	cpc	r21, r19
    27a0:	18 f4       	brcc	.+6      	; 0x27a8 <malloc+0x66>
    27a2:	9a 01       	movw	r18, r20
    27a4:	bd 01       	movw	r22, r26
    27a6:	ef 01       	movw	r28, r30
    27a8:	df 01       	movw	r26, r30
    27aa:	f8 01       	movw	r30, r16
    27ac:	db cf       	rjmp	.-74     	; 0x2764 <malloc+0x22>
    27ae:	21 15       	cp	r18, r1
    27b0:	31 05       	cpc	r19, r1
    27b2:	f9 f0       	breq	.+62     	; 0x27f2 <malloc+0xb0>
    27b4:	28 1b       	sub	r18, r24
    27b6:	39 0b       	sbc	r19, r25
    27b8:	24 30       	cpi	r18, 0x04	; 4
    27ba:	31 05       	cpc	r19, r1
    27bc:	80 f4       	brcc	.+32     	; 0x27de <malloc+0x9c>
    27be:	8a 81       	ldd	r24, Y+2	; 0x02
    27c0:	9b 81       	ldd	r25, Y+3	; 0x03
    27c2:	61 15       	cp	r22, r1
    27c4:	71 05       	cpc	r23, r1
    27c6:	21 f0       	breq	.+8      	; 0x27d0 <malloc+0x8e>
    27c8:	fb 01       	movw	r30, r22
    27ca:	93 83       	std	Z+3, r25	; 0x03
    27cc:	82 83       	std	Z+2, r24	; 0x02
    27ce:	04 c0       	rjmp	.+8      	; 0x27d8 <malloc+0x96>
    27d0:	90 93 fe 04 	sts	0x04FE, r25	; 0x8004fe <__flp+0x1>
    27d4:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <__flp>
    27d8:	fe 01       	movw	r30, r28
    27da:	32 96       	adiw	r30, 0x02	; 2
    27dc:	44 c0       	rjmp	.+136    	; 0x2866 <malloc+0x124>
    27de:	fe 01       	movw	r30, r28
    27e0:	e2 0f       	add	r30, r18
    27e2:	f3 1f       	adc	r31, r19
    27e4:	81 93       	st	Z+, r24
    27e6:	91 93       	st	Z+, r25
    27e8:	22 50       	subi	r18, 0x02	; 2
    27ea:	31 09       	sbc	r19, r1
    27ec:	39 83       	std	Y+1, r19	; 0x01
    27ee:	28 83       	st	Y, r18
    27f0:	3a c0       	rjmp	.+116    	; 0x2866 <malloc+0x124>
    27f2:	20 91 fb 04 	lds	r18, 0x04FB	; 0x8004fb <__brkval>
    27f6:	30 91 fc 04 	lds	r19, 0x04FC	; 0x8004fc <__brkval+0x1>
    27fa:	23 2b       	or	r18, r19
    27fc:	41 f4       	brne	.+16     	; 0x280e <malloc+0xcc>
    27fe:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2802:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    2806:	30 93 fc 04 	sts	0x04FC, r19	; 0x8004fc <__brkval+0x1>
    280a:	20 93 fb 04 	sts	0x04FB, r18	; 0x8004fb <__brkval>
    280e:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2812:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    2816:	21 15       	cp	r18, r1
    2818:	31 05       	cpc	r19, r1
    281a:	41 f4       	brne	.+16     	; 0x282c <malloc+0xea>
    281c:	2d b7       	in	r18, 0x3d	; 61
    281e:	3e b7       	in	r19, 0x3e	; 62
    2820:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2824:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2828:	24 1b       	sub	r18, r20
    282a:	35 0b       	sbc	r19, r21
    282c:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <__brkval>
    2830:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <__brkval+0x1>
    2834:	e2 17       	cp	r30, r18
    2836:	f3 07       	cpc	r31, r19
    2838:	a0 f4       	brcc	.+40     	; 0x2862 <malloc+0x120>
    283a:	2e 1b       	sub	r18, r30
    283c:	3f 0b       	sbc	r19, r31
    283e:	28 17       	cp	r18, r24
    2840:	39 07       	cpc	r19, r25
    2842:	78 f0       	brcs	.+30     	; 0x2862 <malloc+0x120>
    2844:	ac 01       	movw	r20, r24
    2846:	4e 5f       	subi	r20, 0xFE	; 254
    2848:	5f 4f       	sbci	r21, 0xFF	; 255
    284a:	24 17       	cp	r18, r20
    284c:	35 07       	cpc	r19, r21
    284e:	48 f0       	brcs	.+18     	; 0x2862 <malloc+0x120>
    2850:	4e 0f       	add	r20, r30
    2852:	5f 1f       	adc	r21, r31
    2854:	50 93 fc 04 	sts	0x04FC, r21	; 0x8004fc <__brkval+0x1>
    2858:	40 93 fb 04 	sts	0x04FB, r20	; 0x8004fb <__brkval>
    285c:	81 93       	st	Z+, r24
    285e:	91 93       	st	Z+, r25
    2860:	02 c0       	rjmp	.+4      	; 0x2866 <malloc+0x124>
    2862:	e0 e0       	ldi	r30, 0x00	; 0
    2864:	f0 e0       	ldi	r31, 0x00	; 0
    2866:	cf 01       	movw	r24, r30
    2868:	df 91       	pop	r29
    286a:	cf 91       	pop	r28
    286c:	1f 91       	pop	r17
    286e:	0f 91       	pop	r16
    2870:	08 95       	ret

00002872 <free>:
    2872:	cf 93       	push	r28
    2874:	df 93       	push	r29
    2876:	00 97       	sbiw	r24, 0x00	; 0
    2878:	09 f4       	brne	.+2      	; 0x287c <free+0xa>
    287a:	81 c0       	rjmp	.+258    	; 0x297e <free+0x10c>
    287c:	fc 01       	movw	r30, r24
    287e:	32 97       	sbiw	r30, 0x02	; 2
    2880:	13 82       	std	Z+3, r1	; 0x03
    2882:	12 82       	std	Z+2, r1	; 0x02
    2884:	a0 91 fd 04 	lds	r26, 0x04FD	; 0x8004fd <__flp>
    2888:	b0 91 fe 04 	lds	r27, 0x04FE	; 0x8004fe <__flp+0x1>
    288c:	10 97       	sbiw	r26, 0x00	; 0
    288e:	81 f4       	brne	.+32     	; 0x28b0 <free+0x3e>
    2890:	20 81       	ld	r18, Z
    2892:	31 81       	ldd	r19, Z+1	; 0x01
    2894:	82 0f       	add	r24, r18
    2896:	93 1f       	adc	r25, r19
    2898:	20 91 fb 04 	lds	r18, 0x04FB	; 0x8004fb <__brkval>
    289c:	30 91 fc 04 	lds	r19, 0x04FC	; 0x8004fc <__brkval+0x1>
    28a0:	28 17       	cp	r18, r24
    28a2:	39 07       	cpc	r19, r25
    28a4:	51 f5       	brne	.+84     	; 0x28fa <free+0x88>
    28a6:	f0 93 fc 04 	sts	0x04FC, r31	; 0x8004fc <__brkval+0x1>
    28aa:	e0 93 fb 04 	sts	0x04FB, r30	; 0x8004fb <__brkval>
    28ae:	67 c0       	rjmp	.+206    	; 0x297e <free+0x10c>
    28b0:	ed 01       	movw	r28, r26
    28b2:	20 e0       	ldi	r18, 0x00	; 0
    28b4:	30 e0       	ldi	r19, 0x00	; 0
    28b6:	ce 17       	cp	r28, r30
    28b8:	df 07       	cpc	r29, r31
    28ba:	40 f4       	brcc	.+16     	; 0x28cc <free+0x5a>
    28bc:	4a 81       	ldd	r20, Y+2	; 0x02
    28be:	5b 81       	ldd	r21, Y+3	; 0x03
    28c0:	9e 01       	movw	r18, r28
    28c2:	41 15       	cp	r20, r1
    28c4:	51 05       	cpc	r21, r1
    28c6:	f1 f0       	breq	.+60     	; 0x2904 <free+0x92>
    28c8:	ea 01       	movw	r28, r20
    28ca:	f5 cf       	rjmp	.-22     	; 0x28b6 <free+0x44>
    28cc:	d3 83       	std	Z+3, r29	; 0x03
    28ce:	c2 83       	std	Z+2, r28	; 0x02
    28d0:	40 81       	ld	r20, Z
    28d2:	51 81       	ldd	r21, Z+1	; 0x01
    28d4:	84 0f       	add	r24, r20
    28d6:	95 1f       	adc	r25, r21
    28d8:	c8 17       	cp	r28, r24
    28da:	d9 07       	cpc	r29, r25
    28dc:	59 f4       	brne	.+22     	; 0x28f4 <free+0x82>
    28de:	88 81       	ld	r24, Y
    28e0:	99 81       	ldd	r25, Y+1	; 0x01
    28e2:	84 0f       	add	r24, r20
    28e4:	95 1f       	adc	r25, r21
    28e6:	02 96       	adiw	r24, 0x02	; 2
    28e8:	91 83       	std	Z+1, r25	; 0x01
    28ea:	80 83       	st	Z, r24
    28ec:	8a 81       	ldd	r24, Y+2	; 0x02
    28ee:	9b 81       	ldd	r25, Y+3	; 0x03
    28f0:	93 83       	std	Z+3, r25	; 0x03
    28f2:	82 83       	std	Z+2, r24	; 0x02
    28f4:	21 15       	cp	r18, r1
    28f6:	31 05       	cpc	r19, r1
    28f8:	29 f4       	brne	.+10     	; 0x2904 <free+0x92>
    28fa:	f0 93 fe 04 	sts	0x04FE, r31	; 0x8004fe <__flp+0x1>
    28fe:	e0 93 fd 04 	sts	0x04FD, r30	; 0x8004fd <__flp>
    2902:	3d c0       	rjmp	.+122    	; 0x297e <free+0x10c>
    2904:	e9 01       	movw	r28, r18
    2906:	fb 83       	std	Y+3, r31	; 0x03
    2908:	ea 83       	std	Y+2, r30	; 0x02
    290a:	49 91       	ld	r20, Y+
    290c:	59 91       	ld	r21, Y+
    290e:	c4 0f       	add	r28, r20
    2910:	d5 1f       	adc	r29, r21
    2912:	ec 17       	cp	r30, r28
    2914:	fd 07       	cpc	r31, r29
    2916:	61 f4       	brne	.+24     	; 0x2930 <free+0xbe>
    2918:	80 81       	ld	r24, Z
    291a:	91 81       	ldd	r25, Z+1	; 0x01
    291c:	84 0f       	add	r24, r20
    291e:	95 1f       	adc	r25, r21
    2920:	02 96       	adiw	r24, 0x02	; 2
    2922:	e9 01       	movw	r28, r18
    2924:	99 83       	std	Y+1, r25	; 0x01
    2926:	88 83       	st	Y, r24
    2928:	82 81       	ldd	r24, Z+2	; 0x02
    292a:	93 81       	ldd	r25, Z+3	; 0x03
    292c:	9b 83       	std	Y+3, r25	; 0x03
    292e:	8a 83       	std	Y+2, r24	; 0x02
    2930:	e0 e0       	ldi	r30, 0x00	; 0
    2932:	f0 e0       	ldi	r31, 0x00	; 0
    2934:	12 96       	adiw	r26, 0x02	; 2
    2936:	8d 91       	ld	r24, X+
    2938:	9c 91       	ld	r25, X
    293a:	13 97       	sbiw	r26, 0x03	; 3
    293c:	00 97       	sbiw	r24, 0x00	; 0
    293e:	19 f0       	breq	.+6      	; 0x2946 <free+0xd4>
    2940:	fd 01       	movw	r30, r26
    2942:	dc 01       	movw	r26, r24
    2944:	f7 cf       	rjmp	.-18     	; 0x2934 <free+0xc2>
    2946:	8d 91       	ld	r24, X+
    2948:	9c 91       	ld	r25, X
    294a:	11 97       	sbiw	r26, 0x01	; 1
    294c:	9d 01       	movw	r18, r26
    294e:	2e 5f       	subi	r18, 0xFE	; 254
    2950:	3f 4f       	sbci	r19, 0xFF	; 255
    2952:	82 0f       	add	r24, r18
    2954:	93 1f       	adc	r25, r19
    2956:	20 91 fb 04 	lds	r18, 0x04FB	; 0x8004fb <__brkval>
    295a:	30 91 fc 04 	lds	r19, 0x04FC	; 0x8004fc <__brkval+0x1>
    295e:	28 17       	cp	r18, r24
    2960:	39 07       	cpc	r19, r25
    2962:	69 f4       	brne	.+26     	; 0x297e <free+0x10c>
    2964:	30 97       	sbiw	r30, 0x00	; 0
    2966:	29 f4       	brne	.+10     	; 0x2972 <free+0x100>
    2968:	10 92 fe 04 	sts	0x04FE, r1	; 0x8004fe <__flp+0x1>
    296c:	10 92 fd 04 	sts	0x04FD, r1	; 0x8004fd <__flp>
    2970:	02 c0       	rjmp	.+4      	; 0x2976 <free+0x104>
    2972:	13 82       	std	Z+3, r1	; 0x03
    2974:	12 82       	std	Z+2, r1	; 0x02
    2976:	b0 93 fc 04 	sts	0x04FC, r27	; 0x8004fc <__brkval+0x1>
    297a:	a0 93 fb 04 	sts	0x04FB, r26	; 0x8004fb <__brkval>
    297e:	df 91       	pop	r29
    2980:	cf 91       	pop	r28
    2982:	08 95       	ret

00002984 <memcpy>:
    2984:	fb 01       	movw	r30, r22
    2986:	dc 01       	movw	r26, r24
    2988:	02 c0       	rjmp	.+4      	; 0x298e <memcpy+0xa>
    298a:	01 90       	ld	r0, Z+
    298c:	0d 92       	st	X+, r0
    298e:	41 50       	subi	r20, 0x01	; 1
    2990:	50 40       	sbci	r21, 0x00	; 0
    2992:	d8 f7       	brcc	.-10     	; 0x298a <memcpy+0x6>
    2994:	08 95       	ret

00002996 <memset>:
    2996:	dc 01       	movw	r26, r24
    2998:	01 c0       	rjmp	.+2      	; 0x299c <memset+0x6>
    299a:	6d 93       	st	X+, r22
    299c:	41 50       	subi	r20, 0x01	; 1
    299e:	50 40       	sbci	r21, 0x00	; 0
    29a0:	e0 f7       	brcc	.-8      	; 0x299a <memset+0x4>
    29a2:	08 95       	ret

000029a4 <__itoa_ncheck>:
    29a4:	bb 27       	eor	r27, r27
    29a6:	4a 30       	cpi	r20, 0x0A	; 10
    29a8:	31 f4       	brne	.+12     	; 0x29b6 <__itoa_ncheck+0x12>
    29aa:	99 23       	and	r25, r25
    29ac:	22 f4       	brpl	.+8      	; 0x29b6 <__itoa_ncheck+0x12>
    29ae:	bd e2       	ldi	r27, 0x2D	; 45
    29b0:	90 95       	com	r25
    29b2:	81 95       	neg	r24
    29b4:	9f 4f       	sbci	r25, 0xFF	; 255
    29b6:	01 c0       	rjmp	.+2      	; 0x29ba <__utoa_common>

000029b8 <__utoa_ncheck>:
    29b8:	bb 27       	eor	r27, r27

000029ba <__utoa_common>:
    29ba:	fb 01       	movw	r30, r22
    29bc:	55 27       	eor	r21, r21
    29be:	aa 27       	eor	r26, r26
    29c0:	88 0f       	add	r24, r24
    29c2:	99 1f       	adc	r25, r25
    29c4:	aa 1f       	adc	r26, r26
    29c6:	a4 17       	cp	r26, r20
    29c8:	10 f0       	brcs	.+4      	; 0x29ce <__utoa_common+0x14>
    29ca:	a4 1b       	sub	r26, r20
    29cc:	83 95       	inc	r24
    29ce:	50 51       	subi	r21, 0x10	; 16
    29d0:	b9 f7       	brne	.-18     	; 0x29c0 <__utoa_common+0x6>
    29d2:	a0 5d       	subi	r26, 0xD0	; 208
    29d4:	aa 33       	cpi	r26, 0x3A	; 58
    29d6:	08 f0       	brcs	.+2      	; 0x29da <__utoa_common+0x20>
    29d8:	a9 5d       	subi	r26, 0xD9	; 217
    29da:	a1 93       	st	Z+, r26
    29dc:	00 97       	sbiw	r24, 0x00	; 0
    29de:	79 f7       	brne	.-34     	; 0x29be <__utoa_common+0x4>
    29e0:	b1 11       	cpse	r27, r1
    29e2:	b1 93       	st	Z+, r27
    29e4:	11 92       	st	Z+, r1
    29e6:	cb 01       	movw	r24, r22
    29e8:	00 c0       	rjmp	.+0      	; 0x29ea <strrev>

000029ea <strrev>:
    29ea:	dc 01       	movw	r26, r24
    29ec:	fc 01       	movw	r30, r24
    29ee:	67 2f       	mov	r22, r23
    29f0:	71 91       	ld	r23, Z+
    29f2:	77 23       	and	r23, r23
    29f4:	e1 f7       	brne	.-8      	; 0x29ee <strrev+0x4>
    29f6:	32 97       	sbiw	r30, 0x02	; 2
    29f8:	04 c0       	rjmp	.+8      	; 0x2a02 <strrev+0x18>
    29fa:	7c 91       	ld	r23, X
    29fc:	6d 93       	st	X+, r22
    29fe:	70 83       	st	Z, r23
    2a00:	62 91       	ld	r22, -Z
    2a02:	ae 17       	cp	r26, r30
    2a04:	bf 07       	cpc	r27, r31
    2a06:	c8 f3       	brcs	.-14     	; 0x29fa <strrev+0x10>
    2a08:	08 95       	ret

00002a0a <_exit>:
    2a0a:	f8 94       	cli

00002a0c <__stop_program>:
    2a0c:	ff cf       	rjmp	.-2      	; 0x2a0c <__stop_program>
