
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800200  00002bba  00002c4e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002bba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000265  0080029c  0080029c  00002cea  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002cea  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002d1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005e8  00000000  00000000  00002d5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000080ec  00000000  00000000  00003344  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ec2  00000000  00000000  0000b430  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004da4  00000000  00000000  0000d2f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000154c  00000000  00000000  00012098  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000020e6  00000000  00000000  000135e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007768  00000000  00000000  000156ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008c0  00000000  00000000  0001ce32  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6d c1       	rjmp	.+730    	; 0x2dc <__ctors_end>
       2:	00 00       	nop
       4:	8b c1       	rjmp	.+790    	; 0x31c <__bad_interrupt>
       6:	00 00       	nop
       8:	89 c1       	rjmp	.+786    	; 0x31c <__bad_interrupt>
       a:	00 00       	nop
       c:	87 c1       	rjmp	.+782    	; 0x31c <__bad_interrupt>
       e:	00 00       	nop
      10:	85 c1       	rjmp	.+778    	; 0x31c <__bad_interrupt>
      12:	00 00       	nop
      14:	83 c1       	rjmp	.+774    	; 0x31c <__bad_interrupt>
      16:	00 00       	nop
      18:	81 c1       	rjmp	.+770    	; 0x31c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7f c1       	rjmp	.+766    	; 0x31c <__bad_interrupt>
      1e:	00 00       	nop
      20:	7d c1       	rjmp	.+762    	; 0x31c <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c4       	rjmp	.+2302   	; 0x924 <__vector_9>
      26:	00 00       	nop
      28:	79 c1       	rjmp	.+754    	; 0x31c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	77 c1       	rjmp	.+750    	; 0x31c <__bad_interrupt>
      2e:	00 00       	nop
      30:	75 c1       	rjmp	.+746    	; 0x31c <__bad_interrupt>
      32:	00 00       	nop
      34:	73 c1       	rjmp	.+742    	; 0x31c <__bad_interrupt>
      36:	00 00       	nop
      38:	71 c1       	rjmp	.+738    	; 0x31c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6f c1       	rjmp	.+734    	; 0x31c <__bad_interrupt>
      3e:	00 00       	nop
      40:	6d c1       	rjmp	.+730    	; 0x31c <__bad_interrupt>
      42:	00 00       	nop
      44:	40 c7       	rjmp	.+3712   	; 0xec6 <__vector_17>
      46:	00 00       	nop
      48:	69 c1       	rjmp	.+722    	; 0x31c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	67 c1       	rjmp	.+718    	; 0x31c <__bad_interrupt>
      4e:	00 00       	nop
      50:	65 c1       	rjmp	.+714    	; 0x31c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 c9 0a 	jmp	0x1592	; 0x1592 <__vector_21>
      58:	61 c1       	rjmp	.+706    	; 0x31c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5f c1       	rjmp	.+702    	; 0x31c <__bad_interrupt>
      5e:	00 00       	nop
      60:	5d c1       	rjmp	.+698    	; 0x31c <__bad_interrupt>
      62:	00 00       	nop
      64:	5b c1       	rjmp	.+694    	; 0x31c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 6b 0c 	jmp	0x18d6	; 0x18d6 <__vector_26>
      6c:	57 c1       	rjmp	.+686    	; 0x31c <__bad_interrupt>
      6e:	00 00       	nop
      70:	55 c1       	rjmp	.+682    	; 0x31c <__bad_interrupt>
      72:	00 00       	nop
      74:	53 c1       	rjmp	.+678    	; 0x31c <__bad_interrupt>
      76:	00 00       	nop
      78:	51 c1       	rjmp	.+674    	; 0x31c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4f c1       	rjmp	.+670    	; 0x31c <__bad_interrupt>
      7e:	00 00       	nop
      80:	4d c1       	rjmp	.+666    	; 0x31c <__bad_interrupt>
      82:	00 00       	nop
      84:	4b c1       	rjmp	.+662    	; 0x31c <__bad_interrupt>
      86:	00 00       	nop
      88:	49 c1       	rjmp	.+658    	; 0x31c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	ee c4       	rjmp	.+2524   	; 0xa6a <__vector_35>
      8e:	00 00       	nop
      90:	73 c3       	rjmp	.+1766   	; 0x778 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 b4 0c 	jmp	0x1968	; 0x1968 <__vector_37>
      98:	41 c1       	rjmp	.+642    	; 0x31c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c1       	rjmp	.+858    	; 0x3f8 <__vector_39>
      9e:	00 00       	nop
      a0:	3d c1       	rjmp	.+634    	; 0x31c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3b c1       	rjmp	.+630    	; 0x31c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	39 c1       	rjmp	.+626    	; 0x31c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	37 c1       	rjmp	.+622    	; 0x31c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	35 c1       	rjmp	.+618    	; 0x31c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	33 c1       	rjmp	.+614    	; 0x31c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	31 c1       	rjmp	.+610    	; 0x31c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2f c1       	rjmp	.+606    	; 0x31c <__bad_interrupt>
      be:	00 00       	nop
      c0:	2d c1       	rjmp	.+602    	; 0x31c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2b c1       	rjmp	.+598    	; 0x31c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	29 c1       	rjmp	.+594    	; 0x31c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 fd 0c 	jmp	0x19fa	; 0x19fa <__vector_51>
      d0:	0c 94 5c 0d 	jmp	0x1ab8	; 0x1ab8 <__vector_52>
      d4:	23 c1       	rjmp	.+582    	; 0x31c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <__vector_54>
      dc:	0c 94 04 0e 	jmp	0x1c08	; 0x1c08 <__vector_55>
      e0:	1d c1       	rjmp	.+570    	; 0x31c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1b 02       	muls	r17, r27
      e6:	d6 02       	muls	r29, r22
      e8:	d6 02       	muls	r29, r22
      ea:	d6 02       	muls	r29, r22
      ec:	d6 02       	muls	r29, r22
      ee:	d6 02       	muls	r29, r22
      f0:	d6 02       	muls	r29, r22
      f2:	d6 02       	muls	r29, r22
      f4:	1b 02       	muls	r17, r27
      f6:	d6 02       	muls	r29, r22
      f8:	d6 02       	muls	r29, r22
      fa:	d6 02       	muls	r29, r22
      fc:	d6 02       	muls	r29, r22
      fe:	d6 02       	muls	r29, r22
     100:	d6 02       	muls	r29, r22
     102:	d6 02       	muls	r29, r22
     104:	1d 02       	muls	r17, r29
     106:	d6 02       	muls	r29, r22
     108:	d6 02       	muls	r29, r22
     10a:	d6 02       	muls	r29, r22
     10c:	d6 02       	muls	r29, r22
     10e:	d6 02       	muls	r29, r22
     110:	d6 02       	muls	r29, r22
     112:	d6 02       	muls	r29, r22
     114:	3a 02       	muls	r19, r26
     116:	d6 02       	muls	r29, r22
     118:	d6 02       	muls	r29, r22
     11a:	d6 02       	muls	r29, r22
     11c:	d6 02       	muls	r29, r22
     11e:	d6 02       	muls	r29, r22
     120:	d6 02       	muls	r29, r22
     122:	d6 02       	muls	r29, r22
     124:	1d 02       	muls	r17, r29
     126:	d6 02       	muls	r29, r22
     128:	d6 02       	muls	r29, r22
     12a:	d6 02       	muls	r29, r22
     12c:	d6 02       	muls	r29, r22
     12e:	d6 02       	muls	r29, r22
     130:	d6 02       	muls	r29, r22
     132:	d6 02       	muls	r29, r22
     134:	3a 02       	muls	r19, r26
     136:	d6 02       	muls	r29, r22
     138:	d6 02       	muls	r29, r22
     13a:	d6 02       	muls	r29, r22
     13c:	d6 02       	muls	r29, r22
     13e:	d6 02       	muls	r29, r22
     140:	d6 02       	muls	r29, r22
     142:	d6 02       	muls	r29, r22
     144:	d2 02       	muls	r29, r18
     146:	d6 02       	muls	r29, r22
     148:	d6 02       	muls	r29, r22
     14a:	d6 02       	muls	r29, r22
     14c:	d6 02       	muls	r29, r22
     14e:	d6 02       	muls	r29, r22
     150:	d6 02       	muls	r29, r22
     152:	d6 02       	muls	r29, r22
     154:	4e 02       	muls	r20, r30
     156:	d6 02       	muls	r29, r22
     158:	d6 02       	muls	r29, r22
     15a:	d6 02       	muls	r29, r22
     15c:	d6 02       	muls	r29, r22
     15e:	d6 02       	muls	r29, r22
     160:	d6 02       	muls	r29, r22
     162:	d6 02       	muls	r29, r22
     164:	71 02       	muls	r23, r17
     166:	d6 02       	muls	r29, r22
     168:	d6 02       	muls	r29, r22
     16a:	d6 02       	muls	r29, r22
     16c:	d6 02       	muls	r29, r22
     16e:	d6 02       	muls	r29, r22
     170:	d6 02       	muls	r29, r22
     172:	d6 02       	muls	r29, r22
     174:	42 02       	muls	r20, r18
     176:	d6 02       	muls	r29, r22
     178:	d6 02       	muls	r29, r22
     17a:	d6 02       	muls	r29, r22
     17c:	d6 02       	muls	r29, r22
     17e:	d6 02       	muls	r29, r22
     180:	d6 02       	muls	r29, r22
     182:	d6 02       	muls	r29, r22
     184:	60 02       	muls	r22, r16
     186:	d6 02       	muls	r29, r22
     188:	d6 02       	muls	r29, r22
     18a:	d6 02       	muls	r29, r22
     18c:	d6 02       	muls	r29, r22
     18e:	d6 02       	muls	r29, r22
     190:	d6 02       	muls	r29, r22
     192:	d6 02       	muls	r29, r22
     194:	a8 02       	muls	r26, r24
     196:	d6 02       	muls	r29, r22
     198:	d6 02       	muls	r29, r22
     19a:	d6 02       	muls	r29, r22
     19c:	d6 02       	muls	r29, r22
     19e:	d6 02       	muls	r29, r22
     1a0:	d6 02       	muls	r29, r22
     1a2:	d6 02       	muls	r29, r22
     1a4:	a8 02       	muls	r26, r24
     1a6:	d6 02       	muls	r29, r22
     1a8:	d6 02       	muls	r29, r22
     1aa:	d6 02       	muls	r29, r22
     1ac:	d6 02       	muls	r29, r22
     1ae:	d6 02       	muls	r29, r22
     1b0:	d6 02       	muls	r29, r22
     1b2:	d6 02       	muls	r29, r22
     1b4:	a3 02       	muls	r26, r19
     1b6:	d6 02       	muls	r29, r22
     1b8:	d6 02       	muls	r29, r22
     1ba:	d6 02       	muls	r29, r22
     1bc:	d6 02       	muls	r29, r22
     1be:	d6 02       	muls	r29, r22
     1c0:	d6 02       	muls	r29, r22
     1c2:	d6 02       	muls	r29, r22
     1c4:	a3 02       	muls	r26, r19
     1c6:	d6 02       	muls	r29, r22
     1c8:	d6 02       	muls	r29, r22
     1ca:	d6 02       	muls	r29, r22
     1cc:	d6 02       	muls	r29, r22
     1ce:	d6 02       	muls	r29, r22
     1d0:	d6 02       	muls	r29, r22
     1d2:	d6 02       	muls	r29, r22
     1d4:	b3 02       	muls	r27, r19
     1d6:	d6 02       	muls	r29, r22
     1d8:	d6 02       	muls	r29, r22
     1da:	d6 02       	muls	r29, r22
     1dc:	d6 02       	muls	r29, r22
     1de:	d6 02       	muls	r29, r22
     1e0:	d6 02       	muls	r29, r22
     1e2:	d6 02       	muls	r29, r22
     1e4:	c8 02       	muls	r28, r24
     1e6:	d6 02       	muls	r29, r22
     1e8:	d6 02       	muls	r29, r22
     1ea:	d6 02       	muls	r29, r22
     1ec:	d6 02       	muls	r29, r22
     1ee:	d6 02       	muls	r29, r22
     1f0:	d6 02       	muls	r29, r22
     1f2:	d6 02       	muls	r29, r22
     1f4:	b3 02       	muls	r27, r19
     1f6:	d6 02       	muls	r29, r22
     1f8:	d6 02       	muls	r29, r22
     1fa:	d6 02       	muls	r29, r22
     1fc:	d6 02       	muls	r29, r22
     1fe:	d6 02       	muls	r29, r22
     200:	d6 02       	muls	r29, r22
     202:	d6 02       	muls	r29, r22
     204:	c8 02       	muls	r28, r24
     206:	d6 02       	muls	r29, r22
     208:	d6 02       	muls	r29, r22
     20a:	d6 02       	muls	r29, r22
     20c:	d6 02       	muls	r29, r22
     20e:	d6 02       	muls	r29, r22
     210:	d6 02       	muls	r29, r22
     212:	d6 02       	muls	r29, r22
     214:	cc 02       	muls	r28, r28
     216:	d6 02       	muls	r29, r22
     218:	d6 02       	muls	r29, r22
     21a:	d6 02       	muls	r29, r22
     21c:	d6 02       	muls	r29, r22
     21e:	d6 02       	muls	r29, r22
     220:	d6 02       	muls	r29, r22
     222:	d6 02       	muls	r29, r22
     224:	79 02       	muls	r23, r25
     226:	d6 02       	muls	r29, r22
     228:	d6 02       	muls	r29, r22
     22a:	d6 02       	muls	r29, r22
     22c:	d6 02       	muls	r29, r22
     22e:	d6 02       	muls	r29, r22
     230:	d6 02       	muls	r29, r22
     232:	d6 02       	muls	r29, r22
     234:	79 02       	muls	r23, r25
     236:	d6 02       	muls	r29, r22
     238:	d6 02       	muls	r29, r22
     23a:	d6 02       	muls	r29, r22
     23c:	d6 02       	muls	r29, r22
     23e:	d6 02       	muls	r29, r22
     240:	d6 02       	muls	r29, r22
     242:	d6 02       	muls	r29, r22
     244:	7b 02       	muls	r23, r27
     246:	d6 02       	muls	r29, r22
     248:	d6 02       	muls	r29, r22
     24a:	d6 02       	muls	r29, r22
     24c:	d6 02       	muls	r29, r22
     24e:	d6 02       	muls	r29, r22
     250:	d6 02       	muls	r29, r22
     252:	d6 02       	muls	r29, r22
     254:	8b 02       	muls	r24, r27
     256:	d6 02       	muls	r29, r22
     258:	d6 02       	muls	r29, r22
     25a:	d6 02       	muls	r29, r22
     25c:	d6 02       	muls	r29, r22
     25e:	d6 02       	muls	r29, r22
     260:	d6 02       	muls	r29, r22
     262:	d6 02       	muls	r29, r22
     264:	9f 02       	muls	r25, r31

00000266 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     266:	0a ed       	ldi	r16, 0xDA	; 218
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	f2 e0       	ldi	r31, 0x02	; 2
     26e:	ef 2e       	mov	r14, r31
     270:	f3 e0       	ldi	r31, 0x03	; 3
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 00 10 	call	0x2000	; 0x2000 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	ff d1       	rcall	.+1022   	; 0x6a0 <uxListRemove>
     2a2:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxCurrentNumberOfTasks>
     2ac:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 d9 02 	sts	0x02D9, r24	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5d d0       	rcall	.+186    	; 0x37a <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5b d0       	rcall	.+182    	; 0x37a <vPortFree>
     2c4:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	10 f0       	brcs	.+4      	; 0x2d8 <prvIdleTask+0x72>
     2d4:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <vPortYield>
     2d8:	5f d0       	rcall	.+190    	; 0x398 <vApplicationIdleHook>
     2da:	f4 cf       	rjmp	.-24     	; 0x2c4 <prvIdleTask+0x5e>

000002dc <__ctors_end>:
     2dc:	11 24       	eor	r1, r1
     2de:	1f be       	out	0x3f, r1	; 63
     2e0:	cf ef       	ldi	r28, 0xFF	; 255
     2e2:	d1 e2       	ldi	r29, 0x21	; 33
     2e4:	de bf       	out	0x3e, r29	; 62
     2e6:	cd bf       	out	0x3d, r28	; 61
     2e8:	00 e0       	ldi	r16, 0x00	; 0
     2ea:	0c bf       	out	0x3c, r16	; 60

000002ec <__do_copy_data>:
     2ec:	12 e0       	ldi	r17, 0x02	; 2
     2ee:	a0 e0       	ldi	r26, 0x00	; 0
     2f0:	b2 e0       	ldi	r27, 0x02	; 2
     2f2:	ea eb       	ldi	r30, 0xBA	; 186
     2f4:	fb e2       	ldi	r31, 0x2B	; 43
     2f6:	00 e0       	ldi	r16, 0x00	; 0
     2f8:	0b bf       	out	0x3b, r16	; 59
     2fa:	02 c0       	rjmp	.+4      	; 0x300 <__do_copy_data+0x14>
     2fc:	07 90       	elpm	r0, Z+
     2fe:	0d 92       	st	X+, r0
     300:	ac 39       	cpi	r26, 0x9C	; 156
     302:	b1 07       	cpc	r27, r17
     304:	d9 f7       	brne	.-10     	; 0x2fc <__do_copy_data+0x10>

00000306 <__do_clear_bss>:
     306:	25 e0       	ldi	r18, 0x05	; 5
     308:	ac e9       	ldi	r26, 0x9C	; 156
     30a:	b2 e0       	ldi	r27, 0x02	; 2
     30c:	01 c0       	rjmp	.+2      	; 0x310 <.do_clear_bss_start>

0000030e <.do_clear_bss_loop>:
     30e:	1d 92       	st	X+, r1

00000310 <.do_clear_bss_start>:
     310:	a1 30       	cpi	r26, 0x01	; 1
     312:	b2 07       	cpc	r27, r18
     314:	e1 f7       	brne	.-8      	; 0x30e <.do_clear_bss_loop>
     316:	58 d6       	rcall	.+3248   	; 0xfc8 <main>
     318:	0c 94 db 15 	jmp	0x2bb6	; 0x2bb6 <_exit>

0000031c <__bad_interrupt>:
     31c:	71 ce       	rjmp	.-798    	; 0x0 <__vectors>

0000031e <system_tick>:
     31e:	8f 93       	push	r24
     320:	8f b7       	in	r24, 0x3f	; 63
     322:	8f 93       	push	r24
     324:	f8 94       	cli
     326:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <__system_time>
     32a:	8f 5f       	subi	r24, 0xFF	; 255
     32c:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <__system_time>
     330:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <__system_time+0x1>
     334:	8f 4f       	sbci	r24, 0xFF	; 255
     336:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <__system_time+0x1>
     33a:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <__system_time+0x2>
     33e:	8f 4f       	sbci	r24, 0xFF	; 255
     340:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <__system_time+0x2>
     344:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <__system_time+0x3>
     348:	8f 4f       	sbci	r24, 0xFF	; 255
     34a:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <__system_time+0x3>
     34e:	8f 91       	pop	r24
     350:	8f bf       	out	0x3f, r24	; 63
     352:	8f 91       	pop	r24
     354:	08 95       	ret

00000356 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     356:	cf 93       	push	r28
     358:	df 93       	push	r29
     35a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35c:	0e 94 00 10 	call	0x2000	; 0x2000 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     360:	ce 01       	movw	r24, r28
     362:	0e 94 77 14 	call	0x28ee	; 0x28ee <malloc>
     366:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     368:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36c:	20 97       	sbiw	r28, 0x00	; 0
     36e:	09 f4       	brne	.+2      	; 0x372 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     370:	2c d0       	rcall	.+88     	; 0x3ca <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     372:	ce 01       	movw	r24, r28
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     37a:	cf 93       	push	r28
     37c:	df 93       	push	r29
	if( pv )
     37e:	00 97       	sbiw	r24, 0x00	; 0
     380:	41 f0       	breq	.+16     	; 0x392 <vPortFree+0x18>
     382:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     384:	0e 94 00 10 	call	0x2000	; 0x2000 <vTaskSuspendAll>
		{
			free( pv );
     388:	ce 01       	movw	r24, r28
     38a:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38e:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
	}
}
     392:	df 91       	pop	r29
     394:	cf 91       	pop	r28
     396:	08 95       	ret

00000398 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39e:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a2:	80 b7       	in	r24, 0x30	; 48
     3a4:	87 7f       	andi	r24, 0xF7	; 247
     3a6:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a8:	80 b7       	in	r24, 0x30	; 48
     3aa:	80 68       	ori	r24, 0x80	; 128
     3ac:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ae:	83 b7       	in	r24, 0x33	; 51
     3b0:	81 7f       	andi	r24, 0xF1	; 241
     3b2:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	0f 92       	push	r0

	sleep_enable();
     3ba:	83 b7       	in	r24, 0x33	; 51
     3bc:	81 60       	ori	r24, 0x01	; 1
     3be:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3c0:	0f 90       	pop	r0
     3c2:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c4:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c6:	13 be       	out	0x33, r1	; 51
     3c8:	08 95       	ret

000003ca <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3ca:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3cc:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3ce:	83 ed       	ldi	r24, 0xD3	; 211
     3d0:	90 e3       	ldi	r25, 0x30	; 48
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	f1 f7       	brne	.-4      	; 0x3d2 <vApplicationMallocFailedHook+0x8>
     3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <vApplicationMallocFailedHook+0xe>
     3d8:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3da:	1f 9a       	sbi	0x03, 7	; 3
     3dc:	f8 cf       	rjmp	.-16     	; 0x3ce <vApplicationMallocFailedHook+0x4>

000003de <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3de:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3e0:	2f 9a       	sbi	0x05, 7	; 5
     3e2:	2f e7       	ldi	r18, 0x7F	; 127
     3e4:	8a e1       	ldi	r24, 0x1A	; 26
     3e6:	96 e0       	ldi	r25, 0x06	; 6
     3e8:	21 50       	subi	r18, 0x01	; 1
     3ea:	80 40       	sbci	r24, 0x00	; 0
     3ec:	90 40       	sbci	r25, 0x00	; 0
     3ee:	e1 f7       	brne	.-8      	; 0x3e8 <vApplicationStackOverflowHook+0xa>
     3f0:	00 c0       	rjmp	.+0      	; 0x3f2 <vApplicationStackOverflowHook+0x14>
     3f2:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f4:	1f 9a       	sbi	0x03, 7	; 3
     3f6:	f5 cf       	rjmp	.-22     	; 0x3e2 <vApplicationStackOverflowHook+0x4>

000003f8 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f8:	1f 92       	push	r1
     3fa:	0f 92       	push	r0
     3fc:	0f b6       	in	r0, 0x3f	; 63
     3fe:	0f 92       	push	r0
     400:	11 24       	eor	r1, r1
     402:	0b b6       	in	r0, 0x3b	; 59
     404:	0f 92       	push	r0
     406:	2f 93       	push	r18
     408:	3f 93       	push	r19
     40a:	8f 93       	push	r24
     40c:	9f 93       	push	r25
     40e:	af 93       	push	r26
     410:	bf 93       	push	r27
     412:	ef 93       	push	r30
     414:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     416:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     41a:	8e 2f       	mov	r24, r30
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	fc 01       	movw	r30, r24
     420:	38 97       	sbiw	r30, 0x08	; 8
     422:	e1 3c       	cpi	r30, 0xC1	; 193
     424:	f1 05       	cpc	r31, r1
     426:	08 f0       	brcs	.+2      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     428:	c1 c0       	rjmp	.+386    	; 0x5ac <__LOCK_REGION_LENGTH__+0x1ac>
     42a:	88 27       	eor	r24, r24
     42c:	ee 58       	subi	r30, 0x8E	; 142
     42e:	ff 4f       	sbci	r31, 0xFF	; 255
     430:	8f 4f       	sbci	r24, 0xFF	; 255
     432:	0c 94 56 14 	jmp	0x28ac	; 0x28ac <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     436:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     43a:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     43e:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     442:	e8 17       	cp	r30, r24
     444:	70 f4       	brcc	.+28     	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	8e 0f       	add	r24, r30
     44a:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     44e:	f0 e0       	ldi	r31, 0x00	; 0
     450:	e0 56       	subi	r30, 0x60	; 96
     452:	fd 4f       	sbci	r31, 0xFD	; 253
     454:	80 81       	ld	r24, Z
     456:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     45a:	85 e8       	ldi	r24, 0x85	; 133
     45c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     460:	ac c0       	rjmp	.+344    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     462:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     466:	81 60       	ori	r24, 0x01	; 1
     468:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46c:	84 e9       	ldi	r24, 0x94	; 148
     46e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     472:	a3 c0       	rjmp	.+326    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     474:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     478:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47c:	85 ee       	ldi	r24, 0xE5	; 229
     47e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     482:	9b c0       	rjmp	.+310    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     484:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	8e 0f       	add	r24, r30
     48c:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     490:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	e0 56       	subi	r30, 0x60	; 96
     498:	fd 4f       	sbci	r31, 0xFD	; 253
     49a:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49c:	20 91 9c 02 	lds	r18, 0x029C	; 0x80029c <__data_end>
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	01 97       	sbiw	r24, 0x01	; 1
     4aa:	28 17       	cp	r18, r24
     4ac:	39 07       	cpc	r19, r25
     4ae:	24 f4       	brge	.+8      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b0:	85 ec       	ldi	r24, 0xC5	; 197
     4b2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b6:	81 c0       	rjmp	.+258    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b8:	85 e8       	ldi	r24, 0x85	; 133
     4ba:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4be:	7d c0       	rjmp	.+250    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4c0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c4:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     4c8:	f0 e0       	ldi	r31, 0x00	; 0
     4ca:	e0 56       	subi	r30, 0x60	; 96
     4cc:	fd 4f       	sbci	r31, 0xFD	; 253
     4ce:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4d0:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     4d4:	81 60       	ori	r24, 0x01	; 1
     4d6:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4da:	84 ed       	ldi	r24, 0xD4	; 212
     4dc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4e0:	6c c0       	rjmp	.+216    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e6:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4ea:	85 ed       	ldi	r24, 0xD5	; 213
     4ec:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4f0:	64 c0       	rjmp	.+200    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f2:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f6:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	8e 0f       	add	r24, r30
     4fe:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     502:	f0 e0       	ldi	r31, 0x00	; 0
     504:	e0 56       	subi	r30, 0x60	; 96
     506:	fd 4f       	sbci	r31, 0xFD	; 253
     508:	80 81       	ld	r24, Z
     50a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50e:	85 ec       	ldi	r24, 0xC5	; 197
     510:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     514:	52 c0       	rjmp	.+164    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     516:	90 91 9c 02 	lds	r25, 0x029C	; 0x80029c <__data_end>
     51a:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     51e:	98 13       	cpse	r25, r24
     520:	06 c0       	rjmp	.+12     	; 0x52e <__LOCK_REGION_LENGTH__+0x12e>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     522:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     526:	81 60       	ori	r24, 0x01	; 1
     528:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
     52c:	04 c0       	rjmp	.+8      	; 0x536 <__LOCK_REGION_LENGTH__+0x136>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     532:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     536:	84 e0       	ldi	r24, 0x04	; 4
     538:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53c:	3e c0       	rjmp	.+124    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53e:	85 ec       	ldi	r24, 0xC5	; 197
     540:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     544:	3a c0       	rjmp	.+116    	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     546:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     54a:	84 60       	ori	r24, 0x04	; 4
     54c:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     550:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     554:	82 60       	ori	r24, 0x02	; 2
     556:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     55a:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55e:	85 ec       	ldi	r24, 0xC5	; 197
     560:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     564:	2a c0       	rjmp	.+84     	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     566:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     56a:	81 e0       	ldi	r24, 0x01	; 1
     56c:	8e 0f       	add	r24, r30
     56e:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     572:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     576:	f0 e0       	ldi	r31, 0x00	; 0
     578:	e0 56       	subi	r30, 0x60	; 96
     57a:	fd 4f       	sbci	r31, 0xFD	; 253
     57c:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57e:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     582:	81 60       	ori	r24, 0x01	; 1
     584:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     588:	85 ec       	ldi	r24, 0xC5	; 197
     58a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58e:	15 c0       	rjmp	.+42     	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     590:	85 e8       	ldi	r24, 0x85	; 133
     592:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     596:	11 c0       	rjmp	.+34     	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     598:	84 e0       	ldi	r24, 0x04	; 4
     59a:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a2:	0b c0       	rjmp	.+22     	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a4:	85 ee       	ldi	r24, 0xE5	; 229
     5a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5aa:	07 c0       	rjmp	.+14     	; 0x5ba <__LOCK_REGION_LENGTH__+0x1ba>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5ac:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5b0:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b4:	85 ed       	ldi	r24, 0xD5	; 213
     5b6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5ba:	ff 91       	pop	r31
     5bc:	ef 91       	pop	r30
     5be:	bf 91       	pop	r27
     5c0:	af 91       	pop	r26
     5c2:	9f 91       	pop	r25
     5c4:	8f 91       	pop	r24
     5c6:	3f 91       	pop	r19
     5c8:	2f 91       	pop	r18
     5ca:	0f 90       	pop	r0
     5cc:	0b be       	out	0x3b, r0	; 59
     5ce:	0f 90       	pop	r0
     5d0:	0f be       	out	0x3f, r0	; 63
     5d2:	0f 90       	pop	r0
     5d4:	1f 90       	pop	r1
     5d6:	18 95       	reti

000005d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5da:	03 96       	adiw	r24, 0x03	; 3
     5dc:	92 83       	std	Z+2, r25	; 0x02
     5de:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5e0:	2f ef       	ldi	r18, 0xFF	; 255
     5e2:	3f ef       	ldi	r19, 0xFF	; 255
     5e4:	34 83       	std	Z+4, r19	; 0x04
     5e6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e8:	96 83       	std	Z+6, r25	; 0x06
     5ea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ec:	90 87       	std	Z+8, r25	; 0x08
     5ee:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5f0:	10 82       	st	Z, r1
     5f2:	08 95       	ret

000005f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f4:	fc 01       	movw	r30, r24
     5f6:	11 86       	std	Z+9, r1	; 0x09
     5f8:	10 86       	std	Z+8, r1	; 0x08
     5fa:	08 95       	ret

000005fc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fc:	cf 93       	push	r28
     5fe:	df 93       	push	r29
     600:	9c 01       	movw	r18, r24
     602:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     604:	dc 01       	movw	r26, r24
     606:	11 96       	adiw	r26, 0x01	; 1
     608:	cd 91       	ld	r28, X+
     60a:	dc 91       	ld	r29, X
     60c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60e:	d3 83       	std	Z+3, r29	; 0x03
     610:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     612:	8c 81       	ldd	r24, Y+4	; 0x04
     614:	9d 81       	ldd	r25, Y+5	; 0x05
     616:	95 83       	std	Z+5, r25	; 0x05
     618:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     61a:	8c 81       	ldd	r24, Y+4	; 0x04
     61c:	9d 81       	ldd	r25, Y+5	; 0x05
     61e:	dc 01       	movw	r26, r24
     620:	13 96       	adiw	r26, 0x03	; 3
     622:	7c 93       	st	X, r23
     624:	6e 93       	st	-X, r22
     626:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     628:	7d 83       	std	Y+5, r23	; 0x05
     62a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62c:	31 87       	std	Z+9, r19	; 0x09
     62e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     630:	f9 01       	movw	r30, r18
     632:	80 81       	ld	r24, Z
     634:	8f 5f       	subi	r24, 0xFF	; 255
     636:	80 83       	st	Z, r24
}
     638:	df 91       	pop	r29
     63a:	cf 91       	pop	r28
     63c:	08 95       	ret

0000063e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     644:	48 81       	ld	r20, Y
     646:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     648:	4f 3f       	cpi	r20, 0xFF	; 255
     64a:	2f ef       	ldi	r18, 0xFF	; 255
     64c:	52 07       	cpc	r21, r18
     64e:	21 f4       	brne	.+8      	; 0x658 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     650:	fc 01       	movw	r30, r24
     652:	a7 81       	ldd	r26, Z+7	; 0x07
     654:	b0 85       	ldd	r27, Z+8	; 0x08
     656:	0d c0       	rjmp	.+26     	; 0x672 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     658:	dc 01       	movw	r26, r24
     65a:	13 96       	adiw	r26, 0x03	; 3
     65c:	01 c0       	rjmp	.+2      	; 0x660 <vListInsert+0x22>
     65e:	df 01       	movw	r26, r30
     660:	12 96       	adiw	r26, 0x02	; 2
     662:	ed 91       	ld	r30, X+
     664:	fc 91       	ld	r31, X
     666:	13 97       	sbiw	r26, 0x03	; 3
     668:	20 81       	ld	r18, Z
     66a:	31 81       	ldd	r19, Z+1	; 0x01
     66c:	42 17       	cp	r20, r18
     66e:	53 07       	cpc	r21, r19
     670:	b0 f7       	brcc	.-20     	; 0x65e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     672:	12 96       	adiw	r26, 0x02	; 2
     674:	ed 91       	ld	r30, X+
     676:	fc 91       	ld	r31, X
     678:	13 97       	sbiw	r26, 0x03	; 3
     67a:	fb 83       	std	Y+3, r31	; 0x03
     67c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67e:	d5 83       	std	Z+5, r29	; 0x05
     680:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     682:	bd 83       	std	Y+5, r27	; 0x05
     684:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     686:	13 96       	adiw	r26, 0x03	; 3
     688:	dc 93       	st	X, r29
     68a:	ce 93       	st	-X, r28
     68c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68e:	99 87       	std	Y+9, r25	; 0x09
     690:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     692:	fc 01       	movw	r30, r24
     694:	20 81       	ld	r18, Z
     696:	2f 5f       	subi	r18, 0xFF	; 255
     698:	20 83       	st	Z, r18
}
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	08 95       	ret

000006a0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6a0:	cf 93       	push	r28
     6a2:	df 93       	push	r29
     6a4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a6:	a0 85       	ldd	r26, Z+8	; 0x08
     6a8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6aa:	c2 81       	ldd	r28, Z+2	; 0x02
     6ac:	d3 81       	ldd	r29, Z+3	; 0x03
     6ae:	84 81       	ldd	r24, Z+4	; 0x04
     6b0:	95 81       	ldd	r25, Z+5	; 0x05
     6b2:	9d 83       	std	Y+5, r25	; 0x05
     6b4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b6:	c4 81       	ldd	r28, Z+4	; 0x04
     6b8:	d5 81       	ldd	r29, Z+5	; 0x05
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	93 81       	ldd	r25, Z+3	; 0x03
     6be:	9b 83       	std	Y+3, r25	; 0x03
     6c0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c2:	11 96       	adiw	r26, 0x01	; 1
     6c4:	8d 91       	ld	r24, X+
     6c6:	9c 91       	ld	r25, X
     6c8:	12 97       	sbiw	r26, 0x02	; 2
     6ca:	e8 17       	cp	r30, r24
     6cc:	f9 07       	cpc	r31, r25
     6ce:	31 f4       	brne	.+12     	; 0x6dc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6d0:	84 81       	ldd	r24, Z+4	; 0x04
     6d2:	95 81       	ldd	r25, Z+5	; 0x05
     6d4:	12 96       	adiw	r26, 0x02	; 2
     6d6:	9c 93       	st	X, r25
     6d8:	8e 93       	st	-X, r24
     6da:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6dc:	11 86       	std	Z+9, r1	; 0x09
     6de:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6e0:	8c 91       	ld	r24, X
     6e2:	81 50       	subi	r24, 0x01	; 1
     6e4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e6:	df 91       	pop	r29
     6e8:	cf 91       	pop	r28
     6ea:	08 95       	ret

000006ec <watchdogTaak>:
		setSpeed(100);
		motorLinks();
		vTaskDelay(xDelay);
		motorRechts();
		vTaskDelay(xDelay);
		watchdogMotor = 1;
     6ec:	8f e9       	ldi	r24, 0x9F	; 159
     6ee:	9f e0       	ldi	r25, 0x0F	; 15
     6f0:	01 97       	sbiw	r24, 0x01	; 1
     6f2:	f1 f7       	brne	.-4      	; 0x6f0 <watchdogTaak+0x4>
     6f4:	00 c0       	rjmp	.+0      	; 0x6f6 <watchdogTaak+0xa>
     6f6:	00 00       	nop
     6f8:	80 91 30 03 	lds	r24, 0x0330	; 0x800330 <watchdogSonar>
     6fc:	90 91 31 03 	lds	r25, 0x0331	; 0x800331 <watchdogSonar+0x1>
     700:	89 2b       	or	r24, r25
     702:	a1 f3       	breq	.-24     	; 0x6ec <watchdogTaak>
     704:	80 91 5c 04 	lds	r24, 0x045C	; 0x80045c <watchdogServo>
     708:	90 91 5d 04 	lds	r25, 0x045D	; 0x80045d <watchdogServo+0x1>
     70c:	89 2b       	or	r24, r25
     70e:	71 f3       	breq	.-36     	; 0x6ec <watchdogTaak>
     710:	80 91 2e 03 	lds	r24, 0x032E	; 0x80032e <watchdogGyro>
     714:	90 91 2f 03 	lds	r25, 0x032F	; 0x80032f <watchdogGyro+0x1>
     718:	89 2b       	or	r24, r25
     71a:	41 f3       	breq	.-48     	; 0x6ec <watchdogTaak>
     71c:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <watchdogMotor>
     720:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <watchdogMotor+0x1>
     724:	89 2b       	or	r24, r25
     726:	11 f3       	breq	.-60     	; 0x6ec <watchdogTaak>
     728:	a8 95       	wdr
     72a:	10 92 31 03 	sts	0x0331, r1	; 0x800331 <watchdogSonar+0x1>
     72e:	10 92 30 03 	sts	0x0330, r1	; 0x800330 <watchdogSonar>
     732:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <watchdogServo+0x1>
     736:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <watchdogServo>
     73a:	10 92 2f 03 	sts	0x032F, r1	; 0x80032f <watchdogGyro+0x1>
     73e:	10 92 2e 03 	sts	0x032E, r1	; 0x80032e <watchdogGyro>
     742:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <watchdogMotor+0x1>
     746:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <watchdogMotor>
     74a:	d0 cf       	rjmp	.-96     	; 0x6ec <watchdogTaak>

0000074c <UART_Init>:
     74c:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     750:	87 e6       	ldi	r24, 0x67	; 103
     752:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     756:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     75a:	86 e0       	ldi	r24, 0x06	; 6
     75c:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     760:	88 eb       	ldi	r24, 0xB8	; 184
     762:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     766:	08 95       	ret

00000768 <UART_Transmit>:
     768:	e8 ec       	ldi	r30, 0xC8	; 200
     76a:	f0 e0       	ldi	r31, 0x00	; 0
     76c:	90 81       	ld	r25, Z
     76e:	95 ff       	sbrs	r25, 5
     770:	fd cf       	rjmp	.-6      	; 0x76c <UART_Transmit+0x4>
     772:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     776:	08 95       	ret

00000778 <__vector_36>:
     778:	1f 92       	push	r1
     77a:	0f 92       	push	r0
     77c:	0f b6       	in	r0, 0x3f	; 63
     77e:	0f 92       	push	r0
     780:	11 24       	eor	r1, r1
     782:	8f 93       	push	r24
     784:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     788:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <ontvang>
     78c:	8f 91       	pop	r24
     78e:	0f 90       	pop	r0
     790:	0f be       	out	0x3f, r0	; 63
     792:	0f 90       	pop	r0
     794:	1f 90       	pop	r1
     796:	18 95       	reti

00000798 <UART_Transmit_String>:
     798:	cf 93       	push	r28
     79a:	df 93       	push	r29
     79c:	ec 01       	movw	r28, r24
     79e:	88 81       	ld	r24, Y
     7a0:	88 23       	and	r24, r24
     7a2:	29 f0       	breq	.+10     	; 0x7ae <UART_Transmit_String+0x16>
     7a4:	21 96       	adiw	r28, 0x01	; 1
     7a6:	e0 df       	rcall	.-64     	; 0x768 <UART_Transmit>
     7a8:	89 91       	ld	r24, Y+
     7aa:	81 11       	cpse	r24, r1
     7ac:	fc cf       	rjmp	.-8      	; 0x7a6 <UART_Transmit_String+0xe>
     7ae:	df 91       	pop	r29
     7b0:	cf 91       	pop	r28
     7b2:	08 95       	ret

000007b4 <UART_Transmit_Integer>:
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	61 97       	sbiw	r28, 0x11	; 17
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	dc 01       	movw	r26, r24
     7ca:	cb 01       	movw	r24, r22
     7cc:	4a e0       	ldi	r20, 0x0A	; 10
     7ce:	be 01       	movw	r22, r28
     7d0:	6f 5f       	subi	r22, 0xFF	; 255
     7d2:	7f 4f       	sbci	r23, 0xFF	; 255
     7d4:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <__itoa_ncheck>
     7d8:	ce 01       	movw	r24, r28
     7da:	01 96       	adiw	r24, 0x01	; 1
     7dc:	dd df       	rcall	.-70     	; 0x798 <UART_Transmit_String>
     7de:	61 96       	adiw	r28, 0x11	; 17
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	de bf       	out	0x3e, r29	; 62
     7e6:	0f be       	out	0x3f, r0	; 63
     7e8:	cd bf       	out	0x3d, r28	; 61
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <servoTaak>:
     7f0:	0a e8       	ldi	r16, 0x8A	; 138
     7f2:	10 e0       	ldi	r17, 0x00	; 0
     7f4:	c1 e0       	ldi	r28, 0x01	; 1
     7f6:	d0 e0       	ldi	r29, 0x00	; 0
     7f8:	e1 2c       	mov	r14, r1
     7fa:	f1 2c       	mov	r15, r1
     7fc:	f0 92 57 04 	sts	0x0457, r15	; 0x800457 <hoek+0x1>
     800:	e0 92 56 04 	sts	0x0456, r14	; 0x800456 <hoek>
     804:	c7 01       	movw	r24, r14
     806:	99 27       	eor	r25, r25
     808:	9c 01       	movw	r18, r24
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	22 0f       	add	r18, r18
     810:	33 1f       	adc	r19, r19
     812:	22 0f       	add	r18, r18
     814:	33 1f       	adc	r19, r19
     816:	82 1b       	sub	r24, r18
     818:	93 0b       	sbc	r25, r19
     81a:	95 5b       	subi	r25, 0xB5	; 181
     81c:	f8 01       	movw	r30, r16
     81e:	91 83       	std	Z+1, r25	; 0x01
     820:	80 83       	st	Z, r24
     822:	ff ef       	ldi	r31, 0xFF	; 255
     824:	24 e3       	ldi	r18, 0x34	; 52
     826:	8c e0       	ldi	r24, 0x0C	; 12
     828:	f1 50       	subi	r31, 0x01	; 1
     82a:	20 40       	sbci	r18, 0x00	; 0
     82c:	80 40       	sbci	r24, 0x00	; 0
     82e:	e1 f7       	brne	.-8      	; 0x828 <servoTaak+0x38>
     830:	00 c0       	rjmp	.+0      	; 0x832 <servoTaak+0x42>
     832:	00 00       	nop
     834:	87 e0       	ldi	r24, 0x07	; 7
     836:	92 e0       	ldi	r25, 0x02	; 2
     838:	af df       	rcall	.-162    	; 0x798 <UART_Transmit_String>
     83a:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <hoek>
     83e:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <hoek+0x1>
     842:	07 2e       	mov	r0, r23
     844:	00 0c       	add	r0, r0
     846:	88 0b       	sbc	r24, r24
     848:	99 0b       	sbc	r25, r25
     84a:	b4 df       	rcall	.-152    	; 0x7b4 <UART_Transmit_Integer>
     84c:	80 e1       	ldi	r24, 0x10	; 16
     84e:	92 e0       	ldi	r25, 0x02	; 2
     850:	a3 df       	rcall	.-186    	; 0x798 <UART_Transmit_String>
     852:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <afstand>
     856:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <afstand+0x1>
     85a:	07 2e       	mov	r0, r23
     85c:	00 0c       	add	r0, r0
     85e:	88 0b       	sbc	r24, r24
     860:	99 0b       	sbc	r25, r25
     862:	a8 df       	rcall	.-176    	; 0x7b4 <UART_Transmit_Integer>
     864:	8b e1       	ldi	r24, 0x1B	; 27
     866:	92 e0       	ldi	r25, 0x02	; 2
     868:	97 df       	rcall	.-210    	; 0x798 <UART_Transmit_String>
     86a:	60 91 32 03 	lds	r22, 0x0332	; 0x800332 <gyroX>
     86e:	70 91 33 03 	lds	r23, 0x0333	; 0x800333 <gyroX+0x1>
     872:	07 2e       	mov	r0, r23
     874:	00 0c       	add	r0, r0
     876:	88 0b       	sbc	r24, r24
     878:	99 0b       	sbc	r25, r25
     87a:	9c df       	rcall	.-200    	; 0x7b4 <UART_Transmit_Integer>
     87c:	85 e2       	ldi	r24, 0x25	; 37
     87e:	92 e0       	ldi	r25, 0x02	; 2
     880:	8b df       	rcall	.-234    	; 0x798 <UART_Transmit_String>
     882:	60 91 67 04 	lds	r22, 0x0467	; 0x800467 <gyroY>
     886:	70 91 68 04 	lds	r23, 0x0468	; 0x800468 <gyroY+0x1>
     88a:	07 2e       	mov	r0, r23
     88c:	00 0c       	add	r0, r0
     88e:	88 0b       	sbc	r24, r24
     890:	99 0b       	sbc	r25, r25
     892:	90 df       	rcall	.-224    	; 0x7b4 <UART_Transmit_Integer>
     894:	8a e2       	ldi	r24, 0x2A	; 42
     896:	92 e0       	ldi	r25, 0x02	; 2
     898:	7f df       	rcall	.-258    	; 0x798 <UART_Transmit_String>
     89a:	60 91 4e 04 	lds	r22, 0x044E	; 0x80044e <gyroZ>
     89e:	70 91 4f 04 	lds	r23, 0x044F	; 0x80044f <gyroZ+0x1>
     8a2:	07 2e       	mov	r0, r23
     8a4:	00 0c       	add	r0, r0
     8a6:	88 0b       	sbc	r24, r24
     8a8:	99 0b       	sbc	r25, r25
     8aa:	84 df       	rcall	.-248    	; 0x7b4 <UART_Transmit_Integer>
     8ac:	8f e2       	ldi	r24, 0x2F	; 47
     8ae:	92 e0       	ldi	r25, 0x02	; 2
     8b0:	73 df       	rcall	.-282    	; 0x798 <UART_Transmit_String>
     8b2:	60 91 2c 03 	lds	r22, 0x032C	; 0x80032c <accelX>
     8b6:	70 91 2d 03 	lds	r23, 0x032D	; 0x80032d <accelX+0x1>
     8ba:	07 2e       	mov	r0, r23
     8bc:	00 0c       	add	r0, r0
     8be:	88 0b       	sbc	r24, r24
     8c0:	99 0b       	sbc	r25, r25
     8c2:	78 df       	rcall	.-272    	; 0x7b4 <UART_Transmit_Integer>
     8c4:	85 e2       	ldi	r24, 0x25	; 37
     8c6:	92 e0       	ldi	r25, 0x02	; 2
     8c8:	67 df       	rcall	.-306    	; 0x798 <UART_Transmit_String>
     8ca:	60 91 28 03 	lds	r22, 0x0328	; 0x800328 <accelY>
     8ce:	70 91 29 03 	lds	r23, 0x0329	; 0x800329 <accelY+0x1>
     8d2:	07 2e       	mov	r0, r23
     8d4:	00 0c       	add	r0, r0
     8d6:	88 0b       	sbc	r24, r24
     8d8:	99 0b       	sbc	r25, r25
     8da:	6c df       	rcall	.-296    	; 0x7b4 <UART_Transmit_Integer>
     8dc:	8a e2       	ldi	r24, 0x2A	; 42
     8de:	92 e0       	ldi	r25, 0x02	; 2
     8e0:	5b df       	rcall	.-330    	; 0x798 <UART_Transmit_String>
     8e2:	60 91 5f 04 	lds	r22, 0x045F	; 0x80045f <accelZ>
     8e6:	70 91 60 04 	lds	r23, 0x0460	; 0x800460 <accelZ+0x1>
     8ea:	07 2e       	mov	r0, r23
     8ec:	00 0c       	add	r0, r0
     8ee:	88 0b       	sbc	r24, r24
     8f0:	99 0b       	sbc	r25, r25
     8f2:	60 df       	rcall	.-320    	; 0x7b4 <UART_Transmit_Integer>
     8f4:	d0 93 5d 04 	sts	0x045D, r29	; 0x80045d <watchdogServo+0x1>
     8f8:	c0 93 5c 04 	sts	0x045C, r28	; 0x80045c <watchdogServo>
     8fc:	9b e1       	ldi	r25, 0x1B	; 27
     8fe:	e9 0e       	add	r14, r25
     900:	f1 1c       	adc	r15, r1
     902:	e8 ed       	ldi	r30, 0xD8	; 216
     904:	ee 16       	cp	r14, r30
     906:	f1 04       	cpc	r15, r1
     908:	09 f0       	breq	.+2      	; 0x90c <servoTaak+0x11c>
     90a:	78 cf       	rjmp	.-272    	; 0x7fc <servoTaak+0xc>
     90c:	75 cf       	rjmp	.-278    	; 0x7f8 <servoTaak+0x8>

0000090e <INT1_init>:
     90e:	e8 e6       	ldi	r30, 0x68	; 104
     910:	f0 e0       	ldi	r31, 0x00	; 0
     912:	80 81       	ld	r24, Z
     914:	81 60       	ori	r24, 0x01	; 1
     916:	80 83       	st	Z, r24
     918:	eb e6       	ldi	r30, 0x6B	; 107
     91a:	f0 e0       	ldi	r31, 0x00	; 0
     91c:	80 81       	ld	r24, Z
     91e:	82 60       	ori	r24, 0x02	; 2
     920:	80 83       	st	Z, r24
     922:	08 95       	ret

00000924 <__vector_9>:
     924:	1f 92       	push	r1
     926:	0f 92       	push	r0
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	0f 92       	push	r0
     92c:	11 24       	eor	r1, r1
     92e:	0b b6       	in	r0, 0x3b	; 59
     930:	0f 92       	push	r0
     932:	2f 93       	push	r18
     934:	3f 93       	push	r19
     936:	4f 93       	push	r20
     938:	5f 93       	push	r21
     93a:	6f 93       	push	r22
     93c:	7f 93       	push	r23
     93e:	8f 93       	push	r24
     940:	9f 93       	push	r25
     942:	af 93       	push	r26
     944:	bf 93       	push	r27
     946:	ef 93       	push	r30
     948:	ff 93       	push	r31
     94a:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <running>
     94e:	88 23       	and	r24, r24
     950:	d1 f1       	breq	.+116    	; 0x9c6 <__vector_9+0xa2>
     952:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <up>
     956:	81 11       	cpse	r24, r1
     958:	10 c0       	rjmp	.+32     	; 0x97a <__vector_9+0x56>
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <up>
     960:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <timerCounter>
     964:	10 92 bd 02 	sts	0x02BD, r1	; 0x8002bd <timerCounter+0x1>
     968:	10 92 be 02 	sts	0x02BE, r1	; 0x8002be <timerCounter+0x2>
     96c:	10 92 bf 02 	sts	0x02BF, r1	; 0x8002bf <timerCounter+0x3>
     970:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     974:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     978:	26 c0       	rjmp	.+76     	; 0x9c6 <__vector_9+0xa2>
     97a:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <up>
     97e:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <timerCounter>
     982:	30 91 bd 02 	lds	r19, 0x02BD	; 0x8002bd <timerCounter+0x1>
     986:	40 91 be 02 	lds	r20, 0x02BE	; 0x8002be <timerCounter+0x2>
     98a:	50 91 bf 02 	lds	r21, 0x02BF	; 0x8002bf <timerCounter+0x3>
     98e:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     992:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     996:	af ef       	ldi	r26, 0xFF	; 255
     998:	bf ef       	ldi	r27, 0xFF	; 255
     99a:	0e 94 6d 14 	call	0x28da	; 0x28da <__muluhisi3>
     99e:	6e 0f       	add	r22, r30
     9a0:	7f 1f       	adc	r23, r31
     9a2:	81 1d       	adc	r24, r1
     9a4:	91 1d       	adc	r25, r1
     9a6:	24 e7       	ldi	r18, 0x74	; 116
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	40 e0       	ldi	r20, 0x00	; 0
     9ac:	50 e0       	ldi	r21, 0x00	; 0
     9ae:	0e 94 34 14 	call	0x2868	; 0x2868 <__udivmodsi4>
     9b2:	20 93 b8 02 	sts	0x02B8, r18	; 0x8002b8 <result>
     9b6:	30 93 b9 02 	sts	0x02B9, r19	; 0x8002b9 <result+0x1>
     9ba:	40 93 ba 02 	sts	0x02BA, r20	; 0x8002ba <result+0x2>
     9be:	50 93 bb 02 	sts	0x02BB, r21	; 0x8002bb <result+0x3>
     9c2:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <running>
     9c6:	ff 91       	pop	r31
     9c8:	ef 91       	pop	r30
     9ca:	bf 91       	pop	r27
     9cc:	af 91       	pop	r26
     9ce:	9f 91       	pop	r25
     9d0:	8f 91       	pop	r24
     9d2:	7f 91       	pop	r23
     9d4:	6f 91       	pop	r22
     9d6:	5f 91       	pop	r21
     9d8:	4f 91       	pop	r20
     9da:	3f 91       	pop	r19
     9dc:	2f 91       	pop	r18
     9de:	0f 90       	pop	r0
     9e0:	0b be       	out	0x3b, r0	; 59
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	0f 90       	pop	r0
     9e8:	1f 90       	pop	r1
     9ea:	18 95       	reti

000009ec <pulse>:
     9ec:	28 98       	cbi	0x05, 0	; 5
     9ee:	85 e0       	ldi	r24, 0x05	; 5
     9f0:	8a 95       	dec	r24
     9f2:	f1 f7       	brne	.-4      	; 0x9f0 <pulse+0x4>
     9f4:	00 00       	nop
     9f6:	28 9a       	sbi	0x05, 0	; 5
     9f8:	81 e0       	ldi	r24, 0x01	; 1
     9fa:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <running>
     9fe:	85 e3       	ldi	r24, 0x35	; 53
     a00:	8a 95       	dec	r24
     a02:	f1 f7       	brne	.-4      	; 0xa00 <pulse+0x14>
     a04:	00 00       	nop
     a06:	28 98       	cbi	0x05, 0	; 5
     a08:	08 95       	ret

00000a0a <sonarTaak>:
     a0a:	c1 e0       	ldi	r28, 0x01	; 1
     a0c:	d0 e0       	ldi	r29, 0x00	; 0
     a0e:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <running>
     a12:	81 11       	cpse	r24, r1
     a14:	16 c0       	rjmp	.+44     	; 0xa42 <sonarTaak+0x38>
     a16:	2f ef       	ldi	r18, 0xFF	; 255
     a18:	80 e7       	ldi	r24, 0x70	; 112
     a1a:	92 e0       	ldi	r25, 0x02	; 2
     a1c:	21 50       	subi	r18, 0x01	; 1
     a1e:	80 40       	sbci	r24, 0x00	; 0
     a20:	90 40       	sbci	r25, 0x00	; 0
     a22:	e1 f7       	brne	.-8      	; 0xa1c <sonarTaak+0x12>
     a24:	00 c0       	rjmp	.+0      	; 0xa26 <sonarTaak+0x1c>
     a26:	00 00       	nop
     a28:	e1 df       	rcall	.-62     	; 0x9ec <pulse>
     a2a:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <result>
     a2e:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <result+0x1>
     a32:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <result+0x2>
     a36:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <result+0x3>
     a3a:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <afstand+0x1>
     a3e:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <afstand>
     a42:	d0 93 31 03 	sts	0x0331, r29	; 0x800331 <watchdogSonar+0x1>
     a46:	c0 93 30 03 	sts	0x0330, r28	; 0x800330 <watchdogSonar>
     a4a:	e1 cf       	rjmp	.-62     	; 0xa0e <sonarTaak+0x4>

00000a4c <timer3_init>:
     a4c:	e1 e9       	ldi	r30, 0x91	; 145
     a4e:	f0 e0       	ldi	r31, 0x00	; 0
     a50:	80 81       	ld	r24, Z
     a52:	82 60       	ori	r24, 0x02	; 2
     a54:	80 83       	st	Z, r24
     a56:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a5a:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a5e:	e1 e7       	ldi	r30, 0x71	; 113
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	80 81       	ld	r24, Z
     a64:	81 60       	ori	r24, 0x01	; 1
     a66:	80 83       	st	Z, r24
     a68:	08 95       	ret

00000a6a <__vector_35>:
     a6a:	1f 92       	push	r1
     a6c:	0f 92       	push	r0
     a6e:	0f b6       	in	r0, 0x3f	; 63
     a70:	0f 92       	push	r0
     a72:	11 24       	eor	r1, r1
     a74:	0b b6       	in	r0, 0x3b	; 59
     a76:	0f 92       	push	r0
     a78:	2f 93       	push	r18
     a7a:	3f 93       	push	r19
     a7c:	4f 93       	push	r20
     a7e:	5f 93       	push	r21
     a80:	6f 93       	push	r22
     a82:	7f 93       	push	r23
     a84:	8f 93       	push	r24
     a86:	9f 93       	push	r25
     a88:	af 93       	push	r26
     a8a:	bf 93       	push	r27
     a8c:	ef 93       	push	r30
     a8e:	ff 93       	push	r31
     a90:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <up>
     a94:	88 23       	and	r24, r24
     a96:	e9 f1       	breq	.+122    	; 0xb12 <__vector_35+0xa8>
     a98:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <timerCounter>
     a9c:	90 91 bd 02 	lds	r25, 0x02BD	; 0x8002bd <timerCounter+0x1>
     aa0:	a0 91 be 02 	lds	r26, 0x02BE	; 0x8002be <timerCounter+0x2>
     aa4:	b0 91 bf 02 	lds	r27, 0x02BF	; 0x8002bf <timerCounter+0x3>
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	a1 1d       	adc	r26, r1
     aac:	b1 1d       	adc	r27, r1
     aae:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <timerCounter>
     ab2:	90 93 bd 02 	sts	0x02BD, r25	; 0x8002bd <timerCounter+0x1>
     ab6:	a0 93 be 02 	sts	0x02BE, r26	; 0x8002be <timerCounter+0x2>
     aba:	b0 93 bf 02 	sts	0x02BF, r27	; 0x8002bf <timerCounter+0x3>
     abe:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <timerCounter>
     ac2:	30 91 bd 02 	lds	r19, 0x02BD	; 0x8002bd <timerCounter+0x1>
     ac6:	40 91 be 02 	lds	r20, 0x02BE	; 0x8002be <timerCounter+0x2>
     aca:	50 91 bf 02 	lds	r21, 0x02BF	; 0x8002bf <timerCounter+0x3>
     ace:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     ad2:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     ad6:	af ef       	ldi	r26, 0xFF	; 255
     ad8:	bf ef       	ldi	r27, 0xFF	; 255
     ada:	0e 94 6d 14 	call	0x28da	; 0x28da <__muluhisi3>
     ade:	dc 01       	movw	r26, r24
     ae0:	cb 01       	movw	r24, r22
     ae2:	8e 0f       	add	r24, r30
     ae4:	9f 1f       	adc	r25, r31
     ae6:	a1 1d       	adc	r26, r1
     ae8:	b1 1d       	adc	r27, r1
     aea:	81 30       	cpi	r24, 0x01	; 1
     aec:	94 4d       	sbci	r25, 0xD4	; 212
     aee:	a0 43       	sbci	r26, 0x30	; 48
     af0:	b1 05       	cpc	r27, r1
     af2:	78 f0       	brcs	.+30     	; 0xb12 <__vector_35+0xa8>
     af4:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <up>
     af8:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <running>
     afc:	8f ef       	ldi	r24, 0xFF	; 255
     afe:	9f ef       	ldi	r25, 0xFF	; 255
     b00:	dc 01       	movw	r26, r24
     b02:	80 93 b8 02 	sts	0x02B8, r24	; 0x8002b8 <result>
     b06:	90 93 b9 02 	sts	0x02B9, r25	; 0x8002b9 <result+0x1>
     b0a:	a0 93 ba 02 	sts	0x02BA, r26	; 0x8002ba <result+0x2>
     b0e:	b0 93 bb 02 	sts	0x02BB, r27	; 0x8002bb <result+0x3>
     b12:	ff 91       	pop	r31
     b14:	ef 91       	pop	r30
     b16:	bf 91       	pop	r27
     b18:	af 91       	pop	r26
     b1a:	9f 91       	pop	r25
     b1c:	8f 91       	pop	r24
     b1e:	7f 91       	pop	r23
     b20:	6f 91       	pop	r22
     b22:	5f 91       	pop	r21
     b24:	4f 91       	pop	r20
     b26:	3f 91       	pop	r19
     b28:	2f 91       	pop	r18
     b2a:	0f 90       	pop	r0
     b2c:	0b be       	out	0x3b, r0	; 59
     b2e:	0f 90       	pop	r0
     b30:	0f be       	out	0x3f, r0	; 63
     b32:	0f 90       	pop	r0
     b34:	1f 90       	pop	r1
     b36:	18 95       	reti

00000b38 <initServo>:
     b38:	26 9a       	sbi	0x04, 6	; 4
     b3a:	82 e3       	ldi	r24, 0x32	; 50
     b3c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     b40:	82 e1       	ldi	r24, 0x12	; 18
     b42:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
     b46:	80 e2       	ldi	r24, 0x20	; 32
     b48:	9e e4       	ldi	r25, 0x4E	; 78
     b4a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     b4e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     b52:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     b56:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
     b5a:	80 e0       	ldi	r24, 0x00	; 0
     b5c:	9b e4       	ldi	r25, 0x4B	; 75
     b5e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     b62:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     b66:	ef e6       	ldi	r30, 0x6F	; 111
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	82 60       	ori	r24, 0x02	; 2
     b6e:	80 83       	st	Z, r24
     b70:	08 95       	ret

00000b72 <init_master>:
     b72:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     b76:	88 e4       	ldi	r24, 0x48	; 72
     b78:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
     b7c:	84 e0       	ldi	r24, 0x04	; 4
     b7e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     b82:	08 95       	ret

00000b84 <ontvangen>:
     b84:	ef 92       	push	r14
     b86:	ff 92       	push	r15
     b88:	0f 93       	push	r16
     b8a:	1f 93       	push	r17
     b8c:	cf 93       	push	r28
     b8e:	df 93       	push	r29
     b90:	ec eb       	ldi	r30, 0xBC	; 188
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	90 81       	ld	r25, Z
     b96:	90 62       	ori	r25, 0x20	; 32
     b98:	90 83       	st	Z, r25
     b9a:	90 81       	ld	r25, Z
     b9c:	99 23       	and	r25, r25
     b9e:	ec f7       	brge	.-6      	; 0xb9a <ontvangen+0x16>
     ba0:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     ba4:	88 0f       	add	r24, r24
     ba6:	8f 5f       	subi	r24, 0xFF	; 255
     ba8:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     bac:	84 e8       	ldi	r24, 0x84	; 132
     bae:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     bb2:	ec eb       	ldi	r30, 0xBC	; 188
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	88 23       	and	r24, r24
     bba:	ec f7       	brge	.-6      	; 0xbb6 <ontvangen+0x32>
     bbc:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     bc0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     bc4:	db 01       	movw	r26, r22
     bc6:	8c 93       	st	X, r24
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	50 e0       	ldi	r21, 0x00	; 0
     bcc:	41 50       	subi	r20, 0x01	; 1
     bce:	51 09       	sbc	r21, r1
     bd0:	ec eb       	ldi	r30, 0xBC	; 188
     bd2:	f0 e0       	ldi	r31, 0x00	; 0
     bd4:	0f 2e       	mov	r0, r31
     bd6:	f4 ec       	ldi	r31, 0xC4	; 196
     bd8:	ff 2e       	mov	r15, r31
     bda:	f0 2d       	mov	r31, r0
     bdc:	0f 2e       	mov	r0, r31
     bde:	f4 e8       	ldi	r31, 0x84	; 132
     be0:	ef 2e       	mov	r14, r31
     be2:	f0 2d       	mov	r31, r0
     be4:	09 eb       	ldi	r16, 0xB9	; 185
     be6:	10 e0       	ldi	r17, 0x00	; 0
     be8:	cb eb       	ldi	r28, 0xBB	; 187
     bea:	d0 e0       	ldi	r29, 0x00	; 0
     bec:	29 2f       	mov	r18, r25
     bee:	30 e0       	ldi	r19, 0x00	; 0
     bf0:	24 17       	cp	r18, r20
     bf2:	35 07       	cpc	r19, r21
     bf4:	11 f4       	brne	.+4      	; 0xbfa <ontvangen+0x76>
     bf6:	e0 82       	st	Z, r14
     bf8:	01 c0       	rjmp	.+2      	; 0xbfc <ontvangen+0x78>
     bfa:	f0 82       	st	Z, r15
     bfc:	80 81       	ld	r24, Z
     bfe:	88 23       	and	r24, r24
     c00:	ec f7       	brge	.-6      	; 0xbfc <ontvangen+0x78>
     c02:	d8 01       	movw	r26, r16
     c04:	8c 91       	ld	r24, X
     c06:	28 81       	ld	r18, Y
     c08:	db 01       	movw	r26, r22
     c0a:	a9 0f       	add	r26, r25
     c0c:	b1 1d       	adc	r27, r1
     c0e:	2c 93       	st	X, r18
     c10:	9f 5f       	subi	r25, 0xFF	; 255
     c12:	80 35       	cpi	r24, 0x50	; 80
     c14:	59 f3       	breq	.-42     	; 0xbec <ontvangen+0x68>
     c16:	84 e9       	ldi	r24, 0x94	; 148
     c18:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	ff 90       	pop	r15
     c26:	ef 90       	pop	r14
     c28:	08 95       	ret

00000c2a <verzenden>:
     c2a:	ec eb       	ldi	r30, 0xBC	; 188
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	90 81       	ld	r25, Z
     c30:	90 62       	ori	r25, 0x20	; 32
     c32:	90 83       	st	Z, r25
     c34:	90 81       	ld	r25, Z
     c36:	99 23       	and	r25, r25
     c38:	ec f7       	brge	.-6      	; 0xc34 <verzenden+0xa>
     c3a:	88 0f       	add	r24, r24
     c3c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c40:	84 e8       	ldi	r24, 0x84	; 132
     c42:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c46:	ec eb       	ldi	r30, 0xBC	; 188
     c48:	f0 e0       	ldi	r31, 0x00	; 0
     c4a:	80 81       	ld	r24, Z
     c4c:	88 23       	and	r24, r24
     c4e:	ec f7       	brge	.-6      	; 0xc4a <verzenden+0x20>
     c50:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c54:	84 e8       	ldi	r24, 0x84	; 132
     c56:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c5a:	ec eb       	ldi	r30, 0xBC	; 188
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	80 81       	ld	r24, Z
     c60:	88 23       	and	r24, r24
     c62:	ec f7       	brge	.-6      	; 0xc5e <verzenden+0x34>
     c64:	84 e9       	ldi	r24, 0x94	; 148
     c66:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c6a:	08 95       	ret

00000c6c <gyroTaak>:
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	1f 92       	push	r1
     c72:	1f 92       	push	r1
     c74:	cd b7       	in	r28, 0x3d	; 61
     c76:	de b7       	in	r29, 0x3e	; 62
     c78:	01 e0       	ldi	r16, 0x01	; 1
     c7a:	10 e0       	ldi	r17, 0x00	; 0
     c7c:	6b e3       	ldi	r22, 0x3B	; 59
     c7e:	88 e6       	ldi	r24, 0x68	; 104
     c80:	d4 df       	rcall	.-88     	; 0xc2a <verzenden>
     c82:	41 e0       	ldi	r20, 0x01	; 1
     c84:	be 01       	movw	r22, r28
     c86:	6f 5f       	subi	r22, 0xFF	; 255
     c88:	7f 4f       	sbci	r23, 0xFF	; 255
     c8a:	88 e6       	ldi	r24, 0x68	; 104
     c8c:	7b df       	rcall	.-266    	; 0xb84 <ontvangen>
     c8e:	f9 80       	ldd	r15, Y+1	; 0x01
     c90:	6c e3       	ldi	r22, 0x3C	; 60
     c92:	88 e6       	ldi	r24, 0x68	; 104
     c94:	ca df       	rcall	.-108    	; 0xc2a <verzenden>
     c96:	41 e0       	ldi	r20, 0x01	; 1
     c98:	be 01       	movw	r22, r28
     c9a:	6f 5f       	subi	r22, 0xFF	; 255
     c9c:	7f 4f       	sbci	r23, 0xFF	; 255
     c9e:	88 e6       	ldi	r24, 0x68	; 104
     ca0:	71 df       	rcall	.-286    	; 0xb84 <ontvangen>
     ca2:	6f 2d       	mov	r22, r15
     ca4:	70 e0       	ldi	r23, 0x00	; 0
     ca6:	76 2f       	mov	r23, r22
     ca8:	66 27       	eor	r22, r22
     caa:	89 81       	ldd	r24, Y+1	; 0x01
     cac:	68 2b       	or	r22, r24
     cae:	80 e0       	ldi	r24, 0x00	; 0
     cb0:	90 e0       	ldi	r25, 0x00	; 0
     cb2:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     cb6:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <_gyroScale>
     cba:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <_gyroScale+0x1>
     cbe:	40 91 6b 04 	lds	r20, 0x046B	; 0x80046b <_gyroScale+0x2>
     cc2:	50 91 6c 04 	lds	r21, 0x046C	; 0x80046c <_gyroScale+0x3>
     cc6:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     cca:	20 e0       	ldi	r18, 0x00	; 0
     ccc:	30 e0       	ldi	r19, 0x00	; 0
     cce:	4a e8       	ldi	r20, 0x8A	; 138
     cd0:	52 e4       	ldi	r21, 0x42	; 66
     cd2:	0e 94 ad 12 	call	0x255a	; 0x255a <__subsf3>
     cd6:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     cda:	70 93 33 03 	sts	0x0333, r23	; 0x800333 <gyroX+0x1>
     cde:	60 93 32 03 	sts	0x0332, r22	; 0x800332 <gyroX>
     ce2:	6d e3       	ldi	r22, 0x3D	; 61
     ce4:	88 e6       	ldi	r24, 0x68	; 104
     ce6:	a1 df       	rcall	.-190    	; 0xc2a <verzenden>
     ce8:	41 e0       	ldi	r20, 0x01	; 1
     cea:	be 01       	movw	r22, r28
     cec:	6f 5f       	subi	r22, 0xFF	; 255
     cee:	7f 4f       	sbci	r23, 0xFF	; 255
     cf0:	88 e6       	ldi	r24, 0x68	; 104
     cf2:	48 df       	rcall	.-368    	; 0xb84 <ontvangen>
     cf4:	f9 80       	ldd	r15, Y+1	; 0x01
     cf6:	6e e3       	ldi	r22, 0x3E	; 62
     cf8:	88 e6       	ldi	r24, 0x68	; 104
     cfa:	97 df       	rcall	.-210    	; 0xc2a <verzenden>
     cfc:	41 e0       	ldi	r20, 0x01	; 1
     cfe:	be 01       	movw	r22, r28
     d00:	6f 5f       	subi	r22, 0xFF	; 255
     d02:	7f 4f       	sbci	r23, 0xFF	; 255
     d04:	88 e6       	ldi	r24, 0x68	; 104
     d06:	3e df       	rcall	.-388    	; 0xb84 <ontvangen>
     d08:	6f 2d       	mov	r22, r15
     d0a:	70 e0       	ldi	r23, 0x00	; 0
     d0c:	76 2f       	mov	r23, r22
     d0e:	66 27       	eor	r22, r22
     d10:	89 81       	ldd	r24, Y+1	; 0x01
     d12:	68 2b       	or	r22, r24
     d14:	80 e0       	ldi	r24, 0x00	; 0
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     d1c:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <_gyroScale>
     d20:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <_gyroScale+0x1>
     d24:	40 91 6b 04 	lds	r20, 0x046B	; 0x80046b <_gyroScale+0x2>
     d28:	50 91 6c 04 	lds	r21, 0x046C	; 0x80046c <_gyroScale+0x3>
     d2c:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     d30:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     d34:	70 93 68 04 	sts	0x0468, r23	; 0x800468 <gyroY+0x1>
     d38:	60 93 67 04 	sts	0x0467, r22	; 0x800467 <gyroY>
     d3c:	6f e3       	ldi	r22, 0x3F	; 63
     d3e:	88 e6       	ldi	r24, 0x68	; 104
     d40:	74 df       	rcall	.-280    	; 0xc2a <verzenden>
     d42:	41 e0       	ldi	r20, 0x01	; 1
     d44:	be 01       	movw	r22, r28
     d46:	6f 5f       	subi	r22, 0xFF	; 255
     d48:	7f 4f       	sbci	r23, 0xFF	; 255
     d4a:	88 e6       	ldi	r24, 0x68	; 104
     d4c:	1b df       	rcall	.-458    	; 0xb84 <ontvangen>
     d4e:	f9 80       	ldd	r15, Y+1	; 0x01
     d50:	60 e4       	ldi	r22, 0x40	; 64
     d52:	88 e6       	ldi	r24, 0x68	; 104
     d54:	6a df       	rcall	.-300    	; 0xc2a <verzenden>
     d56:	41 e0       	ldi	r20, 0x01	; 1
     d58:	be 01       	movw	r22, r28
     d5a:	6f 5f       	subi	r22, 0xFF	; 255
     d5c:	7f 4f       	sbci	r23, 0xFF	; 255
     d5e:	88 e6       	ldi	r24, 0x68	; 104
     d60:	11 df       	rcall	.-478    	; 0xb84 <ontvangen>
     d62:	6f 2d       	mov	r22, r15
     d64:	70 e0       	ldi	r23, 0x00	; 0
     d66:	76 2f       	mov	r23, r22
     d68:	66 27       	eor	r22, r22
     d6a:	89 81       	ldd	r24, Y+1	; 0x01
     d6c:	68 2b       	or	r22, r24
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     d76:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <_gyroScale>
     d7a:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <_gyroScale+0x1>
     d7e:	40 91 6b 04 	lds	r20, 0x046B	; 0x80046b <_gyroScale+0x2>
     d82:	50 91 6c 04 	lds	r21, 0x046C	; 0x80046c <_gyroScale+0x3>
     d86:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     d8a:	20 e0       	ldi	r18, 0x00	; 0
     d8c:	30 e0       	ldi	r19, 0x00	; 0
     d8e:	40 e8       	ldi	r20, 0x80	; 128
     d90:	51 e4       	ldi	r21, 0x41	; 65
     d92:	0e 94 ad 12 	call	0x255a	; 0x255a <__subsf3>
     d96:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     d9a:	70 93 4f 04 	sts	0x044F, r23	; 0x80044f <gyroZ+0x1>
     d9e:	60 93 4e 04 	sts	0x044E, r22	; 0x80044e <gyroZ>
     da2:	63 e4       	ldi	r22, 0x43	; 67
     da4:	88 e6       	ldi	r24, 0x68	; 104
     da6:	41 df       	rcall	.-382    	; 0xc2a <verzenden>
     da8:	41 e0       	ldi	r20, 0x01	; 1
     daa:	be 01       	movw	r22, r28
     dac:	6f 5f       	subi	r22, 0xFF	; 255
     dae:	7f 4f       	sbci	r23, 0xFF	; 255
     db0:	88 e6       	ldi	r24, 0x68	; 104
     db2:	e8 de       	rcall	.-560    	; 0xb84 <ontvangen>
     db4:	f9 80       	ldd	r15, Y+1	; 0x01
     db6:	64 e4       	ldi	r22, 0x44	; 68
     db8:	88 e6       	ldi	r24, 0x68	; 104
     dba:	37 df       	rcall	.-402    	; 0xc2a <verzenden>
     dbc:	41 e0       	ldi	r20, 0x01	; 1
     dbe:	be 01       	movw	r22, r28
     dc0:	6f 5f       	subi	r22, 0xFF	; 255
     dc2:	7f 4f       	sbci	r23, 0xFF	; 255
     dc4:	88 e6       	ldi	r24, 0x68	; 104
     dc6:	de de       	rcall	.-580    	; 0xb84 <ontvangen>
     dc8:	6f 2d       	mov	r22, r15
     dca:	70 e0       	ldi	r23, 0x00	; 0
     dcc:	76 2f       	mov	r23, r22
     dce:	66 27       	eor	r22, r22
     dd0:	89 81       	ldd	r24, Y+1	; 0x01
     dd2:	68 2b       	or	r22, r24
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     ddc:	20 91 63 04 	lds	r18, 0x0463	; 0x800463 <_accelScale>
     de0:	30 91 64 04 	lds	r19, 0x0464	; 0x800464 <_accelScale+0x1>
     de4:	40 91 65 04 	lds	r20, 0x0465	; 0x800465 <_accelScale+0x2>
     de8:	50 91 66 04 	lds	r21, 0x0466	; 0x800466 <_accelScale+0x3>
     dec:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     df0:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     df4:	70 93 2d 03 	sts	0x032D, r23	; 0x80032d <accelX+0x1>
     df8:	60 93 2c 03 	sts	0x032C, r22	; 0x80032c <accelX>
     dfc:	65 e4       	ldi	r22, 0x45	; 69
     dfe:	88 e6       	ldi	r24, 0x68	; 104
     e00:	14 df       	rcall	.-472    	; 0xc2a <verzenden>
     e02:	41 e0       	ldi	r20, 0x01	; 1
     e04:	be 01       	movw	r22, r28
     e06:	6f 5f       	subi	r22, 0xFF	; 255
     e08:	7f 4f       	sbci	r23, 0xFF	; 255
     e0a:	88 e6       	ldi	r24, 0x68	; 104
     e0c:	bb de       	rcall	.-650    	; 0xb84 <ontvangen>
     e0e:	f9 80       	ldd	r15, Y+1	; 0x01
     e10:	66 e4       	ldi	r22, 0x46	; 70
     e12:	88 e6       	ldi	r24, 0x68	; 104
     e14:	0a df       	rcall	.-492    	; 0xc2a <verzenden>
     e16:	41 e0       	ldi	r20, 0x01	; 1
     e18:	be 01       	movw	r22, r28
     e1a:	6f 5f       	subi	r22, 0xFF	; 255
     e1c:	7f 4f       	sbci	r23, 0xFF	; 255
     e1e:	88 e6       	ldi	r24, 0x68	; 104
     e20:	b1 de       	rcall	.-670    	; 0xb84 <ontvangen>
     e22:	6f 2d       	mov	r22, r15
     e24:	70 e0       	ldi	r23, 0x00	; 0
     e26:	76 2f       	mov	r23, r22
     e28:	66 27       	eor	r22, r22
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	68 2b       	or	r22, r24
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     e36:	20 91 63 04 	lds	r18, 0x0463	; 0x800463 <_accelScale>
     e3a:	30 91 64 04 	lds	r19, 0x0464	; 0x800464 <_accelScale+0x1>
     e3e:	40 91 65 04 	lds	r20, 0x0465	; 0x800465 <_accelScale+0x2>
     e42:	50 91 66 04 	lds	r21, 0x0466	; 0x800466 <_accelScale+0x3>
     e46:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     e4a:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     e4e:	70 93 29 03 	sts	0x0329, r23	; 0x800329 <accelY+0x1>
     e52:	60 93 28 03 	sts	0x0328, r22	; 0x800328 <accelY>
     e56:	67 e4       	ldi	r22, 0x47	; 71
     e58:	88 e6       	ldi	r24, 0x68	; 104
     e5a:	e7 de       	rcall	.-562    	; 0xc2a <verzenden>
     e5c:	41 e0       	ldi	r20, 0x01	; 1
     e5e:	be 01       	movw	r22, r28
     e60:	6f 5f       	subi	r22, 0xFF	; 255
     e62:	7f 4f       	sbci	r23, 0xFF	; 255
     e64:	88 e6       	ldi	r24, 0x68	; 104
     e66:	8e de       	rcall	.-740    	; 0xb84 <ontvangen>
     e68:	f9 80       	ldd	r15, Y+1	; 0x01
     e6a:	68 e4       	ldi	r22, 0x48	; 72
     e6c:	88 e6       	ldi	r24, 0x68	; 104
     e6e:	dd de       	rcall	.-582    	; 0xc2a <verzenden>
     e70:	41 e0       	ldi	r20, 0x01	; 1
     e72:	be 01       	movw	r22, r28
     e74:	6f 5f       	subi	r22, 0xFF	; 255
     e76:	7f 4f       	sbci	r23, 0xFF	; 255
     e78:	88 e6       	ldi	r24, 0x68	; 104
     e7a:	84 de       	rcall	.-760    	; 0xb84 <ontvangen>
     e7c:	6f 2d       	mov	r22, r15
     e7e:	70 e0       	ldi	r23, 0x00	; 0
     e80:	76 2f       	mov	r23, r22
     e82:	66 27       	eor	r22, r22
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	68 2b       	or	r22, r24
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	0e 94 43 13 	call	0x2686	; 0x2686 <__floatunsisf>
     e90:	20 91 63 04 	lds	r18, 0x0463	; 0x800463 <_accelScale>
     e94:	30 91 64 04 	lds	r19, 0x0464	; 0x800464 <_accelScale+0x1>
     e98:	40 91 65 04 	lds	r20, 0x0465	; 0x800465 <_accelScale+0x2>
     e9c:	50 91 66 04 	lds	r21, 0x0466	; 0x800466 <_accelScale+0x3>
     ea0:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <__mulsf3>
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	30 e8       	ldi	r19, 0x80	; 128
     ea8:	4c e9       	ldi	r20, 0x9C	; 156
     eaa:	53 e4       	ldi	r21, 0x43	; 67
     eac:	0e 94 ad 12 	call	0x255a	; 0x255a <__subsf3>
     eb0:	0e 94 12 13 	call	0x2624	; 0x2624 <__fixsfsi>
     eb4:	70 93 60 04 	sts	0x0460, r23	; 0x800460 <accelZ+0x1>
     eb8:	60 93 5f 04 	sts	0x045F, r22	; 0x80045f <accelZ>
     ebc:	10 93 2f 03 	sts	0x032F, r17	; 0x80032f <watchdogGyro+0x1>
     ec0:	00 93 2e 03 	sts	0x032E, r16	; 0x80032e <watchdogGyro>
     ec4:	db ce       	rjmp	.-586    	; 0xc7c <gyroTaak+0x10>

00000ec6 <__vector_17>:
     ec6:	1f 92       	push	r1
     ec8:	0f 92       	push	r0
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	0f 92       	push	r0
     ece:	11 24       	eor	r1, r1
     ed0:	8f 93       	push	r24
     ed2:	9f 93       	push	r25
     ed4:	95 b1       	in	r25, 0x05	; 5
     ed6:	80 e4       	ldi	r24, 0x40	; 64
     ed8:	89 27       	eor	r24, r25
     eda:	85 b9       	out	0x05, r24	; 5
     edc:	9f 91       	pop	r25
     ede:	8f 91       	pop	r24
     ee0:	0f 90       	pop	r0
     ee2:	0f be       	out	0x3f, r0	; 63
     ee4:	0f 90       	pop	r0
     ee6:	1f 90       	pop	r1
     ee8:	18 95       	reti

00000eea <motorAchteruit>:
     eea:	eb e0       	ldi	r30, 0x0B	; 11
     eec:	f1 e0       	ldi	r31, 0x01	; 1
     eee:	80 81       	ld	r24, Z
     ef0:	8f 77       	andi	r24, 0x7F	; 127
     ef2:	80 83       	st	Z, r24
     ef4:	5f 98       	cbi	0x0b, 7	; 11
     ef6:	a1 9a       	sbi	0x14, 1	; 20
     ef8:	41 9a       	sbi	0x08, 1	; 8
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f02:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f06:	08 95       	ret

00000f08 <motorVooruit>:
     f08:	a1 98       	cbi	0x14, 1	; 20
     f0a:	41 98       	cbi	0x08, 1	; 8
     f0c:	eb e0       	ldi	r30, 0x0B	; 11
     f0e:	f1 e0       	ldi	r31, 0x01	; 1
     f10:	80 81       	ld	r24, Z
     f12:	80 68       	ori	r24, 0x80	; 128
     f14:	80 83       	st	Z, r24
     f16:	5f 9a       	sbi	0x0b, 7	; 11
     f18:	81 e0       	ldi	r24, 0x01	; 1
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f20:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f24:	08 95       	ret

00000f26 <motorRechts>:
     f26:	5f 98       	cbi	0x0b, 7	; 11
     f28:	a1 98       	cbi	0x14, 1	; 20
     f2a:	eb e0       	ldi	r30, 0x0B	; 11
     f2c:	f1 e0       	ldi	r31, 0x01	; 1
     f2e:	80 81       	ld	r24, Z
     f30:	80 68       	ori	r24, 0x80	; 128
     f32:	80 83       	st	Z, r24
     f34:	41 9a       	sbi	0x08, 1	; 8
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f3e:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f42:	08 95       	ret

00000f44 <motorLinks>:
     f44:	41 98       	cbi	0x08, 1	; 8
     f46:	eb e0       	ldi	r30, 0x0B	; 11
     f48:	f1 e0       	ldi	r31, 0x01	; 1
     f4a:	80 81       	ld	r24, Z
     f4c:	8f 77       	andi	r24, 0x7F	; 127
     f4e:	80 83       	st	Z, r24
     f50:	a1 9a       	sbi	0x14, 1	; 20
     f52:	5f 9a       	sbi	0x0b, 7	; 11
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f5c:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f60:	08 95       	ret

00000f62 <motorStop>:
     f62:	a1 98       	cbi	0x14, 1	; 20
     f64:	eb e0       	ldi	r30, 0x0B	; 11
     f66:	f1 e0       	ldi	r31, 0x01	; 1
     f68:	80 81       	ld	r24, Z
     f6a:	8f 77       	andi	r24, 0x7F	; 127
     f6c:	80 83       	st	Z, r24
     f6e:	41 98       	cbi	0x08, 1	; 8
     f70:	5f 98       	cbi	0x0b, 7	; 11
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f7a:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f7e:	08 95       	ret

00000f80 <motorEnable>:
     f80:	f0 df       	rcall	.-32     	; 0xf62 <motorStop>
     f82:	eb e0       	ldi	r30, 0x0B	; 11
     f84:	f1 e0       	ldi	r31, 0x01	; 1
     f86:	80 81       	ld	r24, Z
     f88:	88 60       	ori	r24, 0x08	; 8
     f8a:	80 83       	st	Z, r24
     f8c:	80 81       	ld	r24, Z
     f8e:	80 62       	ori	r24, 0x20	; 32
     f90:	80 83       	st	Z, r24
     f92:	08 95       	ret

00000f94 <initMotor>:
     f94:	39 9a       	sbi	0x07, 1	; 7
     f96:	57 9a       	sbi	0x0a, 7	; 10
     f98:	ea e0       	ldi	r30, 0x0A	; 10
     f9a:	f1 e0       	ldi	r31, 0x01	; 1
     f9c:	80 81       	ld	r24, Z
     f9e:	88 6a       	ori	r24, 0xA8	; 168
     fa0:	80 83       	st	Z, r24
     fa2:	99 9a       	sbi	0x13, 1	; 19
     fa4:	8e ec       	ldi	r24, 0xCE	; 206
     fa6:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
     faa:	82 e1       	ldi	r24, 0x12	; 18
     fac:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
     fb0:	80 e2       	ldi	r24, 0x20	; 32
     fb2:	9e e4       	ldi	r25, 0x4E	; 78
     fb4:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     fb8:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
     fbc:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     fc0:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     fc4:	dd cf       	rjmp	.-70     	; 0xf80 <motorEnable>
     fc6:	08 95       	ret

00000fc8 <main>:
     fc8:	ef 92       	push	r14
     fca:	ff 92       	push	r15
     fcc:	0f 93       	push	r16
     fce:	43 e0       	ldi	r20, 0x03	; 3
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	c2 d3       	rcall	.+1924   	; 0x175a <xQueueGenericCreate>
     fd6:	90 93 2b 03 	sts	0x032B, r25	; 0x80032b <sem+0x1>
     fda:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <sem>
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	40 e0       	ldi	r20, 0x00	; 0
     fe2:	50 e0       	ldi	r21, 0x00	; 0
     fe4:	60 e0       	ldi	r22, 0x00	; 0
     fe6:	70 e0       	ldi	r23, 0x00	; 0
     fe8:	e4 d3       	rcall	.+1992   	; 0x17b2 <xQueueGenericSend>
     fea:	8a b1       	in	r24, 0x0a	; 10
     fec:	83 60       	ori	r24, 0x03	; 3
     fee:	8a b9       	out	0x0a, r24	; 10
     ff0:	20 9a       	sbi	0x04, 0	; 4
     ff2:	d0 df       	rcall	.-96     	; 0xf94 <initMotor>
     ff4:	40 e0       	ldi	r20, 0x00	; 0
     ff6:	61 e0       	ldi	r22, 0x01	; 1
     ff8:	8a e0       	ldi	r24, 0x0A	; 10
     ffa:	af d3       	rcall	.+1886   	; 0x175a <xQueueGenericCreate>
     ffc:	90 93 37 04 	sts	0x0437, r25	; 0x800437 <motorCommand+0x1>
    1000:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <motorCommand>
    1004:	a3 db       	rcall	.-2234   	; 0x74c <UART_Init>
    1006:	83 dc       	rcall	.-1786   	; 0x90e <INT1_init>
    1008:	21 dd       	rcall	.-1470   	; 0xa4c <timer3_init>
    100a:	96 dd       	rcall	.-1236   	; 0xb38 <initServo>
    100c:	78 94       	sei
    100e:	b1 dd       	rcall	.-1182   	; 0xb72 <init_master>
    1010:	10 92 31 03 	sts	0x0331, r1	; 0x800331 <watchdogSonar+0x1>
    1014:	10 92 30 03 	sts	0x0330, r1	; 0x800330 <watchdogSonar>
    1018:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <watchdogServo+0x1>
    101c:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <watchdogServo>
    1020:	10 92 51 04 	sts	0x0451, r1	; 0x800451 <watchdogTemp+0x1>
    1024:	10 92 50 04 	sts	0x0450, r1	; 0x800450 <watchdogTemp>
    1028:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <watchdogMotor+0x1>
    102c:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <watchdogMotor>
    1030:	98 e2       	ldi	r25, 0x28	; 40
    1032:	88 e1       	ldi	r24, 0x18	; 24
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	f8 94       	cli
    1038:	a8 95       	wdr
    103a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    103e:	0f be       	out	0x3f, r0	; 63
    1040:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1044:	86 e1       	ldi	r24, 0x16	; 22
    1046:	9a ee       	ldi	r25, 0xEA	; 234
    1048:	ac e9       	ldi	r26, 0x9C	; 156
    104a:	bb e3       	ldi	r27, 0x3B	; 59
    104c:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <_accelScale>
    1050:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <_accelScale+0x1>
    1054:	a0 93 65 04 	sts	0x0465, r26	; 0x800465 <_accelScale+0x2>
    1058:	b0 93 66 04 	sts	0x0466, r27	; 0x800466 <_accelScale+0x3>
    105c:	83 ee       	ldi	r24, 0xE3	; 227
    105e:	90 ea       	ldi	r25, 0xA0	; 160
    1060:	ab e8       	ldi	r26, 0x8B	; 139
    1062:	ba e3       	ldi	r27, 0x3A	; 58
    1064:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <_gyroScale>
    1068:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <_gyroScale+0x1>
    106c:	a0 93 6b 04 	sts	0x046B, r26	; 0x80046b <_gyroScale+0x2>
    1070:	b0 93 6c 04 	sts	0x046C, r27	; 0x80046c <_gyroScale+0x3>
    1074:	8a e3       	ldi	r24, 0x3A	; 58
    1076:	92 e0       	ldi	r25, 0x02	; 2
    1078:	8f db       	rcall	.-2274   	; 0x798 <UART_Transmit_String>
    107a:	e1 2c       	mov	r14, r1
    107c:	f1 2c       	mov	r15, r1
    107e:	03 e0       	ldi	r16, 0x03	; 3
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	40 e0       	ldi	r20, 0x00	; 0
    1086:	51 e0       	ldi	r21, 0x01	; 1
    1088:	69 e4       	ldi	r22, 0x49	; 73
    108a:	72 e0       	ldi	r23, 0x02	; 2
    108c:	85 e0       	ldi	r24, 0x05	; 5
    108e:	95 e0       	ldi	r25, 0x05	; 5
    1090:	7b d6       	rcall	.+3318   	; 0x1d88 <xTaskCreate>
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	40 e0       	ldi	r20, 0x00	; 0
    1098:	51 e0       	ldi	r21, 0x01	; 1
    109a:	66 e5       	ldi	r22, 0x56	; 86
    109c:	72 e0       	ldi	r23, 0x02	; 2
    109e:	88 ef       	ldi	r24, 0xF8	; 248
    10a0:	93 e0       	ldi	r25, 0x03	; 3
    10a2:	72 d6       	rcall	.+3300   	; 0x1d88 <xTaskCreate>
    10a4:	20 e0       	ldi	r18, 0x00	; 0
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	40 e0       	ldi	r20, 0x00	; 0
    10aa:	51 e0       	ldi	r21, 0x01	; 1
    10ac:	62 e6       	ldi	r22, 0x62	; 98
    10ae:	72 e0       	ldi	r23, 0x02	; 2
    10b0:	86 e3       	ldi	r24, 0x36	; 54
    10b2:	96 e0       	ldi	r25, 0x06	; 6
    10b4:	69 d6       	rcall	.+3282   	; 0x1d88 <xTaskCreate>
    10b6:	20 e0       	ldi	r18, 0x00	; 0
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	40 e0       	ldi	r20, 0x00	; 0
    10bc:	51 e0       	ldi	r21, 0x01	; 1
    10be:	63 e7       	ldi	r22, 0x73	; 115
    10c0:	72 e0       	ldi	r23, 0x02	; 2
    10c2:	83 ea       	ldi	r24, 0xA3	; 163
    10c4:	98 e0       	ldi	r25, 0x08	; 8
    10c6:	60 d6       	rcall	.+3264   	; 0x1d88 <xTaskCreate>
    10c8:	04 e0       	ldi	r16, 0x04	; 4
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	40 e0       	ldi	r20, 0x00	; 0
    10d0:	51 e0       	ldi	r21, 0x01	; 1
    10d2:	68 e8       	ldi	r22, 0x88	; 136
    10d4:	72 e0       	ldi	r23, 0x02	; 2
    10d6:	86 e7       	ldi	r24, 0x76	; 118
    10d8:	93 e0       	ldi	r25, 0x03	; 3
    10da:	56 d6       	rcall	.+3244   	; 0x1d88 <xTaskCreate>
    10dc:	69 d7       	rcall	.+3794   	; 0x1fb0 <vTaskStartScheduler>
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	0f 91       	pop	r16
    10e4:	ff 90       	pop	r15
    10e6:	ef 90       	pop	r14
    10e8:	08 95       	ret

000010ea <setSpeed>:
    10ea:	0f 93       	push	r16
    10ec:	1f 93       	push	r17
    10ee:	cf 93       	push	r28
    10f0:	df 93       	push	r29
    10f2:	08 2f       	mov	r16, r24
    10f4:	10 e0       	ldi	r17, 0x00	; 0
    10f6:	4a e0       	ldi	r20, 0x0A	; 10
    10f8:	68 e3       	ldi	r22, 0x38	; 56
    10fa:	74 e0       	ldi	r23, 0x04	; 4
    10fc:	c8 01       	movw	r24, r16
    10fe:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <__itoa_ncheck>
    1102:	88 e3       	ldi	r24, 0x38	; 56
    1104:	94 e0       	ldi	r25, 0x04	; 4
    1106:	48 db       	rcall	.-2416   	; 0x798 <UART_Transmit_String>
    1108:	88 e3       	ldi	r24, 0x38	; 56
    110a:	80 9f       	mul	r24, r16
    110c:	e0 01       	movw	r28, r0
    110e:	81 9f       	mul	r24, r17
    1110:	d0 0d       	add	r29, r0
    1112:	d0 1b       	sub	r29, r16
    1114:	11 24       	eor	r1, r1
    1116:	c0 5e       	subi	r28, 0xE0	; 224
    1118:	d1 4b       	sbci	r29, 0xB1	; 177
    111a:	4a e0       	ldi	r20, 0x0A	; 10
    111c:	68 e3       	ldi	r22, 0x38	; 56
    111e:	74 e0       	ldi	r23, 0x04	; 4
    1120:	ce 01       	movw	r24, r28
    1122:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <__itoa_ncheck>
    1126:	88 e3       	ldi	r24, 0x38	; 56
    1128:	94 e0       	ldi	r25, 0x04	; 4
    112a:	36 db       	rcall	.-2452   	; 0x798 <UART_Transmit_String>
    112c:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1130:	c0 93 28 01 	sts	0x0128, r28	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    1134:	d0 93 2d 01 	sts	0x012D, r29	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1138:	c0 93 2c 01 	sts	0x012C, r28	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    113c:	df 91       	pop	r29
    113e:	cf 91       	pop	r28
    1140:	1f 91       	pop	r17
    1142:	0f 91       	pop	r16
    1144:	08 95       	ret

00001146 <motorTaak>:
	uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
	bool turning = false;
	setSpeed(currentSpeed);
    1146:	84 e1       	ldi	r24, 0x14	; 20
    1148:	d0 df       	rcall	.-96     	; 0x10ea <setSpeed>
void motorTaak(){
	uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
	bool turning = false;
    114a:	20 e0       	ldi	r18, 0x00	; 0

void motorTaak(){
	uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
    114c:	90 e0       	ldi	r25, 0x00	; 0
}

void motorTaak(){
	uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
    114e:	c4 e1       	ldi	r28, 0x14	; 20
    1150:	d0 e0       	ldi	r29, 0x00	; 0
	}
}

void motorTaak(){
	uint8_t temp;
	int16_t targetSpeed = 50;
    1152:	02 e3       	ldi	r16, 0x32	; 50
    1154:	10 e0       	ldi	r17, 0x00	; 0
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    1156:	0f 2e       	mov	r0, r31
    1158:	f0 e3       	ldi	r31, 0x30	; 48
    115a:	df 2e       	mov	r13, r31
    115c:	f0 2d       	mov	r31, r0
    115e:	cc 24       	eor	r12, r12
    1160:	c3 94       	inc	r12
				setSpeed(currentSpeed);
				vTaskDelay(25);
			}
			else{
				setSpeed(currentSpeed);
				vTaskDelay(25);
    1162:	b1 2c       	mov	r11, r1
    1164:	71 2c       	mov	r7, r1
    1166:	81 2c       	mov	r8, r1
    1168:	0f 2e       	mov	r0, r31
    116a:	f4 e6       	ldi	r31, 0x64	; 100
    116c:	9f 2e       	mov	r9, r31
    116e:	f0 2d       	mov	r31, r0
    1170:	a1 2c       	mov	r10, r1
			}
		}
		watchdogMotor = 1;
    1172:	ee 24       	eor	r14, r14
    1174:	e3 94       	inc	r14
    1176:	f1 2c       	mov	r15, r1
	setSpeed(currentSpeed);

	while (1){
		/*if (xQueueReceive(motorCommand, &temp, 0)){
			UART_Transmit(temp);*/
			switch(ontvang){
    1178:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <ontvang>
    117c:	84 36       	cpi	r24, 0x64	; 100
    117e:	e1 f0       	breq	.+56     	; 0x11b8 <motorTaak+0x72>
    1180:	38 f4       	brcc	.+14     	; 0x1190 <motorTaak+0x4a>
    1182:	8d 32       	cpi	r24, 0x2D	; 45
    1184:	79 f1       	breq	.+94     	; 0x11e4 <motorTaak+0x9e>
    1186:	81 36       	cpi	r24, 0x61	; 97
    1188:	79 f0       	breq	.+30     	; 0x11a8 <motorTaak+0x62>
    118a:	8b 32       	cpi	r24, 0x2B	; 43
    118c:	81 f5       	brne	.+96     	; 0x11ee <motorTaak+0xa8>
    118e:	22 c0       	rjmp	.+68     	; 0x11d4 <motorTaak+0x8e>
    1190:	87 37       	cpi	r24, 0x77	; 119
    1192:	29 f0       	breq	.+10     	; 0x119e <motorTaak+0x58>
    1194:	88 37       	cpi	r24, 0x78	; 120
    1196:	c1 f0       	breq	.+48     	; 0x11c8 <motorTaak+0x82>
    1198:	83 37       	cpi	r24, 0x73	; 115
    119a:	49 f5       	brne	.+82     	; 0x11ee <motorTaak+0xa8>
    119c:	08 c0       	rjmp	.+16     	; 0x11ae <motorTaak+0x68>
				case 'w':
					//currentSpeed = 0;
					setSpeed(currentSpeed);
    119e:	8c 2f       	mov	r24, r28
					riding = true;
					turning = false;
					motorStop();
    11a0:	a4 df       	rcall	.-184    	; 0x10ea <setSpeed>
					motorVooruit();
    11a2:	df de       	rcall	.-578    	; 0xf62 <motorStop>
					break;
    11a4:	b1 de       	rcall	.-670    	; 0xf08 <motorVooruit>
				case 'a':
					riding = true;
					turning = true;
					//if(currentSpeed <= 50) setSpeed(50);
					motorStop();
    11a6:	62 c0       	rjmp	.+196    	; 0x126c <motorTaak+0x126>
					motorLinks();
    11a8:	dc de       	rcall	.-584    	; 0xf62 <motorStop>
					break;
    11aa:	cc de       	rcall	.-616    	; 0xf44 <motorLinks>
				case 's':
					//currentSpeed = 0;
					setSpeed(currentSpeed);
    11ac:	5c c0       	rjmp	.+184    	; 0x1266 <motorTaak+0x120>
    11ae:	8c 2f       	mov	r24, r28
    11b0:	9c df       	rcall	.-200    	; 0x10ea <setSpeed>
					riding = true;
					turning = false;
					motorStop();
    11b2:	d7 de       	rcall	.-594    	; 0xf62 <motorStop>
					motorAchteruit();
    11b4:	9a de       	rcall	.-716    	; 0xeea <motorAchteruit>
					break;
				case 'd':
					riding = true;
					turning = true;
					if(currentSpeed <= 50) setSpeed(50);
    11b6:	5a c0       	rjmp	.+180    	; 0x126c <motorTaak+0x126>
    11b8:	c3 33       	cpi	r28, 0x33	; 51
    11ba:	d1 05       	cpc	r29, r1
    11bc:	14 f4       	brge	.+4      	; 0x11c2 <motorTaak+0x7c>
    11be:	82 e3       	ldi	r24, 0x32	; 50
    11c0:	94 df       	rcall	.-216    	; 0x10ea <setSpeed>
					motorStop();
    11c2:	cf de       	rcall	.-610    	; 0xf62 <motorStop>
    11c4:	b0 de       	rcall	.-672    	; 0xf26 <motorRechts>
					motorRechts();
    11c6:	4f c0       	rjmp	.+158    	; 0x1266 <motorTaak+0x120>
    11c8:	cc de       	rcall	.-616    	; 0xf62 <motorStop>
					break;
    11ca:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
				case 'x':
					riding = false;
					turning = false;
					motorStop();
    11ce:	2b 2d       	mov	r18, r11
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    11d0:	9b 2d       	mov	r25, r11
    11d2:	44 c0       	rjmp	.+136    	; 0x125c <motorTaak+0x116>
					motorStop();
					motorRechts();
					break;
				case 'x':
					riding = false;
					turning = false;
    11d4:	06 5f       	subi	r16, 0xF6	; 246
					if(currentSpeed <= 50) setSpeed(50);
					motorStop();
					motorRechts();
					break;
				case 'x':
					riding = false;
    11d6:	1f 4f       	sbci	r17, 0xFF	; 255
    11d8:	05 36       	cpi	r16, 0x65	; 101
    11da:	11 05       	cpc	r17, r1
    11dc:	44 f0       	brlt	.+16     	; 0x11ee <motorTaak+0xa8>
    11de:	09 2d       	mov	r16, r9
    11e0:	1a 2d       	mov	r17, r10
    11e2:	05 c0       	rjmp	.+10     	; 0x11ee <motorTaak+0xa8>
    11e4:	0a 50       	subi	r16, 0x0A	; 10
    11e6:	11 09       	sbc	r17, r1
    11e8:	12 f4       	brpl	.+4      	; 0x11ee <motorTaak+0xa8>
    11ea:	07 2d       	mov	r16, r7
    11ec:	18 2d       	mov	r17, r8
    11ee:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    11f2:	99 23       	and	r25, r25
    11f4:	99 f1       	breq	.+102    	; 0x125c <motorTaak+0x116>

		if (riding){
    11f6:	22 23       	and	r18, r18
    11f8:	29 f0       	breq	.+10     	; 0x1204 <motorTaak+0xbe>
			if (turning){
    11fa:	82 e3       	ldi	r24, 0x32	; 50
    11fc:	76 df       	rcall	.-276    	; 0x10ea <setSpeed>
				setSpeed(50);
    11fe:	2c 2d       	mov	r18, r12
    1200:	9c 2d       	mov	r25, r12
    1202:	2c c0       	rjmp	.+88     	; 0x125c <motorTaak+0x116>
    1204:	c0 17       	cp	r28, r16
    1206:	d1 07       	cpc	r29, r17
			}
			else if (currentSpeed < targetSpeed){
    1208:	7c f4       	brge	.+30     	; 0x1228 <motorTaak+0xe2>
    120a:	25 96       	adiw	r28, 0x05	; 5
    120c:	c5 36       	cpi	r28, 0x65	; 101
    120e:	d1 05       	cpc	r29, r1
    1210:	14 f0       	brlt	.+4      	; 0x1216 <motorTaak+0xd0>
    1212:	c4 e6       	ldi	r28, 0x64	; 100
    1214:	d0 e0       	ldi	r29, 0x00	; 0
    1216:	8c 2f       	mov	r24, r28
    1218:	68 df       	rcall	.-304    	; 0x10ea <setSpeed>
				currentSpeed += 5;
				if (currentSpeed > 100) currentSpeed = 100;
				setSpeed(currentSpeed);
    121a:	89 e1       	ldi	r24, 0x19	; 25
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 3c 11 	call	0x2278	; 0x2278 <vTaskDelay>
				vTaskDelay(25);
    1222:	2b 2d       	mov	r18, r11
    1224:	9c 2d       	mov	r25, r12
    1226:	1a c0       	rjmp	.+52     	; 0x125c <motorTaak+0x116>
    1228:	0c 17       	cp	r16, r28
    122a:	1d 07       	cpc	r17, r29
			}
			else if(currentSpeed > targetSpeed){
    122c:	7c f4       	brge	.+30     	; 0x124c <motorTaak+0x106>
    122e:	25 97       	sbiw	r28, 0x05	; 5
    1230:	c4 31       	cpi	r28, 0x14	; 20
				currentSpeed -= 5;
    1232:	d1 05       	cpc	r29, r1
				if (currentSpeed < 20) currentSpeed = 20;
    1234:	14 f4       	brge	.+4      	; 0x123a <motorTaak+0xf4>
    1236:	c4 e1       	ldi	r28, 0x14	; 20
    1238:	d0 e0       	ldi	r29, 0x00	; 0
    123a:	8c 2f       	mov	r24, r28
				setSpeed(currentSpeed);
    123c:	56 df       	rcall	.-340    	; 0x10ea <setSpeed>
    123e:	89 e1       	ldi	r24, 0x19	; 25
    1240:	90 e0       	ldi	r25, 0x00	; 0
				vTaskDelay(25);
    1242:	0e 94 3c 11 	call	0x2278	; 0x2278 <vTaskDelay>
    1246:	2b 2d       	mov	r18, r11
    1248:	9c 2d       	mov	r25, r12
    124a:	08 c0       	rjmp	.+16     	; 0x125c <motorTaak+0x116>
    124c:	8c 2f       	mov	r24, r28
    124e:	4d df       	rcall	.-358    	; 0x10ea <setSpeed>
			}
			else{
				setSpeed(currentSpeed);
    1250:	89 e1       	ldi	r24, 0x19	; 25
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	0e 94 3c 11 	call	0x2278	; 0x2278 <vTaskDelay>
				vTaskDelay(25);
    1258:	2b 2d       	mov	r18, r11
    125a:	9c 2d       	mov	r25, r12
    125c:	f0 92 4d 04 	sts	0x044D, r15	; 0x80044d <watchdogMotor+0x1>
    1260:	e0 92 4c 04 	sts	0x044C, r14	; 0x80044c <watchdogMotor>
			}
		}
		watchdogMotor = 1;
    1264:	89 cf       	rjmp	.-238    	; 0x1178 <motorTaak+0x32>
    1266:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
	}
    126a:	c7 cf       	rjmp	.-114    	; 0x11fa <motorTaak+0xb4>
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    126c:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
    1270:	c9 cf       	rjmp	.-110    	; 0x1204 <motorTaak+0xbe>

00001272 <pxPortInitialiseStack>:
    1272:	31 e1       	ldi	r19, 0x11	; 17
    1274:	fc 01       	movw	r30, r24
    1276:	30 83       	st	Z, r19

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
    1278:	31 97       	sbiw	r30, 0x01	; 1
    127a:	22 e2       	ldi	r18, 0x22	; 34
    127c:	20 83       	st	Z, r18
    127e:	31 97       	sbiw	r30, 0x01	; 1
    1280:	a3 e3       	ldi	r26, 0x33	; 51
    1282:	a0 83       	st	Z, r26
    1284:	31 97       	sbiw	r30, 0x01	; 1
    1286:	60 83       	st	Z, r22
    1288:	31 97       	sbiw	r30, 0x01	; 1
    128a:	70 83       	st	Z, r23
    128c:	31 97       	sbiw	r30, 0x01	; 1
    128e:	10 82       	st	Z, r1
    1290:	31 97       	sbiw	r30, 0x01	; 1
    1292:	10 82       	st	Z, r1
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	60 e8       	ldi	r22, 0x80	; 128
    1298:	60 83       	st	Z, r22
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	10 82       	st	Z, r1
    129e:	31 97       	sbiw	r30, 0x01	; 1
    12a0:	10 82       	st	Z, r1
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	10 82       	st	Z, r1
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	62 e0       	ldi	r22, 0x02	; 2
    12aa:	60 83       	st	Z, r22
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	63 e0       	ldi	r22, 0x03	; 3
    12b0:	60 83       	st	Z, r22
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	64 e0       	ldi	r22, 0x04	; 4
    12b6:	60 83       	st	Z, r22
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	65 e0       	ldi	r22, 0x05	; 5
    12bc:	60 83       	st	Z, r22
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	66 e0       	ldi	r22, 0x06	; 6
    12c2:	60 83       	st	Z, r22
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	67 e0       	ldi	r22, 0x07	; 7
    12c8:	60 83       	st	Z, r22
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	68 e0       	ldi	r22, 0x08	; 8
    12ce:	60 83       	st	Z, r22
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	69 e0       	ldi	r22, 0x09	; 9
    12d4:	60 83       	st	Z, r22
    12d6:	31 97       	sbiw	r30, 0x01	; 1
    12d8:	60 e1       	ldi	r22, 0x10	; 16
    12da:	60 83       	st	Z, r22
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	30 83       	st	Z, r19
    12e0:	31 97       	sbiw	r30, 0x01	; 1
    12e2:	32 e1       	ldi	r19, 0x12	; 18
    12e4:	30 83       	st	Z, r19
    12e6:	31 97       	sbiw	r30, 0x01	; 1
    12e8:	33 e1       	ldi	r19, 0x13	; 19
    12ea:	30 83       	st	Z, r19
    12ec:	31 97       	sbiw	r30, 0x01	; 1
    12ee:	34 e1       	ldi	r19, 0x14	; 20
    12f0:	30 83       	st	Z, r19
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	35 e1       	ldi	r19, 0x15	; 21
    12f6:	30 83       	st	Z, r19
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	36 e1       	ldi	r19, 0x16	; 22
    12fc:	30 83       	st	Z, r19
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	37 e1       	ldi	r19, 0x17	; 23
    1302:	30 83       	st	Z, r19
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	38 e1       	ldi	r19, 0x18	; 24
    1308:	30 83       	st	Z, r19
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	39 e1       	ldi	r19, 0x19	; 25
    130e:	30 83       	st	Z, r19
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	30 e2       	ldi	r19, 0x20	; 32
    1314:	30 83       	st	Z, r19
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	31 e2       	ldi	r19, 0x21	; 33
    131a:	30 83       	st	Z, r19
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	20 83       	st	Z, r18
    1320:	31 97       	sbiw	r30, 0x01	; 1
    1322:	23 e2       	ldi	r18, 0x23	; 35
    1324:	20 83       	st	Z, r18
    1326:	31 97       	sbiw	r30, 0x01	; 1
    1328:	40 83       	st	Z, r20
    132a:	31 97       	sbiw	r30, 0x01	; 1
    132c:	50 83       	st	Z, r21
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	26 e2       	ldi	r18, 0x26	; 38
    1332:	20 83       	st	Z, r18
    1334:	31 97       	sbiw	r30, 0x01	; 1
    1336:	27 e2       	ldi	r18, 0x27	; 39
    1338:	20 83       	st	Z, r18
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	28 e2       	ldi	r18, 0x28	; 40
    133e:	20 83       	st	Z, r18
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	29 e2       	ldi	r18, 0x29	; 41
    1344:	20 83       	st	Z, r18
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	20 e3       	ldi	r18, 0x30	; 48
    134a:	20 83       	st	Z, r18
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	21 e3       	ldi	r18, 0x31	; 49
    1350:	20 83       	st	Z, r18
    1352:	89 97       	sbiw	r24, 0x29	; 41
    1354:	08 95       	ret

00001356 <xPortStartScheduler>:
    1356:	88 ec       	ldi	r24, 0xC8	; 200
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	90 93 6e 04 	sts	0x046E, r25	; 0x80046e <portTickRateHz+0x1>
    135e:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <portTickRateHz>
    1362:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    1366:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
    136a:	8d e4       	ldi	r24, 0x4D	; 77
    136c:	87 bd       	out	0x27, r24	; 39
    136e:	82 e0       	ldi	r24, 0x02	; 2
    1370:	84 bd       	out	0x24, r24	; 36
    1372:	85 e0       	ldi	r24, 0x05	; 5
    1374:	85 bd       	out	0x25, r24	; 37
    1376:	ee e6       	ldi	r30, 0x6E	; 110
    1378:	f0 e0       	ldi	r31, 0x00	; 0
    137a:	80 81       	ld	r24, Z
    137c:	82 60       	ori	r24, 0x02	; 2
    137e:	80 83       	st	Z, r24
    1380:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1384:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1388:	cd 91       	ld	r28, X+
    138a:	cd bf       	out	0x3d, r28	; 61
    138c:	dd 91       	ld	r29, X+
    138e:	de bf       	out	0x3e, r29	; 62
    1390:	ff 91       	pop	r31
    1392:	ef 91       	pop	r30
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	bf 91       	pop	r27
    139a:	af 91       	pop	r26
    139c:	9f 91       	pop	r25
    139e:	8f 91       	pop	r24
    13a0:	7f 91       	pop	r23
    13a2:	6f 91       	pop	r22
    13a4:	5f 91       	pop	r21
    13a6:	4f 91       	pop	r20
    13a8:	3f 91       	pop	r19
    13aa:	2f 91       	pop	r18
    13ac:	1f 91       	pop	r17
    13ae:	0f 91       	pop	r16
    13b0:	ff 90       	pop	r15
    13b2:	ef 90       	pop	r14
    13b4:	df 90       	pop	r13
    13b6:	cf 90       	pop	r12
    13b8:	bf 90       	pop	r11
    13ba:	af 90       	pop	r10
    13bc:	9f 90       	pop	r9
    13be:	8f 90       	pop	r8
    13c0:	7f 90       	pop	r7
    13c2:	6f 90       	pop	r6
    13c4:	5f 90       	pop	r5
    13c6:	4f 90       	pop	r4
    13c8:	3f 90       	pop	r3
    13ca:	2f 90       	pop	r2
    13cc:	1f 90       	pop	r1
    13ce:	0f 90       	pop	r0
    13d0:	0c be       	out	0x3c, r0	; 60
    13d2:	0f 90       	pop	r0
    13d4:	0b be       	out	0x3b, r0	; 59
    13d6:	0f 90       	pop	r0
    13d8:	0f be       	out	0x3f, r0	; 63
    13da:	0f 90       	pop	r0
    13dc:	08 95       	ret
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	08 95       	ret

000013e2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13e2:	0f 92       	push	r0
    13e4:	0f b6       	in	r0, 0x3f	; 63
    13e6:	f8 94       	cli
    13e8:	0f 92       	push	r0
    13ea:	0b b6       	in	r0, 0x3b	; 59
    13ec:	0f 92       	push	r0
    13ee:	0c b6       	in	r0, 0x3c	; 60
    13f0:	0f 92       	push	r0
    13f2:	1f 92       	push	r1
    13f4:	11 24       	eor	r1, r1
    13f6:	2f 92       	push	r2
    13f8:	3f 92       	push	r3
    13fa:	4f 92       	push	r4
    13fc:	5f 92       	push	r5
    13fe:	6f 92       	push	r6
    1400:	7f 92       	push	r7
    1402:	8f 92       	push	r8
    1404:	9f 92       	push	r9
    1406:	af 92       	push	r10
    1408:	bf 92       	push	r11
    140a:	cf 92       	push	r12
    140c:	df 92       	push	r13
    140e:	ef 92       	push	r14
    1410:	ff 92       	push	r15
    1412:	0f 93       	push	r16
    1414:	1f 93       	push	r17
    1416:	2f 93       	push	r18
    1418:	3f 93       	push	r19
    141a:	4f 93       	push	r20
    141c:	5f 93       	push	r21
    141e:	6f 93       	push	r22
    1420:	7f 93       	push	r23
    1422:	8f 93       	push	r24
    1424:	9f 93       	push	r25
    1426:	af 93       	push	r26
    1428:	bf 93       	push	r27
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
    142e:	ef 93       	push	r30
    1430:	ff 93       	push	r31
    1432:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1436:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    143a:	0d b6       	in	r0, 0x3d	; 61
    143c:	0d 92       	st	X+, r0
    143e:	0e b6       	in	r0, 0x3e	; 62
    1440:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1442:	2a d7       	rcall	.+3668   	; 0x2298 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1444:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1448:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    144c:	cd 91       	ld	r28, X+
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	dd 91       	ld	r29, X+
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	ff 91       	pop	r31
    1456:	ef 91       	pop	r30
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	bf 91       	pop	r27
    145e:	af 91       	pop	r26
    1460:	9f 91       	pop	r25
    1462:	8f 91       	pop	r24
    1464:	7f 91       	pop	r23
    1466:	6f 91       	pop	r22
    1468:	5f 91       	pop	r21
    146a:	4f 91       	pop	r20
    146c:	3f 91       	pop	r19
    146e:	2f 91       	pop	r18
    1470:	1f 91       	pop	r17
    1472:	0f 91       	pop	r16
    1474:	ff 90       	pop	r15
    1476:	ef 90       	pop	r14
    1478:	df 90       	pop	r13
    147a:	cf 90       	pop	r12
    147c:	bf 90       	pop	r11
    147e:	af 90       	pop	r10
    1480:	9f 90       	pop	r9
    1482:	8f 90       	pop	r8
    1484:	7f 90       	pop	r7
    1486:	6f 90       	pop	r6
    1488:	5f 90       	pop	r5
    148a:	4f 90       	pop	r4
    148c:	3f 90       	pop	r3
    148e:	2f 90       	pop	r2
    1490:	1f 90       	pop	r1
    1492:	0f 90       	pop	r0
    1494:	0c be       	out	0x3c, r0	; 60
    1496:	0f 90       	pop	r0
    1498:	0b be       	out	0x3b, r0	; 59
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    14a0:	08 95       	ret

000014a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14a2:	0f 92       	push	r0
    14a4:	0f b6       	in	r0, 0x3f	; 63
    14a6:	f8 94       	cli
    14a8:	0f 92       	push	r0
    14aa:	0b b6       	in	r0, 0x3b	; 59
    14ac:	0f 92       	push	r0
    14ae:	0c b6       	in	r0, 0x3c	; 60
    14b0:	0f 92       	push	r0
    14b2:	1f 92       	push	r1
    14b4:	11 24       	eor	r1, r1
    14b6:	2f 92       	push	r2
    14b8:	3f 92       	push	r3
    14ba:	4f 92       	push	r4
    14bc:	5f 92       	push	r5
    14be:	6f 92       	push	r6
    14c0:	7f 92       	push	r7
    14c2:	8f 92       	push	r8
    14c4:	9f 92       	push	r9
    14c6:	af 92       	push	r10
    14c8:	bf 92       	push	r11
    14ca:	cf 92       	push	r12
    14cc:	df 92       	push	r13
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	1f 93       	push	r17
    14d6:	2f 93       	push	r18
    14d8:	3f 93       	push	r19
    14da:	4f 93       	push	r20
    14dc:	5f 93       	push	r21
    14de:	6f 93       	push	r22
    14e0:	7f 93       	push	r23
    14e2:	8f 93       	push	r24
    14e4:	9f 93       	push	r25
    14e6:	af 93       	push	r26
    14e8:	bf 93       	push	r27
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	ef 93       	push	r30
    14f0:	ff 93       	push	r31
    14f2:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    14f6:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    14fa:	0d b6       	in	r0, 0x3d	; 61
    14fc:	0d 92       	st	X+, r0
    14fe:	0e b6       	in	r0, 0x3e	; 62
    1500:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1502:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    1504:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <ticksRemainingInSec>
    1508:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <ticksRemainingInSec+0x1>
    150c:	01 97       	sbiw	r24, 0x01	; 1
    150e:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    1512:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
    1516:	89 2b       	or	r24, r25
    1518:	51 f4       	brne	.+20     	; 0x152e <vPortYieldFromTick+0x8c>
	{
		system_tick();
    151a:	0e 94 8f 01 	call	0x31e	; 0x31e <system_tick>
		ticksRemainingInSec = portTickRateHz;
    151e:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <portTickRateHz>
    1522:	90 91 6e 04 	lds	r25, 0x046E	; 0x80046e <portTickRateHz+0x1>
    1526:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    152a:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    152e:	6e d5       	rcall	.+2780   	; 0x200c <xTaskIncrementTick>
    1530:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1532:	b2 d6       	rcall	.+3428   	; 0x2298 <vTaskSwitchContext>
    1534:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    1538:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    153c:	cd 91       	ld	r28, X+
    153e:	cd bf       	out	0x3d, r28	; 61
    1540:	dd 91       	ld	r29, X+
    1542:	de bf       	out	0x3e, r29	; 62
    1544:	ff 91       	pop	r31
    1546:	ef 91       	pop	r30
    1548:	df 91       	pop	r29
    154a:	cf 91       	pop	r28
    154c:	bf 91       	pop	r27
    154e:	af 91       	pop	r26
    1550:	9f 91       	pop	r25
    1552:	8f 91       	pop	r24
    1554:	7f 91       	pop	r23
    1556:	6f 91       	pop	r22
    1558:	5f 91       	pop	r21
    155a:	4f 91       	pop	r20
    155c:	3f 91       	pop	r19
    155e:	2f 91       	pop	r18
    1560:	1f 91       	pop	r17
    1562:	0f 91       	pop	r16
    1564:	ff 90       	pop	r15
    1566:	ef 90       	pop	r14
    1568:	df 90       	pop	r13
    156a:	cf 90       	pop	r12
    156c:	bf 90       	pop	r11
    156e:	af 90       	pop	r10
    1570:	9f 90       	pop	r9
    1572:	8f 90       	pop	r8
    1574:	7f 90       	pop	r7
    1576:	6f 90       	pop	r6
    1578:	5f 90       	pop	r5
    157a:	4f 90       	pop	r4
    157c:	3f 90       	pop	r3
    157e:	2f 90       	pop	r2
    1580:	1f 90       	pop	r1
    1582:	0f 90       	pop	r0
    1584:	0c be       	out	0x3c, r0	; 60
    1586:	0f 90       	pop	r0
    1588:	0b be       	out	0x3b, r0	; 59
    158a:	0f 90       	pop	r0
    158c:	0f be       	out	0x3f, r0	; 63
    158e:	0f 90       	pop	r0
    1590:	08 95       	ret

00001592 <__vector_21>:

	__asm__ __volatile__ ( "ret" );
    1592:	87 df       	rcall	.-242    	; 0x14a2 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    1594:	18 95       	reti

00001596 <prvCopyDataToQueue>:
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
    1596:	0f 93       	push	r16
    1598:	1f 93       	push	r17
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	ec 01       	movw	r28, r24
    15a0:	04 2f       	mov	r16, r20
    15a2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    15a4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    15a6:	41 11       	cpse	r20, r1
    15a8:	0b c0       	rjmp	.+22     	; 0x15c0 <prvCopyDataToQueue+0x2a>
    15aa:	88 81       	ld	r24, Y
    15ac:	99 81       	ldd	r25, Y+1	; 0x01
    15ae:	89 2b       	or	r24, r25
    15b0:	09 f0       	breq	.+2      	; 0x15b4 <prvCopyDataToQueue+0x1e>
    15b2:	41 c0       	rjmp	.+130    	; 0x1636 <prvCopyDataToQueue+0xa0>
    15b4:	8a 81       	ldd	r24, Y+2	; 0x02
    15b6:	9b 81       	ldd	r25, Y+3	; 0x03
    15b8:	90 d7       	rcall	.+3872   	; 0x24da <xTaskPriorityDisinherit>
    15ba:	1b 82       	std	Y+3, r1	; 0x03
    15bc:	1a 82       	std	Y+2, r1	; 0x02
    15be:	42 c0       	rjmp	.+132    	; 0x1644 <prvCopyDataToQueue+0xae>
    15c0:	01 11       	cpse	r16, r1
    15c2:	17 c0       	rjmp	.+46     	; 0x15f2 <prvCopyDataToQueue+0x5c>
    15c4:	50 e0       	ldi	r21, 0x00	; 0
    15c6:	8c 81       	ldd	r24, Y+4	; 0x04
    15c8:	9d 81       	ldd	r25, Y+5	; 0x05
    15ca:	0e 94 98 15 	call	0x2b30	; 0x2b30 <memcpy>
    15ce:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15d0:	8c 81       	ldd	r24, Y+4	; 0x04
    15d2:	9d 81       	ldd	r25, Y+5	; 0x05
    15d4:	82 0f       	add	r24, r18
    15d6:	91 1d       	adc	r25, r1
    15d8:	9d 83       	std	Y+5, r25	; 0x05
    15da:	8c 83       	std	Y+4, r24	; 0x04
    15dc:	2a 81       	ldd	r18, Y+2	; 0x02
    15de:	3b 81       	ldd	r19, Y+3	; 0x03
    15e0:	82 17       	cp	r24, r18
    15e2:	93 07       	cpc	r25, r19
    15e4:	50 f1       	brcs	.+84     	; 0x163a <prvCopyDataToQueue+0xa4>
    15e6:	88 81       	ld	r24, Y
    15e8:	99 81       	ldd	r25, Y+1	; 0x01
    15ea:	9d 83       	std	Y+5, r25	; 0x05
    15ec:	8c 83       	std	Y+4, r24	; 0x04
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	29 c0       	rjmp	.+82     	; 0x1644 <prvCopyDataToQueue+0xae>
    15f2:	50 e0       	ldi	r21, 0x00	; 0
    15f4:	8e 81       	ldd	r24, Y+6	; 0x06
    15f6:	9f 81       	ldd	r25, Y+7	; 0x07
    15f8:	0e 94 98 15 	call	0x2b30	; 0x2b30 <memcpy>
    15fc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	91 95       	neg	r25
    1602:	81 95       	neg	r24
    1604:	91 09       	sbc	r25, r1
    1606:	2e 81       	ldd	r18, Y+6	; 0x06
    1608:	3f 81       	ldd	r19, Y+7	; 0x07
    160a:	28 0f       	add	r18, r24
    160c:	39 1f       	adc	r19, r25
    160e:	3f 83       	std	Y+7, r19	; 0x07
    1610:	2e 83       	std	Y+6, r18	; 0x06
    1612:	48 81       	ld	r20, Y
    1614:	59 81       	ldd	r21, Y+1	; 0x01
    1616:	24 17       	cp	r18, r20
    1618:	35 07       	cpc	r19, r21
    161a:	30 f4       	brcc	.+12     	; 0x1628 <prvCopyDataToQueue+0x92>
    161c:	2a 81       	ldd	r18, Y+2	; 0x02
    161e:	3b 81       	ldd	r19, Y+3	; 0x03
    1620:	82 0f       	add	r24, r18
    1622:	93 1f       	adc	r25, r19
    1624:	9f 83       	std	Y+7, r25	; 0x07
    1626:	8e 83       	std	Y+6, r24	; 0x06
    1628:	02 30       	cpi	r16, 0x02	; 2
    162a:	49 f4       	brne	.+18     	; 0x163e <prvCopyDataToQueue+0xa8>
    162c:	11 23       	and	r17, r17
    162e:	49 f0       	breq	.+18     	; 0x1642 <prvCopyDataToQueue+0xac>
    1630:	11 50       	subi	r17, 0x01	; 1
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	07 c0       	rjmp	.+14     	; 0x1644 <prvCopyDataToQueue+0xae>
    1636:	80 e0       	ldi	r24, 0x00	; 0
    1638:	05 c0       	rjmp	.+10     	; 0x1644 <prvCopyDataToQueue+0xae>
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	03 c0       	rjmp	.+6      	; 0x1644 <prvCopyDataToQueue+0xae>
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	01 c0       	rjmp	.+2      	; 0x1644 <prvCopyDataToQueue+0xae>
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	1f 5f       	subi	r17, 0xFF	; 255
    1646:	1a 8f       	std	Y+26, r17	; 0x1a
    1648:	df 91       	pop	r29
    164a:	cf 91       	pop	r28
    164c:	1f 91       	pop	r17
    164e:	0f 91       	pop	r16
    1650:	08 95       	ret

00001652 <prvUnlockQueue>:
    1652:	ef 92       	push	r14
    1654:	ff 92       	push	r15
    1656:	0f 93       	push	r16
    1658:	1f 93       	push	r17
    165a:	cf 93       	push	r28
    165c:	8c 01       	movw	r16, r24
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	0f 92       	push	r0
    1664:	fc 01       	movw	r30, r24
    1666:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1668:	1c 16       	cp	r1, r28
    166a:	9c f4       	brge	.+38     	; 0x1692 <prvUnlockQueue+0x40>
    166c:	81 89       	ldd	r24, Z+17	; 0x11
    166e:	81 11       	cpse	r24, r1
    1670:	06 c0       	rjmp	.+12     	; 0x167e <prvUnlockQueue+0x2c>
    1672:	0f c0       	rjmp	.+30     	; 0x1692 <prvUnlockQueue+0x40>
    1674:	f8 01       	movw	r30, r16
    1676:	81 89       	ldd	r24, Z+17	; 0x11
    1678:	81 11       	cpse	r24, r1
    167a:	05 c0       	rjmp	.+10     	; 0x1686 <prvUnlockQueue+0x34>
    167c:	0a c0       	rjmp	.+20     	; 0x1692 <prvUnlockQueue+0x40>
    167e:	78 01       	movw	r14, r16
    1680:	f1 e1       	ldi	r31, 0x11	; 17
    1682:	ef 0e       	add	r14, r31
    1684:	f1 1c       	adc	r15, r1
    1686:	c7 01       	movw	r24, r14
    1688:	99 d6       	rcall	.+3378   	; 0x23bc <xTaskRemoveFromEventList>
    168a:	81 11       	cpse	r24, r1
    168c:	22 d7       	rcall	.+3652   	; 0x24d2 <vTaskMissedYield>
    168e:	c1 50       	subi	r28, 0x01	; 1
    1690:	89 f7       	brne	.-30     	; 0x1674 <prvUnlockQueue+0x22>
    1692:	8f ef       	ldi	r24, 0xFF	; 255
    1694:	f8 01       	movw	r30, r16
    1696:	86 8f       	std	Z+30, r24	; 0x1e
    1698:	0f 90       	pop	r0
    169a:	0f be       	out	0x3f, r0	; 63
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	0f 92       	push	r0
    16a2:	c5 8d       	ldd	r28, Z+29	; 0x1d
    16a4:	1c 16       	cp	r1, r28
    16a6:	9c f4       	brge	.+38     	; 0x16ce <prvUnlockQueue+0x7c>
    16a8:	80 85       	ldd	r24, Z+8	; 0x08
    16aa:	81 11       	cpse	r24, r1
    16ac:	06 c0       	rjmp	.+12     	; 0x16ba <prvUnlockQueue+0x68>
    16ae:	0f c0       	rjmp	.+30     	; 0x16ce <prvUnlockQueue+0x7c>
    16b0:	f8 01       	movw	r30, r16
    16b2:	80 85       	ldd	r24, Z+8	; 0x08
    16b4:	81 11       	cpse	r24, r1
    16b6:	05 c0       	rjmp	.+10     	; 0x16c2 <prvUnlockQueue+0x70>
    16b8:	0a c0       	rjmp	.+20     	; 0x16ce <prvUnlockQueue+0x7c>
    16ba:	78 01       	movw	r14, r16
    16bc:	f8 e0       	ldi	r31, 0x08	; 8
    16be:	ef 0e       	add	r14, r31
    16c0:	f1 1c       	adc	r15, r1
    16c2:	c7 01       	movw	r24, r14
    16c4:	7b d6       	rcall	.+3318   	; 0x23bc <xTaskRemoveFromEventList>
    16c6:	81 11       	cpse	r24, r1
    16c8:	04 d7       	rcall	.+3592   	; 0x24d2 <vTaskMissedYield>
    16ca:	c1 50       	subi	r28, 0x01	; 1
    16cc:	89 f7       	brne	.-30     	; 0x16b0 <prvUnlockQueue+0x5e>
    16ce:	8f ef       	ldi	r24, 0xFF	; 255
    16d0:	f8 01       	movw	r30, r16
    16d2:	85 8f       	std	Z+29, r24	; 0x1d
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	ff 90       	pop	r15
    16e0:	ef 90       	pop	r14
    16e2:	08 95       	ret

000016e4 <xQueueGenericReset>:
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	ec 01       	movw	r28, r24
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
    16f0:	48 81       	ld	r20, Y
    16f2:	59 81       	ldd	r21, Y+1	; 0x01
    16f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16f6:	30 e0       	ldi	r19, 0x00	; 0
    16f8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    16fa:	72 9f       	mul	r23, r18
    16fc:	c0 01       	movw	r24, r0
    16fe:	73 9f       	mul	r23, r19
    1700:	90 0d       	add	r25, r0
    1702:	11 24       	eor	r1, r1
    1704:	fa 01       	movw	r30, r20
    1706:	e8 0f       	add	r30, r24
    1708:	f9 1f       	adc	r31, r25
    170a:	fb 83       	std	Y+3, r31	; 0x03
    170c:	ea 83       	std	Y+2, r30	; 0x02
    170e:	1a 8e       	std	Y+26, r1	; 0x1a
    1710:	5d 83       	std	Y+5, r21	; 0x05
    1712:	4c 83       	std	Y+4, r20	; 0x04
    1714:	82 1b       	sub	r24, r18
    1716:	93 0b       	sbc	r25, r19
    1718:	84 0f       	add	r24, r20
    171a:	95 1f       	adc	r25, r21
    171c:	9f 83       	std	Y+7, r25	; 0x07
    171e:	8e 83       	std	Y+6, r24	; 0x06
    1720:	8f ef       	ldi	r24, 0xFF	; 255
    1722:	8d 8f       	std	Y+29, r24	; 0x1d
    1724:	8e 8f       	std	Y+30, r24	; 0x1e
    1726:	61 11       	cpse	r22, r1
    1728:	0a c0       	rjmp	.+20     	; 0x173e <xQueueGenericReset+0x5a>
    172a:	88 85       	ldd	r24, Y+8	; 0x08
    172c:	88 23       	and	r24, r24
    172e:	79 f0       	breq	.+30     	; 0x174e <xQueueGenericReset+0x6a>
    1730:	ce 01       	movw	r24, r28
    1732:	08 96       	adiw	r24, 0x08	; 8
    1734:	43 d6       	rcall	.+3206   	; 0x23bc <xTaskRemoveFromEventList>
    1736:	88 23       	and	r24, r24
    1738:	51 f0       	breq	.+20     	; 0x174e <xQueueGenericReset+0x6a>
    173a:	53 de       	rcall	.-858    	; 0x13e2 <vPortYield>
    173c:	08 c0       	rjmp	.+16     	; 0x174e <xQueueGenericReset+0x6a>
    173e:	ce 01       	movw	r24, r28
    1740:	08 96       	adiw	r24, 0x08	; 8
    1742:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1746:	ce 01       	movw	r24, r28
    1748:	41 96       	adiw	r24, 0x11	; 17
    174a:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    174e:	0f 90       	pop	r0
    1750:	0f be       	out	0x3f, r0	; 63
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	08 95       	ret

0000175a <xQueueGenericCreate>:
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	08 2f       	mov	r16, r24
    1764:	16 2f       	mov	r17, r22
    1766:	66 23       	and	r22, r22
    1768:	b9 f0       	breq	.+46     	; 0x1798 <xQueueGenericCreate+0x3e>
    176a:	86 9f       	mul	r24, r22
    176c:	c0 01       	movw	r24, r0
    176e:	11 24       	eor	r1, r1
    1770:	4f 96       	adiw	r24, 0x1f	; 31
    1772:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    1776:	ec 01       	movw	r28, r24
    1778:	00 97       	sbiw	r24, 0x00	; 0
    177a:	39 f4       	brne	.+14     	; 0x178a <xQueueGenericCreate+0x30>
    177c:	14 c0       	rjmp	.+40     	; 0x17a6 <xQueueGenericCreate+0x4c>
    177e:	0b 8f       	std	Y+27, r16	; 0x1b
    1780:	1c 8f       	std	Y+28, r17	; 0x1c
    1782:	61 e0       	ldi	r22, 0x01	; 1
    1784:	ce 01       	movw	r24, r28
    1786:	ae df       	rcall	.-164    	; 0x16e4 <xQueueGenericReset>
    1788:	0e c0       	rjmp	.+28     	; 0x17a6 <xQueueGenericCreate+0x4c>
    178a:	4f 96       	adiw	r24, 0x1f	; 31
    178c:	99 83       	std	Y+1, r25	; 0x01
    178e:	88 83       	st	Y, r24
    1790:	f6 cf       	rjmp	.-20     	; 0x177e <xQueueGenericCreate+0x24>
    1792:	d9 83       	std	Y+1, r29	; 0x01
    1794:	c8 83       	st	Y, r28
    1796:	f3 cf       	rjmp	.-26     	; 0x177e <xQueueGenericCreate+0x24>
    1798:	8f e1       	ldi	r24, 0x1F	; 31
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    17a0:	ec 01       	movw	r28, r24
    17a2:	89 2b       	or	r24, r25
    17a4:	b1 f7       	brne	.-20     	; 0x1792 <xQueueGenericCreate+0x38>
    17a6:	ce 01       	movw	r24, r28
    17a8:	df 91       	pop	r29
    17aa:	cf 91       	pop	r28
    17ac:	1f 91       	pop	r17
    17ae:	0f 91       	pop	r16
    17b0:	08 95       	ret

000017b2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    17b2:	9f 92       	push	r9
    17b4:	af 92       	push	r10
    17b6:	bf 92       	push	r11
    17b8:	cf 92       	push	r12
    17ba:	df 92       	push	r13
    17bc:	ef 92       	push	r14
    17be:	ff 92       	push	r15
    17c0:	0f 93       	push	r16
    17c2:	1f 93       	push	r17
    17c4:	cf 93       	push	r28
    17c6:	df 93       	push	r29
    17c8:	00 d0       	rcall	.+0      	; 0x17ca <xQueueGenericSend+0x18>
    17ca:	1f 92       	push	r1
    17cc:	1f 92       	push	r1
    17ce:	cd b7       	in	r28, 0x3d	; 61
    17d0:	de b7       	in	r29, 0x3e	; 62
    17d2:	8c 01       	movw	r16, r24
    17d4:	6b 01       	movw	r12, r22
    17d6:	5d 83       	std	Y+5, r21	; 0x05
    17d8:	4c 83       	std	Y+4, r20	; 0x04
    17da:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    17dc:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17de:	99 24       	eor	r9, r9
    17e0:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17e2:	7c 01       	movw	r14, r24
    17e4:	88 e0       	ldi	r24, 0x08	; 8
    17e6:	e8 0e       	add	r14, r24
    17e8:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17ea:	0f b6       	in	r0, 0x3f	; 63
    17ec:	f8 94       	cli
    17ee:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17f0:	f8 01       	movw	r30, r16
    17f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    17f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    17f6:	98 17       	cp	r25, r24
    17f8:	18 f0       	brcs	.+6      	; 0x1800 <xQueueGenericSend+0x4e>
    17fa:	f2 e0       	ldi	r31, 0x02	; 2
    17fc:	af 12       	cpse	r10, r31
    17fe:	15 c0       	rjmp	.+42     	; 0x182a <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1800:	4a 2d       	mov	r20, r10
    1802:	b6 01       	movw	r22, r12
    1804:	c8 01       	movw	r24, r16
    1806:	c7 de       	rcall	.-626    	; 0x1596 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1808:	f8 01       	movw	r30, r16
    180a:	91 89       	ldd	r25, Z+17	; 0x11
    180c:	99 23       	and	r25, r25
    180e:	39 f0       	breq	.+14     	; 0x181e <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1810:	c8 01       	movw	r24, r16
    1812:	41 96       	adiw	r24, 0x11	; 17
    1814:	d3 d5       	rcall	.+2982   	; 0x23bc <xTaskRemoveFromEventList>
    1816:	88 23       	and	r24, r24
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1818:	21 f0       	breq	.+8      	; 0x1822 <xQueueGenericSend+0x70>
    181a:	e3 dd       	rcall	.-1082   	; 0x13e2 <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    181c:	02 c0       	rjmp	.+4      	; 0x1822 <xQueueGenericSend+0x70>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    181e:	81 11       	cpse	r24, r1
    1820:	e0 dd       	rcall	.-1088   	; 0x13e2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	45 c0       	rjmp	.+138    	; 0x18b4 <xQueueGenericSend+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    182a:	8c 81       	ldd	r24, Y+4	; 0x04
    182c:	9d 81       	ldd	r25, Y+5	; 0x05
    182e:	89 2b       	or	r24, r25
    1830:	21 f4       	brne	.+8      	; 0x183a <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1836:	80 e0       	ldi	r24, 0x00	; 0
    1838:	3d c0       	rjmp	.+122    	; 0x18b4 <xQueueGenericSend+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    183a:	b1 10       	cpse	r11, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    183c:	04 c0       	rjmp	.+8      	; 0x1846 <xQueueGenericSend+0x94>
    183e:	ce 01       	movw	r24, r28
    1840:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    1842:	04 d6       	rcall	.+3080   	; 0x244c <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1844:	b9 2c       	mov	r11, r9
    1846:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1848:	0f be       	out	0x3f, r0	; 63
    184a:	da d3       	rcall	.+1972   	; 0x2000 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	0f 92       	push	r0
    1852:	f8 01       	movw	r30, r16
    1854:	85 8d       	ldd	r24, Z+29	; 0x1d
    1856:	8f 3f       	cpi	r24, 0xFF	; 255
    1858:	09 f4       	brne	.+2      	; 0x185c <xQueueGenericSend+0xaa>
    185a:	15 8e       	std	Z+29, r1	; 0x1d
    185c:	f8 01       	movw	r30, r16
    185e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1860:	8f 3f       	cpi	r24, 0xFF	; 255
    1862:	09 f4       	brne	.+2      	; 0x1866 <xQueueGenericSend+0xb4>
    1864:	16 8e       	std	Z+30, r1	; 0x1e
    1866:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	be 01       	movw	r22, r28
    186c:	6c 5f       	subi	r22, 0xFC	; 252
    186e:	7f 4f       	sbci	r23, 0xFF	; 255
    1870:	ce 01       	movw	r24, r28
    1872:	01 96       	adiw	r24, 0x01	; 1
    1874:	f6 d5       	rcall	.+3052   	; 0x2462 <xTaskCheckForTimeOut>
    1876:	81 11       	cpse	r24, r1
    1878:	19 c0       	rjmp	.+50     	; 0x18ac <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
    187e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1880:	f8 01       	movw	r30, r16
    1882:	92 8d       	ldd	r25, Z+26	; 0x1a
    1884:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1888:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    188a:	98 13       	cpse	r25, r24
    188c:	0b c0       	rjmp	.+22     	; 0x18a4 <xQueueGenericSend+0xf2>
    188e:	6c 81       	ldd	r22, Y+4	; 0x04
    1890:	7d 81       	ldd	r23, Y+5	; 0x05
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1892:	c7 01       	movw	r24, r14
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1894:	82 d5       	rcall	.+2820   	; 0x239a <vTaskPlaceOnEventList>
    1896:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    1898:	dc de       	rcall	.-584    	; 0x1652 <prvUnlockQueue>
    189a:	72 d4       	rcall	.+2276   	; 0x2180 <xTaskResumeAll>
    189c:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    189e:	a5 cf       	rjmp	.-182    	; 0x17ea <xQueueGenericSend+0x38>
    18a0:	a0 dd       	rcall	.-1216   	; 0x13e2 <vPortYield>
    18a2:	a3 cf       	rjmp	.-186    	; 0x17ea <xQueueGenericSend+0x38>
				( void ) xTaskResumeAll();
    18a4:	c8 01       	movw	r24, r16
    18a6:	d5 de       	rcall	.-598    	; 0x1652 <prvUnlockQueue>
    18a8:	6b d4       	rcall	.+2262   	; 0x2180 <xTaskResumeAll>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18aa:	9f cf       	rjmp	.-194    	; 0x17ea <xQueueGenericSend+0x38>
    18ac:	c8 01       	movw	r24, r16
    18ae:	d1 de       	rcall	.-606    	; 0x1652 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18b0:	67 d4       	rcall	.+2254   	; 0x2180 <xTaskResumeAll>
    18b2:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18b4:	0f 90       	pop	r0
		}
	}
}
    18b6:	0f 90       	pop	r0
    18b8:	0f 90       	pop	r0
    18ba:	0f 90       	pop	r0
    18bc:	0f 90       	pop	r0
    18be:	df 91       	pop	r29
    18c0:	cf 91       	pop	r28
    18c2:	1f 91       	pop	r17
    18c4:	0f 91       	pop	r16
    18c6:	ff 90       	pop	r15
    18c8:	ef 90       	pop	r14
    18ca:	df 90       	pop	r13
    18cc:	cf 90       	pop	r12
    18ce:	bf 90       	pop	r11
    18d0:	af 90       	pop	r10
    18d2:	9f 90       	pop	r9
    18d4:	08 95       	ret

000018d6 <__vector_26>:
    18d6:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    18d8:	0f 92       	push	r0
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	0f 92       	push	r0
    18de:	11 24       	eor	r1, r1
    18e0:	0b b6       	in	r0, 0x3b	; 59
    18e2:	0f 92       	push	r0
    18e4:	2f 93       	push	r18
    18e6:	8f 93       	push	r24
    18e8:	9f 93       	push	r25
    18ea:	af 93       	push	r26
    18ec:	bf 93       	push	r27
    18ee:	ef 93       	push	r30
    18f0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	0f 92       	push	r0
	{
	    count = buffer->count;
    18f8:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <xSerialPort+0xd>
    18fc:	90 91 7f 04 	lds	r25, 0x047F	; 0x80047f <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    1900:	0f 90       	pop	r0
    1902:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    1904:	89 2b       	or	r24, r25
    1906:	31 f4       	brne	.+12     	; 0x1914 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    1908:	e1 ec       	ldi	r30, 0xC1	; 193
    190a:	f0 e0       	ldi	r31, 0x00	; 0
    190c:	80 81       	ld	r24, Z
    190e:	8f 7d       	andi	r24, 0xDF	; 223
    1910:	80 83       	st	Z, r24
    1912:	1c c0       	rjmp	.+56     	; 0x194c <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1914:	ee e7       	ldi	r30, 0x7E	; 126
    1916:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1918:	a4 81       	ldd	r26, Z+4	; 0x04
    191a:	b5 81       	ldd	r27, Z+5	; 0x05
    191c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    191e:	b5 83       	std	Z+5, r27	; 0x05
    1920:	a4 83       	std	Z+4, r26	; 0x04
    1922:	80 85       	ldd	r24, Z+8	; 0x08
    1924:	91 85       	ldd	r25, Z+9	; 0x09
    1926:	a8 17       	cp	r26, r24
    1928:	b9 07       	cpc	r27, r25
    192a:	21 f4       	brne	.+8      	; 0x1934 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    192c:	86 81       	ldd	r24, Z+6	; 0x06
    192e:	97 81       	ldd	r25, Z+7	; 0x07
    1930:	95 83       	std	Z+5, r25	; 0x05
    1932:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1934:	0f b6       	in	r0, 0x3f	; 63
    1936:	f8 94       	cli
    1938:	0f 92       	push	r0
	{
	    buffer->count--;
    193a:	80 81       	ld	r24, Z
    193c:	91 81       	ldd	r25, Z+1	; 0x01
    193e:	01 97       	sbiw	r24, 0x01	; 1
    1940:	91 83       	std	Z+1, r25	; 0x01
    1942:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1944:	0f 90       	pop	r0
    1946:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1948:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    194c:	ff 91       	pop	r31
    194e:	ef 91       	pop	r30
    1950:	bf 91       	pop	r27
    1952:	af 91       	pop	r26
    1954:	9f 91       	pop	r25
    1956:	8f 91       	pop	r24
    1958:	2f 91       	pop	r18
    195a:	0f 90       	pop	r0
    195c:	0b be       	out	0x3b, r0	; 59
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63
    1962:	0f 90       	pop	r0
    1964:	1f 90       	pop	r1
    1966:	18 95       	reti

00001968 <__vector_37>:
//}
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    1968:	1f 92       	push	r1
    196a:	0f 92       	push	r0
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	0f 92       	push	r0
    1970:	11 24       	eor	r1, r1
    1972:	0b b6       	in	r0, 0x3b	; 59
    1974:	0f 92       	push	r0
    1976:	2f 93       	push	r18
    1978:	8f 93       	push	r24
    197a:	9f 93       	push	r25
    197c:	af 93       	push	r26
    197e:	bf 93       	push	r27
    1980:	ef 93       	push	r30
    1982:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
	{
	    count = buffer->count;
    198a:	80 91 e4 04 	lds	r24, 0x04E4	; 0x8004e4 <xSerial1Port+0xd>
    198e:	90 91 e5 04 	lds	r25, 0x04E5	; 0x8004e5 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1996:	89 2b       	or	r24, r25
    1998:	31 f4       	brne	.+12     	; 0x19a6 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    199a:	e9 ec       	ldi	r30, 0xC9	; 201
    199c:	f0 e0       	ldi	r31, 0x00	; 0
    199e:	80 81       	ld	r24, Z
    19a0:	8f 7d       	andi	r24, 0xDF	; 223
    19a2:	80 83       	st	Z, r24
    19a4:	1c c0       	rjmp	.+56     	; 0x19de <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    19a6:	e4 ee       	ldi	r30, 0xE4	; 228
    19a8:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    19aa:	a4 81       	ldd	r26, Z+4	; 0x04
    19ac:	b5 81       	ldd	r27, Z+5	; 0x05
    19ae:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    19b0:	b5 83       	std	Z+5, r27	; 0x05
    19b2:	a4 83       	std	Z+4, r26	; 0x04
    19b4:	80 85       	ldd	r24, Z+8	; 0x08
    19b6:	91 85       	ldd	r25, Z+9	; 0x09
    19b8:	a8 17       	cp	r26, r24
    19ba:	b9 07       	cpc	r27, r25
    19bc:	21 f4       	brne	.+8      	; 0x19c6 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    19be:	86 81       	ldd	r24, Z+6	; 0x06
    19c0:	97 81       	ldd	r25, Z+7	; 0x07
    19c2:	95 83       	std	Z+5, r25	; 0x05
    19c4:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	0f 92       	push	r0
	{
	    buffer->count--;
    19cc:	80 81       	ld	r24, Z
    19ce:	91 81       	ldd	r25, Z+1	; 0x01
    19d0:	01 97       	sbiw	r24, 0x01	; 1
    19d2:	91 83       	std	Z+1, r25	; 0x01
    19d4:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    19da:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    19de:	ff 91       	pop	r31
    19e0:	ef 91       	pop	r30
    19e2:	bf 91       	pop	r27
    19e4:	af 91       	pop	r26
    19e6:	9f 91       	pop	r25
    19e8:	8f 91       	pop	r24
    19ea:	2f 91       	pop	r18
    19ec:	0f 90       	pop	r0
    19ee:	0b be       	out	0x3b, r0	; 59
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	0f 90       	pop	r0
    19f6:	1f 90       	pop	r1
    19f8:	18 95       	reti

000019fa <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    19fa:	1f 92       	push	r1
    19fc:	0f 92       	push	r0
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	0f 92       	push	r0
    1a02:	11 24       	eor	r1, r1
    1a04:	0b b6       	in	r0, 0x3b	; 59
    1a06:	0f 92       	push	r0
    1a08:	2f 93       	push	r18
    1a0a:	3f 93       	push	r19
    1a0c:	4f 93       	push	r20
    1a0e:	8f 93       	push	r24
    1a10:	9f 93       	push	r25
    1a12:	af 93       	push	r26
    1a14:	bf 93       	push	r27
    1a16:	ef 93       	push	r30
    1a18:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1a1a:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1a1e:	8c 71       	andi	r24, 0x1C	; 28
    1a20:	71 f0       	breq	.+28     	; 0x1a3e <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1a22:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1a26:	88 23       	and	r24, r24
    1a28:	0c f0       	brlt	.+2      	; 0x1a2c <__vector_51+0x32>
    1a2a:	36 c0       	rjmp	.+108    	; 0x1a98 <__vector_51+0x9e>
    1a2c:	a6 ed       	ldi	r26, 0xD6	; 214
    1a2e:	b0 e0       	ldi	r27, 0x00	; 0
    1a30:	e0 ed       	ldi	r30, 0xD0	; 208
    1a32:	f0 e0       	ldi	r31, 0x00	; 0
    1a34:	8c 91       	ld	r24, X
    1a36:	80 81       	ld	r24, Z
    1a38:	88 23       	and	r24, r24
    1a3a:	e4 f3       	brlt	.-8      	; 0x1a34 <__vector_51+0x3a>
    1a3c:	2d c0       	rjmp	.+90     	; 0x1a98 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    1a3e:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a42:	0f b6       	in	r0, 0x3f	; 63
    1a44:	f8 94       	cli
    1a46:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a48:	e3 e9       	ldi	r30, 0x93	; 147
    1a4a:	f4 e0       	ldi	r31, 0x04	; 4
    1a4c:	21 81       	ldd	r18, Z+1	; 0x01
    1a4e:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1a50:	0f 90       	pop	r0
    1a52:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    1a54:	83 85       	ldd	r24, Z+11	; 0x0b
    1a56:	94 85       	ldd	r25, Z+12	; 0x0c
    1a58:	28 17       	cp	r18, r24
    1a5a:	39 07       	cpc	r19, r25
    1a5c:	e9 f0       	breq	.+58     	; 0x1a98 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a5e:	e4 e9       	ldi	r30, 0x94	; 148
    1a60:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1a62:	a2 81       	ldd	r26, Z+2	; 0x02
    1a64:	b3 81       	ldd	r27, Z+3	; 0x03
    1a66:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1a68:	82 81       	ldd	r24, Z+2	; 0x02
    1a6a:	93 81       	ldd	r25, Z+3	; 0x03
    1a6c:	01 96       	adiw	r24, 0x01	; 1
    1a6e:	93 83       	std	Z+3, r25	; 0x03
    1a70:	82 83       	std	Z+2, r24	; 0x02
    1a72:	20 85       	ldd	r18, Z+8	; 0x08
    1a74:	31 85       	ldd	r19, Z+9	; 0x09
    1a76:	82 17       	cp	r24, r18
    1a78:	93 07       	cpc	r25, r19
    1a7a:	21 f4       	brne	.+8      	; 0x1a84 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    1a7c:	86 81       	ldd	r24, Z+6	; 0x06
    1a7e:	97 81       	ldd	r25, Z+7	; 0x07
    1a80:	93 83       	std	Z+3, r25	; 0x03
    1a82:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1a84:	0f b6       	in	r0, 0x3f	; 63
    1a86:	f8 94       	cli
    1a88:	0f 92       	push	r0
	{
	    buffer->count++;
    1a8a:	80 81       	ld	r24, Z
    1a8c:	91 81       	ldd	r25, Z+1	; 0x01
    1a8e:	01 96       	adiw	r24, 0x01	; 1
    1a90:	91 83       	std	Z+1, r25	; 0x01
    1a92:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a94:	0f 90       	pop	r0
    1a96:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1a98:	ff 91       	pop	r31
    1a9a:	ef 91       	pop	r30
    1a9c:	bf 91       	pop	r27
    1a9e:	af 91       	pop	r26
    1aa0:	9f 91       	pop	r25
    1aa2:	8f 91       	pop	r24
    1aa4:	4f 91       	pop	r20
    1aa6:	3f 91       	pop	r19
    1aa8:	2f 91       	pop	r18
    1aaa:	0f 90       	pop	r0
    1aac:	0b be       	out	0x3b, r0	; 59
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
    1ab2:	0f 90       	pop	r0
    1ab4:	1f 90       	pop	r1
    1ab6:	18 95       	reti

00001ab8 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1ab8:	1f 92       	push	r1
    1aba:	0f 92       	push	r0
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	0f 92       	push	r0
    1ac0:	11 24       	eor	r1, r1
    1ac2:	0b b6       	in	r0, 0x3b	; 59
    1ac4:	0f 92       	push	r0
    1ac6:	2f 93       	push	r18
    1ac8:	8f 93       	push	r24
    1aca:	9f 93       	push	r25
    1acc:	af 93       	push	r26
    1ace:	bf 93       	push	r27
    1ad0:	ef 93       	push	r30
    1ad2:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1ad4:	0f b6       	in	r0, 0x3f	; 63
    1ad6:	f8 94       	cli
    1ad8:	0f 92       	push	r0
	{
	    count = buffer->count;
    1ada:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <xSerial2Port+0xd>
    1ade:	90 91 a1 04 	lds	r25, 0x04A1	; 0x8004a1 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1ae6:	89 2b       	or	r24, r25
    1ae8:	31 f4       	brne	.+12     	; 0x1af6 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1aea:	e1 ed       	ldi	r30, 0xD1	; 209
    1aec:	f0 e0       	ldi	r31, 0x00	; 0
    1aee:	80 81       	ld	r24, Z
    1af0:	8f 7d       	andi	r24, 0xDF	; 223
    1af2:	80 83       	st	Z, r24
    1af4:	1c c0       	rjmp	.+56     	; 0x1b2e <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1af6:	e0 ea       	ldi	r30, 0xA0	; 160
    1af8:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1afa:	a4 81       	ldd	r26, Z+4	; 0x04
    1afc:	b5 81       	ldd	r27, Z+5	; 0x05
    1afe:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1b00:	b5 83       	std	Z+5, r27	; 0x05
    1b02:	a4 83       	std	Z+4, r26	; 0x04
    1b04:	80 85       	ldd	r24, Z+8	; 0x08
    1b06:	91 85       	ldd	r25, Z+9	; 0x09
    1b08:	a8 17       	cp	r26, r24
    1b0a:	b9 07       	cpc	r27, r25
    1b0c:	21 f4       	brne	.+8      	; 0x1b16 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    1b0e:	86 81       	ldd	r24, Z+6	; 0x06
    1b10:	97 81       	ldd	r25, Z+7	; 0x07
    1b12:	95 83       	std	Z+5, r25	; 0x05
    1b14:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
	{
	    buffer->count--;
    1b1c:	80 81       	ld	r24, Z
    1b1e:	91 81       	ldd	r25, Z+1	; 0x01
    1b20:	01 97       	sbiw	r24, 0x01	; 1
    1b22:	91 83       	std	Z+1, r25	; 0x01
    1b24:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    1b2a:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    1b2e:	ff 91       	pop	r31
    1b30:	ef 91       	pop	r30
    1b32:	bf 91       	pop	r27
    1b34:	af 91       	pop	r26
    1b36:	9f 91       	pop	r25
    1b38:	8f 91       	pop	r24
    1b3a:	2f 91       	pop	r18
    1b3c:	0f 90       	pop	r0
    1b3e:	0b be       	out	0x3b, r0	; 59
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	0f 90       	pop	r0
    1b46:	1f 90       	pop	r1
    1b48:	18 95       	reti

00001b4a <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    1b4a:	1f 92       	push	r1
    1b4c:	0f 92       	push	r0
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	0f 92       	push	r0
    1b52:	11 24       	eor	r1, r1
    1b54:	0b b6       	in	r0, 0x3b	; 59
    1b56:	0f 92       	push	r0
    1b58:	2f 93       	push	r18
    1b5a:	3f 93       	push	r19
    1b5c:	4f 93       	push	r20
    1b5e:	8f 93       	push	r24
    1b60:	9f 93       	push	r25
    1b62:	af 93       	push	r26
    1b64:	bf 93       	push	r27
    1b66:	ef 93       	push	r30
    1b68:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    1b6a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1b6e:	8c 71       	andi	r24, 0x1C	; 28
    1b70:	71 f0       	breq	.+28     	; 0x1b8e <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    1b72:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1b76:	88 23       	and	r24, r24
    1b78:	0c f0       	brlt	.+2      	; 0x1b7c <__vector_54+0x32>
    1b7a:	36 c0       	rjmp	.+108    	; 0x1be8 <__vector_54+0x9e>
    1b7c:	a6 e3       	ldi	r26, 0x36	; 54
    1b7e:	b1 e0       	ldi	r27, 0x01	; 1
    1b80:	e0 e3       	ldi	r30, 0x30	; 48
    1b82:	f1 e0       	ldi	r31, 0x01	; 1
    1b84:	8c 91       	ld	r24, X
    1b86:	80 81       	ld	r24, Z
    1b88:	88 23       	and	r24, r24
    1b8a:	e4 f3       	brlt	.-8      	; 0x1b84 <__vector_54+0x3a>
    1b8c:	2d c0       	rjmp	.+90     	; 0x1be8 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1b8e:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1b92:	0f b6       	in	r0, 0x3f	; 63
    1b94:	f8 94       	cli
    1b96:	0f 92       	push	r0
	{
	    count = buffer->count;
    1b98:	e5 eb       	ldi	r30, 0xB5	; 181
    1b9a:	f4 e0       	ldi	r31, 0x04	; 4
    1b9c:	21 81       	ldd	r18, Z+1	; 0x01
    1b9e:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1ba0:	0f 90       	pop	r0
    1ba2:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1ba4:	83 85       	ldd	r24, Z+11	; 0x0b
    1ba6:	94 85       	ldd	r25, Z+12	; 0x0c
    1ba8:	28 17       	cp	r18, r24
    1baa:	39 07       	cpc	r19, r25
    1bac:	e9 f0       	breq	.+58     	; 0x1be8 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1bae:	e6 eb       	ldi	r30, 0xB6	; 182
    1bb0:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1bb2:	a2 81       	ldd	r26, Z+2	; 0x02
    1bb4:	b3 81       	ldd	r27, Z+3	; 0x03
    1bb6:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1bb8:	82 81       	ldd	r24, Z+2	; 0x02
    1bba:	93 81       	ldd	r25, Z+3	; 0x03
    1bbc:	01 96       	adiw	r24, 0x01	; 1
    1bbe:	93 83       	std	Z+3, r25	; 0x03
    1bc0:	82 83       	std	Z+2, r24	; 0x02
    1bc2:	20 85       	ldd	r18, Z+8	; 0x08
    1bc4:	31 85       	ldd	r19, Z+9	; 0x09
    1bc6:	82 17       	cp	r24, r18
    1bc8:	93 07       	cpc	r25, r19
    1bca:	21 f4       	brne	.+8      	; 0x1bd4 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1bcc:	86 81       	ldd	r24, Z+6	; 0x06
    1bce:	97 81       	ldd	r25, Z+7	; 0x07
    1bd0:	93 83       	std	Z+3, r25	; 0x03
    1bd2:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	0f 92       	push	r0
	{
	    buffer->count++;
    1bda:	80 81       	ld	r24, Z
    1bdc:	91 81       	ldd	r25, Z+1	; 0x01
    1bde:	01 96       	adiw	r24, 0x01	; 1
    1be0:	91 83       	std	Z+1, r25	; 0x01
    1be2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1be4:	0f 90       	pop	r0
    1be6:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1be8:	ff 91       	pop	r31
    1bea:	ef 91       	pop	r30
    1bec:	bf 91       	pop	r27
    1bee:	af 91       	pop	r26
    1bf0:	9f 91       	pop	r25
    1bf2:	8f 91       	pop	r24
    1bf4:	4f 91       	pop	r20
    1bf6:	3f 91       	pop	r19
    1bf8:	2f 91       	pop	r18
    1bfa:	0f 90       	pop	r0
    1bfc:	0b be       	out	0x3b, r0	; 59
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63
    1c02:	0f 90       	pop	r0
    1c04:	1f 90       	pop	r1
    1c06:	18 95       	reti

00001c08 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1c08:	1f 92       	push	r1
    1c0a:	0f 92       	push	r0
    1c0c:	0f b6       	in	r0, 0x3f	; 63
    1c0e:	0f 92       	push	r0
    1c10:	11 24       	eor	r1, r1
    1c12:	0b b6       	in	r0, 0x3b	; 59
    1c14:	0f 92       	push	r0
    1c16:	2f 93       	push	r18
    1c18:	8f 93       	push	r24
    1c1a:	9f 93       	push	r25
    1c1c:	af 93       	push	r26
    1c1e:	bf 93       	push	r27
    1c20:	ef 93       	push	r30
    1c22:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	f8 94       	cli
    1c28:	0f 92       	push	r0
	{
	    count = buffer->count;
    1c2a:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <xSerial3Port+0xd>
    1c2e:	90 91 c3 04 	lds	r25, 0x04C3	; 0x8004c3 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1c32:	0f 90       	pop	r0
    1c34:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1c36:	89 2b       	or	r24, r25
    1c38:	31 f4       	brne	.+12     	; 0x1c46 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1c3a:	e1 e3       	ldi	r30, 0x31	; 49
    1c3c:	f1 e0       	ldi	r31, 0x01	; 1
    1c3e:	80 81       	ld	r24, Z
    1c40:	8f 7d       	andi	r24, 0xDF	; 223
    1c42:	80 83       	st	Z, r24
    1c44:	1c c0       	rjmp	.+56     	; 0x1c7e <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1c46:	e2 ec       	ldi	r30, 0xC2	; 194
    1c48:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1c4a:	a4 81       	ldd	r26, Z+4	; 0x04
    1c4c:	b5 81       	ldd	r27, Z+5	; 0x05
    1c4e:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1c50:	b5 83       	std	Z+5, r27	; 0x05
    1c52:	a4 83       	std	Z+4, r26	; 0x04
    1c54:	80 85       	ldd	r24, Z+8	; 0x08
    1c56:	91 85       	ldd	r25, Z+9	; 0x09
    1c58:	a8 17       	cp	r26, r24
    1c5a:	b9 07       	cpc	r27, r25
    1c5c:	21 f4       	brne	.+8      	; 0x1c66 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1c5e:	86 81       	ldd	r24, Z+6	; 0x06
    1c60:	97 81       	ldd	r25, Z+7	; 0x07
    1c62:	95 83       	std	Z+5, r25	; 0x05
    1c64:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1c66:	0f b6       	in	r0, 0x3f	; 63
    1c68:	f8 94       	cli
    1c6a:	0f 92       	push	r0
	{
	    buffer->count--;
    1c6c:	80 81       	ld	r24, Z
    1c6e:	91 81       	ldd	r25, Z+1	; 0x01
    1c70:	01 97       	sbiw	r24, 0x01	; 1
    1c72:	91 83       	std	Z+1, r25	; 0x01
    1c74:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1c76:	0f 90       	pop	r0
    1c78:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1c7a:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1c7e:	ff 91       	pop	r31
    1c80:	ef 91       	pop	r30
    1c82:	bf 91       	pop	r27
    1c84:	af 91       	pop	r26
    1c86:	9f 91       	pop	r25
    1c88:	8f 91       	pop	r24
    1c8a:	2f 91       	pop	r18
    1c8c:	0f 90       	pop	r0
    1c8e:	0b be       	out	0x3b, r0	; 59
    1c90:	0f 90       	pop	r0
    1c92:	0f be       	out	0x3f, r0	; 63
    1c94:	0f 90       	pop	r0
    1c96:	1f 90       	pop	r1
    1c98:	18 95       	reti

00001c9a <prvResetNextTaskUnblockTime>:
    1c9a:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1c9e:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1ca2:	80 81       	ld	r24, Z
    1ca4:	81 11       	cpse	r24, r1
    1ca6:	07 c0       	rjmp	.+14     	; 0x1cb6 <prvResetNextTaskUnblockTime+0x1c>
    1ca8:	8f ef       	ldi	r24, 0xFF	; 255
    1caa:	9f ef       	ldi	r25, 0xFF	; 255
    1cac:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1cb0:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1cb4:	08 95       	ret
    1cb6:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1cba:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1cbe:	05 80       	ldd	r0, Z+5	; 0x05
    1cc0:	f6 81       	ldd	r31, Z+6	; 0x06
    1cc2:	e0 2d       	mov	r30, r0
    1cc4:	06 80       	ldd	r0, Z+6	; 0x06
    1cc6:	f7 81       	ldd	r31, Z+7	; 0x07
    1cc8:	e0 2d       	mov	r30, r0
    1cca:	82 81       	ldd	r24, Z+2	; 0x02
    1ccc:	93 81       	ldd	r25, Z+3	; 0x03
    1cce:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1cd2:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1cd6:	08 95       	ret

00001cd8 <prvAddCurrentTaskToDelayedList>:
    1cd8:	ff 92       	push	r15
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	ec 01       	movw	r28, r24
    1ce4:	f6 2e       	mov	r15, r22
    1ce6:	00 91 cd 02 	lds	r16, 0x02CD	; 0x8002cd <xTickCount>
    1cea:	10 91 ce 02 	lds	r17, 0x02CE	; 0x8002ce <xTickCount+0x1>
    1cee:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    1cf2:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1cf6:	02 96       	adiw	r24, 0x02	; 2
    1cf8:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    1cfc:	cf 3f       	cpi	r28, 0xFF	; 255
    1cfe:	8f ef       	ldi	r24, 0xFF	; 255
    1d00:	d8 07       	cpc	r29, r24
    1d02:	69 f4       	brne	.+26     	; 0x1d1e <prvAddCurrentTaskToDelayedList+0x46>
    1d04:	ff 20       	and	r15, r15
    1d06:	59 f0       	breq	.+22     	; 0x1d1e <prvAddCurrentTaskToDelayedList+0x46>
    1d08:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1d0c:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d10:	6e 5f       	subi	r22, 0xFE	; 254
    1d12:	7f 4f       	sbci	r23, 0xFF	; 255
    1d14:	80 ed       	ldi	r24, 0xD0	; 208
    1d16:	92 e0       	ldi	r25, 0x02	; 2
    1d18:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1d1c:	2f c0       	rjmp	.+94     	; 0x1d7c <prvAddCurrentTaskToDelayedList+0xa4>
    1d1e:	c0 0f       	add	r28, r16
    1d20:	d1 1f       	adc	r29, r17
    1d22:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1d26:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d2a:	d3 83       	std	Z+3, r29	; 0x03
    1d2c:	c2 83       	std	Z+2, r28	; 0x02
    1d2e:	c0 17       	cp	r28, r16
    1d30:	d1 07       	cpc	r29, r17
    1d32:	68 f4       	brcc	.+26     	; 0x1d4e <prvAddCurrentTaskToDelayedList+0x76>
    1d34:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1d38:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d3c:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <pxOverflowDelayedTaskList>
    1d40:	90 91 ed 02 	lds	r25, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    1d44:	6e 5f       	subi	r22, 0xFE	; 254
    1d46:	7f 4f       	sbci	r23, 0xFF	; 255
    1d48:	0e 94 1f 03 	call	0x63e	; 0x63e <vListInsert>
    1d4c:	17 c0       	rjmp	.+46     	; 0x1d7c <prvAddCurrentTaskToDelayedList+0xa4>
    1d4e:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1d52:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d56:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1d5a:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1d5e:	6e 5f       	subi	r22, 0xFE	; 254
    1d60:	7f 4f       	sbci	r23, 0xFF	; 255
    1d62:	0e 94 1f 03 	call	0x63e	; 0x63e <vListInsert>
    1d66:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
    1d6a:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1d6e:	c8 17       	cp	r28, r24
    1d70:	d9 07       	cpc	r29, r25
    1d72:	20 f4       	brcc	.+8      	; 0x1d7c <prvAddCurrentTaskToDelayedList+0xa4>
    1d74:	d0 93 c6 02 	sts	0x02C6, r29	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1d78:	c0 93 c5 02 	sts	0x02C5, r28	; 0x8002c5 <xNextTaskUnblockTime>
    1d7c:	df 91       	pop	r29
    1d7e:	cf 91       	pop	r28
    1d80:	1f 91       	pop	r17
    1d82:	0f 91       	pop	r16
    1d84:	ff 90       	pop	r15
    1d86:	08 95       	ret

00001d88 <xTaskCreate>:
    1d88:	4f 92       	push	r4
    1d8a:	5f 92       	push	r5
    1d8c:	6f 92       	push	r6
    1d8e:	7f 92       	push	r7
    1d90:	8f 92       	push	r8
    1d92:	9f 92       	push	r9
    1d94:	af 92       	push	r10
    1d96:	bf 92       	push	r11
    1d98:	cf 92       	push	r12
    1d9a:	df 92       	push	r13
    1d9c:	ef 92       	push	r14
    1d9e:	ff 92       	push	r15
    1da0:	0f 93       	push	r16
    1da2:	cf 93       	push	r28
    1da4:	df 93       	push	r29
    1da6:	4c 01       	movw	r8, r24
    1da8:	6b 01       	movw	r12, r22
    1daa:	5a 01       	movw	r10, r20
    1dac:	29 01       	movw	r4, r18
    1dae:	ca 01       	movw	r24, r20
    1db0:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    1db4:	3c 01       	movw	r6, r24
    1db6:	89 2b       	or	r24, r25
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <xTaskCreate+0x34>
    1dba:	e9 c0       	rjmp	.+466    	; 0x1f8e <xTaskCreate+0x206>
    1dbc:	88 e2       	ldi	r24, 0x28	; 40
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	0e 94 ab 01 	call	0x356	; 0x356 <pvPortMalloc>
    1dc4:	ec 01       	movw	r28, r24
    1dc6:	89 2b       	or	r24, r25
    1dc8:	a9 f0       	breq	.+42     	; 0x1df4 <xTaskCreate+0x6c>
    1dca:	78 8e       	std	Y+24, r7	; 0x18
    1dcc:	6f 8a       	std	Y+23, r6	; 0x17
    1dce:	a5 01       	movw	r20, r10
    1dd0:	65 ea       	ldi	r22, 0xA5	; 165
    1dd2:	70 e0       	ldi	r23, 0x00	; 0
    1dd4:	c3 01       	movw	r24, r6
    1dd6:	b5 d6       	rcall	.+3434   	; 0x2b42 <memset>
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	a8 1a       	sub	r10, r24
    1ddc:	b1 08       	sbc	r11, r1
    1dde:	8f 89       	ldd	r24, Y+23	; 0x17
    1de0:	98 8d       	ldd	r25, Y+24	; 0x18
    1de2:	a8 0e       	add	r10, r24
    1de4:	b9 1e       	adc	r11, r25
    1de6:	d6 01       	movw	r26, r12
    1de8:	8c 91       	ld	r24, X
    1dea:	89 8f       	std	Y+25, r24	; 0x19
    1dec:	8c 91       	ld	r24, X
    1dee:	81 11       	cpse	r24, r1
    1df0:	05 c0       	rjmp	.+10     	; 0x1dfc <xTaskCreate+0x74>
    1df2:	18 c0       	rjmp	.+48     	; 0x1e24 <xTaskCreate+0x9c>
    1df4:	c3 01       	movw	r24, r6
    1df6:	0e 94 bd 01 	call	0x37a	; 0x37a <vPortFree>
    1dfa:	c9 c0       	rjmp	.+402    	; 0x1f8e <xTaskCreate+0x206>
    1dfc:	ae 01       	movw	r20, r28
    1dfe:	46 5e       	subi	r20, 0xE6	; 230
    1e00:	5f 4f       	sbci	r21, 0xFF	; 255
    1e02:	f6 01       	movw	r30, r12
    1e04:	31 96       	adiw	r30, 0x01	; 1
    1e06:	b8 e0       	ldi	r27, 0x08	; 8
    1e08:	cb 0e       	add	r12, r27
    1e0a:	d1 1c       	adc	r13, r1
    1e0c:	cf 01       	movw	r24, r30
    1e0e:	21 91       	ld	r18, Z+
    1e10:	da 01       	movw	r26, r20
    1e12:	2d 93       	st	X+, r18
    1e14:	ad 01       	movw	r20, r26
    1e16:	dc 01       	movw	r26, r24
    1e18:	8c 91       	ld	r24, X
    1e1a:	88 23       	and	r24, r24
    1e1c:	19 f0       	breq	.+6      	; 0x1e24 <xTaskCreate+0x9c>
    1e1e:	ec 15       	cp	r30, r12
    1e20:	fd 05       	cpc	r31, r13
    1e22:	a1 f7       	brne	.-24     	; 0x1e0c <xTaskCreate+0x84>
    1e24:	18 a2       	std	Y+32, r1	; 0x20
    1e26:	04 30       	cpi	r16, 0x04	; 4
    1e28:	08 f0       	brcs	.+2      	; 0x1e2c <xTaskCreate+0xa4>
    1e2a:	03 e0       	ldi	r16, 0x03	; 3
    1e2c:	0e 8b       	std	Y+22, r16	; 0x16
    1e2e:	09 a3       	std	Y+33, r16	; 0x21
    1e30:	1a a2       	std	Y+34, r1	; 0x22
    1e32:	6e 01       	movw	r12, r28
    1e34:	b2 e0       	ldi	r27, 0x02	; 2
    1e36:	cb 0e       	add	r12, r27
    1e38:	d1 1c       	adc	r13, r1
    1e3a:	c6 01       	movw	r24, r12
    1e3c:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <vListInitialiseItem>
    1e40:	ce 01       	movw	r24, r28
    1e42:	0c 96       	adiw	r24, 0x0c	; 12
    1e44:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <vListInitialiseItem>
    1e48:	d9 87       	std	Y+9, r29	; 0x09
    1e4a:	c8 87       	std	Y+8, r28	; 0x08
    1e4c:	84 e0       	ldi	r24, 0x04	; 4
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	80 1b       	sub	r24, r16
    1e52:	91 09       	sbc	r25, r1
    1e54:	9d 87       	std	Y+13, r25	; 0x0d
    1e56:	8c 87       	std	Y+12, r24	; 0x0c
    1e58:	db 8b       	std	Y+19, r29	; 0x13
    1e5a:	ca 8b       	std	Y+18, r28	; 0x12
    1e5c:	1b a2       	std	Y+35, r1	; 0x23
    1e5e:	1c a2       	std	Y+36, r1	; 0x24
    1e60:	1d a2       	std	Y+37, r1	; 0x25
    1e62:	1e a2       	std	Y+38, r1	; 0x26
    1e64:	1f a2       	std	Y+39, r1	; 0x27
    1e66:	a2 01       	movw	r20, r4
    1e68:	b4 01       	movw	r22, r8
    1e6a:	c5 01       	movw	r24, r10
    1e6c:	02 da       	rcall	.-3068   	; 0x1272 <pxPortInitialiseStack>
    1e6e:	99 83       	std	Y+1, r25	; 0x01
    1e70:	88 83       	st	Y, r24
    1e72:	e1 14       	cp	r14, r1
    1e74:	f1 04       	cpc	r15, r1
    1e76:	19 f0       	breq	.+6      	; 0x1e7e <xTaskCreate+0xf6>
    1e78:	f7 01       	movw	r30, r14
    1e7a:	d1 83       	std	Z+1, r29	; 0x01
    1e7c:	c0 83       	st	Z, r28
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	0f 92       	push	r0
    1e84:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    1e88:	8f 5f       	subi	r24, 0xFF	; 255
    1e8a:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxCurrentNumberOfTasks>
    1e8e:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    1e92:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1e96:	89 2b       	or	r24, r25
    1e98:	d1 f5       	brne	.+116    	; 0x1f0e <xTaskCreate+0x186>
    1e9a:	d0 93 27 03 	sts	0x0327, r29	; 0x800327 <pxCurrentTCB+0x1>
    1e9e:	c0 93 26 03 	sts	0x0326, r28	; 0x800326 <pxCurrentTCB>
    1ea2:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    1ea6:	81 30       	cpi	r24, 0x01	; 1
    1ea8:	09 f0       	breq	.+2      	; 0x1eac <xTaskCreate+0x124>
    1eaa:	41 c0       	rjmp	.+130    	; 0x1f2e <xTaskCreate+0x1a6>
    1eac:	82 e0       	ldi	r24, 0x02	; 2
    1eae:	93 e0       	ldi	r25, 0x03	; 3
    1eb0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1eb4:	8b e0       	ldi	r24, 0x0B	; 11
    1eb6:	93 e0       	ldi	r25, 0x03	; 3
    1eb8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ebc:	84 e1       	ldi	r24, 0x14	; 20
    1ebe:	93 e0       	ldi	r25, 0x03	; 3
    1ec0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ec4:	8d e1       	ldi	r24, 0x1D	; 29
    1ec6:	93 e0       	ldi	r25, 0x03	; 3
    1ec8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ecc:	89 ef       	ldi	r24, 0xF9	; 249
    1ece:	92 e0       	ldi	r25, 0x02	; 2
    1ed0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ed4:	80 ef       	ldi	r24, 0xF0	; 240
    1ed6:	92 e0       	ldi	r25, 0x02	; 2
    1ed8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1edc:	83 ee       	ldi	r24, 0xE3	; 227
    1ede:	92 e0       	ldi	r25, 0x02	; 2
    1ee0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ee4:	8a ed       	ldi	r24, 0xDA	; 218
    1ee6:	92 e0       	ldi	r25, 0x02	; 2
    1ee8:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1eec:	80 ed       	ldi	r24, 0xD0	; 208
    1eee:	92 e0       	ldi	r25, 0x02	; 2
    1ef0:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <vListInitialise>
    1ef4:	89 ef       	ldi	r24, 0xF9	; 249
    1ef6:	92 e0       	ldi	r25, 0x02	; 2
    1ef8:	90 93 ef 02 	sts	0x02EF, r25	; 0x8002ef <pxDelayedTaskList+0x1>
    1efc:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <pxDelayedTaskList>
    1f00:	80 ef       	ldi	r24, 0xF0	; 240
    1f02:	92 e0       	ldi	r25, 0x02	; 2
    1f04:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    1f08:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
    1f0c:	10 c0       	rjmp	.+32     	; 0x1f2e <xTaskCreate+0x1a6>
    1f0e:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <xSchedulerRunning>
    1f12:	81 11       	cpse	r24, r1
    1f14:	0c c0       	rjmp	.+24     	; 0x1f2e <xTaskCreate+0x1a6>
    1f16:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1f1a:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1f1e:	96 89       	ldd	r25, Z+22	; 0x16
    1f20:	8e 89       	ldd	r24, Y+22	; 0x16
    1f22:	89 17       	cp	r24, r25
    1f24:	20 f0       	brcs	.+8      	; 0x1f2e <xTaskCreate+0x1a6>
    1f26:	d0 93 27 03 	sts	0x0327, r29	; 0x800327 <pxCurrentTCB+0x1>
    1f2a:	c0 93 26 03 	sts	0x0326, r28	; 0x800326 <pxCurrentTCB>
    1f2e:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxTaskNumber>
    1f32:	8f 5f       	subi	r24, 0xFF	; 255
    1f34:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <uxTaskNumber>
    1f38:	8e 89       	ldd	r24, Y+22	; 0x16
    1f3a:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    1f3e:	98 17       	cp	r25, r24
    1f40:	10 f4       	brcc	.+4      	; 0x1f46 <xTaskCreate+0x1be>
    1f42:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	9c 01       	movw	r18, r24
    1f4a:	22 0f       	add	r18, r18
    1f4c:	33 1f       	adc	r19, r19
    1f4e:	22 0f       	add	r18, r18
    1f50:	33 1f       	adc	r19, r19
    1f52:	22 0f       	add	r18, r18
    1f54:	33 1f       	adc	r19, r19
    1f56:	82 0f       	add	r24, r18
    1f58:	93 1f       	adc	r25, r19
    1f5a:	b6 01       	movw	r22, r12
    1f5c:	8e 5f       	subi	r24, 0xFE	; 254
    1f5e:	9c 4f       	sbci	r25, 0xFC	; 252
    1f60:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63
    1f68:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <xSchedulerRunning>
    1f6c:	88 23       	and	r24, r24
    1f6e:	59 f0       	breq	.+22     	; 0x1f86 <xTaskCreate+0x1fe>
    1f70:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1f74:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1f78:	96 89       	ldd	r25, Z+22	; 0x16
    1f7a:	8e 89       	ldd	r24, Y+22	; 0x16
    1f7c:	98 17       	cp	r25, r24
    1f7e:	28 f4       	brcc	.+10     	; 0x1f8a <xTaskCreate+0x202>
    1f80:	30 da       	rcall	.-2976   	; 0x13e2 <vPortYield>
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	05 c0       	rjmp	.+10     	; 0x1f90 <xTaskCreate+0x208>
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	03 c0       	rjmp	.+6      	; 0x1f90 <xTaskCreate+0x208>
    1f8a:	81 e0       	ldi	r24, 0x01	; 1
    1f8c:	01 c0       	rjmp	.+2      	; 0x1f90 <xTaskCreate+0x208>
    1f8e:	8f ef       	ldi	r24, 0xFF	; 255
    1f90:	df 91       	pop	r29
    1f92:	cf 91       	pop	r28
    1f94:	0f 91       	pop	r16
    1f96:	ff 90       	pop	r15
    1f98:	ef 90       	pop	r14
    1f9a:	df 90       	pop	r13
    1f9c:	cf 90       	pop	r12
    1f9e:	bf 90       	pop	r11
    1fa0:	af 90       	pop	r10
    1fa2:	9f 90       	pop	r9
    1fa4:	8f 90       	pop	r8
    1fa6:	7f 90       	pop	r7
    1fa8:	6f 90       	pop	r6
    1faa:	5f 90       	pop	r5
    1fac:	4f 90       	pop	r4
    1fae:	08 95       	ret

00001fb0 <vTaskStartScheduler>:
    1fb0:	ef 92       	push	r14
    1fb2:	ff 92       	push	r15
    1fb4:	0f 93       	push	r16
    1fb6:	0f 2e       	mov	r0, r31
    1fb8:	f3 ec       	ldi	r31, 0xC3	; 195
    1fba:	ef 2e       	mov	r14, r31
    1fbc:	f2 e0       	ldi	r31, 0x02	; 2
    1fbe:	ff 2e       	mov	r15, r31
    1fc0:	f0 2d       	mov	r31, r0
    1fc2:	00 e0       	ldi	r16, 0x00	; 0
    1fc4:	20 e0       	ldi	r18, 0x00	; 0
    1fc6:	30 e0       	ldi	r19, 0x00	; 0
    1fc8:	45 e5       	ldi	r20, 0x55	; 85
    1fca:	50 e0       	ldi	r21, 0x00	; 0
    1fcc:	67 e9       	ldi	r22, 0x97	; 151
    1fce:	72 e0       	ldi	r23, 0x02	; 2
    1fd0:	83 e3       	ldi	r24, 0x33	; 51
    1fd2:	91 e0       	ldi	r25, 0x01	; 1
    1fd4:	d9 de       	rcall	.-590    	; 0x1d88 <xTaskCreate>
    1fd6:	81 30       	cpi	r24, 0x01	; 1
    1fd8:	79 f4       	brne	.+30     	; 0x1ff8 <vTaskStartScheduler+0x48>
    1fda:	f8 94       	cli
    1fdc:	8f ef       	ldi	r24, 0xFF	; 255
    1fde:	9f ef       	ldi	r25, 0xFF	; 255
    1fe0:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1fe4:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <xSchedulerRunning>
    1fee:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <xTickCount+0x1>
    1ff2:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <xTickCount>
    1ff6:	af d9       	rcall	.-3234   	; 0x1356 <xPortStartScheduler>
    1ff8:	0f 91       	pop	r16
    1ffa:	ff 90       	pop	r15
    1ffc:	ef 90       	pop	r14
    1ffe:	08 95       	ret

00002000 <vTaskSuspendAll>:
    2000:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    2004:	8f 5f       	subi	r24, 0xFF	; 255
    2006:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
    200a:	08 95       	ret

0000200c <xTaskIncrementTick>:
    200c:	cf 92       	push	r12
    200e:	df 92       	push	r13
    2010:	ef 92       	push	r14
    2012:	ff 92       	push	r15
    2014:	0f 93       	push	r16
    2016:	1f 93       	push	r17
    2018:	cf 93       	push	r28
    201a:	df 93       	push	r29
    201c:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    2020:	81 11       	cpse	r24, r1
    2022:	98 c0       	rjmp	.+304    	; 0x2154 <xTaskIncrementTick+0x148>
    2024:	e0 90 cd 02 	lds	r14, 0x02CD	; 0x8002cd <xTickCount>
    2028:	f0 90 ce 02 	lds	r15, 0x02CE	; 0x8002ce <xTickCount+0x1>
    202c:	8f ef       	ldi	r24, 0xFF	; 255
    202e:	e8 1a       	sub	r14, r24
    2030:	f8 0a       	sbc	r15, r24
    2032:	f0 92 ce 02 	sts	0x02CE, r15	; 0x8002ce <xTickCount+0x1>
    2036:	e0 92 cd 02 	sts	0x02CD, r14	; 0x8002cd <xTickCount>
    203a:	e1 14       	cp	r14, r1
    203c:	f1 04       	cpc	r15, r1
    203e:	b1 f4       	brne	.+44     	; 0x206c <xTaskIncrementTick+0x60>
    2040:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    2044:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    2048:	20 91 ec 02 	lds	r18, 0x02EC	; 0x8002ec <pxOverflowDelayedTaskList>
    204c:	30 91 ed 02 	lds	r19, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    2050:	30 93 ef 02 	sts	0x02EF, r19	; 0x8002ef <pxDelayedTaskList+0x1>
    2054:	20 93 ee 02 	sts	0x02EE, r18	; 0x8002ee <pxDelayedTaskList>
    2058:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    205c:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
    2060:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    2064:	8f 5f       	subi	r24, 0xFF	; 255
    2066:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNumOfOverflows>
    206a:	17 de       	rcall	.-978    	; 0x1c9a <prvResetNextTaskUnblockTime>
    206c:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
    2070:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    2074:	e8 16       	cp	r14, r24
    2076:	f9 06       	cpc	r15, r25
    2078:	10 f4       	brcc	.+4      	; 0x207e <xTaskIncrementTick+0x72>
    207a:	d1 2c       	mov	r13, r1
    207c:	53 c0       	rjmp	.+166    	; 0x2124 <xTaskIncrementTick+0x118>
    207e:	d1 2c       	mov	r13, r1
    2080:	cc 24       	eor	r12, r12
    2082:	c3 94       	inc	r12
    2084:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    2088:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    208c:	80 81       	ld	r24, Z
    208e:	81 11       	cpse	r24, r1
    2090:	07 c0       	rjmp	.+14     	; 0x20a0 <xTaskIncrementTick+0x94>
    2092:	8f ef       	ldi	r24, 0xFF	; 255
    2094:	9f ef       	ldi	r25, 0xFF	; 255
    2096:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    209a:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    209e:	42 c0       	rjmp	.+132    	; 0x2124 <xTaskIncrementTick+0x118>
    20a0:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    20a4:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    20a8:	05 80       	ldd	r0, Z+5	; 0x05
    20aa:	f6 81       	ldd	r31, Z+6	; 0x06
    20ac:	e0 2d       	mov	r30, r0
    20ae:	c6 81       	ldd	r28, Z+6	; 0x06
    20b0:	d7 81       	ldd	r29, Z+7	; 0x07
    20b2:	8a 81       	ldd	r24, Y+2	; 0x02
    20b4:	9b 81       	ldd	r25, Y+3	; 0x03
    20b6:	e8 16       	cp	r14, r24
    20b8:	f9 06       	cpc	r15, r25
    20ba:	28 f4       	brcc	.+10     	; 0x20c6 <xTaskIncrementTick+0xba>
    20bc:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    20c0:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    20c4:	2f c0       	rjmp	.+94     	; 0x2124 <xTaskIncrementTick+0x118>
    20c6:	8e 01       	movw	r16, r28
    20c8:	0e 5f       	subi	r16, 0xFE	; 254
    20ca:	1f 4f       	sbci	r17, 0xFF	; 255
    20cc:	c8 01       	movw	r24, r16
    20ce:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    20d2:	8c 89       	ldd	r24, Y+20	; 0x14
    20d4:	9d 89       	ldd	r25, Y+21	; 0x15
    20d6:	89 2b       	or	r24, r25
    20d8:	21 f0       	breq	.+8      	; 0x20e2 <xTaskIncrementTick+0xd6>
    20da:	ce 01       	movw	r24, r28
    20dc:	0c 96       	adiw	r24, 0x0c	; 12
    20de:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    20e2:	8e 89       	ldd	r24, Y+22	; 0x16
    20e4:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    20e8:	98 17       	cp	r25, r24
    20ea:	10 f4       	brcc	.+4      	; 0x20f0 <xTaskIncrementTick+0xe4>
    20ec:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    20f0:	90 e0       	ldi	r25, 0x00	; 0
    20f2:	9c 01       	movw	r18, r24
    20f4:	22 0f       	add	r18, r18
    20f6:	33 1f       	adc	r19, r19
    20f8:	22 0f       	add	r18, r18
    20fa:	33 1f       	adc	r19, r19
    20fc:	22 0f       	add	r18, r18
    20fe:	33 1f       	adc	r19, r19
    2100:	82 0f       	add	r24, r18
    2102:	93 1f       	adc	r25, r19
    2104:	b8 01       	movw	r22, r16
    2106:	8e 5f       	subi	r24, 0xFE	; 254
    2108:	9c 4f       	sbci	r25, 0xFC	; 252
    210a:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    210e:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2112:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2116:	9e 89       	ldd	r25, Y+22	; 0x16
    2118:	86 89       	ldd	r24, Z+22	; 0x16
    211a:	98 17       	cp	r25, r24
    211c:	08 f4       	brcc	.+2      	; 0x2120 <xTaskIncrementTick+0x114>
    211e:	b2 cf       	rjmp	.-156    	; 0x2084 <xTaskIncrementTick+0x78>
    2120:	dc 2c       	mov	r13, r12
    2122:	b0 cf       	rjmp	.-160    	; 0x2084 <xTaskIncrementTick+0x78>
    2124:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2128:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    212c:	86 89       	ldd	r24, Z+22	; 0x16
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	fc 01       	movw	r30, r24
    2132:	ee 0f       	add	r30, r30
    2134:	ff 1f       	adc	r31, r31
    2136:	ee 0f       	add	r30, r30
    2138:	ff 1f       	adc	r31, r31
    213a:	ee 0f       	add	r30, r30
    213c:	ff 1f       	adc	r31, r31
    213e:	8e 0f       	add	r24, r30
    2140:	9f 1f       	adc	r25, r31
    2142:	fc 01       	movw	r30, r24
    2144:	ee 5f       	subi	r30, 0xFE	; 254
    2146:	fc 4f       	sbci	r31, 0xFC	; 252
    2148:	80 81       	ld	r24, Z
    214a:	82 30       	cpi	r24, 0x02	; 2
    214c:	48 f0       	brcs	.+18     	; 0x2160 <xTaskIncrementTick+0x154>
    214e:	dd 24       	eor	r13, r13
    2150:	d3 94       	inc	r13
    2152:	06 c0       	rjmp	.+12     	; 0x2160 <xTaskIncrementTick+0x154>
    2154:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <uxPendedTicks>
    2158:	8f 5f       	subi	r24, 0xFF	; 255
    215a:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <uxPendedTicks>
    215e:	d1 2c       	mov	r13, r1
    2160:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
    2164:	88 23       	and	r24, r24
    2166:	11 f0       	breq	.+4      	; 0x216c <xTaskIncrementTick+0x160>
    2168:	dd 24       	eor	r13, r13
    216a:	d3 94       	inc	r13
    216c:	8d 2d       	mov	r24, r13
    216e:	df 91       	pop	r29
    2170:	cf 91       	pop	r28
    2172:	1f 91       	pop	r17
    2174:	0f 91       	pop	r16
    2176:	ff 90       	pop	r15
    2178:	ef 90       	pop	r14
    217a:	df 90       	pop	r13
    217c:	cf 90       	pop	r12
    217e:	08 95       	ret

00002180 <xTaskResumeAll>:
    2180:	df 92       	push	r13
    2182:	ef 92       	push	r14
    2184:	ff 92       	push	r15
    2186:	0f 93       	push	r16
    2188:	1f 93       	push	r17
    218a:	cf 93       	push	r28
    218c:	df 93       	push	r29
    218e:	0f b6       	in	r0, 0x3f	; 63
    2190:	f8 94       	cli
    2192:	0f 92       	push	r0
    2194:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    2198:	81 50       	subi	r24, 0x01	; 1
    219a:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
    219e:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    21a2:	81 11       	cpse	r24, r1
    21a4:	5c c0       	rjmp	.+184    	; 0x225e <__stack+0x5f>
    21a6:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    21aa:	81 11       	cpse	r24, r1
    21ac:	33 c0       	rjmp	.+102    	; 0x2214 <__stack+0x15>
    21ae:	5a c0       	rjmp	.+180    	; 0x2264 <__stack+0x65>
    21b0:	d7 01       	movw	r26, r14
    21b2:	15 96       	adiw	r26, 0x05	; 5
    21b4:	ed 91       	ld	r30, X+
    21b6:	fc 91       	ld	r31, X
    21b8:	16 97       	sbiw	r26, 0x06	; 6
    21ba:	c6 81       	ldd	r28, Z+6	; 0x06
    21bc:	d7 81       	ldd	r29, Z+7	; 0x07
    21be:	ce 01       	movw	r24, r28
    21c0:	0c 96       	adiw	r24, 0x0c	; 12
    21c2:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    21c6:	8e 01       	movw	r16, r28
    21c8:	0e 5f       	subi	r16, 0xFE	; 254
    21ca:	1f 4f       	sbci	r17, 0xFF	; 255
    21cc:	c8 01       	movw	r24, r16
    21ce:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    21d2:	8e 89       	ldd	r24, Y+22	; 0x16
    21d4:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    21d8:	98 17       	cp	r25, r24
    21da:	10 f4       	brcc	.+4      	; 0x21e0 <xTaskResumeAll+0x60>
    21dc:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    21e0:	90 e0       	ldi	r25, 0x00	; 0
    21e2:	9c 01       	movw	r18, r24
    21e4:	22 0f       	add	r18, r18
    21e6:	33 1f       	adc	r19, r19
    21e8:	22 0f       	add	r18, r18
    21ea:	33 1f       	adc	r19, r19
    21ec:	22 0f       	add	r18, r18
    21ee:	33 1f       	adc	r19, r19
    21f0:	82 0f       	add	r24, r18
    21f2:	93 1f       	adc	r25, r19
    21f4:	b8 01       	movw	r22, r16
    21f6:	8e 5f       	subi	r24, 0xFE	; 254
    21f8:	9c 4f       	sbci	r25, 0xFC	; 252
    21fa:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    21fe:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2202:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2206:	9e 89       	ldd	r25, Y+22	; 0x16
    2208:	86 89       	ldd	r24, Z+22	; 0x16
    220a:	98 17       	cp	r25, r24
    220c:	68 f0       	brcs	.+26     	; 0x2228 <__stack+0x29>
    220e:	d0 92 c9 02 	sts	0x02C9, r13	; 0x8002c9 <xYieldPending>
    2212:	0a c0       	rjmp	.+20     	; 0x2228 <__stack+0x29>
    2214:	c0 e0       	ldi	r28, 0x00	; 0
    2216:	d0 e0       	ldi	r29, 0x00	; 0
    2218:	0f 2e       	mov	r0, r31
    221a:	f3 ee       	ldi	r31, 0xE3	; 227
    221c:	ef 2e       	mov	r14, r31
    221e:	f2 e0       	ldi	r31, 0x02	; 2
    2220:	ff 2e       	mov	r15, r31
    2222:	f0 2d       	mov	r31, r0
    2224:	dd 24       	eor	r13, r13
    2226:	d3 94       	inc	r13
    2228:	f7 01       	movw	r30, r14
    222a:	80 81       	ld	r24, Z
    222c:	81 11       	cpse	r24, r1
    222e:	c0 cf       	rjmp	.-128    	; 0x21b0 <xTaskResumeAll+0x30>
    2230:	cd 2b       	or	r28, r29
    2232:	09 f0       	breq	.+2      	; 0x2236 <__stack+0x37>
    2234:	32 dd       	rcall	.-1436   	; 0x1c9a <prvResetNextTaskUnblockTime>
    2236:	c0 91 ca 02 	lds	r28, 0x02CA	; 0x8002ca <uxPendedTicks>
    223a:	cc 23       	and	r28, r28
    223c:	49 f0       	breq	.+18     	; 0x2250 <__stack+0x51>
    223e:	d1 e0       	ldi	r29, 0x01	; 1
    2240:	e5 de       	rcall	.-566    	; 0x200c <xTaskIncrementTick>
    2242:	81 11       	cpse	r24, r1
    2244:	d0 93 c9 02 	sts	0x02C9, r29	; 0x8002c9 <xYieldPending>
    2248:	c1 50       	subi	r28, 0x01	; 1
    224a:	d1 f7       	brne	.-12     	; 0x2240 <__stack+0x41>
    224c:	10 92 ca 02 	sts	0x02CA, r1	; 0x8002ca <uxPendedTicks>
    2250:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
    2254:	88 23       	and	r24, r24
    2256:	29 f0       	breq	.+10     	; 0x2262 <__stack+0x63>
    2258:	c4 d8       	rcall	.-3704   	; 0x13e2 <vPortYield>
    225a:	81 e0       	ldi	r24, 0x01	; 1
    225c:	03 c0       	rjmp	.+6      	; 0x2264 <__stack+0x65>
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	01 c0       	rjmp	.+2      	; 0x2264 <__stack+0x65>
    2262:	80 e0       	ldi	r24, 0x00	; 0
    2264:	0f 90       	pop	r0
    2266:	0f be       	out	0x3f, r0	; 63
    2268:	df 91       	pop	r29
    226a:	cf 91       	pop	r28
    226c:	1f 91       	pop	r17
    226e:	0f 91       	pop	r16
    2270:	ff 90       	pop	r15
    2272:	ef 90       	pop	r14
    2274:	df 90       	pop	r13
    2276:	08 95       	ret

00002278 <vTaskDelay>:
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	ec 01       	movw	r28, r24
    227e:	89 2b       	or	r24, r25
    2280:	39 f0       	breq	.+14     	; 0x2290 <vTaskDelay+0x18>
    2282:	be de       	rcall	.-644    	; 0x2000 <vTaskSuspendAll>
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	ce 01       	movw	r24, r28
    2288:	27 dd       	rcall	.-1458   	; 0x1cd8 <prvAddCurrentTaskToDelayedList>
    228a:	7a df       	rcall	.-268    	; 0x2180 <xTaskResumeAll>
    228c:	81 11       	cpse	r24, r1
    228e:	01 c0       	rjmp	.+2      	; 0x2292 <vTaskDelay+0x1a>
    2290:	a8 d8       	rcall	.-3760   	; 0x13e2 <vPortYield>
    2292:	df 91       	pop	r29
    2294:	cf 91       	pop	r28
    2296:	08 95       	ret

00002298 <vTaskSwitchContext>:
    2298:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    229c:	88 23       	and	r24, r24
    229e:	21 f0       	breq	.+8      	; 0x22a8 <vTaskSwitchContext+0x10>
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    22a6:	08 95       	ret
    22a8:	10 92 c9 02 	sts	0x02C9, r1	; 0x8002c9 <xYieldPending>
    22ac:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    22b0:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22b4:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    22b8:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22bc:	2d 91       	ld	r18, X+
    22be:	3c 91       	ld	r19, X
    22c0:	87 89       	ldd	r24, Z+23	; 0x17
    22c2:	90 8d       	ldd	r25, Z+24	; 0x18
    22c4:	82 17       	cp	r24, r18
    22c6:	93 07       	cpc	r25, r19
    22c8:	60 f0       	brcs	.+24     	; 0x22e2 <vTaskSwitchContext+0x4a>
    22ca:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    22ce:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22d2:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    22d6:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22da:	67 5e       	subi	r22, 0xE7	; 231
    22dc:	7f 4f       	sbci	r23, 0xFF	; 255
    22de:	0e 94 ef 01 	call	0x3de	; 0x3de <vApplicationStackOverflowHook>
    22e2:	20 91 cc 02 	lds	r18, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    22e6:	82 2f       	mov	r24, r18
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	fc 01       	movw	r30, r24
    22ec:	ee 0f       	add	r30, r30
    22ee:	ff 1f       	adc	r31, r31
    22f0:	ee 0f       	add	r30, r30
    22f2:	ff 1f       	adc	r31, r31
    22f4:	ee 0f       	add	r30, r30
    22f6:	ff 1f       	adc	r31, r31
    22f8:	e8 0f       	add	r30, r24
    22fa:	f9 1f       	adc	r31, r25
    22fc:	ee 5f       	subi	r30, 0xFE	; 254
    22fe:	fc 4f       	sbci	r31, 0xFC	; 252
    2300:	30 81       	ld	r19, Z
    2302:	31 11       	cpse	r19, r1
    2304:	11 c0       	rjmp	.+34     	; 0x2328 <vTaskSwitchContext+0x90>
    2306:	21 50       	subi	r18, 0x01	; 1
    2308:	82 2f       	mov	r24, r18
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	fc 01       	movw	r30, r24
    230e:	ee 0f       	add	r30, r30
    2310:	ff 1f       	adc	r31, r31
    2312:	ee 0f       	add	r30, r30
    2314:	ff 1f       	adc	r31, r31
    2316:	ee 0f       	add	r30, r30
    2318:	ff 1f       	adc	r31, r31
    231a:	e8 0f       	add	r30, r24
    231c:	f9 1f       	adc	r31, r25
    231e:	ee 5f       	subi	r30, 0xFE	; 254
    2320:	fc 4f       	sbci	r31, 0xFC	; 252
    2322:	30 81       	ld	r19, Z
    2324:	33 23       	and	r19, r19
    2326:	79 f3       	breq	.-34     	; 0x2306 <vTaskSwitchContext+0x6e>
    2328:	ac 01       	movw	r20, r24
    232a:	44 0f       	add	r20, r20
    232c:	55 1f       	adc	r21, r21
    232e:	44 0f       	add	r20, r20
    2330:	55 1f       	adc	r21, r21
    2332:	44 0f       	add	r20, r20
    2334:	55 1f       	adc	r21, r21
    2336:	48 0f       	add	r20, r24
    2338:	59 1f       	adc	r21, r25
    233a:	da 01       	movw	r26, r20
    233c:	ae 5f       	subi	r26, 0xFE	; 254
    233e:	bc 4f       	sbci	r27, 0xFC	; 252
    2340:	11 96       	adiw	r26, 0x01	; 1
    2342:	ed 91       	ld	r30, X+
    2344:	fc 91       	ld	r31, X
    2346:	12 97       	sbiw	r26, 0x02	; 2
    2348:	02 80       	ldd	r0, Z+2	; 0x02
    234a:	f3 81       	ldd	r31, Z+3	; 0x03
    234c:	e0 2d       	mov	r30, r0
    234e:	12 96       	adiw	r26, 0x02	; 2
    2350:	fc 93       	st	X, r31
    2352:	ee 93       	st	-X, r30
    2354:	11 97       	sbiw	r26, 0x01	; 1
    2356:	4b 5f       	subi	r20, 0xFB	; 251
    2358:	5c 4f       	sbci	r21, 0xFC	; 252
    235a:	e4 17       	cp	r30, r20
    235c:	f5 07       	cpc	r31, r21
    235e:	29 f4       	brne	.+10     	; 0x236a <vTaskSwitchContext+0xd2>
    2360:	42 81       	ldd	r20, Z+2	; 0x02
    2362:	53 81       	ldd	r21, Z+3	; 0x03
    2364:	fd 01       	movw	r30, r26
    2366:	52 83       	std	Z+2, r21	; 0x02
    2368:	41 83       	std	Z+1, r20	; 0x01
    236a:	fc 01       	movw	r30, r24
    236c:	ee 0f       	add	r30, r30
    236e:	ff 1f       	adc	r31, r31
    2370:	ee 0f       	add	r30, r30
    2372:	ff 1f       	adc	r31, r31
    2374:	ee 0f       	add	r30, r30
    2376:	ff 1f       	adc	r31, r31
    2378:	8e 0f       	add	r24, r30
    237a:	9f 1f       	adc	r25, r31
    237c:	fc 01       	movw	r30, r24
    237e:	ee 5f       	subi	r30, 0xFE	; 254
    2380:	fc 4f       	sbci	r31, 0xFC	; 252
    2382:	01 80       	ldd	r0, Z+1	; 0x01
    2384:	f2 81       	ldd	r31, Z+2	; 0x02
    2386:	e0 2d       	mov	r30, r0
    2388:	86 81       	ldd	r24, Z+6	; 0x06
    238a:	97 81       	ldd	r25, Z+7	; 0x07
    238c:	90 93 27 03 	sts	0x0327, r25	; 0x800327 <pxCurrentTCB+0x1>
    2390:	80 93 26 03 	sts	0x0326, r24	; 0x800326 <pxCurrentTCB>
    2394:	20 93 cc 02 	sts	0x02CC, r18	; 0x8002cc <uxTopReadyPriority>
    2398:	08 95       	ret

0000239a <vTaskPlaceOnEventList>:
    239a:	cf 93       	push	r28
    239c:	df 93       	push	r29
    239e:	eb 01       	movw	r28, r22
    23a0:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    23a4:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    23a8:	64 5f       	subi	r22, 0xF4	; 244
    23aa:	7f 4f       	sbci	r23, 0xFF	; 255
    23ac:	0e 94 1f 03 	call	0x63e	; 0x63e <vListInsert>
    23b0:	61 e0       	ldi	r22, 0x01	; 1
    23b2:	ce 01       	movw	r24, r28
    23b4:	91 dc       	rcall	.-1758   	; 0x1cd8 <prvAddCurrentTaskToDelayedList>
    23b6:	df 91       	pop	r29
    23b8:	cf 91       	pop	r28
    23ba:	08 95       	ret

000023bc <xTaskRemoveFromEventList>:
    23bc:	0f 93       	push	r16
    23be:	1f 93       	push	r17
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	dc 01       	movw	r26, r24
    23c6:	15 96       	adiw	r26, 0x05	; 5
    23c8:	ed 91       	ld	r30, X+
    23ca:	fc 91       	ld	r31, X
    23cc:	16 97       	sbiw	r26, 0x06	; 6
    23ce:	c6 81       	ldd	r28, Z+6	; 0x06
    23d0:	d7 81       	ldd	r29, Z+7	; 0x07
    23d2:	8e 01       	movw	r16, r28
    23d4:	04 5f       	subi	r16, 0xF4	; 244
    23d6:	1f 4f       	sbci	r17, 0xFF	; 255
    23d8:	c8 01       	movw	r24, r16
    23da:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    23de:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    23e2:	81 11       	cpse	r24, r1
    23e4:	1c c0       	rjmp	.+56     	; 0x241e <xTaskRemoveFromEventList+0x62>
    23e6:	0a 50       	subi	r16, 0x0A	; 10
    23e8:	11 09       	sbc	r17, r1
    23ea:	c8 01       	movw	r24, r16
    23ec:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
    23f0:	8e 89       	ldd	r24, Y+22	; 0x16
    23f2:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    23f6:	98 17       	cp	r25, r24
    23f8:	10 f4       	brcc	.+4      	; 0x23fe <xTaskRemoveFromEventList+0x42>
    23fa:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	9c 01       	movw	r18, r24
    2402:	22 0f       	add	r18, r18
    2404:	33 1f       	adc	r19, r19
    2406:	22 0f       	add	r18, r18
    2408:	33 1f       	adc	r19, r19
    240a:	22 0f       	add	r18, r18
    240c:	33 1f       	adc	r19, r19
    240e:	82 0f       	add	r24, r18
    2410:	93 1f       	adc	r25, r19
    2412:	b8 01       	movw	r22, r16
    2414:	8e 5f       	subi	r24, 0xFE	; 254
    2416:	9c 4f       	sbci	r25, 0xFC	; 252
    2418:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    241c:	05 c0       	rjmp	.+10     	; 0x2428 <xTaskRemoveFromEventList+0x6c>
    241e:	b8 01       	movw	r22, r16
    2420:	83 ee       	ldi	r24, 0xE3	; 227
    2422:	92 e0       	ldi	r25, 0x02	; 2
    2424:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
    2428:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    242c:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2430:	9e 89       	ldd	r25, Y+22	; 0x16
    2432:	86 89       	ldd	r24, Z+22	; 0x16
    2434:	89 17       	cp	r24, r25
    2436:	20 f4       	brcc	.+8      	; 0x2440 <xTaskRemoveFromEventList+0x84>
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    243e:	01 c0       	rjmp	.+2      	; 0x2442 <xTaskRemoveFromEventList+0x86>
    2440:	80 e0       	ldi	r24, 0x00	; 0
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	08 95       	ret

0000244c <vTaskSetTimeOutState>:
    244c:	20 91 c8 02 	lds	r18, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    2450:	fc 01       	movw	r30, r24
    2452:	20 83       	st	Z, r18
    2454:	20 91 cd 02 	lds	r18, 0x02CD	; 0x8002cd <xTickCount>
    2458:	30 91 ce 02 	lds	r19, 0x02CE	; 0x8002ce <xTickCount+0x1>
    245c:	32 83       	std	Z+2, r19	; 0x02
    245e:	21 83       	std	Z+1, r18	; 0x01
    2460:	08 95       	ret

00002462 <xTaskCheckForTimeOut>:
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	0f 92       	push	r0
    2468:	40 91 cd 02 	lds	r20, 0x02CD	; 0x8002cd <xTickCount>
    246c:	50 91 ce 02 	lds	r21, 0x02CE	; 0x8002ce <xTickCount+0x1>
    2470:	db 01       	movw	r26, r22
    2472:	2d 91       	ld	r18, X+
    2474:	3c 91       	ld	r19, X
    2476:	2f 3f       	cpi	r18, 0xFF	; 255
    2478:	bf ef       	ldi	r27, 0xFF	; 255
    247a:	3b 07       	cpc	r19, r27
    247c:	11 f1       	breq	.+68     	; 0x24c2 <xTaskCheckForTimeOut+0x60>
    247e:	e0 91 c8 02 	lds	r30, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    2482:	dc 01       	movw	r26, r24
    2484:	fc 91       	ld	r31, X
    2486:	fe 17       	cp	r31, r30
    2488:	39 f0       	breq	.+14     	; 0x2498 <xTaskCheckForTimeOut+0x36>
    248a:	11 96       	adiw	r26, 0x01	; 1
    248c:	ed 91       	ld	r30, X+
    248e:	fc 91       	ld	r31, X
    2490:	12 97       	sbiw	r26, 0x02	; 2
    2492:	4e 17       	cp	r20, r30
    2494:	5f 07       	cpc	r21, r31
    2496:	b8 f4       	brcc	.+46     	; 0x24c6 <xTaskCheckForTimeOut+0x64>
    2498:	dc 01       	movw	r26, r24
    249a:	11 96       	adiw	r26, 0x01	; 1
    249c:	ed 91       	ld	r30, X+
    249e:	fc 91       	ld	r31, X
    24a0:	12 97       	sbiw	r26, 0x02	; 2
    24a2:	da 01       	movw	r26, r20
    24a4:	ae 1b       	sub	r26, r30
    24a6:	bf 0b       	sbc	r27, r31
    24a8:	a2 17       	cp	r26, r18
    24aa:	b3 07       	cpc	r27, r19
    24ac:	70 f4       	brcc	.+28     	; 0x24ca <xTaskCheckForTimeOut+0x68>
    24ae:	db 01       	movw	r26, r22
    24b0:	e4 1b       	sub	r30, r20
    24b2:	f5 0b       	sbc	r31, r21
    24b4:	2e 0f       	add	r18, r30
    24b6:	3f 1f       	adc	r19, r31
    24b8:	2d 93       	st	X+, r18
    24ba:	3c 93       	st	X, r19
    24bc:	c7 df       	rcall	.-114    	; 0x244c <vTaskSetTimeOutState>
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	05 c0       	rjmp	.+10     	; 0x24cc <xTaskCheckForTimeOut+0x6a>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	03 c0       	rjmp	.+6      	; 0x24cc <xTaskCheckForTimeOut+0x6a>
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	01 c0       	rjmp	.+2      	; 0x24cc <xTaskCheckForTimeOut+0x6a>
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	0f 90       	pop	r0
    24ce:	0f be       	out	0x3f, r0	; 63
    24d0:	08 95       	ret

000024d2 <vTaskMissedYield>:
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    24d8:	08 95       	ret

000024da <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    24da:	0f 93       	push	r16
    24dc:	1f 93       	push	r17
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    24e4:	89 2b       	or	r24, r25
    24e6:	79 f1       	breq	.+94     	; 0x2546 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    24e8:	82 a1       	ldd	r24, Z+34	; 0x22
    24ea:	81 50       	subi	r24, 0x01	; 1
    24ec:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    24ee:	26 89       	ldd	r18, Z+22	; 0x16
    24f0:	91 a1       	ldd	r25, Z+33	; 0x21
    24f2:	29 17       	cp	r18, r25
    24f4:	51 f1       	breq	.+84     	; 0x254a <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    24f6:	81 11       	cpse	r24, r1
    24f8:	2a c0       	rjmp	.+84     	; 0x254e <xTaskPriorityDisinherit+0x74>
    24fa:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    24fc:	8f 01       	movw	r16, r30
    24fe:	0e 5f       	subi	r16, 0xFE	; 254
    2500:	1f 4f       	sbci	r17, 0xFF	; 255
    2502:	c8 01       	movw	r24, r16
    2504:	0e 94 50 03 	call	0x6a0	; 0x6a0 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2508:	89 a1       	ldd	r24, Y+33	; 0x21
    250a:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    250c:	24 e0       	ldi	r18, 0x04	; 4
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	28 1b       	sub	r18, r24
    2512:	31 09       	sbc	r19, r1
    2514:	3d 87       	std	Y+13, r19	; 0x0d
    2516:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2518:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    251c:	98 17       	cp	r25, r24
    251e:	10 f4       	brcc	.+4      	; 0x2524 <xTaskPriorityDisinherit+0x4a>
    2520:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	9c 01       	movw	r18, r24
    2528:	22 0f       	add	r18, r18
    252a:	33 1f       	adc	r19, r19
    252c:	22 0f       	add	r18, r18
    252e:	33 1f       	adc	r19, r19
    2530:	22 0f       	add	r18, r18
    2532:	33 1f       	adc	r19, r19
    2534:	82 0f       	add	r24, r18
    2536:	93 1f       	adc	r25, r19
    2538:	b8 01       	movw	r22, r16
    253a:	8e 5f       	subi	r24, 0xFE	; 254
    253c:	9c 4f       	sbci	r25, 0xFC	; 252
    253e:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	05 c0       	rjmp	.+10     	; 0x2550 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2546:	80 e0       	ldi	r24, 0x00	; 0
    2548:	03 c0       	rjmp	.+6      	; 0x2550 <xTaskPriorityDisinherit+0x76>
    254a:	80 e0       	ldi	r24, 0x00	; 0
    254c:	01 c0       	rjmp	.+2      	; 0x2550 <xTaskPriorityDisinherit+0x76>
    254e:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    2550:	df 91       	pop	r29
    2552:	cf 91       	pop	r28
    2554:	1f 91       	pop	r17
    2556:	0f 91       	pop	r16
    2558:	08 95       	ret

0000255a <__subsf3>:
    255a:	50 58       	subi	r21, 0x80	; 128

0000255c <__addsf3>:
    255c:	bb 27       	eor	r27, r27
    255e:	aa 27       	eor	r26, r26
    2560:	0e d0       	rcall	.+28     	; 0x257e <__addsf3x>
    2562:	e5 c0       	rjmp	.+458    	; 0x272e <__fp_round>
    2564:	d6 d0       	rcall	.+428    	; 0x2712 <__fp_pscA>
    2566:	30 f0       	brcs	.+12     	; 0x2574 <__addsf3+0x18>
    2568:	db d0       	rcall	.+438    	; 0x2720 <__fp_pscB>
    256a:	20 f0       	brcs	.+8      	; 0x2574 <__addsf3+0x18>
    256c:	31 f4       	brne	.+12     	; 0x257a <__addsf3+0x1e>
    256e:	9f 3f       	cpi	r25, 0xFF	; 255
    2570:	11 f4       	brne	.+4      	; 0x2576 <__addsf3+0x1a>
    2572:	1e f4       	brtc	.+6      	; 0x257a <__addsf3+0x1e>
    2574:	cb c0       	rjmp	.+406    	; 0x270c <__fp_nan>
    2576:	0e f4       	brtc	.+2      	; 0x257a <__addsf3+0x1e>
    2578:	e0 95       	com	r30
    257a:	e7 fb       	bst	r30, 7
    257c:	c1 c0       	rjmp	.+386    	; 0x2700 <__fp_inf>

0000257e <__addsf3x>:
    257e:	e9 2f       	mov	r30, r25
    2580:	e7 d0       	rcall	.+462    	; 0x2750 <__fp_split3>
    2582:	80 f3       	brcs	.-32     	; 0x2564 <__addsf3+0x8>
    2584:	ba 17       	cp	r27, r26
    2586:	62 07       	cpc	r22, r18
    2588:	73 07       	cpc	r23, r19
    258a:	84 07       	cpc	r24, r20
    258c:	95 07       	cpc	r25, r21
    258e:	18 f0       	brcs	.+6      	; 0x2596 <__addsf3x+0x18>
    2590:	71 f4       	brne	.+28     	; 0x25ae <__addsf3x+0x30>
    2592:	9e f5       	brtc	.+102    	; 0x25fa <__addsf3x+0x7c>
    2594:	ff c0       	rjmp	.+510    	; 0x2794 <__fp_zero>
    2596:	0e f4       	brtc	.+2      	; 0x259a <__addsf3x+0x1c>
    2598:	e0 95       	com	r30
    259a:	0b 2e       	mov	r0, r27
    259c:	ba 2f       	mov	r27, r26
    259e:	a0 2d       	mov	r26, r0
    25a0:	0b 01       	movw	r0, r22
    25a2:	b9 01       	movw	r22, r18
    25a4:	90 01       	movw	r18, r0
    25a6:	0c 01       	movw	r0, r24
    25a8:	ca 01       	movw	r24, r20
    25aa:	a0 01       	movw	r20, r0
    25ac:	11 24       	eor	r1, r1
    25ae:	ff 27       	eor	r31, r31
    25b0:	59 1b       	sub	r21, r25
    25b2:	99 f0       	breq	.+38     	; 0x25da <__addsf3x+0x5c>
    25b4:	59 3f       	cpi	r21, 0xF9	; 249
    25b6:	50 f4       	brcc	.+20     	; 0x25cc <__addsf3x+0x4e>
    25b8:	50 3e       	cpi	r21, 0xE0	; 224
    25ba:	68 f1       	brcs	.+90     	; 0x2616 <__addsf3x+0x98>
    25bc:	1a 16       	cp	r1, r26
    25be:	f0 40       	sbci	r31, 0x00	; 0
    25c0:	a2 2f       	mov	r26, r18
    25c2:	23 2f       	mov	r18, r19
    25c4:	34 2f       	mov	r19, r20
    25c6:	44 27       	eor	r20, r20
    25c8:	58 5f       	subi	r21, 0xF8	; 248
    25ca:	f3 cf       	rjmp	.-26     	; 0x25b2 <__addsf3x+0x34>
    25cc:	46 95       	lsr	r20
    25ce:	37 95       	ror	r19
    25d0:	27 95       	ror	r18
    25d2:	a7 95       	ror	r26
    25d4:	f0 40       	sbci	r31, 0x00	; 0
    25d6:	53 95       	inc	r21
    25d8:	c9 f7       	brne	.-14     	; 0x25cc <__addsf3x+0x4e>
    25da:	7e f4       	brtc	.+30     	; 0x25fa <__addsf3x+0x7c>
    25dc:	1f 16       	cp	r1, r31
    25de:	ba 0b       	sbc	r27, r26
    25e0:	62 0b       	sbc	r22, r18
    25e2:	73 0b       	sbc	r23, r19
    25e4:	84 0b       	sbc	r24, r20
    25e6:	ba f0       	brmi	.+46     	; 0x2616 <__addsf3x+0x98>
    25e8:	91 50       	subi	r25, 0x01	; 1
    25ea:	a1 f0       	breq	.+40     	; 0x2614 <__addsf3x+0x96>
    25ec:	ff 0f       	add	r31, r31
    25ee:	bb 1f       	adc	r27, r27
    25f0:	66 1f       	adc	r22, r22
    25f2:	77 1f       	adc	r23, r23
    25f4:	88 1f       	adc	r24, r24
    25f6:	c2 f7       	brpl	.-16     	; 0x25e8 <__addsf3x+0x6a>
    25f8:	0e c0       	rjmp	.+28     	; 0x2616 <__addsf3x+0x98>
    25fa:	ba 0f       	add	r27, r26
    25fc:	62 1f       	adc	r22, r18
    25fe:	73 1f       	adc	r23, r19
    2600:	84 1f       	adc	r24, r20
    2602:	48 f4       	brcc	.+18     	; 0x2616 <__addsf3x+0x98>
    2604:	87 95       	ror	r24
    2606:	77 95       	ror	r23
    2608:	67 95       	ror	r22
    260a:	b7 95       	ror	r27
    260c:	f7 95       	ror	r31
    260e:	9e 3f       	cpi	r25, 0xFE	; 254
    2610:	08 f0       	brcs	.+2      	; 0x2614 <__addsf3x+0x96>
    2612:	b3 cf       	rjmp	.-154    	; 0x257a <__addsf3+0x1e>
    2614:	93 95       	inc	r25
    2616:	88 0f       	add	r24, r24
    2618:	08 f0       	brcs	.+2      	; 0x261c <__addsf3x+0x9e>
    261a:	99 27       	eor	r25, r25
    261c:	ee 0f       	add	r30, r30
    261e:	97 95       	ror	r25
    2620:	87 95       	ror	r24
    2622:	08 95       	ret

00002624 <__fixsfsi>:
    2624:	04 d0       	rcall	.+8      	; 0x262e <__fixunssfsi>
    2626:	68 94       	set
    2628:	b1 11       	cpse	r27, r1
    262a:	b5 c0       	rjmp	.+362    	; 0x2796 <__fp_szero>
    262c:	08 95       	ret

0000262e <__fixunssfsi>:
    262e:	98 d0       	rcall	.+304    	; 0x2760 <__fp_splitA>
    2630:	88 f0       	brcs	.+34     	; 0x2654 <__fixunssfsi+0x26>
    2632:	9f 57       	subi	r25, 0x7F	; 127
    2634:	90 f0       	brcs	.+36     	; 0x265a <__fixunssfsi+0x2c>
    2636:	b9 2f       	mov	r27, r25
    2638:	99 27       	eor	r25, r25
    263a:	b7 51       	subi	r27, 0x17	; 23
    263c:	a0 f0       	brcs	.+40     	; 0x2666 <__fixunssfsi+0x38>
    263e:	d1 f0       	breq	.+52     	; 0x2674 <__fixunssfsi+0x46>
    2640:	66 0f       	add	r22, r22
    2642:	77 1f       	adc	r23, r23
    2644:	88 1f       	adc	r24, r24
    2646:	99 1f       	adc	r25, r25
    2648:	1a f0       	brmi	.+6      	; 0x2650 <__fixunssfsi+0x22>
    264a:	ba 95       	dec	r27
    264c:	c9 f7       	brne	.-14     	; 0x2640 <__fixunssfsi+0x12>
    264e:	12 c0       	rjmp	.+36     	; 0x2674 <__fixunssfsi+0x46>
    2650:	b1 30       	cpi	r27, 0x01	; 1
    2652:	81 f0       	breq	.+32     	; 0x2674 <__fixunssfsi+0x46>
    2654:	9f d0       	rcall	.+318    	; 0x2794 <__fp_zero>
    2656:	b1 e0       	ldi	r27, 0x01	; 1
    2658:	08 95       	ret
    265a:	9c c0       	rjmp	.+312    	; 0x2794 <__fp_zero>
    265c:	67 2f       	mov	r22, r23
    265e:	78 2f       	mov	r23, r24
    2660:	88 27       	eor	r24, r24
    2662:	b8 5f       	subi	r27, 0xF8	; 248
    2664:	39 f0       	breq	.+14     	; 0x2674 <__fixunssfsi+0x46>
    2666:	b9 3f       	cpi	r27, 0xF9	; 249
    2668:	cc f3       	brlt	.-14     	; 0x265c <__fixunssfsi+0x2e>
    266a:	86 95       	lsr	r24
    266c:	77 95       	ror	r23
    266e:	67 95       	ror	r22
    2670:	b3 95       	inc	r27
    2672:	d9 f7       	brne	.-10     	; 0x266a <__fixunssfsi+0x3c>
    2674:	3e f4       	brtc	.+14     	; 0x2684 <__fixunssfsi+0x56>
    2676:	90 95       	com	r25
    2678:	80 95       	com	r24
    267a:	70 95       	com	r23
    267c:	61 95       	neg	r22
    267e:	7f 4f       	sbci	r23, 0xFF	; 255
    2680:	8f 4f       	sbci	r24, 0xFF	; 255
    2682:	9f 4f       	sbci	r25, 0xFF	; 255
    2684:	08 95       	ret

00002686 <__floatunsisf>:
    2686:	e8 94       	clt
    2688:	09 c0       	rjmp	.+18     	; 0x269c <__floatsisf+0x12>

0000268a <__floatsisf>:
    268a:	97 fb       	bst	r25, 7
    268c:	3e f4       	brtc	.+14     	; 0x269c <__floatsisf+0x12>
    268e:	90 95       	com	r25
    2690:	80 95       	com	r24
    2692:	70 95       	com	r23
    2694:	61 95       	neg	r22
    2696:	7f 4f       	sbci	r23, 0xFF	; 255
    2698:	8f 4f       	sbci	r24, 0xFF	; 255
    269a:	9f 4f       	sbci	r25, 0xFF	; 255
    269c:	99 23       	and	r25, r25
    269e:	a9 f0       	breq	.+42     	; 0x26ca <__floatsisf+0x40>
    26a0:	f9 2f       	mov	r31, r25
    26a2:	96 e9       	ldi	r25, 0x96	; 150
    26a4:	bb 27       	eor	r27, r27
    26a6:	93 95       	inc	r25
    26a8:	f6 95       	lsr	r31
    26aa:	87 95       	ror	r24
    26ac:	77 95       	ror	r23
    26ae:	67 95       	ror	r22
    26b0:	b7 95       	ror	r27
    26b2:	f1 11       	cpse	r31, r1
    26b4:	f8 cf       	rjmp	.-16     	; 0x26a6 <__floatsisf+0x1c>
    26b6:	fa f4       	brpl	.+62     	; 0x26f6 <__floatsisf+0x6c>
    26b8:	bb 0f       	add	r27, r27
    26ba:	11 f4       	brne	.+4      	; 0x26c0 <__floatsisf+0x36>
    26bc:	60 ff       	sbrs	r22, 0
    26be:	1b c0       	rjmp	.+54     	; 0x26f6 <__floatsisf+0x6c>
    26c0:	6f 5f       	subi	r22, 0xFF	; 255
    26c2:	7f 4f       	sbci	r23, 0xFF	; 255
    26c4:	8f 4f       	sbci	r24, 0xFF	; 255
    26c6:	9f 4f       	sbci	r25, 0xFF	; 255
    26c8:	16 c0       	rjmp	.+44     	; 0x26f6 <__floatsisf+0x6c>
    26ca:	88 23       	and	r24, r24
    26cc:	11 f0       	breq	.+4      	; 0x26d2 <__floatsisf+0x48>
    26ce:	96 e9       	ldi	r25, 0x96	; 150
    26d0:	11 c0       	rjmp	.+34     	; 0x26f4 <__floatsisf+0x6a>
    26d2:	77 23       	and	r23, r23
    26d4:	21 f0       	breq	.+8      	; 0x26de <__floatsisf+0x54>
    26d6:	9e e8       	ldi	r25, 0x8E	; 142
    26d8:	87 2f       	mov	r24, r23
    26da:	76 2f       	mov	r23, r22
    26dc:	05 c0       	rjmp	.+10     	; 0x26e8 <__floatsisf+0x5e>
    26de:	66 23       	and	r22, r22
    26e0:	71 f0       	breq	.+28     	; 0x26fe <__floatsisf+0x74>
    26e2:	96 e8       	ldi	r25, 0x86	; 134
    26e4:	86 2f       	mov	r24, r22
    26e6:	70 e0       	ldi	r23, 0x00	; 0
    26e8:	60 e0       	ldi	r22, 0x00	; 0
    26ea:	2a f0       	brmi	.+10     	; 0x26f6 <__floatsisf+0x6c>
    26ec:	9a 95       	dec	r25
    26ee:	66 0f       	add	r22, r22
    26f0:	77 1f       	adc	r23, r23
    26f2:	88 1f       	adc	r24, r24
    26f4:	da f7       	brpl	.-10     	; 0x26ec <__floatsisf+0x62>
    26f6:	88 0f       	add	r24, r24
    26f8:	96 95       	lsr	r25
    26fa:	87 95       	ror	r24
    26fc:	97 f9       	bld	r25, 7
    26fe:	08 95       	ret

00002700 <__fp_inf>:
    2700:	97 f9       	bld	r25, 7
    2702:	9f 67       	ori	r25, 0x7F	; 127
    2704:	80 e8       	ldi	r24, 0x80	; 128
    2706:	70 e0       	ldi	r23, 0x00	; 0
    2708:	60 e0       	ldi	r22, 0x00	; 0
    270a:	08 95       	ret

0000270c <__fp_nan>:
    270c:	9f ef       	ldi	r25, 0xFF	; 255
    270e:	80 ec       	ldi	r24, 0xC0	; 192
    2710:	08 95       	ret

00002712 <__fp_pscA>:
    2712:	00 24       	eor	r0, r0
    2714:	0a 94       	dec	r0
    2716:	16 16       	cp	r1, r22
    2718:	17 06       	cpc	r1, r23
    271a:	18 06       	cpc	r1, r24
    271c:	09 06       	cpc	r0, r25
    271e:	08 95       	ret

00002720 <__fp_pscB>:
    2720:	00 24       	eor	r0, r0
    2722:	0a 94       	dec	r0
    2724:	12 16       	cp	r1, r18
    2726:	13 06       	cpc	r1, r19
    2728:	14 06       	cpc	r1, r20
    272a:	05 06       	cpc	r0, r21
    272c:	08 95       	ret

0000272e <__fp_round>:
    272e:	09 2e       	mov	r0, r25
    2730:	03 94       	inc	r0
    2732:	00 0c       	add	r0, r0
    2734:	11 f4       	brne	.+4      	; 0x273a <__fp_round+0xc>
    2736:	88 23       	and	r24, r24
    2738:	52 f0       	brmi	.+20     	; 0x274e <__fp_round+0x20>
    273a:	bb 0f       	add	r27, r27
    273c:	40 f4       	brcc	.+16     	; 0x274e <__fp_round+0x20>
    273e:	bf 2b       	or	r27, r31
    2740:	11 f4       	brne	.+4      	; 0x2746 <__fp_round+0x18>
    2742:	60 ff       	sbrs	r22, 0
    2744:	04 c0       	rjmp	.+8      	; 0x274e <__fp_round+0x20>
    2746:	6f 5f       	subi	r22, 0xFF	; 255
    2748:	7f 4f       	sbci	r23, 0xFF	; 255
    274a:	8f 4f       	sbci	r24, 0xFF	; 255
    274c:	9f 4f       	sbci	r25, 0xFF	; 255
    274e:	08 95       	ret

00002750 <__fp_split3>:
    2750:	57 fd       	sbrc	r21, 7
    2752:	90 58       	subi	r25, 0x80	; 128
    2754:	44 0f       	add	r20, r20
    2756:	55 1f       	adc	r21, r21
    2758:	59 f0       	breq	.+22     	; 0x2770 <__fp_splitA+0x10>
    275a:	5f 3f       	cpi	r21, 0xFF	; 255
    275c:	71 f0       	breq	.+28     	; 0x277a <__fp_splitA+0x1a>
    275e:	47 95       	ror	r20

00002760 <__fp_splitA>:
    2760:	88 0f       	add	r24, r24
    2762:	97 fb       	bst	r25, 7
    2764:	99 1f       	adc	r25, r25
    2766:	61 f0       	breq	.+24     	; 0x2780 <__fp_splitA+0x20>
    2768:	9f 3f       	cpi	r25, 0xFF	; 255
    276a:	79 f0       	breq	.+30     	; 0x278a <__fp_splitA+0x2a>
    276c:	87 95       	ror	r24
    276e:	08 95       	ret
    2770:	12 16       	cp	r1, r18
    2772:	13 06       	cpc	r1, r19
    2774:	14 06       	cpc	r1, r20
    2776:	55 1f       	adc	r21, r21
    2778:	f2 cf       	rjmp	.-28     	; 0x275e <__fp_split3+0xe>
    277a:	46 95       	lsr	r20
    277c:	f1 df       	rcall	.-30     	; 0x2760 <__fp_splitA>
    277e:	08 c0       	rjmp	.+16     	; 0x2790 <__fp_splitA+0x30>
    2780:	16 16       	cp	r1, r22
    2782:	17 06       	cpc	r1, r23
    2784:	18 06       	cpc	r1, r24
    2786:	99 1f       	adc	r25, r25
    2788:	f1 cf       	rjmp	.-30     	; 0x276c <__fp_splitA+0xc>
    278a:	86 95       	lsr	r24
    278c:	71 05       	cpc	r23, r1
    278e:	61 05       	cpc	r22, r1
    2790:	08 94       	sec
    2792:	08 95       	ret

00002794 <__fp_zero>:
    2794:	e8 94       	clt

00002796 <__fp_szero>:
    2796:	bb 27       	eor	r27, r27
    2798:	66 27       	eor	r22, r22
    279a:	77 27       	eor	r23, r23
    279c:	cb 01       	movw	r24, r22
    279e:	97 f9       	bld	r25, 7
    27a0:	08 95       	ret

000027a2 <__mulsf3>:
    27a2:	0b d0       	rcall	.+22     	; 0x27ba <__mulsf3x>
    27a4:	c4 cf       	rjmp	.-120    	; 0x272e <__fp_round>
    27a6:	b5 df       	rcall	.-150    	; 0x2712 <__fp_pscA>
    27a8:	28 f0       	brcs	.+10     	; 0x27b4 <__mulsf3+0x12>
    27aa:	ba df       	rcall	.-140    	; 0x2720 <__fp_pscB>
    27ac:	18 f0       	brcs	.+6      	; 0x27b4 <__mulsf3+0x12>
    27ae:	95 23       	and	r25, r21
    27b0:	09 f0       	breq	.+2      	; 0x27b4 <__mulsf3+0x12>
    27b2:	a6 cf       	rjmp	.-180    	; 0x2700 <__fp_inf>
    27b4:	ab cf       	rjmp	.-170    	; 0x270c <__fp_nan>
    27b6:	11 24       	eor	r1, r1
    27b8:	ee cf       	rjmp	.-36     	; 0x2796 <__fp_szero>

000027ba <__mulsf3x>:
    27ba:	ca df       	rcall	.-108    	; 0x2750 <__fp_split3>
    27bc:	a0 f3       	brcs	.-24     	; 0x27a6 <__mulsf3+0x4>

000027be <__mulsf3_pse>:
    27be:	95 9f       	mul	r25, r21
    27c0:	d1 f3       	breq	.-12     	; 0x27b6 <__mulsf3+0x14>
    27c2:	95 0f       	add	r25, r21
    27c4:	50 e0       	ldi	r21, 0x00	; 0
    27c6:	55 1f       	adc	r21, r21
    27c8:	62 9f       	mul	r22, r18
    27ca:	f0 01       	movw	r30, r0
    27cc:	72 9f       	mul	r23, r18
    27ce:	bb 27       	eor	r27, r27
    27d0:	f0 0d       	add	r31, r0
    27d2:	b1 1d       	adc	r27, r1
    27d4:	63 9f       	mul	r22, r19
    27d6:	aa 27       	eor	r26, r26
    27d8:	f0 0d       	add	r31, r0
    27da:	b1 1d       	adc	r27, r1
    27dc:	aa 1f       	adc	r26, r26
    27de:	64 9f       	mul	r22, r20
    27e0:	66 27       	eor	r22, r22
    27e2:	b0 0d       	add	r27, r0
    27e4:	a1 1d       	adc	r26, r1
    27e6:	66 1f       	adc	r22, r22
    27e8:	82 9f       	mul	r24, r18
    27ea:	22 27       	eor	r18, r18
    27ec:	b0 0d       	add	r27, r0
    27ee:	a1 1d       	adc	r26, r1
    27f0:	62 1f       	adc	r22, r18
    27f2:	73 9f       	mul	r23, r19
    27f4:	b0 0d       	add	r27, r0
    27f6:	a1 1d       	adc	r26, r1
    27f8:	62 1f       	adc	r22, r18
    27fa:	83 9f       	mul	r24, r19
    27fc:	a0 0d       	add	r26, r0
    27fe:	61 1d       	adc	r22, r1
    2800:	22 1f       	adc	r18, r18
    2802:	74 9f       	mul	r23, r20
    2804:	33 27       	eor	r19, r19
    2806:	a0 0d       	add	r26, r0
    2808:	61 1d       	adc	r22, r1
    280a:	23 1f       	adc	r18, r19
    280c:	84 9f       	mul	r24, r20
    280e:	60 0d       	add	r22, r0
    2810:	21 1d       	adc	r18, r1
    2812:	82 2f       	mov	r24, r18
    2814:	76 2f       	mov	r23, r22
    2816:	6a 2f       	mov	r22, r26
    2818:	11 24       	eor	r1, r1
    281a:	9f 57       	subi	r25, 0x7F	; 127
    281c:	50 40       	sbci	r21, 0x00	; 0
    281e:	8a f0       	brmi	.+34     	; 0x2842 <__mulsf3_pse+0x84>
    2820:	e1 f0       	breq	.+56     	; 0x285a <__mulsf3_pse+0x9c>
    2822:	88 23       	and	r24, r24
    2824:	4a f0       	brmi	.+18     	; 0x2838 <__mulsf3_pse+0x7a>
    2826:	ee 0f       	add	r30, r30
    2828:	ff 1f       	adc	r31, r31
    282a:	bb 1f       	adc	r27, r27
    282c:	66 1f       	adc	r22, r22
    282e:	77 1f       	adc	r23, r23
    2830:	88 1f       	adc	r24, r24
    2832:	91 50       	subi	r25, 0x01	; 1
    2834:	50 40       	sbci	r21, 0x00	; 0
    2836:	a9 f7       	brne	.-22     	; 0x2822 <__mulsf3_pse+0x64>
    2838:	9e 3f       	cpi	r25, 0xFE	; 254
    283a:	51 05       	cpc	r21, r1
    283c:	70 f0       	brcs	.+28     	; 0x285a <__mulsf3_pse+0x9c>
    283e:	60 cf       	rjmp	.-320    	; 0x2700 <__fp_inf>
    2840:	aa cf       	rjmp	.-172    	; 0x2796 <__fp_szero>
    2842:	5f 3f       	cpi	r21, 0xFF	; 255
    2844:	ec f3       	brlt	.-6      	; 0x2840 <__mulsf3_pse+0x82>
    2846:	98 3e       	cpi	r25, 0xE8	; 232
    2848:	dc f3       	brlt	.-10     	; 0x2840 <__mulsf3_pse+0x82>
    284a:	86 95       	lsr	r24
    284c:	77 95       	ror	r23
    284e:	67 95       	ror	r22
    2850:	b7 95       	ror	r27
    2852:	f7 95       	ror	r31
    2854:	e7 95       	ror	r30
    2856:	9f 5f       	subi	r25, 0xFF	; 255
    2858:	c1 f7       	brne	.-16     	; 0x284a <__mulsf3_pse+0x8c>
    285a:	fe 2b       	or	r31, r30
    285c:	88 0f       	add	r24, r24
    285e:	91 1d       	adc	r25, r1
    2860:	96 95       	lsr	r25
    2862:	87 95       	ror	r24
    2864:	97 f9       	bld	r25, 7
    2866:	08 95       	ret

00002868 <__udivmodsi4>:
    2868:	a1 e2       	ldi	r26, 0x21	; 33
    286a:	1a 2e       	mov	r1, r26
    286c:	aa 1b       	sub	r26, r26
    286e:	bb 1b       	sub	r27, r27
    2870:	fd 01       	movw	r30, r26
    2872:	0d c0       	rjmp	.+26     	; 0x288e <__udivmodsi4_ep>

00002874 <__udivmodsi4_loop>:
    2874:	aa 1f       	adc	r26, r26
    2876:	bb 1f       	adc	r27, r27
    2878:	ee 1f       	adc	r30, r30
    287a:	ff 1f       	adc	r31, r31
    287c:	a2 17       	cp	r26, r18
    287e:	b3 07       	cpc	r27, r19
    2880:	e4 07       	cpc	r30, r20
    2882:	f5 07       	cpc	r31, r21
    2884:	20 f0       	brcs	.+8      	; 0x288e <__udivmodsi4_ep>
    2886:	a2 1b       	sub	r26, r18
    2888:	b3 0b       	sbc	r27, r19
    288a:	e4 0b       	sbc	r30, r20
    288c:	f5 0b       	sbc	r31, r21

0000288e <__udivmodsi4_ep>:
    288e:	66 1f       	adc	r22, r22
    2890:	77 1f       	adc	r23, r23
    2892:	88 1f       	adc	r24, r24
    2894:	99 1f       	adc	r25, r25
    2896:	1a 94       	dec	r1
    2898:	69 f7       	brne	.-38     	; 0x2874 <__udivmodsi4_loop>
    289a:	60 95       	com	r22
    289c:	70 95       	com	r23
    289e:	80 95       	com	r24
    28a0:	90 95       	com	r25
    28a2:	9b 01       	movw	r18, r22
    28a4:	ac 01       	movw	r20, r24
    28a6:	bd 01       	movw	r22, r26
    28a8:	cf 01       	movw	r24, r30
    28aa:	08 95       	ret

000028ac <__tablejump2__>:
    28ac:	ee 0f       	add	r30, r30
    28ae:	ff 1f       	adc	r31, r31
    28b0:	88 1f       	adc	r24, r24
    28b2:	8b bf       	out	0x3b, r24	; 59
    28b4:	07 90       	elpm	r0, Z+
    28b6:	f6 91       	elpm	r31, Z
    28b8:	e0 2d       	mov	r30, r0
    28ba:	19 94       	eijmp

000028bc <__umulhisi3>:
    28bc:	a2 9f       	mul	r26, r18
    28be:	b0 01       	movw	r22, r0
    28c0:	b3 9f       	mul	r27, r19
    28c2:	c0 01       	movw	r24, r0
    28c4:	a3 9f       	mul	r26, r19
    28c6:	70 0d       	add	r23, r0
    28c8:	81 1d       	adc	r24, r1
    28ca:	11 24       	eor	r1, r1
    28cc:	91 1d       	adc	r25, r1
    28ce:	b2 9f       	mul	r27, r18
    28d0:	70 0d       	add	r23, r0
    28d2:	81 1d       	adc	r24, r1
    28d4:	11 24       	eor	r1, r1
    28d6:	91 1d       	adc	r25, r1
    28d8:	08 95       	ret

000028da <__muluhisi3>:
    28da:	f0 df       	rcall	.-32     	; 0x28bc <__umulhisi3>
    28dc:	a5 9f       	mul	r26, r21
    28de:	90 0d       	add	r25, r0
    28e0:	b4 9f       	mul	r27, r20
    28e2:	90 0d       	add	r25, r0
    28e4:	a4 9f       	mul	r26, r20
    28e6:	80 0d       	add	r24, r0
    28e8:	91 1d       	adc	r25, r1
    28ea:	11 24       	eor	r1, r1
    28ec:	08 95       	ret

000028ee <malloc>:
    28ee:	0f 93       	push	r16
    28f0:	1f 93       	push	r17
    28f2:	cf 93       	push	r28
    28f4:	df 93       	push	r29
    28f6:	82 30       	cpi	r24, 0x02	; 2
    28f8:	91 05       	cpc	r25, r1
    28fa:	10 f4       	brcc	.+4      	; 0x2900 <malloc+0x12>
    28fc:	82 e0       	ldi	r24, 0x02	; 2
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <__flp>
    2904:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <__flp+0x1>
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	a0 e0       	ldi	r26, 0x00	; 0
    290e:	b0 e0       	ldi	r27, 0x00	; 0
    2910:	30 97       	sbiw	r30, 0x00	; 0
    2912:	19 f1       	breq	.+70     	; 0x295a <malloc+0x6c>
    2914:	40 81       	ld	r20, Z
    2916:	51 81       	ldd	r21, Z+1	; 0x01
    2918:	02 81       	ldd	r16, Z+2	; 0x02
    291a:	13 81       	ldd	r17, Z+3	; 0x03
    291c:	48 17       	cp	r20, r24
    291e:	59 07       	cpc	r21, r25
    2920:	c8 f0       	brcs	.+50     	; 0x2954 <malloc+0x66>
    2922:	84 17       	cp	r24, r20
    2924:	95 07       	cpc	r25, r21
    2926:	69 f4       	brne	.+26     	; 0x2942 <malloc+0x54>
    2928:	10 97       	sbiw	r26, 0x00	; 0
    292a:	31 f0       	breq	.+12     	; 0x2938 <malloc+0x4a>
    292c:	12 96       	adiw	r26, 0x02	; 2
    292e:	0c 93       	st	X, r16
    2930:	12 97       	sbiw	r26, 0x02	; 2
    2932:	13 96       	adiw	r26, 0x03	; 3
    2934:	1c 93       	st	X, r17
    2936:	27 c0       	rjmp	.+78     	; 0x2986 <malloc+0x98>
    2938:	00 93 fb 04 	sts	0x04FB, r16	; 0x8004fb <__flp>
    293c:	10 93 fc 04 	sts	0x04FC, r17	; 0x8004fc <__flp+0x1>
    2940:	22 c0       	rjmp	.+68     	; 0x2986 <malloc+0x98>
    2942:	21 15       	cp	r18, r1
    2944:	31 05       	cpc	r19, r1
    2946:	19 f0       	breq	.+6      	; 0x294e <malloc+0x60>
    2948:	42 17       	cp	r20, r18
    294a:	53 07       	cpc	r21, r19
    294c:	18 f4       	brcc	.+6      	; 0x2954 <malloc+0x66>
    294e:	9a 01       	movw	r18, r20
    2950:	bd 01       	movw	r22, r26
    2952:	ef 01       	movw	r28, r30
    2954:	df 01       	movw	r26, r30
    2956:	f8 01       	movw	r30, r16
    2958:	db cf       	rjmp	.-74     	; 0x2910 <malloc+0x22>
    295a:	21 15       	cp	r18, r1
    295c:	31 05       	cpc	r19, r1
    295e:	f9 f0       	breq	.+62     	; 0x299e <malloc+0xb0>
    2960:	28 1b       	sub	r18, r24
    2962:	39 0b       	sbc	r19, r25
    2964:	24 30       	cpi	r18, 0x04	; 4
    2966:	31 05       	cpc	r19, r1
    2968:	80 f4       	brcc	.+32     	; 0x298a <malloc+0x9c>
    296a:	8a 81       	ldd	r24, Y+2	; 0x02
    296c:	9b 81       	ldd	r25, Y+3	; 0x03
    296e:	61 15       	cp	r22, r1
    2970:	71 05       	cpc	r23, r1
    2972:	21 f0       	breq	.+8      	; 0x297c <malloc+0x8e>
    2974:	fb 01       	movw	r30, r22
    2976:	93 83       	std	Z+3, r25	; 0x03
    2978:	82 83       	std	Z+2, r24	; 0x02
    297a:	04 c0       	rjmp	.+8      	; 0x2984 <malloc+0x96>
    297c:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <__flp+0x1>
    2980:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <__flp>
    2984:	fe 01       	movw	r30, r28
    2986:	32 96       	adiw	r30, 0x02	; 2
    2988:	44 c0       	rjmp	.+136    	; 0x2a12 <malloc+0x124>
    298a:	fe 01       	movw	r30, r28
    298c:	e2 0f       	add	r30, r18
    298e:	f3 1f       	adc	r31, r19
    2990:	81 93       	st	Z+, r24
    2992:	91 93       	st	Z+, r25
    2994:	22 50       	subi	r18, 0x02	; 2
    2996:	31 09       	sbc	r19, r1
    2998:	39 83       	std	Y+1, r19	; 0x01
    299a:	28 83       	st	Y, r18
    299c:	3a c0       	rjmp	.+116    	; 0x2a12 <malloc+0x124>
    299e:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    29a2:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    29a6:	23 2b       	or	r18, r19
    29a8:	41 f4       	brne	.+16     	; 0x29ba <malloc+0xcc>
    29aa:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    29ae:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    29b2:	30 93 fa 04 	sts	0x04FA, r19	; 0x8004fa <__brkval+0x1>
    29b6:	20 93 f9 04 	sts	0x04F9, r18	; 0x8004f9 <__brkval>
    29ba:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    29be:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    29c2:	21 15       	cp	r18, r1
    29c4:	31 05       	cpc	r19, r1
    29c6:	41 f4       	brne	.+16     	; 0x29d8 <malloc+0xea>
    29c8:	2d b7       	in	r18, 0x3d	; 61
    29ca:	3e b7       	in	r19, 0x3e	; 62
    29cc:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    29d0:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    29d4:	24 1b       	sub	r18, r20
    29d6:	35 0b       	sbc	r19, r21
    29d8:	e0 91 f9 04 	lds	r30, 0x04F9	; 0x8004f9 <__brkval>
    29dc:	f0 91 fa 04 	lds	r31, 0x04FA	; 0x8004fa <__brkval+0x1>
    29e0:	e2 17       	cp	r30, r18
    29e2:	f3 07       	cpc	r31, r19
    29e4:	a0 f4       	brcc	.+40     	; 0x2a0e <malloc+0x120>
    29e6:	2e 1b       	sub	r18, r30
    29e8:	3f 0b       	sbc	r19, r31
    29ea:	28 17       	cp	r18, r24
    29ec:	39 07       	cpc	r19, r25
    29ee:	78 f0       	brcs	.+30     	; 0x2a0e <malloc+0x120>
    29f0:	ac 01       	movw	r20, r24
    29f2:	4e 5f       	subi	r20, 0xFE	; 254
    29f4:	5f 4f       	sbci	r21, 0xFF	; 255
    29f6:	24 17       	cp	r18, r20
    29f8:	35 07       	cpc	r19, r21
    29fa:	48 f0       	brcs	.+18     	; 0x2a0e <malloc+0x120>
    29fc:	4e 0f       	add	r20, r30
    29fe:	5f 1f       	adc	r21, r31
    2a00:	50 93 fa 04 	sts	0x04FA, r21	; 0x8004fa <__brkval+0x1>
    2a04:	40 93 f9 04 	sts	0x04F9, r20	; 0x8004f9 <__brkval>
    2a08:	81 93       	st	Z+, r24
    2a0a:	91 93       	st	Z+, r25
    2a0c:	02 c0       	rjmp	.+4      	; 0x2a12 <malloc+0x124>
    2a0e:	e0 e0       	ldi	r30, 0x00	; 0
    2a10:	f0 e0       	ldi	r31, 0x00	; 0
    2a12:	cf 01       	movw	r24, r30
    2a14:	df 91       	pop	r29
    2a16:	cf 91       	pop	r28
    2a18:	1f 91       	pop	r17
    2a1a:	0f 91       	pop	r16
    2a1c:	08 95       	ret

00002a1e <free>:
    2a1e:	cf 93       	push	r28
    2a20:	df 93       	push	r29
    2a22:	00 97       	sbiw	r24, 0x00	; 0
    2a24:	09 f4       	brne	.+2      	; 0x2a28 <free+0xa>
    2a26:	81 c0       	rjmp	.+258    	; 0x2b2a <free+0x10c>
    2a28:	fc 01       	movw	r30, r24
    2a2a:	32 97       	sbiw	r30, 0x02	; 2
    2a2c:	13 82       	std	Z+3, r1	; 0x03
    2a2e:	12 82       	std	Z+2, r1	; 0x02
    2a30:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <__flp>
    2a34:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <__flp+0x1>
    2a38:	10 97       	sbiw	r26, 0x00	; 0
    2a3a:	81 f4       	brne	.+32     	; 0x2a5c <free+0x3e>
    2a3c:	20 81       	ld	r18, Z
    2a3e:	31 81       	ldd	r19, Z+1	; 0x01
    2a40:	82 0f       	add	r24, r18
    2a42:	93 1f       	adc	r25, r19
    2a44:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    2a48:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    2a4c:	28 17       	cp	r18, r24
    2a4e:	39 07       	cpc	r19, r25
    2a50:	51 f5       	brne	.+84     	; 0x2aa6 <free+0x88>
    2a52:	f0 93 fa 04 	sts	0x04FA, r31	; 0x8004fa <__brkval+0x1>
    2a56:	e0 93 f9 04 	sts	0x04F9, r30	; 0x8004f9 <__brkval>
    2a5a:	67 c0       	rjmp	.+206    	; 0x2b2a <free+0x10c>
    2a5c:	ed 01       	movw	r28, r26
    2a5e:	20 e0       	ldi	r18, 0x00	; 0
    2a60:	30 e0       	ldi	r19, 0x00	; 0
    2a62:	ce 17       	cp	r28, r30
    2a64:	df 07       	cpc	r29, r31
    2a66:	40 f4       	brcc	.+16     	; 0x2a78 <free+0x5a>
    2a68:	4a 81       	ldd	r20, Y+2	; 0x02
    2a6a:	5b 81       	ldd	r21, Y+3	; 0x03
    2a6c:	9e 01       	movw	r18, r28
    2a6e:	41 15       	cp	r20, r1
    2a70:	51 05       	cpc	r21, r1
    2a72:	f1 f0       	breq	.+60     	; 0x2ab0 <free+0x92>
    2a74:	ea 01       	movw	r28, r20
    2a76:	f5 cf       	rjmp	.-22     	; 0x2a62 <free+0x44>
    2a78:	d3 83       	std	Z+3, r29	; 0x03
    2a7a:	c2 83       	std	Z+2, r28	; 0x02
    2a7c:	40 81       	ld	r20, Z
    2a7e:	51 81       	ldd	r21, Z+1	; 0x01
    2a80:	84 0f       	add	r24, r20
    2a82:	95 1f       	adc	r25, r21
    2a84:	c8 17       	cp	r28, r24
    2a86:	d9 07       	cpc	r29, r25
    2a88:	59 f4       	brne	.+22     	; 0x2aa0 <free+0x82>
    2a8a:	88 81       	ld	r24, Y
    2a8c:	99 81       	ldd	r25, Y+1	; 0x01
    2a8e:	84 0f       	add	r24, r20
    2a90:	95 1f       	adc	r25, r21
    2a92:	02 96       	adiw	r24, 0x02	; 2
    2a94:	91 83       	std	Z+1, r25	; 0x01
    2a96:	80 83       	st	Z, r24
    2a98:	8a 81       	ldd	r24, Y+2	; 0x02
    2a9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a9c:	93 83       	std	Z+3, r25	; 0x03
    2a9e:	82 83       	std	Z+2, r24	; 0x02
    2aa0:	21 15       	cp	r18, r1
    2aa2:	31 05       	cpc	r19, r1
    2aa4:	29 f4       	brne	.+10     	; 0x2ab0 <free+0x92>
    2aa6:	f0 93 fc 04 	sts	0x04FC, r31	; 0x8004fc <__flp+0x1>
    2aaa:	e0 93 fb 04 	sts	0x04FB, r30	; 0x8004fb <__flp>
    2aae:	3d c0       	rjmp	.+122    	; 0x2b2a <free+0x10c>
    2ab0:	e9 01       	movw	r28, r18
    2ab2:	fb 83       	std	Y+3, r31	; 0x03
    2ab4:	ea 83       	std	Y+2, r30	; 0x02
    2ab6:	49 91       	ld	r20, Y+
    2ab8:	59 91       	ld	r21, Y+
    2aba:	c4 0f       	add	r28, r20
    2abc:	d5 1f       	adc	r29, r21
    2abe:	ec 17       	cp	r30, r28
    2ac0:	fd 07       	cpc	r31, r29
    2ac2:	61 f4       	brne	.+24     	; 0x2adc <free+0xbe>
    2ac4:	80 81       	ld	r24, Z
    2ac6:	91 81       	ldd	r25, Z+1	; 0x01
    2ac8:	84 0f       	add	r24, r20
    2aca:	95 1f       	adc	r25, r21
    2acc:	02 96       	adiw	r24, 0x02	; 2
    2ace:	e9 01       	movw	r28, r18
    2ad0:	99 83       	std	Y+1, r25	; 0x01
    2ad2:	88 83       	st	Y, r24
    2ad4:	82 81       	ldd	r24, Z+2	; 0x02
    2ad6:	93 81       	ldd	r25, Z+3	; 0x03
    2ad8:	9b 83       	std	Y+3, r25	; 0x03
    2ada:	8a 83       	std	Y+2, r24	; 0x02
    2adc:	e0 e0       	ldi	r30, 0x00	; 0
    2ade:	f0 e0       	ldi	r31, 0x00	; 0
    2ae0:	12 96       	adiw	r26, 0x02	; 2
    2ae2:	8d 91       	ld	r24, X+
    2ae4:	9c 91       	ld	r25, X
    2ae6:	13 97       	sbiw	r26, 0x03	; 3
    2ae8:	00 97       	sbiw	r24, 0x00	; 0
    2aea:	19 f0       	breq	.+6      	; 0x2af2 <free+0xd4>
    2aec:	fd 01       	movw	r30, r26
    2aee:	dc 01       	movw	r26, r24
    2af0:	f7 cf       	rjmp	.-18     	; 0x2ae0 <free+0xc2>
    2af2:	8d 91       	ld	r24, X+
    2af4:	9c 91       	ld	r25, X
    2af6:	11 97       	sbiw	r26, 0x01	; 1
    2af8:	9d 01       	movw	r18, r26
    2afa:	2e 5f       	subi	r18, 0xFE	; 254
    2afc:	3f 4f       	sbci	r19, 0xFF	; 255
    2afe:	82 0f       	add	r24, r18
    2b00:	93 1f       	adc	r25, r19
    2b02:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    2b06:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    2b0a:	28 17       	cp	r18, r24
    2b0c:	39 07       	cpc	r19, r25
    2b0e:	69 f4       	brne	.+26     	; 0x2b2a <free+0x10c>
    2b10:	30 97       	sbiw	r30, 0x00	; 0
    2b12:	29 f4       	brne	.+10     	; 0x2b1e <free+0x100>
    2b14:	10 92 fc 04 	sts	0x04FC, r1	; 0x8004fc <__flp+0x1>
    2b18:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <__flp>
    2b1c:	02 c0       	rjmp	.+4      	; 0x2b22 <free+0x104>
    2b1e:	13 82       	std	Z+3, r1	; 0x03
    2b20:	12 82       	std	Z+2, r1	; 0x02
    2b22:	b0 93 fa 04 	sts	0x04FA, r27	; 0x8004fa <__brkval+0x1>
    2b26:	a0 93 f9 04 	sts	0x04F9, r26	; 0x8004f9 <__brkval>
    2b2a:	df 91       	pop	r29
    2b2c:	cf 91       	pop	r28
    2b2e:	08 95       	ret

00002b30 <memcpy>:
    2b30:	fb 01       	movw	r30, r22
    2b32:	dc 01       	movw	r26, r24
    2b34:	02 c0       	rjmp	.+4      	; 0x2b3a <memcpy+0xa>
    2b36:	01 90       	ld	r0, Z+
    2b38:	0d 92       	st	X+, r0
    2b3a:	41 50       	subi	r20, 0x01	; 1
    2b3c:	50 40       	sbci	r21, 0x00	; 0
    2b3e:	d8 f7       	brcc	.-10     	; 0x2b36 <memcpy+0x6>
    2b40:	08 95       	ret

00002b42 <memset>:
    2b42:	dc 01       	movw	r26, r24
    2b44:	01 c0       	rjmp	.+2      	; 0x2b48 <memset+0x6>
    2b46:	6d 93       	st	X+, r22
    2b48:	41 50       	subi	r20, 0x01	; 1
    2b4a:	50 40       	sbci	r21, 0x00	; 0
    2b4c:	e0 f7       	brcc	.-8      	; 0x2b46 <memset+0x4>
    2b4e:	08 95       	ret

00002b50 <__itoa_ncheck>:
    2b50:	bb 27       	eor	r27, r27
    2b52:	4a 30       	cpi	r20, 0x0A	; 10
    2b54:	31 f4       	brne	.+12     	; 0x2b62 <__itoa_ncheck+0x12>
    2b56:	99 23       	and	r25, r25
    2b58:	22 f4       	brpl	.+8      	; 0x2b62 <__itoa_ncheck+0x12>
    2b5a:	bd e2       	ldi	r27, 0x2D	; 45
    2b5c:	90 95       	com	r25
    2b5e:	81 95       	neg	r24
    2b60:	9f 4f       	sbci	r25, 0xFF	; 255
    2b62:	01 c0       	rjmp	.+2      	; 0x2b66 <__utoa_common>

00002b64 <__utoa_ncheck>:
    2b64:	bb 27       	eor	r27, r27

00002b66 <__utoa_common>:
    2b66:	fb 01       	movw	r30, r22
    2b68:	55 27       	eor	r21, r21
    2b6a:	aa 27       	eor	r26, r26
    2b6c:	88 0f       	add	r24, r24
    2b6e:	99 1f       	adc	r25, r25
    2b70:	aa 1f       	adc	r26, r26
    2b72:	a4 17       	cp	r26, r20
    2b74:	10 f0       	brcs	.+4      	; 0x2b7a <__utoa_common+0x14>
    2b76:	a4 1b       	sub	r26, r20
    2b78:	83 95       	inc	r24
    2b7a:	50 51       	subi	r21, 0x10	; 16
    2b7c:	b9 f7       	brne	.-18     	; 0x2b6c <__utoa_common+0x6>
    2b7e:	a0 5d       	subi	r26, 0xD0	; 208
    2b80:	aa 33       	cpi	r26, 0x3A	; 58
    2b82:	08 f0       	brcs	.+2      	; 0x2b86 <__utoa_common+0x20>
    2b84:	a9 5d       	subi	r26, 0xD9	; 217
    2b86:	a1 93       	st	Z+, r26
    2b88:	00 97       	sbiw	r24, 0x00	; 0
    2b8a:	79 f7       	brne	.-34     	; 0x2b6a <__utoa_common+0x4>
    2b8c:	b1 11       	cpse	r27, r1
    2b8e:	b1 93       	st	Z+, r27
    2b90:	11 92       	st	Z+, r1
    2b92:	cb 01       	movw	r24, r22
    2b94:	00 c0       	rjmp	.+0      	; 0x2b96 <strrev>

00002b96 <strrev>:
    2b96:	dc 01       	movw	r26, r24
    2b98:	fc 01       	movw	r30, r24
    2b9a:	67 2f       	mov	r22, r23
    2b9c:	71 91       	ld	r23, Z+
    2b9e:	77 23       	and	r23, r23
    2ba0:	e1 f7       	brne	.-8      	; 0x2b9a <strrev+0x4>
    2ba2:	32 97       	sbiw	r30, 0x02	; 2
    2ba4:	04 c0       	rjmp	.+8      	; 0x2bae <strrev+0x18>
    2ba6:	7c 91       	ld	r23, X
    2ba8:	6d 93       	st	X+, r22
    2baa:	70 83       	st	Z, r23
    2bac:	62 91       	ld	r22, -Z
    2bae:	ae 17       	cp	r26, r30
    2bb0:	bf 07       	cpc	r27, r31
    2bb2:	c8 f3       	brcs	.-14     	; 0x2ba6 <strrev+0x10>
    2bb4:	08 95       	ret

00002bb6 <_exit>:
    2bb6:	f8 94       	cli

00002bb8 <__stop_program>:
    2bb8:	ff cf       	rjmp	.-2      	; 0x2bb8 <__stop_program>
