
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800200  00002888  0000291c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002888  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000265  0080029c  0080029c  000029b8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000029b8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000029e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005f8  00000000  00000000  00002a28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008039  00000000  00000000  00003020  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ed6  00000000  00000000  0000b059  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004dd8  00000000  00000000  0000cf2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000015a0  00000000  00000000  00011d08  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000020fb  00000000  00000000  000132a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007764  00000000  00000000  000153a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008d0  00000000  00000000  0001cb07  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	bb c1       	rjmp	.+886    	; 0x378 <__ctors_end>
       2:	00 00       	nop
       4:	d9 c1       	rjmp	.+946    	; 0x3b8 <__bad_interrupt>
       6:	00 00       	nop
       8:	d7 c1       	rjmp	.+942    	; 0x3b8 <__bad_interrupt>
       a:	00 00       	nop
       c:	d5 c1       	rjmp	.+938    	; 0x3b8 <__bad_interrupt>
       e:	00 00       	nop
      10:	d3 c1       	rjmp	.+934    	; 0x3b8 <__bad_interrupt>
      12:	00 00       	nop
      14:	9c c7       	rjmp	.+3896   	; 0xf4e <__vector_5>
      16:	00 00       	nop
      18:	cf c1       	rjmp	.+926    	; 0x3b8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	cd c1       	rjmp	.+922    	; 0x3b8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	cb c1       	rjmp	.+918    	; 0x3b8 <__bad_interrupt>
      22:	00 00       	nop
      24:	cd c4       	rjmp	.+2458   	; 0x9c0 <__vector_9>
      26:	00 00       	nop
      28:	c7 c1       	rjmp	.+910    	; 0x3b8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	c5 c1       	rjmp	.+906    	; 0x3b8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	c3 c1       	rjmp	.+902    	; 0x3b8 <__bad_interrupt>
      32:	00 00       	nop
      34:	c1 c1       	rjmp	.+898    	; 0x3b8 <__bad_interrupt>
      36:	00 00       	nop
      38:	bf c1       	rjmp	.+894    	; 0x3b8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	bd c1       	rjmp	.+890    	; 0x3b8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	bb c1       	rjmp	.+886    	; 0x3b8 <__bad_interrupt>
      42:	00 00       	nop
      44:	27 c7       	rjmp	.+3662   	; 0xe94 <__vector_17>
      46:	00 00       	nop
      48:	b7 c1       	rjmp	.+878    	; 0x3b8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	b5 c1       	rjmp	.+874    	; 0x3b8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	b3 c1       	rjmp	.+870    	; 0x3b8 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 b7 0a 	jmp	0x156e	; 0x156e <__vector_21>
      58:	af c1       	rjmp	.+862    	; 0x3b8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ad c1       	rjmp	.+858    	; 0x3b8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	ab c1       	rjmp	.+854    	; 0x3b8 <__bad_interrupt>
      62:	00 00       	nop
      64:	a9 c1       	rjmp	.+850    	; 0x3b8 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 59 0c 	jmp	0x18b2	; 0x18b2 <__vector_26>
      6c:	a5 c1       	rjmp	.+842    	; 0x3b8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a3 c1       	rjmp	.+838    	; 0x3b8 <__bad_interrupt>
      72:	00 00       	nop
      74:	a1 c1       	rjmp	.+834    	; 0x3b8 <__bad_interrupt>
      76:	00 00       	nop
      78:	9f c1       	rjmp	.+830    	; 0x3b8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	9d c1       	rjmp	.+826    	; 0x3b8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	9b c1       	rjmp	.+822    	; 0x3b8 <__bad_interrupt>
      82:	00 00       	nop
      84:	99 c1       	rjmp	.+818    	; 0x3b8 <__bad_interrupt>
      86:	00 00       	nop
      88:	97 c1       	rjmp	.+814    	; 0x3b8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	3c c5       	rjmp	.+2680   	; 0xb06 <__vector_35>
      8e:	00 00       	nop
      90:	c1 c3       	rjmp	.+1922   	; 0x814 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 a2 0c 	jmp	0x1944	; 0x1944 <__vector_37>
      98:	8f c1       	rjmp	.+798    	; 0x3b8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	fb c1       	rjmp	.+1014   	; 0x494 <__vector_39>
      9e:	00 00       	nop
      a0:	8b c1       	rjmp	.+790    	; 0x3b8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	89 c1       	rjmp	.+786    	; 0x3b8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	87 c1       	rjmp	.+782    	; 0x3b8 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	85 c1       	rjmp	.+778    	; 0x3b8 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	83 c1       	rjmp	.+774    	; 0x3b8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	81 c1       	rjmp	.+770    	; 0x3b8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	7f c1       	rjmp	.+766    	; 0x3b8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	7d c1       	rjmp	.+762    	; 0x3b8 <__bad_interrupt>
      be:	00 00       	nop
      c0:	7b c1       	rjmp	.+758    	; 0x3b8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	79 c1       	rjmp	.+754    	; 0x3b8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	77 c1       	rjmp	.+750    	; 0x3b8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 eb 0c 	jmp	0x19d6	; 0x19d6 <__vector_51>
      d0:	0c 94 4a 0d 	jmp	0x1a94	; 0x1a94 <__vector_52>
      d4:	71 c1       	rjmp	.+738    	; 0x3b8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 93 0d 	jmp	0x1b26	; 0x1b26 <__vector_54>
      dc:	0c 94 f2 0d 	jmp	0x1be4	; 0x1be4 <__vector_55>
      e0:	6b c1       	rjmp	.+726    	; 0x3b8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	69 02       	muls	r22, r25
      e6:	24 03       	mulsu	r18, r20
      e8:	24 03       	mulsu	r18, r20
      ea:	24 03       	mulsu	r18, r20
      ec:	24 03       	mulsu	r18, r20
      ee:	24 03       	mulsu	r18, r20
      f0:	24 03       	mulsu	r18, r20
      f2:	24 03       	mulsu	r18, r20
      f4:	69 02       	muls	r22, r25
      f6:	24 03       	mulsu	r18, r20
      f8:	24 03       	mulsu	r18, r20
      fa:	24 03       	mulsu	r18, r20
      fc:	24 03       	mulsu	r18, r20
      fe:	24 03       	mulsu	r18, r20
     100:	24 03       	mulsu	r18, r20
     102:	24 03       	mulsu	r18, r20
     104:	6b 02       	muls	r22, r27
     106:	24 03       	mulsu	r18, r20
     108:	24 03       	mulsu	r18, r20
     10a:	24 03       	mulsu	r18, r20
     10c:	24 03       	mulsu	r18, r20
     10e:	24 03       	mulsu	r18, r20
     110:	24 03       	mulsu	r18, r20
     112:	24 03       	mulsu	r18, r20
     114:	88 02       	muls	r24, r24
     116:	24 03       	mulsu	r18, r20
     118:	24 03       	mulsu	r18, r20
     11a:	24 03       	mulsu	r18, r20
     11c:	24 03       	mulsu	r18, r20
     11e:	24 03       	mulsu	r18, r20
     120:	24 03       	mulsu	r18, r20
     122:	24 03       	mulsu	r18, r20
     124:	6b 02       	muls	r22, r27
     126:	24 03       	mulsu	r18, r20
     128:	24 03       	mulsu	r18, r20
     12a:	24 03       	mulsu	r18, r20
     12c:	24 03       	mulsu	r18, r20
     12e:	24 03       	mulsu	r18, r20
     130:	24 03       	mulsu	r18, r20
     132:	24 03       	mulsu	r18, r20
     134:	88 02       	muls	r24, r24
     136:	24 03       	mulsu	r18, r20
     138:	24 03       	mulsu	r18, r20
     13a:	24 03       	mulsu	r18, r20
     13c:	24 03       	mulsu	r18, r20
     13e:	24 03       	mulsu	r18, r20
     140:	24 03       	mulsu	r18, r20
     142:	24 03       	mulsu	r18, r20
     144:	20 03       	mulsu	r18, r16
     146:	24 03       	mulsu	r18, r20
     148:	24 03       	mulsu	r18, r20
     14a:	24 03       	mulsu	r18, r20
     14c:	24 03       	mulsu	r18, r20
     14e:	24 03       	mulsu	r18, r20
     150:	24 03       	mulsu	r18, r20
     152:	24 03       	mulsu	r18, r20
     154:	9c 02       	muls	r25, r28
     156:	24 03       	mulsu	r18, r20
     158:	24 03       	mulsu	r18, r20
     15a:	24 03       	mulsu	r18, r20
     15c:	24 03       	mulsu	r18, r20
     15e:	24 03       	mulsu	r18, r20
     160:	24 03       	mulsu	r18, r20
     162:	24 03       	mulsu	r18, r20
     164:	bf 02       	muls	r27, r31
     166:	24 03       	mulsu	r18, r20
     168:	24 03       	mulsu	r18, r20
     16a:	24 03       	mulsu	r18, r20
     16c:	24 03       	mulsu	r18, r20
     16e:	24 03       	mulsu	r18, r20
     170:	24 03       	mulsu	r18, r20
     172:	24 03       	mulsu	r18, r20
     174:	90 02       	muls	r25, r16
     176:	24 03       	mulsu	r18, r20
     178:	24 03       	mulsu	r18, r20
     17a:	24 03       	mulsu	r18, r20
     17c:	24 03       	mulsu	r18, r20
     17e:	24 03       	mulsu	r18, r20
     180:	24 03       	mulsu	r18, r20
     182:	24 03       	mulsu	r18, r20
     184:	ae 02       	muls	r26, r30
     186:	24 03       	mulsu	r18, r20
     188:	24 03       	mulsu	r18, r20
     18a:	24 03       	mulsu	r18, r20
     18c:	24 03       	mulsu	r18, r20
     18e:	24 03       	mulsu	r18, r20
     190:	24 03       	mulsu	r18, r20
     192:	24 03       	mulsu	r18, r20
     194:	f6 02       	muls	r31, r22
     196:	24 03       	mulsu	r18, r20
     198:	24 03       	mulsu	r18, r20
     19a:	24 03       	mulsu	r18, r20
     19c:	24 03       	mulsu	r18, r20
     19e:	24 03       	mulsu	r18, r20
     1a0:	24 03       	mulsu	r18, r20
     1a2:	24 03       	mulsu	r18, r20
     1a4:	f6 02       	muls	r31, r22
     1a6:	24 03       	mulsu	r18, r20
     1a8:	24 03       	mulsu	r18, r20
     1aa:	24 03       	mulsu	r18, r20
     1ac:	24 03       	mulsu	r18, r20
     1ae:	24 03       	mulsu	r18, r20
     1b0:	24 03       	mulsu	r18, r20
     1b2:	24 03       	mulsu	r18, r20
     1b4:	f1 02       	muls	r31, r17
     1b6:	24 03       	mulsu	r18, r20
     1b8:	24 03       	mulsu	r18, r20
     1ba:	24 03       	mulsu	r18, r20
     1bc:	24 03       	mulsu	r18, r20
     1be:	24 03       	mulsu	r18, r20
     1c0:	24 03       	mulsu	r18, r20
     1c2:	24 03       	mulsu	r18, r20
     1c4:	f1 02       	muls	r31, r17
     1c6:	24 03       	mulsu	r18, r20
     1c8:	24 03       	mulsu	r18, r20
     1ca:	24 03       	mulsu	r18, r20
     1cc:	24 03       	mulsu	r18, r20
     1ce:	24 03       	mulsu	r18, r20
     1d0:	24 03       	mulsu	r18, r20
     1d2:	24 03       	mulsu	r18, r20
     1d4:	01 03       	mulsu	r16, r17
     1d6:	24 03       	mulsu	r18, r20
     1d8:	24 03       	mulsu	r18, r20
     1da:	24 03       	mulsu	r18, r20
     1dc:	24 03       	mulsu	r18, r20
     1de:	24 03       	mulsu	r18, r20
     1e0:	24 03       	mulsu	r18, r20
     1e2:	24 03       	mulsu	r18, r20
     1e4:	16 03       	mulsu	r17, r22
     1e6:	24 03       	mulsu	r18, r20
     1e8:	24 03       	mulsu	r18, r20
     1ea:	24 03       	mulsu	r18, r20
     1ec:	24 03       	mulsu	r18, r20
     1ee:	24 03       	mulsu	r18, r20
     1f0:	24 03       	mulsu	r18, r20
     1f2:	24 03       	mulsu	r18, r20
     1f4:	01 03       	mulsu	r16, r17
     1f6:	24 03       	mulsu	r18, r20
     1f8:	24 03       	mulsu	r18, r20
     1fa:	24 03       	mulsu	r18, r20
     1fc:	24 03       	mulsu	r18, r20
     1fe:	24 03       	mulsu	r18, r20
     200:	24 03       	mulsu	r18, r20
     202:	24 03       	mulsu	r18, r20
     204:	16 03       	mulsu	r17, r22
     206:	24 03       	mulsu	r18, r20
     208:	24 03       	mulsu	r18, r20
     20a:	24 03       	mulsu	r18, r20
     20c:	24 03       	mulsu	r18, r20
     20e:	24 03       	mulsu	r18, r20
     210:	24 03       	mulsu	r18, r20
     212:	24 03       	mulsu	r18, r20
     214:	1a 03       	fmul	r17, r18
     216:	24 03       	mulsu	r18, r20
     218:	24 03       	mulsu	r18, r20
     21a:	24 03       	mulsu	r18, r20
     21c:	24 03       	mulsu	r18, r20
     21e:	24 03       	mulsu	r18, r20
     220:	24 03       	mulsu	r18, r20
     222:	24 03       	mulsu	r18, r20
     224:	c7 02       	muls	r28, r23
     226:	24 03       	mulsu	r18, r20
     228:	24 03       	mulsu	r18, r20
     22a:	24 03       	mulsu	r18, r20
     22c:	24 03       	mulsu	r18, r20
     22e:	24 03       	mulsu	r18, r20
     230:	24 03       	mulsu	r18, r20
     232:	24 03       	mulsu	r18, r20
     234:	c7 02       	muls	r28, r23
     236:	24 03       	mulsu	r18, r20
     238:	24 03       	mulsu	r18, r20
     23a:	24 03       	mulsu	r18, r20
     23c:	24 03       	mulsu	r18, r20
     23e:	24 03       	mulsu	r18, r20
     240:	24 03       	mulsu	r18, r20
     242:	24 03       	mulsu	r18, r20
     244:	c9 02       	muls	r28, r25
     246:	24 03       	mulsu	r18, r20
     248:	24 03       	mulsu	r18, r20
     24a:	24 03       	mulsu	r18, r20
     24c:	24 03       	mulsu	r18, r20
     24e:	24 03       	mulsu	r18, r20
     250:	24 03       	mulsu	r18, r20
     252:	24 03       	mulsu	r18, r20
     254:	d9 02       	muls	r29, r25
     256:	24 03       	mulsu	r18, r20
     258:	24 03       	mulsu	r18, r20
     25a:	24 03       	mulsu	r18, r20
     25c:	24 03       	mulsu	r18, r20
     25e:	24 03       	mulsu	r18, r20
     260:	24 03       	mulsu	r18, r20
     262:	24 03       	mulsu	r18, r20
     264:	ed 02       	muls	r30, r29
     266:	d4 08       	sbc	r13, r4
     268:	e3 08       	sbc	r14, r3
     26a:	dc 08       	sbc	r13, r12
     26c:	e3 08       	sbc	r14, r3
     26e:	e3 08       	sbc	r14, r3
     270:	e3 08       	sbc	r14, r3
     272:	e3 08       	sbc	r14, r3
     274:	e3 08       	sbc	r14, r3
     276:	e3 08       	sbc	r14, r3
     278:	e3 08       	sbc	r14, r3
     27a:	e3 08       	sbc	r14, r3
     27c:	e3 08       	sbc	r14, r3
     27e:	e3 08       	sbc	r14, r3
     280:	e3 08       	sbc	r14, r3
     282:	e3 08       	sbc	r14, r3
     284:	e3 08       	sbc	r14, r3
     286:	e3 08       	sbc	r14, r3
     288:	e3 08       	sbc	r14, r3
     28a:	e3 08       	sbc	r14, r3
     28c:	e3 08       	sbc	r14, r3
     28e:	e3 08       	sbc	r14, r3
     290:	e3 08       	sbc	r14, r3
     292:	e3 08       	sbc	r14, r3
     294:	e3 08       	sbc	r14, r3
     296:	e3 08       	sbc	r14, r3
     298:	e3 08       	sbc	r14, r3
     29a:	e3 08       	sbc	r14, r3
     29c:	e3 08       	sbc	r14, r3
     29e:	e3 08       	sbc	r14, r3
     2a0:	e3 08       	sbc	r14, r3
     2a2:	e3 08       	sbc	r14, r3
     2a4:	e3 08       	sbc	r14, r3
     2a6:	e3 08       	sbc	r14, r3
     2a8:	e3 08       	sbc	r14, r3
     2aa:	e3 08       	sbc	r14, r3
     2ac:	e3 08       	sbc	r14, r3
     2ae:	e3 08       	sbc	r14, r3
     2b0:	e3 08       	sbc	r14, r3
     2b2:	e3 08       	sbc	r14, r3
     2b4:	e3 08       	sbc	r14, r3
     2b6:	e3 08       	sbc	r14, r3
     2b8:	e3 08       	sbc	r14, r3
     2ba:	e3 08       	sbc	r14, r3
     2bc:	e3 08       	sbc	r14, r3
     2be:	e3 08       	sbc	r14, r3
     2c0:	ce 08       	sbc	r12, r14
     2c2:	e3 08       	sbc	r14, r3
     2c4:	e3 08       	sbc	r14, r3
     2c6:	e3 08       	sbc	r14, r3
     2c8:	e3 08       	sbc	r14, r3
     2ca:	e3 08       	sbc	r14, r3
     2cc:	e3 08       	sbc	r14, r3
     2ce:	e3 08       	sbc	r14, r3
     2d0:	e3 08       	sbc	r14, r3
     2d2:	be 08       	sbc	r11, r14
     2d4:	e3 08       	sbc	r14, r3
     2d6:	e3 08       	sbc	r14, r3
     2d8:	c6 08       	sbc	r12, r6
     2da:	e3 08       	sbc	r14, r3
     2dc:	e3 08       	sbc	r14, r3
     2de:	e3 08       	sbc	r14, r3
     2e0:	e3 08       	sbc	r14, r3
     2e2:	e3 08       	sbc	r14, r3
     2e4:	e3 08       	sbc	r14, r3
     2e6:	e3 08       	sbc	r14, r3
     2e8:	e3 08       	sbc	r14, r3
     2ea:	e3 08       	sbc	r14, r3
     2ec:	e3 08       	sbc	r14, r3
     2ee:	e3 08       	sbc	r14, r3
     2f0:	e3 08       	sbc	r14, r3
     2f2:	e3 08       	sbc	r14, r3
     2f4:	e3 08       	sbc	r14, r3
     2f6:	c1 08       	sbc	r12, r1
     2f8:	e3 08       	sbc	r14, r3
     2fa:	e3 08       	sbc	r14, r3
     2fc:	e3 08       	sbc	r14, r3
     2fe:	b9 08       	sbc	r11, r9
     300:	22 09       	sbc	r18, r2

00000302 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     302:	0a ed       	ldi	r16, 0xDA	; 218
     304:	12 e0       	ldi	r17, 0x02	; 2
     306:	0f 2e       	mov	r0, r31
     308:	f2 e0       	ldi	r31, 0x02	; 2
     30a:	ef 2e       	mov	r14, r31
     30c:	f3 e0       	ldi	r31, 0x03	; 3
     30e:	ff 2e       	mov	r15, r31
     310:	f0 2d       	mov	r31, r0
     312:	26 c0       	rjmp	.+76     	; 0x360 <prvIdleTask+0x5e>
     314:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <vTaskSuspendAll>
     318:	d8 01       	movw	r26, r16
     31a:	cc 91       	ld	r28, X
     31c:	0e 94 ae 10 	call	0x215c	; 0x215c <xTaskResumeAll>
     320:	cc 23       	and	r28, r28
     322:	f1 f0       	breq	.+60     	; 0x360 <prvIdleTask+0x5e>
     324:	0f b6       	in	r0, 0x3f	; 63
     326:	f8 94       	cli
     328:	0f 92       	push	r0
     32a:	d8 01       	movw	r26, r16
     32c:	15 96       	adiw	r26, 0x05	; 5
     32e:	ed 91       	ld	r30, X+
     330:	fc 91       	ld	r31, X
     332:	16 97       	sbiw	r26, 0x06	; 6
     334:	c6 81       	ldd	r28, Z+6	; 0x06
     336:	d7 81       	ldd	r29, Z+7	; 0x07
     338:	ce 01       	movw	r24, r28
     33a:	02 96       	adiw	r24, 0x02	; 2
     33c:	ff d1       	rcall	.+1022   	; 0x73c <uxListRemove>
     33e:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
     342:	81 50       	subi	r24, 0x01	; 1
     344:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxCurrentNumberOfTasks>
     348:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     34c:	81 50       	subi	r24, 0x01	; 1
     34e:	80 93 d9 02 	sts	0x02D9, r24	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     352:	0f 90       	pop	r0
     354:	0f be       	out	0x3f, r0	; 63
     356:	8f 89       	ldd	r24, Y+23	; 0x17
     358:	98 8d       	ldd	r25, Y+24	; 0x18
     35a:	5d d0       	rcall	.+186    	; 0x416 <vPortFree>
     35c:	ce 01       	movw	r24, r28
     35e:	5b d0       	rcall	.+182    	; 0x416 <vPortFree>
     360:	80 91 d9 02 	lds	r24, 0x02D9	; 0x8002d9 <uxDeletedTasksWaitingCleanUp>
     364:	81 11       	cpse	r24, r1
     366:	d6 cf       	rjmp	.-84     	; 0x314 <prvIdleTask+0x12>
     368:	f7 01       	movw	r30, r14
     36a:	80 81       	ld	r24, Z
     36c:	82 30       	cpi	r24, 0x02	; 2
     36e:	10 f0       	brcs	.+4      	; 0x374 <prvIdleTask+0x72>
     370:	0e 94 df 09 	call	0x13be	; 0x13be <vPortYield>
     374:	5f d0       	rcall	.+190    	; 0x434 <vApplicationIdleHook>
     376:	f4 cf       	rjmp	.-24     	; 0x360 <prvIdleTask+0x5e>

00000378 <__ctors_end>:
     378:	11 24       	eor	r1, r1
     37a:	1f be       	out	0x3f, r1	; 63
     37c:	cf ef       	ldi	r28, 0xFF	; 255
     37e:	d1 e2       	ldi	r29, 0x21	; 33
     380:	de bf       	out	0x3e, r29	; 62
     382:	cd bf       	out	0x3d, r28	; 61
     384:	00 e0       	ldi	r16, 0x00	; 0
     386:	0c bf       	out	0x3c, r16	; 60

00000388 <__do_copy_data>:
     388:	12 e0       	ldi	r17, 0x02	; 2
     38a:	a0 e0       	ldi	r26, 0x00	; 0
     38c:	b2 e0       	ldi	r27, 0x02	; 2
     38e:	e8 e8       	ldi	r30, 0x88	; 136
     390:	f8 e2       	ldi	r31, 0x28	; 40
     392:	00 e0       	ldi	r16, 0x00	; 0
     394:	0b bf       	out	0x3b, r16	; 59
     396:	02 c0       	rjmp	.+4      	; 0x39c <__do_copy_data+0x14>
     398:	07 90       	elpm	r0, Z+
     39a:	0d 92       	st	X+, r0
     39c:	ac 39       	cpi	r26, 0x9C	; 156
     39e:	b1 07       	cpc	r27, r17
     3a0:	d9 f7       	brne	.-10     	; 0x398 <__do_copy_data+0x10>

000003a2 <__do_clear_bss>:
     3a2:	25 e0       	ldi	r18, 0x05	; 5
     3a4:	ac e9       	ldi	r26, 0x9C	; 156
     3a6:	b2 e0       	ldi	r27, 0x02	; 2
     3a8:	01 c0       	rjmp	.+2      	; 0x3ac <.do_clear_bss_start>

000003aa <.do_clear_bss_loop>:
     3aa:	1d 92       	st	X+, r1

000003ac <.do_clear_bss_start>:
     3ac:	a1 30       	cpi	r26, 0x01	; 1
     3ae:	b2 07       	cpc	r27, r18
     3b0:	e1 f7       	brne	.-8      	; 0x3aa <.do_clear_bss_loop>
     3b2:	1b d6       	rcall	.+3126   	; 0xfea <main>
     3b4:	0c 94 42 14 	jmp	0x2884	; 0x2884 <_exit>

000003b8 <__bad_interrupt>:
     3b8:	23 ce       	rjmp	.-954    	; 0x0 <__vectors>

000003ba <system_tick>:
     3ba:	8f 93       	push	r24
     3bc:	8f b7       	in	r24, 0x3f	; 63
     3be:	8f 93       	push	r24
     3c0:	f8 94       	cli
     3c2:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <__system_time>
     3c6:	8f 5f       	subi	r24, 0xFF	; 255
     3c8:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <__system_time>
     3cc:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <__system_time+0x1>
     3d0:	8f 4f       	sbci	r24, 0xFF	; 255
     3d2:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <__system_time+0x1>
     3d6:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <__system_time+0x2>
     3da:	8f 4f       	sbci	r24, 0xFF	; 255
     3dc:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <__system_time+0x2>
     3e0:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <__system_time+0x3>
     3e4:	8f 4f       	sbci	r24, 0xFF	; 255
     3e6:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <__system_time+0x3>
     3ea:	8f 91       	pop	r24
     3ec:	8f bf       	out	0x3f, r24	; 63
     3ee:	8f 91       	pop	r24
     3f0:	08 95       	ret

000003f2 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     3f8:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     3fc:	ce 01       	movw	r24, r28
     3fe:	0e 94 de 12 	call	0x25bc	; 0x25bc <malloc>
     402:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     404:	0e 94 ae 10 	call	0x215c	; 0x215c <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     408:	20 97       	sbiw	r28, 0x00	; 0
     40a:	09 f4       	brne	.+2      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     40c:	2c d0       	rcall	.+88     	; 0x466 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     40e:	ce 01       	movw	r24, r28
     410:	df 91       	pop	r29
     412:	cf 91       	pop	r28
     414:	08 95       	ret

00000416 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     416:	cf 93       	push	r28
     418:	df 93       	push	r29
	if( pv )
     41a:	00 97       	sbiw	r24, 0x00	; 0
     41c:	41 f0       	breq	.+16     	; 0x42e <vPortFree+0x18>
     41e:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     420:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <vTaskSuspendAll>
		{
			free( pv );
     424:	ce 01       	movw	r24, r28
     426:	0e 94 76 13 	call	0x26ec	; 0x26ec <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     42a:	0e 94 ae 10 	call	0x215c	; 0x215c <xTaskResumeAll>
	}
}
     42e:	df 91       	pop	r29
     430:	cf 91       	pop	r28
     432:	08 95       	ret

00000434 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     434:	8f ef       	ldi	r24, 0xFF	; 255
     436:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     43a:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     43e:	80 b7       	in	r24, 0x30	; 48
     440:	87 7f       	andi	r24, 0xF7	; 247
     442:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     444:	80 b7       	in	r24, 0x30	; 48
     446:	80 68       	ori	r24, 0x80	; 128
     448:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     44a:	83 b7       	in	r24, 0x33	; 51
     44c:	81 7f       	andi	r24, 0xF1	; 241
     44e:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     450:	0f b6       	in	r0, 0x3f	; 63
     452:	f8 94       	cli
     454:	0f 92       	push	r0

	sleep_enable();
     456:	83 b7       	in	r24, 0x33	; 51
     458:	81 60       	ori	r24, 0x01	; 1
     45a:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     45c:	0f 90       	pop	r0
     45e:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     460:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     462:	13 be       	out	0x33, r1	; 51
     464:	08 95       	ret

00000466 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     466:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     468:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     46a:	83 ed       	ldi	r24, 0xD3	; 211
     46c:	90 e3       	ldi	r25, 0x30	; 48
     46e:	01 97       	sbiw	r24, 0x01	; 1
     470:	f1 f7       	brne	.-4      	; 0x46e <vApplicationMallocFailedHook+0x8>
     472:	00 c0       	rjmp	.+0      	; 0x474 <vApplicationMallocFailedHook+0xe>
     474:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     476:	1f 9a       	sbi	0x03, 7	; 3
     478:	f8 cf       	rjmp	.-16     	; 0x46a <vApplicationMallocFailedHook+0x4>

0000047a <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     47a:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     47c:	2f 9a       	sbi	0x05, 7	; 5
     47e:	2f e7       	ldi	r18, 0x7F	; 127
     480:	8a e1       	ldi	r24, 0x1A	; 26
     482:	96 e0       	ldi	r25, 0x06	; 6
     484:	21 50       	subi	r18, 0x01	; 1
     486:	80 40       	sbci	r24, 0x00	; 0
     488:	90 40       	sbci	r25, 0x00	; 0
     48a:	e1 f7       	brne	.-8      	; 0x484 <vApplicationStackOverflowHook+0xa>
     48c:	00 c0       	rjmp	.+0      	; 0x48e <vApplicationStackOverflowHook+0x14>
     48e:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     490:	1f 9a       	sbi	0x03, 7	; 3
     492:	f5 cf       	rjmp	.-22     	; 0x47e <vApplicationStackOverflowHook+0x4>

00000494 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     494:	1f 92       	push	r1
     496:	0f 92       	push	r0
     498:	0f b6       	in	r0, 0x3f	; 63
     49a:	0f 92       	push	r0
     49c:	11 24       	eor	r1, r1
     49e:	0b b6       	in	r0, 0x3b	; 59
     4a0:	0f 92       	push	r0
     4a2:	2f 93       	push	r18
     4a4:	3f 93       	push	r19
     4a6:	8f 93       	push	r24
     4a8:	9f 93       	push	r25
     4aa:	af 93       	push	r26
     4ac:	bf 93       	push	r27
     4ae:	ef 93       	push	r30
     4b0:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     4b2:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4b6:	8e 2f       	mov	r24, r30
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	fc 01       	movw	r30, r24
     4bc:	38 97       	sbiw	r30, 0x08	; 8
     4be:	e1 3c       	cpi	r30, 0xC1	; 193
     4c0:	f1 05       	cpc	r31, r1
     4c2:	08 f0       	brcs	.+2      	; 0x4c6 <__vector_39+0x32>
     4c4:	c1 c0       	rjmp	.+386    	; 0x648 <__vector_39+0x1b4>
     4c6:	88 27       	eor	r24, r24
     4c8:	ee 58       	subi	r30, 0x8E	; 142
     4ca:	ff 4f       	sbci	r31, 0xFF	; 255
     4cc:	8f 4f       	sbci	r24, 0xFF	; 255
     4ce:	0c 94 bd 12 	jmp	0x257a	; 0x257a <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     4d2:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     4d6:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     4da:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     4de:	e8 17       	cp	r30, r24
     4e0:	70 f4       	brcc	.+28     	; 0x4fe <__vector_39+0x6a>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	8e 0f       	add	r24, r30
     4e6:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	e0 56       	subi	r30, 0x60	; 96
     4ee:	fd 4f       	sbci	r31, 0xFD	; 253
     4f0:	80 81       	ld	r24, Z
     4f2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4f6:	85 e8       	ldi	r24, 0x85	; 133
     4f8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4fc:	ac c0       	rjmp	.+344    	; 0x656 <__vector_39+0x1c2>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4fe:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     502:	81 60       	ori	r24, 0x01	; 1
     504:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     508:	84 e9       	ldi	r24, 0x94	; 148
     50a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     50e:	a3 c0       	rjmp	.+326    	; 0x656 <__vector_39+0x1c2>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     510:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     514:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     518:	85 ee       	ldi	r24, 0xE5	; 229
     51a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     51e:	9b c0       	rjmp	.+310    	; 0x656 <__vector_39+0x1c2>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     520:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     524:	81 e0       	ldi	r24, 0x01	; 1
     526:	8e 0f       	add	r24, r30
     528:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     52c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     530:	f0 e0       	ldi	r31, 0x00	; 0
     532:	e0 56       	subi	r30, 0x60	; 96
     534:	fd 4f       	sbci	r31, 0xFD	; 253
     536:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     538:	20 91 9c 02 	lds	r18, 0x029C	; 0x80029c <__data_end>
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	01 97       	sbiw	r24, 0x01	; 1
     546:	28 17       	cp	r18, r24
     548:	39 07       	cpc	r19, r25
     54a:	24 f4       	brge	.+8      	; 0x554 <__vector_39+0xc0>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     54c:	85 ec       	ldi	r24, 0xC5	; 197
     54e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     552:	81 c0       	rjmp	.+258    	; 0x656 <__vector_39+0x1c2>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     554:	85 e8       	ldi	r24, 0x85	; 133
     556:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     55a:	7d c0       	rjmp	.+250    	; 0x656 <__vector_39+0x1c2>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     55c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     560:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     564:	f0 e0       	ldi	r31, 0x00	; 0
     566:	e0 56       	subi	r30, 0x60	; 96
     568:	fd 4f       	sbci	r31, 0xFD	; 253
     56a:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     56c:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     570:	81 60       	ori	r24, 0x01	; 1
     572:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     576:	84 ed       	ldi	r24, 0xD4	; 212
     578:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     57c:	6c c0       	rjmp	.+216    	; 0x656 <__vector_39+0x1c2>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     57e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     582:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     586:	85 ed       	ldi	r24, 0xD5	; 213
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     58c:	64 c0       	rjmp	.+200    	; 0x656 <__vector_39+0x1c2>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     58e:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     592:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     596:	81 e0       	ldi	r24, 0x01	; 1
     598:	8e 0f       	add	r24, r30
     59a:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     59e:	f0 e0       	ldi	r31, 0x00	; 0
     5a0:	e0 56       	subi	r30, 0x60	; 96
     5a2:	fd 4f       	sbci	r31, 0xFD	; 253
     5a4:	80 81       	ld	r24, Z
     5a6:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     5aa:	85 ec       	ldi	r24, 0xC5	; 197
     5ac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     5b0:	52 c0       	rjmp	.+164    	; 0x656 <__vector_39+0x1c2>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     5b2:	90 91 9c 02 	lds	r25, 0x029C	; 0x80029c <__data_end>
     5b6:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <I2C_msgSize>
     5ba:	98 13       	cpse	r25, r24
     5bc:	06 c0       	rjmp	.+12     	; 0x5ca <__vector_39+0x136>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     5be:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     5c2:	81 60       	ori	r24, 0x01	; 1
     5c4:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>
     5c8:	04 c0       	rjmp	.+8      	; 0x5d2 <__vector_39+0x13e>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     5ca:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ce:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     5d2:	84 e0       	ldi	r24, 0x04	; 4
     5d4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     5d8:	3e c0       	rjmp	.+124    	; 0x656 <__vector_39+0x1c2>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     5da:	85 ec       	ldi	r24, 0xC5	; 197
     5dc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     5e0:	3a c0       	rjmp	.+116    	; 0x656 <__vector_39+0x1c2>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     5e2:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     5e6:	84 60       	ori	r24, 0x04	; 4
     5e8:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     5ec:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     5f0:	82 60       	ori	r24, 0x02	; 2
     5f2:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     5f6:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     5fa:	85 ec       	ldi	r24, 0xC5	; 197
     5fc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     600:	2a c0       	rjmp	.+84     	; 0x656 <__vector_39+0x1c2>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     602:	e0 91 9c 02 	lds	r30, 0x029C	; 0x80029c <__data_end>
     606:	81 e0       	ldi	r24, 0x01	; 1
     608:	8e 0f       	add	r24, r30
     60a:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <__data_end>
     60e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     612:	f0 e0       	ldi	r31, 0x00	; 0
     614:	e0 56       	subi	r30, 0x60	; 96
     616:	fd 4f       	sbci	r31, 0xFD	; 253
     618:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     61a:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <I2C_statusReg>
     61e:	81 60       	ori	r24, 0x01	; 1
     620:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     624:	85 ec       	ldi	r24, 0xC5	; 197
     626:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     62a:	15 c0       	rjmp	.+42     	; 0x656 <__vector_39+0x1c2>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     62c:	85 e8       	ldi	r24, 0x85	; 133
     62e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     632:	11 c0       	rjmp	.+34     	; 0x656 <__vector_39+0x1c2>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     634:	84 e0       	ldi	r24, 0x04	; 4
     636:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     63a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     63e:	0b c0       	rjmp	.+22     	; 0x656 <__vector_39+0x1c2>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     640:	85 ee       	ldi	r24, 0xE5	; 229
     642:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     646:	07 c0       	rjmp	.+14     	; 0x656 <__vector_39+0x1c2>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     648:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     64c:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     650:	85 ed       	ldi	r24, 0xD5	; 213
     652:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     656:	ff 91       	pop	r31
     658:	ef 91       	pop	r30
     65a:	bf 91       	pop	r27
     65c:	af 91       	pop	r26
     65e:	9f 91       	pop	r25
     660:	8f 91       	pop	r24
     662:	3f 91       	pop	r19
     664:	2f 91       	pop	r18
     666:	0f 90       	pop	r0
     668:	0b be       	out	0x3b, r0	; 59
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63
     66e:	0f 90       	pop	r0
     670:	1f 90       	pop	r1
     672:	18 95       	reti

00000674 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     674:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     676:	03 96       	adiw	r24, 0x03	; 3
     678:	92 83       	std	Z+2, r25	; 0x02
     67a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     67c:	2f ef       	ldi	r18, 0xFF	; 255
     67e:	3f ef       	ldi	r19, 0xFF	; 255
     680:	34 83       	std	Z+4, r19	; 0x04
     682:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     684:	96 83       	std	Z+6, r25	; 0x06
     686:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     688:	90 87       	std	Z+8, r25	; 0x08
     68a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     68c:	10 82       	st	Z, r1
     68e:	08 95       	ret

00000690 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     690:	fc 01       	movw	r30, r24
     692:	11 86       	std	Z+9, r1	; 0x09
     694:	10 86       	std	Z+8, r1	; 0x08
     696:	08 95       	ret

00000698 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     698:	cf 93       	push	r28
     69a:	df 93       	push	r29
     69c:	9c 01       	movw	r18, r24
     69e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6a0:	dc 01       	movw	r26, r24
     6a2:	11 96       	adiw	r26, 0x01	; 1
     6a4:	cd 91       	ld	r28, X+
     6a6:	dc 91       	ld	r29, X
     6a8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6aa:	d3 83       	std	Z+3, r29	; 0x03
     6ac:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6ae:	8c 81       	ldd	r24, Y+4	; 0x04
     6b0:	9d 81       	ldd	r25, Y+5	; 0x05
     6b2:	95 83       	std	Z+5, r25	; 0x05
     6b4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6b6:	8c 81       	ldd	r24, Y+4	; 0x04
     6b8:	9d 81       	ldd	r25, Y+5	; 0x05
     6ba:	dc 01       	movw	r26, r24
     6bc:	13 96       	adiw	r26, 0x03	; 3
     6be:	7c 93       	st	X, r23
     6c0:	6e 93       	st	-X, r22
     6c2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6c4:	7d 83       	std	Y+5, r23	; 0x05
     6c6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6c8:	31 87       	std	Z+9, r19	; 0x09
     6ca:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6cc:	f9 01       	movw	r30, r18
     6ce:	80 81       	ld	r24, Z
     6d0:	8f 5f       	subi	r24, 0xFF	; 255
     6d2:	80 83       	st	Z, r24
}
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	08 95       	ret

000006da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6e0:	48 81       	ld	r20, Y
     6e2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6e4:	4f 3f       	cpi	r20, 0xFF	; 255
     6e6:	2f ef       	ldi	r18, 0xFF	; 255
     6e8:	52 07       	cpc	r21, r18
     6ea:	21 f4       	brne	.+8      	; 0x6f4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6ec:	fc 01       	movw	r30, r24
     6ee:	a7 81       	ldd	r26, Z+7	; 0x07
     6f0:	b0 85       	ldd	r27, Z+8	; 0x08
     6f2:	0d c0       	rjmp	.+26     	; 0x70e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6f4:	dc 01       	movw	r26, r24
     6f6:	13 96       	adiw	r26, 0x03	; 3
     6f8:	01 c0       	rjmp	.+2      	; 0x6fc <vListInsert+0x22>
     6fa:	df 01       	movw	r26, r30
     6fc:	12 96       	adiw	r26, 0x02	; 2
     6fe:	ed 91       	ld	r30, X+
     700:	fc 91       	ld	r31, X
     702:	13 97       	sbiw	r26, 0x03	; 3
     704:	20 81       	ld	r18, Z
     706:	31 81       	ldd	r19, Z+1	; 0x01
     708:	42 17       	cp	r20, r18
     70a:	53 07       	cpc	r21, r19
     70c:	b0 f7       	brcc	.-20     	; 0x6fa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     70e:	12 96       	adiw	r26, 0x02	; 2
     710:	ed 91       	ld	r30, X+
     712:	fc 91       	ld	r31, X
     714:	13 97       	sbiw	r26, 0x03	; 3
     716:	fb 83       	std	Y+3, r31	; 0x03
     718:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     71a:	d5 83       	std	Z+5, r29	; 0x05
     71c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     71e:	bd 83       	std	Y+5, r27	; 0x05
     720:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     722:	13 96       	adiw	r26, 0x03	; 3
     724:	dc 93       	st	X, r29
     726:	ce 93       	st	-X, r28
     728:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     72a:	99 87       	std	Y+9, r25	; 0x09
     72c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     72e:	fc 01       	movw	r30, r24
     730:	20 81       	ld	r18, Z
     732:	2f 5f       	subi	r18, 0xFF	; 255
     734:	20 83       	st	Z, r18
}
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	08 95       	ret

0000073c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     73c:	cf 93       	push	r28
     73e:	df 93       	push	r29
     740:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     742:	a0 85       	ldd	r26, Z+8	; 0x08
     744:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     746:	c2 81       	ldd	r28, Z+2	; 0x02
     748:	d3 81       	ldd	r29, Z+3	; 0x03
     74a:	84 81       	ldd	r24, Z+4	; 0x04
     74c:	95 81       	ldd	r25, Z+5	; 0x05
     74e:	9d 83       	std	Y+5, r25	; 0x05
     750:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     752:	c4 81       	ldd	r28, Z+4	; 0x04
     754:	d5 81       	ldd	r29, Z+5	; 0x05
     756:	82 81       	ldd	r24, Z+2	; 0x02
     758:	93 81       	ldd	r25, Z+3	; 0x03
     75a:	9b 83       	std	Y+3, r25	; 0x03
     75c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     75e:	11 96       	adiw	r26, 0x01	; 1
     760:	8d 91       	ld	r24, X+
     762:	9c 91       	ld	r25, X
     764:	12 97       	sbiw	r26, 0x02	; 2
     766:	e8 17       	cp	r30, r24
     768:	f9 07       	cpc	r31, r25
     76a:	31 f4       	brne	.+12     	; 0x778 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     76c:	84 81       	ldd	r24, Z+4	; 0x04
     76e:	95 81       	ldd	r25, Z+5	; 0x05
     770:	12 96       	adiw	r26, 0x02	; 2
     772:	9c 93       	st	X, r25
     774:	8e 93       	st	-X, r24
     776:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     778:	11 86       	std	Z+9, r1	; 0x09
     77a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     77c:	8c 91       	ld	r24, X
     77e:	81 50       	subi	r24, 0x01	; 1
     780:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     782:	df 91       	pop	r29
     784:	cf 91       	pop	r28
     786:	08 95       	ret

00000788 <watchdogTaak>:
		setSpeed(100);
		motorLinks();
		vTaskDelay(xDelay);
		motorRechts();
		vTaskDelay(xDelay);
		watchdogMotor = 1;
     788:	8f e9       	ldi	r24, 0x9F	; 159
     78a:	9f e0       	ldi	r25, 0x0F	; 15
     78c:	01 97       	sbiw	r24, 0x01	; 1
     78e:	f1 f7       	brne	.-4      	; 0x78c <watchdogTaak+0x4>
     790:	00 c0       	rjmp	.+0      	; 0x792 <watchdogTaak+0xa>
     792:	00 00       	nop
     794:	80 91 30 03 	lds	r24, 0x0330	; 0x800330 <watchdogSonar>
     798:	90 91 31 03 	lds	r25, 0x0331	; 0x800331 <watchdogSonar+0x1>
     79c:	89 2b       	or	r24, r25
     79e:	a1 f3       	breq	.-24     	; 0x788 <watchdogTaak>
     7a0:	80 91 5c 04 	lds	r24, 0x045C	; 0x80045c <watchdogServo>
     7a4:	90 91 5d 04 	lds	r25, 0x045D	; 0x80045d <watchdogServo+0x1>
     7a8:	89 2b       	or	r24, r25
     7aa:	71 f3       	breq	.-36     	; 0x788 <watchdogTaak>
     7ac:	80 91 2e 03 	lds	r24, 0x032E	; 0x80032e <watchdogGyro>
     7b0:	90 91 2f 03 	lds	r25, 0x032F	; 0x80032f <watchdogGyro+0x1>
     7b4:	89 2b       	or	r24, r25
     7b6:	41 f3       	breq	.-48     	; 0x788 <watchdogTaak>
     7b8:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <watchdogMotor>
     7bc:	90 91 4d 04 	lds	r25, 0x044D	; 0x80044d <watchdogMotor+0x1>
     7c0:	89 2b       	or	r24, r25
     7c2:	11 f3       	breq	.-60     	; 0x788 <watchdogTaak>
     7c4:	a8 95       	wdr
     7c6:	10 92 31 03 	sts	0x0331, r1	; 0x800331 <watchdogSonar+0x1>
     7ca:	10 92 30 03 	sts	0x0330, r1	; 0x800330 <watchdogSonar>
     7ce:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <watchdogServo+0x1>
     7d2:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <watchdogServo>
     7d6:	10 92 2f 03 	sts	0x032F, r1	; 0x80032f <watchdogGyro+0x1>
     7da:	10 92 2e 03 	sts	0x032E, r1	; 0x80032e <watchdogGyro>
     7de:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <watchdogMotor+0x1>
     7e2:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <watchdogMotor>
     7e6:	d0 cf       	rjmp	.-96     	; 0x788 <watchdogTaak>

000007e8 <UART_Init>:
     7e8:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     7ec:	87 e6       	ldi	r24, 0x67	; 103
     7ee:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     7f2:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     7f6:	86 e0       	ldi	r24, 0x06	; 6
     7f8:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     7fc:	88 eb       	ldi	r24, 0xB8	; 184
     7fe:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     802:	08 95       	ret

00000804 <UART_Transmit>:
     804:	e8 ec       	ldi	r30, 0xC8	; 200
     806:	f0 e0       	ldi	r31, 0x00	; 0
     808:	90 81       	ld	r25, Z
     80a:	95 ff       	sbrs	r25, 5
     80c:	fd cf       	rjmp	.-6      	; 0x808 <UART_Transmit+0x4>
     80e:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     812:	08 95       	ret

00000814 <__vector_36>:
     814:	1f 92       	push	r1
     816:	0f 92       	push	r0
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	0f 92       	push	r0
     81c:	11 24       	eor	r1, r1
     81e:	8f 93       	push	r24
     820:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     824:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <ontvang>
     828:	8f 91       	pop	r24
     82a:	0f 90       	pop	r0
     82c:	0f be       	out	0x3f, r0	; 63
     82e:	0f 90       	pop	r0
     830:	1f 90       	pop	r1
     832:	18 95       	reti

00000834 <UART_Transmit_String>:
     834:	cf 93       	push	r28
     836:	df 93       	push	r29
     838:	ec 01       	movw	r28, r24
     83a:	88 81       	ld	r24, Y
     83c:	88 23       	and	r24, r24
     83e:	29 f0       	breq	.+10     	; 0x84a <UART_Transmit_String+0x16>
     840:	21 96       	adiw	r28, 0x01	; 1
     842:	e0 df       	rcall	.-64     	; 0x804 <UART_Transmit>
     844:	89 91       	ld	r24, Y+
     846:	81 11       	cpse	r24, r1
     848:	fc cf       	rjmp	.-8      	; 0x842 <UART_Transmit_String+0xe>
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	08 95       	ret

00000850 <UART_Transmit_Integer>:
     850:	cf 93       	push	r28
     852:	df 93       	push	r29
     854:	cd b7       	in	r28, 0x3d	; 61
     856:	de b7       	in	r29, 0x3e	; 62
     858:	61 97       	sbiw	r28, 0x11	; 17
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	f8 94       	cli
     85e:	de bf       	out	0x3e, r29	; 62
     860:	0f be       	out	0x3f, r0	; 63
     862:	cd bf       	out	0x3d, r28	; 61
     864:	dc 01       	movw	r26, r24
     866:	cb 01       	movw	r24, r22
     868:	4a e0       	ldi	r20, 0x0A	; 10
     86a:	be 01       	movw	r22, r28
     86c:	6f 5f       	subi	r22, 0xFF	; 255
     86e:	7f 4f       	sbci	r23, 0xFF	; 255
     870:	0e 94 0f 14 	call	0x281e	; 0x281e <__itoa_ncheck>
     874:	ce 01       	movw	r24, r28
     876:	01 96       	adiw	r24, 0x01	; 1
     878:	dd df       	rcall	.-70     	; 0x834 <UART_Transmit_String>
     87a:	61 96       	adiw	r28, 0x11	; 17
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	de bf       	out	0x3e, r29	; 62
     882:	0f be       	out	0x3f, r0	; 63
     884:	cd bf       	out	0x3d, r28	; 61
     886:	df 91       	pop	r29
     888:	cf 91       	pop	r28
     88a:	08 95       	ret

0000088c <servoTaak>:
     88c:	0a e8       	ldi	r16, 0x8A	; 138
     88e:	10 e0       	ldi	r17, 0x00	; 0
     890:	c1 e0       	ldi	r28, 0x01	; 1
     892:	d0 e0       	ldi	r29, 0x00	; 0
     894:	e1 2c       	mov	r14, r1
     896:	f1 2c       	mov	r15, r1
     898:	f0 92 57 04 	sts	0x0457, r15	; 0x800457 <hoek+0x1>
     89c:	e0 92 56 04 	sts	0x0456, r14	; 0x800456 <hoek>
     8a0:	c7 01       	movw	r24, r14
     8a2:	99 27       	eor	r25, r25
     8a4:	9c 01       	movw	r18, r24
     8a6:	22 0f       	add	r18, r18
     8a8:	33 1f       	adc	r19, r19
     8aa:	22 0f       	add	r18, r18
     8ac:	33 1f       	adc	r19, r19
     8ae:	22 0f       	add	r18, r18
     8b0:	33 1f       	adc	r19, r19
     8b2:	82 1b       	sub	r24, r18
     8b4:	93 0b       	sbc	r25, r19
     8b6:	95 5b       	subi	r25, 0xB5	; 181
     8b8:	f8 01       	movw	r30, r16
     8ba:	91 83       	std	Z+1, r25	; 0x01
     8bc:	80 83       	st	Z, r24
     8be:	ff ef       	ldi	r31, 0xFF	; 255
     8c0:	24 e3       	ldi	r18, 0x34	; 52
     8c2:	8c e0       	ldi	r24, 0x0C	; 12
     8c4:	f1 50       	subi	r31, 0x01	; 1
     8c6:	20 40       	sbci	r18, 0x00	; 0
     8c8:	80 40       	sbci	r24, 0x00	; 0
     8ca:	e1 f7       	brne	.-8      	; 0x8c4 <servoTaak+0x38>
     8cc:	00 c0       	rjmp	.+0      	; 0x8ce <servoTaak+0x42>
     8ce:	00 00       	nop
     8d0:	87 e0       	ldi	r24, 0x07	; 7
     8d2:	92 e0       	ldi	r25, 0x02	; 2
     8d4:	af df       	rcall	.-162    	; 0x834 <UART_Transmit_String>
     8d6:	60 91 56 04 	lds	r22, 0x0456	; 0x800456 <hoek>
     8da:	70 91 57 04 	lds	r23, 0x0457	; 0x800457 <hoek+0x1>
     8de:	07 2e       	mov	r0, r23
     8e0:	00 0c       	add	r0, r0
     8e2:	88 0b       	sbc	r24, r24
     8e4:	99 0b       	sbc	r25, r25
     8e6:	b4 df       	rcall	.-152    	; 0x850 <UART_Transmit_Integer>
     8e8:	80 e1       	ldi	r24, 0x10	; 16
     8ea:	92 e0       	ldi	r25, 0x02	; 2
     8ec:	a3 df       	rcall	.-186    	; 0x834 <UART_Transmit_String>
     8ee:	60 91 61 04 	lds	r22, 0x0461	; 0x800461 <afstand>
     8f2:	70 91 62 04 	lds	r23, 0x0462	; 0x800462 <afstand+0x1>
     8f6:	07 2e       	mov	r0, r23
     8f8:	00 0c       	add	r0, r0
     8fa:	88 0b       	sbc	r24, r24
     8fc:	99 0b       	sbc	r25, r25
     8fe:	a8 df       	rcall	.-176    	; 0x850 <UART_Transmit_Integer>
     900:	8b e1       	ldi	r24, 0x1B	; 27
     902:	92 e0       	ldi	r25, 0x02	; 2
     904:	97 df       	rcall	.-210    	; 0x834 <UART_Transmit_String>
     906:	60 91 32 03 	lds	r22, 0x0332	; 0x800332 <gyroX>
     90a:	70 91 33 03 	lds	r23, 0x0333	; 0x800333 <gyroX+0x1>
     90e:	07 2e       	mov	r0, r23
     910:	00 0c       	add	r0, r0
     912:	88 0b       	sbc	r24, r24
     914:	99 0b       	sbc	r25, r25
     916:	9c df       	rcall	.-200    	; 0x850 <UART_Transmit_Integer>
     918:	85 e2       	ldi	r24, 0x25	; 37
     91a:	92 e0       	ldi	r25, 0x02	; 2
     91c:	8b df       	rcall	.-234    	; 0x834 <UART_Transmit_String>
     91e:	60 91 67 04 	lds	r22, 0x0467	; 0x800467 <gyroY>
     922:	70 91 68 04 	lds	r23, 0x0468	; 0x800468 <gyroY+0x1>
     926:	07 2e       	mov	r0, r23
     928:	00 0c       	add	r0, r0
     92a:	88 0b       	sbc	r24, r24
     92c:	99 0b       	sbc	r25, r25
     92e:	90 df       	rcall	.-224    	; 0x850 <UART_Transmit_Integer>
     930:	8a e2       	ldi	r24, 0x2A	; 42
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	7f df       	rcall	.-258    	; 0x834 <UART_Transmit_String>
     936:	60 91 4e 04 	lds	r22, 0x044E	; 0x80044e <gyroZ>
     93a:	70 91 4f 04 	lds	r23, 0x044F	; 0x80044f <gyroZ+0x1>
     93e:	07 2e       	mov	r0, r23
     940:	00 0c       	add	r0, r0
     942:	88 0b       	sbc	r24, r24
     944:	99 0b       	sbc	r25, r25
     946:	84 df       	rcall	.-248    	; 0x850 <UART_Transmit_Integer>
     948:	8f e2       	ldi	r24, 0x2F	; 47
     94a:	92 e0       	ldi	r25, 0x02	; 2
     94c:	73 df       	rcall	.-282    	; 0x834 <UART_Transmit_String>
     94e:	60 91 2c 03 	lds	r22, 0x032C	; 0x80032c <accelX>
     952:	70 91 2d 03 	lds	r23, 0x032D	; 0x80032d <accelX+0x1>
     956:	07 2e       	mov	r0, r23
     958:	00 0c       	add	r0, r0
     95a:	88 0b       	sbc	r24, r24
     95c:	99 0b       	sbc	r25, r25
     95e:	78 df       	rcall	.-272    	; 0x850 <UART_Transmit_Integer>
     960:	85 e2       	ldi	r24, 0x25	; 37
     962:	92 e0       	ldi	r25, 0x02	; 2
     964:	67 df       	rcall	.-306    	; 0x834 <UART_Transmit_String>
     966:	60 91 28 03 	lds	r22, 0x0328	; 0x800328 <accelY>
     96a:	70 91 29 03 	lds	r23, 0x0329	; 0x800329 <accelY+0x1>
     96e:	07 2e       	mov	r0, r23
     970:	00 0c       	add	r0, r0
     972:	88 0b       	sbc	r24, r24
     974:	99 0b       	sbc	r25, r25
     976:	6c df       	rcall	.-296    	; 0x850 <UART_Transmit_Integer>
     978:	8a e2       	ldi	r24, 0x2A	; 42
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	5b df       	rcall	.-330    	; 0x834 <UART_Transmit_String>
     97e:	60 91 5f 04 	lds	r22, 0x045F	; 0x80045f <accelZ>
     982:	70 91 60 04 	lds	r23, 0x0460	; 0x800460 <accelZ+0x1>
     986:	07 2e       	mov	r0, r23
     988:	00 0c       	add	r0, r0
     98a:	88 0b       	sbc	r24, r24
     98c:	99 0b       	sbc	r25, r25
     98e:	60 df       	rcall	.-320    	; 0x850 <UART_Transmit_Integer>
     990:	d0 93 5d 04 	sts	0x045D, r29	; 0x80045d <watchdogServo+0x1>
     994:	c0 93 5c 04 	sts	0x045C, r28	; 0x80045c <watchdogServo>
     998:	9b e1       	ldi	r25, 0x1B	; 27
     99a:	e9 0e       	add	r14, r25
     99c:	f1 1c       	adc	r15, r1
     99e:	e8 ed       	ldi	r30, 0xD8	; 216
     9a0:	ee 16       	cp	r14, r30
     9a2:	f1 04       	cpc	r15, r1
     9a4:	09 f0       	breq	.+2      	; 0x9a8 <servoTaak+0x11c>
     9a6:	78 cf       	rjmp	.-272    	; 0x898 <servoTaak+0xc>
     9a8:	75 cf       	rjmp	.-278    	; 0x894 <servoTaak+0x8>

000009aa <INT0_init>:
     9aa:	e8 e6       	ldi	r30, 0x68	; 104
     9ac:	f0 e0       	ldi	r31, 0x00	; 0
     9ae:	80 81       	ld	r24, Z
     9b0:	81 60       	ori	r24, 0x01	; 1
     9b2:	80 83       	st	Z, r24
     9b4:	eb e6       	ldi	r30, 0x6B	; 107
     9b6:	f0 e0       	ldi	r31, 0x00	; 0
     9b8:	80 81       	ld	r24, Z
     9ba:	82 60       	ori	r24, 0x02	; 2
     9bc:	80 83       	st	Z, r24
     9be:	08 95       	ret

000009c0 <__vector_9>:
     9c0:	1f 92       	push	r1
     9c2:	0f 92       	push	r0
     9c4:	0f b6       	in	r0, 0x3f	; 63
     9c6:	0f 92       	push	r0
     9c8:	11 24       	eor	r1, r1
     9ca:	0b b6       	in	r0, 0x3b	; 59
     9cc:	0f 92       	push	r0
     9ce:	2f 93       	push	r18
     9d0:	3f 93       	push	r19
     9d2:	4f 93       	push	r20
     9d4:	5f 93       	push	r21
     9d6:	6f 93       	push	r22
     9d8:	7f 93       	push	r23
     9da:	8f 93       	push	r24
     9dc:	9f 93       	push	r25
     9de:	af 93       	push	r26
     9e0:	bf 93       	push	r27
     9e2:	ef 93       	push	r30
     9e4:	ff 93       	push	r31
     9e6:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <running>
     9ea:	88 23       	and	r24, r24
     9ec:	d1 f1       	breq	.+116    	; 0xa62 <__vector_9+0xa2>
     9ee:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <up>
     9f2:	81 11       	cpse	r24, r1
     9f4:	10 c0       	rjmp	.+32     	; 0xa16 <__vector_9+0x56>
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <up>
     9fc:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <timerCounter>
     a00:	10 92 bd 02 	sts	0x02BD, r1	; 0x8002bd <timerCounter+0x1>
     a04:	10 92 be 02 	sts	0x02BE, r1	; 0x8002be <timerCounter+0x2>
     a08:	10 92 bf 02 	sts	0x02BF, r1	; 0x8002bf <timerCounter+0x3>
     a0c:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a10:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a14:	26 c0       	rjmp	.+76     	; 0xa62 <__vector_9+0xa2>
     a16:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <up>
     a1a:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <timerCounter>
     a1e:	30 91 bd 02 	lds	r19, 0x02BD	; 0x8002bd <timerCounter+0x1>
     a22:	40 91 be 02 	lds	r20, 0x02BE	; 0x8002be <timerCounter+0x2>
     a26:	50 91 bf 02 	lds	r21, 0x02BF	; 0x8002bf <timerCounter+0x3>
     a2a:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a2e:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a32:	af ef       	ldi	r26, 0xFF	; 255
     a34:	bf ef       	ldi	r27, 0xFF	; 255
     a36:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <__muluhisi3>
     a3a:	6e 0f       	add	r22, r30
     a3c:	7f 1f       	adc	r23, r31
     a3e:	81 1d       	adc	r24, r1
     a40:	91 1d       	adc	r25, r1
     a42:	24 e7       	ldi	r18, 0x74	; 116
     a44:	30 e0       	ldi	r19, 0x00	; 0
     a46:	40 e0       	ldi	r20, 0x00	; 0
     a48:	50 e0       	ldi	r21, 0x00	; 0
     a4a:	0e 94 9b 12 	call	0x2536	; 0x2536 <__udivmodsi4>
     a4e:	20 93 b8 02 	sts	0x02B8, r18	; 0x8002b8 <result>
     a52:	30 93 b9 02 	sts	0x02B9, r19	; 0x8002b9 <result+0x1>
     a56:	40 93 ba 02 	sts	0x02BA, r20	; 0x8002ba <result+0x2>
     a5a:	50 93 bb 02 	sts	0x02BB, r21	; 0x8002bb <result+0x3>
     a5e:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <running>
     a62:	ff 91       	pop	r31
     a64:	ef 91       	pop	r30
     a66:	bf 91       	pop	r27
     a68:	af 91       	pop	r26
     a6a:	9f 91       	pop	r25
     a6c:	8f 91       	pop	r24
     a6e:	7f 91       	pop	r23
     a70:	6f 91       	pop	r22
     a72:	5f 91       	pop	r21
     a74:	4f 91       	pop	r20
     a76:	3f 91       	pop	r19
     a78:	2f 91       	pop	r18
     a7a:	0f 90       	pop	r0
     a7c:	0b be       	out	0x3b, r0	; 59
     a7e:	0f 90       	pop	r0
     a80:	0f be       	out	0x3f, r0	; 63
     a82:	0f 90       	pop	r0
     a84:	1f 90       	pop	r1
     a86:	18 95       	reti

00000a88 <pulse>:
     a88:	28 98       	cbi	0x05, 0	; 5
     a8a:	85 e0       	ldi	r24, 0x05	; 5
     a8c:	8a 95       	dec	r24
     a8e:	f1 f7       	brne	.-4      	; 0xa8c <pulse+0x4>
     a90:	00 00       	nop
     a92:	28 9a       	sbi	0x05, 0	; 5
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <running>
     a9a:	85 e3       	ldi	r24, 0x35	; 53
     a9c:	8a 95       	dec	r24
     a9e:	f1 f7       	brne	.-4      	; 0xa9c <pulse+0x14>
     aa0:	00 00       	nop
     aa2:	28 98       	cbi	0x05, 0	; 5
     aa4:	08 95       	ret

00000aa6 <sonarTaak>:
     aa6:	c1 e0       	ldi	r28, 0x01	; 1
     aa8:	d0 e0       	ldi	r29, 0x00	; 0
     aaa:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <running>
     aae:	81 11       	cpse	r24, r1
     ab0:	16 c0       	rjmp	.+44     	; 0xade <sonarTaak+0x38>
     ab2:	2f ef       	ldi	r18, 0xFF	; 255
     ab4:	80 e7       	ldi	r24, 0x70	; 112
     ab6:	92 e0       	ldi	r25, 0x02	; 2
     ab8:	21 50       	subi	r18, 0x01	; 1
     aba:	80 40       	sbci	r24, 0x00	; 0
     abc:	90 40       	sbci	r25, 0x00	; 0
     abe:	e1 f7       	brne	.-8      	; 0xab8 <sonarTaak+0x12>
     ac0:	00 c0       	rjmp	.+0      	; 0xac2 <sonarTaak+0x1c>
     ac2:	00 00       	nop
     ac4:	e1 df       	rcall	.-62     	; 0xa88 <pulse>
     ac6:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <result>
     aca:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <result+0x1>
     ace:	a0 91 ba 02 	lds	r26, 0x02BA	; 0x8002ba <result+0x2>
     ad2:	b0 91 bb 02 	lds	r27, 0x02BB	; 0x8002bb <result+0x3>
     ad6:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <afstand+0x1>
     ada:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <afstand>
     ade:	d0 93 31 03 	sts	0x0331, r29	; 0x800331 <watchdogSonar+0x1>
     ae2:	c0 93 30 03 	sts	0x0330, r28	; 0x800330 <watchdogSonar>
     ae6:	e1 cf       	rjmp	.-62     	; 0xaaa <sonarTaak+0x4>

00000ae8 <timer3_init>:
     ae8:	e1 e9       	ldi	r30, 0x91	; 145
     aea:	f0 e0       	ldi	r31, 0x00	; 0
     aec:	80 81       	ld	r24, Z
     aee:	82 60       	ori	r24, 0x02	; 2
     af0:	80 83       	st	Z, r24
     af2:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     af6:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     afa:	e1 e7       	ldi	r30, 0x71	; 113
     afc:	f0 e0       	ldi	r31, 0x00	; 0
     afe:	80 81       	ld	r24, Z
     b00:	81 60       	ori	r24, 0x01	; 1
     b02:	80 83       	st	Z, r24
     b04:	08 95       	ret

00000b06 <__vector_35>:
     b06:	1f 92       	push	r1
     b08:	0f 92       	push	r0
     b0a:	0f b6       	in	r0, 0x3f	; 63
     b0c:	0f 92       	push	r0
     b0e:	11 24       	eor	r1, r1
     b10:	0b b6       	in	r0, 0x3b	; 59
     b12:	0f 92       	push	r0
     b14:	2f 93       	push	r18
     b16:	3f 93       	push	r19
     b18:	4f 93       	push	r20
     b1a:	5f 93       	push	r21
     b1c:	6f 93       	push	r22
     b1e:	7f 93       	push	r23
     b20:	8f 93       	push	r24
     b22:	9f 93       	push	r25
     b24:	af 93       	push	r26
     b26:	bf 93       	push	r27
     b28:	ef 93       	push	r30
     b2a:	ff 93       	push	r31
     b2c:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <up>
     b30:	88 23       	and	r24, r24
     b32:	e9 f1       	breq	.+122    	; 0xbae <__vector_35+0xa8>
     b34:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <timerCounter>
     b38:	90 91 bd 02 	lds	r25, 0x02BD	; 0x8002bd <timerCounter+0x1>
     b3c:	a0 91 be 02 	lds	r26, 0x02BE	; 0x8002be <timerCounter+0x2>
     b40:	b0 91 bf 02 	lds	r27, 0x02BF	; 0x8002bf <timerCounter+0x3>
     b44:	01 96       	adiw	r24, 0x01	; 1
     b46:	a1 1d       	adc	r26, r1
     b48:	b1 1d       	adc	r27, r1
     b4a:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <timerCounter>
     b4e:	90 93 bd 02 	sts	0x02BD, r25	; 0x8002bd <timerCounter+0x1>
     b52:	a0 93 be 02 	sts	0x02BE, r26	; 0x8002be <timerCounter+0x2>
     b56:	b0 93 bf 02 	sts	0x02BF, r27	; 0x8002bf <timerCounter+0x3>
     b5a:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <timerCounter>
     b5e:	30 91 bd 02 	lds	r19, 0x02BD	; 0x8002bd <timerCounter+0x1>
     b62:	40 91 be 02 	lds	r20, 0x02BE	; 0x8002be <timerCounter+0x2>
     b66:	50 91 bf 02 	lds	r21, 0x02BF	; 0x8002bf <timerCounter+0x3>
     b6a:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     b6e:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     b72:	af ef       	ldi	r26, 0xFF	; 255
     b74:	bf ef       	ldi	r27, 0xFF	; 255
     b76:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <__muluhisi3>
     b7a:	dc 01       	movw	r26, r24
     b7c:	cb 01       	movw	r24, r22
     b7e:	8e 0f       	add	r24, r30
     b80:	9f 1f       	adc	r25, r31
     b82:	a1 1d       	adc	r26, r1
     b84:	b1 1d       	adc	r27, r1
     b86:	81 30       	cpi	r24, 0x01	; 1
     b88:	94 4d       	sbci	r25, 0xD4	; 212
     b8a:	a0 43       	sbci	r26, 0x30	; 48
     b8c:	b1 05       	cpc	r27, r1
     b8e:	78 f0       	brcs	.+30     	; 0xbae <__vector_35+0xa8>
     b90:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <up>
     b94:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <running>
     b98:	8f ef       	ldi	r24, 0xFF	; 255
     b9a:	9f ef       	ldi	r25, 0xFF	; 255
     b9c:	dc 01       	movw	r26, r24
     b9e:	80 93 b8 02 	sts	0x02B8, r24	; 0x8002b8 <result>
     ba2:	90 93 b9 02 	sts	0x02B9, r25	; 0x8002b9 <result+0x1>
     ba6:	a0 93 ba 02 	sts	0x02BA, r26	; 0x8002ba <result+0x2>
     baa:	b0 93 bb 02 	sts	0x02BB, r27	; 0x8002bb <result+0x3>
     bae:	ff 91       	pop	r31
     bb0:	ef 91       	pop	r30
     bb2:	bf 91       	pop	r27
     bb4:	af 91       	pop	r26
     bb6:	9f 91       	pop	r25
     bb8:	8f 91       	pop	r24
     bba:	7f 91       	pop	r23
     bbc:	6f 91       	pop	r22
     bbe:	5f 91       	pop	r21
     bc0:	4f 91       	pop	r20
     bc2:	3f 91       	pop	r19
     bc4:	2f 91       	pop	r18
     bc6:	0f 90       	pop	r0
     bc8:	0b be       	out	0x3b, r0	; 59
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	0f 90       	pop	r0
     bd0:	1f 90       	pop	r1
     bd2:	18 95       	reti

00000bd4 <INT4_init>:
     bd4:	ea e6       	ldi	r30, 0x6A	; 106
     bd6:	f0 e0       	ldi	r31, 0x00	; 0
     bd8:	80 81       	ld	r24, Z
     bda:	8e 7f       	andi	r24, 0xFE	; 254
     bdc:	80 83       	st	Z, r24
     bde:	80 81       	ld	r24, Z
     be0:	82 60       	ori	r24, 0x02	; 2
     be2:	80 83       	st	Z, r24
     be4:	ec 9a       	sbi	0x1d, 4	; 29
     be6:	08 95       	ret

00000be8 <initServo>:
     be8:	26 9a       	sbi	0x04, 6	; 4
     bea:	82 e3       	ldi	r24, 0x32	; 50
     bec:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     bf0:	82 e1       	ldi	r24, 0x12	; 18
     bf2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
     bf6:	80 e2       	ldi	r24, 0x20	; 32
     bf8:	9e e4       	ldi	r25, 0x4E	; 78
     bfa:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     bfe:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     c02:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     c06:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	9b e4       	ldi	r25, 0x4B	; 75
     c0e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     c12:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
     c16:	ef e6       	ldi	r30, 0x6F	; 111
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	80 81       	ld	r24, Z
     c1c:	82 60       	ori	r24, 0x02	; 2
     c1e:	80 83       	st	Z, r24
     c20:	08 95       	ret

00000c22 <init_master>:
     c22:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     c26:	88 e4       	ldi	r24, 0x48	; 72
     c28:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
     c2c:	84 e0       	ldi	r24, 0x04	; 4
     c2e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c32:	08 95       	ret

00000c34 <ontvangen>:
     c34:	ef 92       	push	r14
     c36:	ff 92       	push	r15
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	ec eb       	ldi	r30, 0xBC	; 188
     c42:	f0 e0       	ldi	r31, 0x00	; 0
     c44:	90 81       	ld	r25, Z
     c46:	90 62       	ori	r25, 0x20	; 32
     c48:	90 83       	st	Z, r25
     c4a:	90 81       	ld	r25, Z
     c4c:	99 23       	and	r25, r25
     c4e:	ec f7       	brge	.-6      	; 0xc4a <ontvangen+0x16>
     c50:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     c54:	88 0f       	add	r24, r24
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c5c:	84 e8       	ldi	r24, 0x84	; 132
     c5e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c62:	ec eb       	ldi	r30, 0xBC	; 188
     c64:	f0 e0       	ldi	r31, 0x00	; 0
     c66:	80 81       	ld	r24, Z
     c68:	88 23       	and	r24, r24
     c6a:	ec f7       	brge	.-6      	; 0xc66 <ontvangen+0x32>
     c6c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     c70:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c74:	db 01       	movw	r26, r22
     c76:	8c 93       	st	X, r24
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	50 e0       	ldi	r21, 0x00	; 0
     c7c:	41 50       	subi	r20, 0x01	; 1
     c7e:	51 09       	sbc	r21, r1
     c80:	ec eb       	ldi	r30, 0xBC	; 188
     c82:	f0 e0       	ldi	r31, 0x00	; 0
     c84:	0f 2e       	mov	r0, r31
     c86:	f4 ec       	ldi	r31, 0xC4	; 196
     c88:	ff 2e       	mov	r15, r31
     c8a:	f0 2d       	mov	r31, r0
     c8c:	0f 2e       	mov	r0, r31
     c8e:	f4 e8       	ldi	r31, 0x84	; 132
     c90:	ef 2e       	mov	r14, r31
     c92:	f0 2d       	mov	r31, r0
     c94:	09 eb       	ldi	r16, 0xB9	; 185
     c96:	10 e0       	ldi	r17, 0x00	; 0
     c98:	cb eb       	ldi	r28, 0xBB	; 187
     c9a:	d0 e0       	ldi	r29, 0x00	; 0
     c9c:	29 2f       	mov	r18, r25
     c9e:	30 e0       	ldi	r19, 0x00	; 0
     ca0:	24 17       	cp	r18, r20
     ca2:	35 07       	cpc	r19, r21
     ca4:	11 f4       	brne	.+4      	; 0xcaa <ontvangen+0x76>
     ca6:	e0 82       	st	Z, r14
     ca8:	01 c0       	rjmp	.+2      	; 0xcac <ontvangen+0x78>
     caa:	f0 82       	st	Z, r15
     cac:	80 81       	ld	r24, Z
     cae:	88 23       	and	r24, r24
     cb0:	ec f7       	brge	.-6      	; 0xcac <ontvangen+0x78>
     cb2:	d8 01       	movw	r26, r16
     cb4:	8c 91       	ld	r24, X
     cb6:	28 81       	ld	r18, Y
     cb8:	db 01       	movw	r26, r22
     cba:	a9 0f       	add	r26, r25
     cbc:	b1 1d       	adc	r27, r1
     cbe:	2c 93       	st	X, r18
     cc0:	9f 5f       	subi	r25, 0xFF	; 255
     cc2:	80 35       	cpi	r24, 0x50	; 80
     cc4:	59 f3       	breq	.-42     	; 0xc9c <ontvangen+0x68>
     cc6:	84 e9       	ldi	r24, 0x94	; 148
     cc8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     ccc:	df 91       	pop	r29
     cce:	cf 91       	pop	r28
     cd0:	1f 91       	pop	r17
     cd2:	0f 91       	pop	r16
     cd4:	ff 90       	pop	r15
     cd6:	ef 90       	pop	r14
     cd8:	08 95       	ret

00000cda <verzenden>:
     cda:	ec eb       	ldi	r30, 0xBC	; 188
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	90 81       	ld	r25, Z
     ce0:	90 62       	ori	r25, 0x20	; 32
     ce2:	90 83       	st	Z, r25
     ce4:	90 81       	ld	r25, Z
     ce6:	99 23       	and	r25, r25
     ce8:	ec f7       	brge	.-6      	; 0xce4 <verzenden+0xa>
     cea:	88 0f       	add	r24, r24
     cec:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     cf0:	84 e8       	ldi	r24, 0x84	; 132
     cf2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     cf6:	ec eb       	ldi	r30, 0xBC	; 188
     cf8:	f0 e0       	ldi	r31, 0x00	; 0
     cfa:	80 81       	ld	r24, Z
     cfc:	88 23       	and	r24, r24
     cfe:	ec f7       	brge	.-6      	; 0xcfa <verzenden+0x20>
     d00:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     d04:	84 e8       	ldi	r24, 0x84	; 132
     d06:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     d0a:	ec eb       	ldi	r30, 0xBC	; 188
     d0c:	f0 e0       	ldi	r31, 0x00	; 0
     d0e:	80 81       	ld	r24, Z
     d10:	88 23       	and	r24, r24
     d12:	ec f7       	brge	.-6      	; 0xd0e <verzenden+0x34>
     d14:	84 e9       	ldi	r24, 0x94	; 148
     d16:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     d1a:	08 95       	ret

00000d1c <gyroTaak>:
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
     d20:	1f 92       	push	r1
     d22:	1f 92       	push	r1
     d24:	cd b7       	in	r28, 0x3d	; 61
     d26:	de b7       	in	r29, 0x3e	; 62
     d28:	ee 24       	eor	r14, r14
     d2a:	e3 94       	inc	r14
     d2c:	f1 2c       	mov	r15, r1
     d2e:	6b e3       	ldi	r22, 0x3B	; 59
     d30:	88 e6       	ldi	r24, 0x68	; 104
     d32:	d3 df       	rcall	.-90     	; 0xcda <verzenden>
     d34:	41 e0       	ldi	r20, 0x01	; 1
     d36:	be 01       	movw	r22, r28
     d38:	6f 5f       	subi	r22, 0xFF	; 255
     d3a:	7f 4f       	sbci	r23, 0xFF	; 255
     d3c:	88 e6       	ldi	r24, 0x68	; 104
     d3e:	7a df       	rcall	.-268    	; 0xc34 <ontvangen>
     d40:	19 81       	ldd	r17, Y+1	; 0x01
     d42:	6c e3       	ldi	r22, 0x3C	; 60
     d44:	88 e6       	ldi	r24, 0x68	; 104
     d46:	c9 df       	rcall	.-110    	; 0xcda <verzenden>
     d48:	41 e0       	ldi	r20, 0x01	; 1
     d4a:	be 01       	movw	r22, r28
     d4c:	6f 5f       	subi	r22, 0xFF	; 255
     d4e:	7f 4f       	sbci	r23, 0xFF	; 255
     d50:	88 e6       	ldi	r24, 0x68	; 104
     d52:	70 df       	rcall	.-288    	; 0xc34 <ontvangen>
     d54:	81 2f       	mov	r24, r17
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	98 2f       	mov	r25, r24
     d5a:	88 27       	eor	r24, r24
     d5c:	29 81       	ldd	r18, Y+1	; 0x01
     d5e:	82 2b       	or	r24, r18
     d60:	90 93 33 03 	sts	0x0333, r25	; 0x800333 <gyroX+0x1>
     d64:	80 93 32 03 	sts	0x0332, r24	; 0x800332 <gyroX>
     d68:	6d e3       	ldi	r22, 0x3D	; 61
     d6a:	88 e6       	ldi	r24, 0x68	; 104
     d6c:	b6 df       	rcall	.-148    	; 0xcda <verzenden>
     d6e:	41 e0       	ldi	r20, 0x01	; 1
     d70:	be 01       	movw	r22, r28
     d72:	6f 5f       	subi	r22, 0xFF	; 255
     d74:	7f 4f       	sbci	r23, 0xFF	; 255
     d76:	88 e6       	ldi	r24, 0x68	; 104
     d78:	5d df       	rcall	.-326    	; 0xc34 <ontvangen>
     d7a:	19 81       	ldd	r17, Y+1	; 0x01
     d7c:	6e e3       	ldi	r22, 0x3E	; 62
     d7e:	88 e6       	ldi	r24, 0x68	; 104
     d80:	ac df       	rcall	.-168    	; 0xcda <verzenden>
     d82:	41 e0       	ldi	r20, 0x01	; 1
     d84:	be 01       	movw	r22, r28
     d86:	6f 5f       	subi	r22, 0xFF	; 255
     d88:	7f 4f       	sbci	r23, 0xFF	; 255
     d8a:	88 e6       	ldi	r24, 0x68	; 104
     d8c:	53 df       	rcall	.-346    	; 0xc34 <ontvangen>
     d8e:	81 2f       	mov	r24, r17
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	98 2f       	mov	r25, r24
     d94:	88 27       	eor	r24, r24
     d96:	29 81       	ldd	r18, Y+1	; 0x01
     d98:	82 2b       	or	r24, r18
     d9a:	90 93 68 04 	sts	0x0468, r25	; 0x800468 <gyroY+0x1>
     d9e:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <gyroY>
     da2:	6f e3       	ldi	r22, 0x3F	; 63
     da4:	88 e6       	ldi	r24, 0x68	; 104
     da6:	99 df       	rcall	.-206    	; 0xcda <verzenden>
     da8:	41 e0       	ldi	r20, 0x01	; 1
     daa:	be 01       	movw	r22, r28
     dac:	6f 5f       	subi	r22, 0xFF	; 255
     dae:	7f 4f       	sbci	r23, 0xFF	; 255
     db0:	88 e6       	ldi	r24, 0x68	; 104
     db2:	40 df       	rcall	.-384    	; 0xc34 <ontvangen>
     db4:	19 81       	ldd	r17, Y+1	; 0x01
     db6:	60 e4       	ldi	r22, 0x40	; 64
     db8:	88 e6       	ldi	r24, 0x68	; 104
     dba:	8f df       	rcall	.-226    	; 0xcda <verzenden>
     dbc:	41 e0       	ldi	r20, 0x01	; 1
     dbe:	be 01       	movw	r22, r28
     dc0:	6f 5f       	subi	r22, 0xFF	; 255
     dc2:	7f 4f       	sbci	r23, 0xFF	; 255
     dc4:	88 e6       	ldi	r24, 0x68	; 104
     dc6:	36 df       	rcall	.-404    	; 0xc34 <ontvangen>
     dc8:	81 2f       	mov	r24, r17
     dca:	90 e0       	ldi	r25, 0x00	; 0
     dcc:	98 2f       	mov	r25, r24
     dce:	88 27       	eor	r24, r24
     dd0:	29 81       	ldd	r18, Y+1	; 0x01
     dd2:	82 2b       	or	r24, r18
     dd4:	90 93 4f 04 	sts	0x044F, r25	; 0x80044f <gyroZ+0x1>
     dd8:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <gyroZ>
     ddc:	63 e4       	ldi	r22, 0x43	; 67
     dde:	88 e6       	ldi	r24, 0x68	; 104
     de0:	7c df       	rcall	.-264    	; 0xcda <verzenden>
     de2:	41 e0       	ldi	r20, 0x01	; 1
     de4:	be 01       	movw	r22, r28
     de6:	6f 5f       	subi	r22, 0xFF	; 255
     de8:	7f 4f       	sbci	r23, 0xFF	; 255
     dea:	88 e6       	ldi	r24, 0x68	; 104
     dec:	23 df       	rcall	.-442    	; 0xc34 <ontvangen>
     dee:	19 81       	ldd	r17, Y+1	; 0x01
     df0:	64 e4       	ldi	r22, 0x44	; 68
     df2:	88 e6       	ldi	r24, 0x68	; 104
     df4:	72 df       	rcall	.-284    	; 0xcda <verzenden>
     df6:	41 e0       	ldi	r20, 0x01	; 1
     df8:	be 01       	movw	r22, r28
     dfa:	6f 5f       	subi	r22, 0xFF	; 255
     dfc:	7f 4f       	sbci	r23, 0xFF	; 255
     dfe:	88 e6       	ldi	r24, 0x68	; 104
     e00:	19 df       	rcall	.-462    	; 0xc34 <ontvangen>
     e02:	81 2f       	mov	r24, r17
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	98 2f       	mov	r25, r24
     e08:	88 27       	eor	r24, r24
     e0a:	29 81       	ldd	r18, Y+1	; 0x01
     e0c:	82 2b       	or	r24, r18
     e0e:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <accelX+0x1>
     e12:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <accelX>
     e16:	65 e4       	ldi	r22, 0x45	; 69
     e18:	88 e6       	ldi	r24, 0x68	; 104
     e1a:	5f df       	rcall	.-322    	; 0xcda <verzenden>
     e1c:	41 e0       	ldi	r20, 0x01	; 1
     e1e:	be 01       	movw	r22, r28
     e20:	6f 5f       	subi	r22, 0xFF	; 255
     e22:	7f 4f       	sbci	r23, 0xFF	; 255
     e24:	88 e6       	ldi	r24, 0x68	; 104
     e26:	06 df       	rcall	.-500    	; 0xc34 <ontvangen>
     e28:	19 81       	ldd	r17, Y+1	; 0x01
     e2a:	66 e4       	ldi	r22, 0x46	; 70
     e2c:	88 e6       	ldi	r24, 0x68	; 104
     e2e:	55 df       	rcall	.-342    	; 0xcda <verzenden>
     e30:	41 e0       	ldi	r20, 0x01	; 1
     e32:	be 01       	movw	r22, r28
     e34:	6f 5f       	subi	r22, 0xFF	; 255
     e36:	7f 4f       	sbci	r23, 0xFF	; 255
     e38:	88 e6       	ldi	r24, 0x68	; 104
     e3a:	fc de       	rcall	.-520    	; 0xc34 <ontvangen>
     e3c:	81 2f       	mov	r24, r17
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	98 2f       	mov	r25, r24
     e42:	88 27       	eor	r24, r24
     e44:	29 81       	ldd	r18, Y+1	; 0x01
     e46:	82 2b       	or	r24, r18
     e48:	90 93 29 03 	sts	0x0329, r25	; 0x800329 <accelY+0x1>
     e4c:	80 93 28 03 	sts	0x0328, r24	; 0x800328 <accelY>
     e50:	67 e4       	ldi	r22, 0x47	; 71
     e52:	88 e6       	ldi	r24, 0x68	; 104
     e54:	42 df       	rcall	.-380    	; 0xcda <verzenden>
     e56:	41 e0       	ldi	r20, 0x01	; 1
     e58:	be 01       	movw	r22, r28
     e5a:	6f 5f       	subi	r22, 0xFF	; 255
     e5c:	7f 4f       	sbci	r23, 0xFF	; 255
     e5e:	88 e6       	ldi	r24, 0x68	; 104
     e60:	e9 de       	rcall	.-558    	; 0xc34 <ontvangen>
     e62:	19 81       	ldd	r17, Y+1	; 0x01
     e64:	68 e4       	ldi	r22, 0x48	; 72
     e66:	88 e6       	ldi	r24, 0x68	; 104
     e68:	38 df       	rcall	.-400    	; 0xcda <verzenden>
     e6a:	41 e0       	ldi	r20, 0x01	; 1
     e6c:	be 01       	movw	r22, r28
     e6e:	6f 5f       	subi	r22, 0xFF	; 255
     e70:	7f 4f       	sbci	r23, 0xFF	; 255
     e72:	88 e6       	ldi	r24, 0x68	; 104
     e74:	df de       	rcall	.-578    	; 0xc34 <ontvangen>
     e76:	81 2f       	mov	r24, r17
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	98 2f       	mov	r25, r24
     e7c:	88 27       	eor	r24, r24
     e7e:	29 81       	ldd	r18, Y+1	; 0x01
     e80:	82 2b       	or	r24, r18
     e82:	90 93 60 04 	sts	0x0460, r25	; 0x800460 <accelZ+0x1>
     e86:	80 93 5f 04 	sts	0x045F, r24	; 0x80045f <accelZ>
     e8a:	f0 92 2f 03 	sts	0x032F, r15	; 0x80032f <watchdogGyro+0x1>
     e8e:	e0 92 2e 03 	sts	0x032E, r14	; 0x80032e <watchdogGyro>
     e92:	4d cf       	rjmp	.-358    	; 0xd2e <gyroTaak+0x12>

00000e94 <__vector_17>:
     e94:	1f 92       	push	r1
     e96:	0f 92       	push	r0
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	0f 92       	push	r0
     e9c:	11 24       	eor	r1, r1
     e9e:	8f 93       	push	r24
     ea0:	9f 93       	push	r25
     ea2:	95 b1       	in	r25, 0x05	; 5
     ea4:	80 e4       	ldi	r24, 0x40	; 64
     ea6:	89 27       	eor	r24, r25
     ea8:	85 b9       	out	0x05, r24	; 5
     eaa:	9f 91       	pop	r25
     eac:	8f 91       	pop	r24
     eae:	0f 90       	pop	r0
     eb0:	0f be       	out	0x3f, r0	; 63
     eb2:	0f 90       	pop	r0
     eb4:	1f 90       	pop	r1
     eb6:	18 95       	reti

00000eb8 <motorAchteruit>:
     eb8:	eb e0       	ldi	r30, 0x0B	; 11
     eba:	f1 e0       	ldi	r31, 0x01	; 1
     ebc:	80 81       	ld	r24, Z
     ebe:	8f 77       	andi	r24, 0x7F	; 127
     ec0:	80 83       	st	Z, r24
     ec2:	5f 98       	cbi	0x0b, 7	; 11
     ec4:	a1 9a       	sbi	0x14, 1	; 20
     ec6:	41 9a       	sbi	0x08, 1	; 8
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     ed0:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     ed4:	08 95       	ret

00000ed6 <motorVooruit>:
     ed6:	a1 98       	cbi	0x14, 1	; 20
     ed8:	41 98       	cbi	0x08, 1	; 8
     eda:	eb e0       	ldi	r30, 0x0B	; 11
     edc:	f1 e0       	ldi	r31, 0x01	; 1
     ede:	80 81       	ld	r24, Z
     ee0:	80 68       	ori	r24, 0x80	; 128
     ee2:	80 83       	st	Z, r24
     ee4:	5f 9a       	sbi	0x0b, 7	; 11
     ee6:	81 e0       	ldi	r24, 0x01	; 1
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     eee:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     ef2:	08 95       	ret

00000ef4 <motorRechts>:
     ef4:	5f 98       	cbi	0x0b, 7	; 11
     ef6:	a1 98       	cbi	0x14, 1	; 20
     ef8:	eb e0       	ldi	r30, 0x0B	; 11
     efa:	f1 e0       	ldi	r31, 0x01	; 1
     efc:	80 81       	ld	r24, Z
     efe:	80 68       	ori	r24, 0x80	; 128
     f00:	80 83       	st	Z, r24
     f02:	41 9a       	sbi	0x08, 1	; 8
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f0c:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f10:	08 95       	ret

00000f12 <motorLinks>:
     f12:	41 98       	cbi	0x08, 1	; 8
     f14:	eb e0       	ldi	r30, 0x0B	; 11
     f16:	f1 e0       	ldi	r31, 0x01	; 1
     f18:	80 81       	ld	r24, Z
     f1a:	8f 77       	andi	r24, 0x7F	; 127
     f1c:	80 83       	st	Z, r24
     f1e:	a1 9a       	sbi	0x14, 1	; 20
     f20:	5f 9a       	sbi	0x0b, 7	; 11
     f22:	81 e0       	ldi	r24, 0x01	; 1
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f2a:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f2e:	08 95       	ret

00000f30 <motorStop>:
     f30:	a1 98       	cbi	0x14, 1	; 20
     f32:	eb e0       	ldi	r30, 0x0B	; 11
     f34:	f1 e0       	ldi	r31, 0x01	; 1
     f36:	80 81       	ld	r24, Z
     f38:	8f 77       	andi	r24, 0x7F	; 127
     f3a:	80 83       	st	Z, r24
     f3c:	41 98       	cbi	0x08, 1	; 8
     f3e:	5f 98       	cbi	0x0b, 7	; 11
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	90 93 4d 04 	sts	0x044D, r25	; 0x80044d <watchdogMotor+0x1>
     f48:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <watchdogMotor>
     f4c:	08 95       	ret

00000f4e <__vector_5>:
     f4e:	1f 92       	push	r1
     f50:	0f 92       	push	r0
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	0f 92       	push	r0
     f56:	11 24       	eor	r1, r1
     f58:	0b b6       	in	r0, 0x3b	; 59
     f5a:	0f 92       	push	r0
     f5c:	2f 93       	push	r18
     f5e:	3f 93       	push	r19
     f60:	4f 93       	push	r20
     f62:	5f 93       	push	r21
     f64:	6f 93       	push	r22
     f66:	7f 93       	push	r23
     f68:	8f 93       	push	r24
     f6a:	9f 93       	push	r25
     f6c:	af 93       	push	r26
     f6e:	bf 93       	push	r27
     f70:	ef 93       	push	r30
     f72:	ff 93       	push	r31
     f74:	88 e5       	ldi	r24, 0x58	; 88
     f76:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <ontvang>
     f7a:	da df       	rcall	.-76     	; 0xf30 <motorStop>
     f7c:	ff 91       	pop	r31
     f7e:	ef 91       	pop	r30
     f80:	bf 91       	pop	r27
     f82:	af 91       	pop	r26
     f84:	9f 91       	pop	r25
     f86:	8f 91       	pop	r24
     f88:	7f 91       	pop	r23
     f8a:	6f 91       	pop	r22
     f8c:	5f 91       	pop	r21
     f8e:	4f 91       	pop	r20
     f90:	3f 91       	pop	r19
     f92:	2f 91       	pop	r18
     f94:	0f 90       	pop	r0
     f96:	0b be       	out	0x3b, r0	; 59
     f98:	0f 90       	pop	r0
     f9a:	0f be       	out	0x3f, r0	; 63
     f9c:	0f 90       	pop	r0
     f9e:	1f 90       	pop	r1
     fa0:	18 95       	reti

00000fa2 <motorEnable>:
     fa2:	c6 df       	rcall	.-116    	; 0xf30 <motorStop>
     fa4:	eb e0       	ldi	r30, 0x0B	; 11
     fa6:	f1 e0       	ldi	r31, 0x01	; 1
     fa8:	80 81       	ld	r24, Z
     faa:	88 60       	ori	r24, 0x08	; 8
     fac:	80 83       	st	Z, r24
     fae:	80 81       	ld	r24, Z
     fb0:	80 62       	ori	r24, 0x20	; 32
     fb2:	80 83       	st	Z, r24
     fb4:	08 95       	ret

00000fb6 <initMotor>:
     fb6:	39 9a       	sbi	0x07, 1	; 7
     fb8:	57 9a       	sbi	0x0a, 7	; 10
     fba:	ea e0       	ldi	r30, 0x0A	; 10
     fbc:	f1 e0       	ldi	r31, 0x01	; 1
     fbe:	80 81       	ld	r24, Z
     fc0:	88 6a       	ori	r24, 0xA8	; 168
     fc2:	80 83       	st	Z, r24
     fc4:	99 9a       	sbi	0x13, 1	; 19
     fc6:	8e ec       	ldi	r24, 0xCE	; 206
     fc8:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
     fcc:	82 e1       	ldi	r24, 0x12	; 18
     fce:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
     fd2:	80 e2       	ldi	r24, 0x20	; 32
     fd4:	9e e4       	ldi	r25, 0x4E	; 78
     fd6:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     fda:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
     fde:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     fe2:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     fe6:	dd cf       	rjmp	.-70     	; 0xfa2 <motorEnable>
     fe8:	08 95       	ret

00000fea <main>:
     fea:	ef 92       	push	r14
     fec:	ff 92       	push	r15
     fee:	0f 93       	push	r16
     ff0:	43 e0       	ldi	r20, 0x03	; 3
     ff2:	60 e0       	ldi	r22, 0x00	; 0
     ff4:	81 e0       	ldi	r24, 0x01	; 1
     ff6:	9f d3       	rcall	.+1854   	; 0x1736 <xQueueGenericCreate>
     ff8:	90 93 2b 03 	sts	0x032B, r25	; 0x80032b <sem+0x1>
     ffc:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <sem>
    1000:	20 e0       	ldi	r18, 0x00	; 0
    1002:	40 e0       	ldi	r20, 0x00	; 0
    1004:	50 e0       	ldi	r21, 0x00	; 0
    1006:	60 e0       	ldi	r22, 0x00	; 0
    1008:	70 e0       	ldi	r23, 0x00	; 0
    100a:	c1 d3       	rcall	.+1922   	; 0x178e <xQueueGenericSend>
    100c:	8a b1       	in	r24, 0x0a	; 10
    100e:	83 60       	ori	r24, 0x03	; 3
    1010:	8a b9       	out	0x0a, r24	; 10
    1012:	20 9a       	sbi	0x04, 0	; 4
    1014:	d0 df       	rcall	.-96     	; 0xfb6 <initMotor>
    1016:	40 e0       	ldi	r20, 0x00	; 0
    1018:	61 e0       	ldi	r22, 0x01	; 1
    101a:	8a e0       	ldi	r24, 0x0A	; 10
    101c:	8c d3       	rcall	.+1816   	; 0x1736 <xQueueGenericCreate>
    101e:	90 93 37 04 	sts	0x0437, r25	; 0x800437 <motorCommand+0x1>
    1022:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <motorCommand>
    1026:	e0 db       	rcall	.-2112   	; 0x7e8 <UART_Init>
    1028:	c0 dc       	rcall	.-1664   	; 0x9aa <INT0_init>
    102a:	d4 dd       	rcall	.-1112   	; 0xbd4 <INT4_init>
    102c:	5d dd       	rcall	.-1350   	; 0xae8 <timer3_init>
    102e:	dc dd       	rcall	.-1096   	; 0xbe8 <initServo>
    1030:	78 94       	sei
    1032:	f7 dd       	rcall	.-1042   	; 0xc22 <init_master>
    1034:	10 92 31 03 	sts	0x0331, r1	; 0x800331 <watchdogSonar+0x1>
    1038:	10 92 30 03 	sts	0x0330, r1	; 0x800330 <watchdogSonar>
    103c:	10 92 5d 04 	sts	0x045D, r1	; 0x80045d <watchdogServo+0x1>
    1040:	10 92 5c 04 	sts	0x045C, r1	; 0x80045c <watchdogServo>
    1044:	10 92 51 04 	sts	0x0451, r1	; 0x800451 <watchdogTemp+0x1>
    1048:	10 92 50 04 	sts	0x0450, r1	; 0x800450 <watchdogTemp>
    104c:	10 92 4d 04 	sts	0x044D, r1	; 0x80044d <watchdogMotor+0x1>
    1050:	10 92 4c 04 	sts	0x044C, r1	; 0x80044c <watchdogMotor>
    1054:	98 e2       	ldi	r25, 0x28	; 40
    1056:	88 e1       	ldi	r24, 0x18	; 24
    1058:	0f b6       	in	r0, 0x3f	; 63
    105a:	f8 94       	cli
    105c:	a8 95       	wdr
    105e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1068:	86 e1       	ldi	r24, 0x16	; 22
    106a:	9a ee       	ldi	r25, 0xEA	; 234
    106c:	ac e9       	ldi	r26, 0x9C	; 156
    106e:	bb e3       	ldi	r27, 0x3B	; 59
    1070:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <_accelScale>
    1074:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <_accelScale+0x1>
    1078:	a0 93 65 04 	sts	0x0465, r26	; 0x800465 <_accelScale+0x2>
    107c:	b0 93 66 04 	sts	0x0466, r27	; 0x800466 <_accelScale+0x3>
    1080:	83 ee       	ldi	r24, 0xE3	; 227
    1082:	90 ea       	ldi	r25, 0xA0	; 160
    1084:	ab e8       	ldi	r26, 0x8B	; 139
    1086:	ba e3       	ldi	r27, 0x3A	; 58
    1088:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <_gyroScale>
    108c:	90 93 6a 04 	sts	0x046A, r25	; 0x80046a <_gyroScale+0x1>
    1090:	a0 93 6b 04 	sts	0x046B, r26	; 0x80046b <_gyroScale+0x2>
    1094:	b0 93 6c 04 	sts	0x046C, r27	; 0x80046c <_gyroScale+0x3>
    1098:	8a e3       	ldi	r24, 0x3A	; 58
    109a:	92 e0       	ldi	r25, 0x02	; 2
    109c:	cb db       	rcall	.-2154   	; 0x834 <UART_Transmit_String>
    109e:	e1 2c       	mov	r14, r1
    10a0:	f1 2c       	mov	r15, r1
    10a2:	03 e0       	ldi	r16, 0x03	; 3
    10a4:	20 e0       	ldi	r18, 0x00	; 0
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	40 e0       	ldi	r20, 0x00	; 0
    10aa:	51 e0       	ldi	r21, 0x01	; 1
    10ac:	69 e4       	ldi	r22, 0x49	; 73
    10ae:	72 e0       	ldi	r23, 0x02	; 2
    10b0:	83 e5       	ldi	r24, 0x53	; 83
    10b2:	95 e0       	ldi	r25, 0x05	; 5
    10b4:	57 d6       	rcall	.+3246   	; 0x1d64 <xTaskCreate>
    10b6:	20 e0       	ldi	r18, 0x00	; 0
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	40 e0       	ldi	r20, 0x00	; 0
    10bc:	51 e0       	ldi	r21, 0x01	; 1
    10be:	66 e5       	ldi	r22, 0x56	; 86
    10c0:	72 e0       	ldi	r23, 0x02	; 2
    10c2:	86 e4       	ldi	r24, 0x46	; 70
    10c4:	94 e0       	ldi	r25, 0x04	; 4
    10c6:	4e d6       	rcall	.+3228   	; 0x1d64 <xTaskCreate>
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	40 e0       	ldi	r20, 0x00	; 0
    10ce:	51 e0       	ldi	r21, 0x01	; 1
    10d0:	62 e6       	ldi	r22, 0x62	; 98
    10d2:	72 e0       	ldi	r23, 0x02	; 2
    10d4:	8e e8       	ldi	r24, 0x8E	; 142
    10d6:	96 e0       	ldi	r25, 0x06	; 6
    10d8:	45 d6       	rcall	.+3210   	; 0x1d64 <xTaskCreate>
    10da:	20 e0       	ldi	r18, 0x00	; 0
    10dc:	30 e0       	ldi	r19, 0x00	; 0
    10de:	40 e0       	ldi	r20, 0x00	; 0
    10e0:	51 e0       	ldi	r21, 0x01	; 1
    10e2:	63 e7       	ldi	r22, 0x73	; 115
    10e4:	72 e0       	ldi	r23, 0x02	; 2
    10e6:	88 e9       	ldi	r24, 0x98	; 152
    10e8:	98 e0       	ldi	r25, 0x08	; 8
    10ea:	3c d6       	rcall	.+3192   	; 0x1d64 <xTaskCreate>
    10ec:	04 e0       	ldi	r16, 0x04	; 4
    10ee:	20 e0       	ldi	r18, 0x00	; 0
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	40 e0       	ldi	r20, 0x00	; 0
    10f4:	51 e0       	ldi	r21, 0x01	; 1
    10f6:	68 e8       	ldi	r22, 0x88	; 136
    10f8:	72 e0       	ldi	r23, 0x02	; 2
    10fa:	84 ec       	ldi	r24, 0xC4	; 196
    10fc:	93 e0       	ldi	r25, 0x03	; 3
    10fe:	32 d6       	rcall	.+3172   	; 0x1d64 <xTaskCreate>
    1100:	45 d7       	rcall	.+3722   	; 0x1f8c <vTaskStartScheduler>
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	0f 91       	pop	r16
    1108:	ff 90       	pop	r15
    110a:	ef 90       	pop	r14
    110c:	08 95       	ret

0000110e <setSpeed>:
    110e:	28 e3       	ldi	r18, 0x38	; 56
    1110:	38 2f       	mov	r19, r24
    1112:	32 9f       	mul	r19, r18
    1114:	c0 01       	movw	r24, r0
    1116:	93 1b       	sub	r25, r19
    1118:	11 24       	eor	r1, r1
    111a:	80 5e       	subi	r24, 0xE0	; 224
    111c:	91 4b       	sbci	r25, 0xB1	; 177
    111e:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1122:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    1126:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    112a:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    112e:	08 95       	ret

00001130 <motorTaak>:
	//uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
	bool turning = false;
	setSpeed(currentSpeed);
    1130:	84 e1       	ldi	r24, 0x14	; 20
    1132:	ed df       	rcall	.-38     	; 0x110e <setSpeed>
void motorTaak(){
	//uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
	bool turning = false;
    1134:	30 e0       	ldi	r19, 0x00	; 0

void motorTaak(){
	//uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
	bool riding = false;
    1136:	20 e0       	ldi	r18, 0x00	; 0
}

void motorTaak(){
	//uint8_t temp;
	int16_t targetSpeed = 50;
	int16_t currentSpeed = 20;
    1138:	c4 e1       	ldi	r28, 0x14	; 20
    113a:	d0 e0       	ldi	r29, 0x00	; 0
	}
}

void motorTaak(){
	//uint8_t temp;
	int16_t targetSpeed = 50;
    113c:	02 e3       	ldi	r16, 0x32	; 50
    113e:	10 e0       	ldi	r17, 0x00	; 0
				setSpeed(currentSpeed);
				vTaskDelay(25);
			}
			else{
				setSpeed(currentSpeed);
				vTaskDelay(25);
    1140:	b1 2c       	mov	r11, r1
    1142:	cc 24       	eor	r12, r12
    1144:	c3 94       	inc	r12
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    1146:	0f 2e       	mov	r0, r31
    1148:	f0 e3       	ldi	r31, 0x30	; 48
    114a:	df 2e       	mov	r13, r31
    114c:	f0 2d       	mov	r31, r0
			else{
				setSpeed(currentSpeed);
				vTaskDelay(25);
			}
		}
		watchdogMotor = 1;
    114e:	ee 24       	eor	r14, r14
    1150:	e3 94       	inc	r14
    1152:	f1 2c       	mov	r15, r1
	setSpeed(currentSpeed);

	while (1){
		/*if (xQueueReceive(motorCommand, &temp, 0)){
			UART_Transmit(temp);*/
			switch(ontvang){
    1154:	e0 91 5e 04 	lds	r30, 0x045E	; 0x80045e <ontvang>
    1158:	8e 2f       	mov	r24, r30
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	fc 01       	movw	r30, r24
    115e:	bb 97       	sbiw	r30, 0x2b	; 43
    1160:	ee 34       	cpi	r30, 0x4E	; 78
    1162:	f1 05       	cpc	r31, r1
    1164:	80 f5       	brcc	.+96     	; 0x11c6 <motorTaak+0x96>
    1166:	88 27       	eor	r24, r24
    1168:	ed 5c       	subi	r30, 0xCD	; 205
    116a:	fe 4f       	sbci	r31, 0xFE	; 254
    116c:	8f 4f       	sbci	r24, 0xFF	; 255
    116e:	0c 94 bd 12 	jmp	0x257a	; 0x257a <__tablejump2__>
				case 'w': // VOORUIT
					//currentSpeed = 0;
					setSpeed(currentSpeed);
    1172:	8c 2f       	mov	r24, r28
					riding = true;
					turning = false;
					motorStop();
    1174:	cc df       	rcall	.-104    	; 0x110e <setSpeed>
					motorVooruit();
    1176:	dc de       	rcall	.-584    	; 0xf30 <motorStop>
					break;
    1178:	ae de       	rcall	.-676    	; 0xed6 <motorVooruit>
				case 'a': // LINKS
					riding = true;
					turning = true;
					//if(currentSpeed <= 50) setSpeed(50);
					motorStop();
    117a:	66 c0       	rjmp	.+204    	; 0x1248 <motorTaak+0x118>
					motorLinks();
    117c:	d9 de       	rcall	.-590    	; 0xf30 <motorStop>
					break;
    117e:	c9 de       	rcall	.-622    	; 0xf12 <motorLinks>
				case 's': // ACHTERUIT
					//currentSpeed = 0;
					setSpeed(currentSpeed);
    1180:	5e c0       	rjmp	.+188    	; 0x123e <motorTaak+0x10e>
    1182:	8c 2f       	mov	r24, r28
    1184:	c4 df       	rcall	.-120    	; 0x110e <setSpeed>
					riding = true;
					turning = false;
					motorStop();
    1186:	d4 de       	rcall	.-600    	; 0xf30 <motorStop>
					motorAchteruit();
    1188:	97 de       	rcall	.-722    	; 0xeb8 <motorAchteruit>
					break;
				case 'd': // RECHTS
					riding = true;
					turning = true;
					if(currentSpeed <= 50) setSpeed(50);
    118a:	5e c0       	rjmp	.+188    	; 0x1248 <motorTaak+0x118>
    118c:	c3 33       	cpi	r28, 0x33	; 51
    118e:	d1 05       	cpc	r29, r1
    1190:	14 f4       	brge	.+4      	; 0x1196 <motorTaak+0x66>
    1192:	82 e3       	ldi	r24, 0x32	; 50
    1194:	bc df       	rcall	.-136    	; 0x110e <setSpeed>
					motorStop();
    1196:	cc de       	rcall	.-616    	; 0xf30 <motorStop>
    1198:	ad de       	rcall	.-678    	; 0xef4 <motorRechts>
					motorRechts();
    119a:	51 c0       	rjmp	.+162    	; 0x123e <motorTaak+0x10e>
    119c:	c9 de       	rcall	.-622    	; 0xf30 <motorStop>
					break;
    119e:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
				case 'X': // HARDE STOP
					riding = false;
					turning = false;
					motorStop();
    11a2:	3b 2d       	mov	r19, r11
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    11a4:	2b 2d       	mov	r18, r11
    11a6:	46 c0       	rjmp	.+140    	; 0x1234 <motorTaak+0x104>
					motorStop();
					motorRechts();
					break;
				case 'X': // HARDE STOP
					riding = false;
					turning = false;
    11a8:	06 5f       	subi	r16, 0xF6	; 246
					if(currentSpeed <= 50) setSpeed(50);
					motorStop();
					motorRechts();
					break;
				case 'X': // HARDE STOP
					riding = false;
    11aa:	1f 4f       	sbci	r17, 0xFF	; 255
    11ac:	05 36       	cpi	r16, 0x65	; 101
    11ae:	11 05       	cpc	r17, r1
    11b0:	54 f0       	brlt	.+20     	; 0x11c6 <motorTaak+0x96>
    11b2:	04 e6       	ldi	r16, 0x64	; 100
    11b4:	10 e0       	ldi	r17, 0x00	; 0
    11b6:	07 c0       	rjmp	.+14     	; 0x11c6 <motorTaak+0x96>
    11b8:	0a 50       	subi	r16, 0x0A	; 10
    11ba:	11 09       	sbc	r17, r1
    11bc:	04 31       	cpi	r16, 0x14	; 20
				case '+':
					targetSpeed += 10;
					if (targetSpeed > 100) targetSpeed = 100;
					break;
				case '-':
					targetSpeed -= 10;
    11be:	11 05       	cpc	r17, r1
					if (targetSpeed < 20) targetSpeed = 20;
    11c0:	14 f4       	brge	.+4      	; 0x11c6 <motorTaak+0x96>
    11c2:	04 e1       	ldi	r16, 0x14	; 20
    11c4:	10 e0       	ldi	r17, 0x00	; 0
    11c6:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    11ca:	22 23       	and	r18, r18
    11cc:	99 f1       	breq	.+102    	; 0x1234 <motorTaak+0x104>

		if (riding){
    11ce:	33 23       	and	r19, r19
    11d0:	29 f0       	breq	.+10     	; 0x11dc <motorTaak+0xac>
			if (turning){
    11d2:	82 e3       	ldi	r24, 0x32	; 50
    11d4:	9c df       	rcall	.-200    	; 0x110e <setSpeed>
				setSpeed(50);
    11d6:	3c 2d       	mov	r19, r12
    11d8:	2c 2d       	mov	r18, r12
    11da:	2c c0       	rjmp	.+88     	; 0x1234 <motorTaak+0x104>
    11dc:	c0 17       	cp	r28, r16
    11de:	d1 07       	cpc	r29, r17
			}
			else if (currentSpeed < targetSpeed){
    11e0:	7c f4       	brge	.+30     	; 0x1200 <motorTaak+0xd0>
    11e2:	22 96       	adiw	r28, 0x02	; 2
    11e4:	c5 36       	cpi	r28, 0x65	; 101
    11e6:	d1 05       	cpc	r29, r1
    11e8:	14 f0       	brlt	.+4      	; 0x11ee <motorTaak+0xbe>
    11ea:	c4 e6       	ldi	r28, 0x64	; 100
    11ec:	d0 e0       	ldi	r29, 0x00	; 0
    11ee:	8c 2f       	mov	r24, r28
    11f0:	8e df       	rcall	.-228    	; 0x110e <setSpeed>
				currentSpeed += 2;
				if (currentSpeed > 100) currentSpeed = 100;
				setSpeed(currentSpeed);
    11f2:	89 e1       	ldi	r24, 0x19	; 25
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskDelay>
				vTaskDelay(25);
    11fa:	3b 2d       	mov	r19, r11
    11fc:	2c 2d       	mov	r18, r12
    11fe:	1a c0       	rjmp	.+52     	; 0x1234 <motorTaak+0x104>
    1200:	0c 17       	cp	r16, r28
    1202:	1d 07       	cpc	r17, r29
			}
			else if(currentSpeed > targetSpeed){
    1204:	7c f4       	brge	.+30     	; 0x1224 <motorTaak+0xf4>
    1206:	22 97       	sbiw	r28, 0x02	; 2
    1208:	c4 31       	cpi	r28, 0x14	; 20
				currentSpeed -= 2;
    120a:	d1 05       	cpc	r29, r1
				if (currentSpeed < 20) currentSpeed = 20;
    120c:	14 f4       	brge	.+4      	; 0x1212 <motorTaak+0xe2>
    120e:	c4 e1       	ldi	r28, 0x14	; 20
    1210:	d0 e0       	ldi	r29, 0x00	; 0
    1212:	8c 2f       	mov	r24, r28
				setSpeed(currentSpeed);
    1214:	7c df       	rcall	.-264    	; 0x110e <setSpeed>
    1216:	89 e1       	ldi	r24, 0x19	; 25
    1218:	90 e0       	ldi	r25, 0x00	; 0
				vTaskDelay(25);
    121a:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskDelay>
    121e:	3b 2d       	mov	r19, r11
    1220:	2c 2d       	mov	r18, r12
    1222:	08 c0       	rjmp	.+16     	; 0x1234 <motorTaak+0x104>
    1224:	8c 2f       	mov	r24, r28
    1226:	73 df       	rcall	.-282    	; 0x110e <setSpeed>
			}
			else{
				setSpeed(currentSpeed);
    1228:	89 e1       	ldi	r24, 0x19	; 25
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskDelay>
				vTaskDelay(25);
    1230:	3b 2d       	mov	r19, r11
    1232:	2c 2d       	mov	r18, r12
    1234:	f0 92 4d 04 	sts	0x044D, r15	; 0x80044d <watchdogMotor+0x1>
    1238:	e0 92 4c 04 	sts	0x044C, r14	; 0x80044c <watchdogMotor>
			}
		}
		watchdogMotor = 1;
    123c:	8b cf       	rjmp	.-234    	; 0x1154 <motorTaak+0x24>
    123e:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
	}
    1242:	c7 cf       	rjmp	.-114    	; 0x11d2 <motorTaak+0xa2>
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    1244:	04 e1       	ldi	r16, 0x14	; 20
    1246:	10 e0       	ldi	r17, 0x00	; 0
    1248:	d0 92 5e 04 	sts	0x045E, r13	; 0x80045e <ontvang>
					motorStop();
					break;
				case 'x': // ZACHTE STOP
					riding = true;
					turning = false;
					targetSpeed = 20;
    124c:	c7 cf       	rjmp	.-114    	; 0x11dc <motorTaak+0xac>

0000124e <pxPortInitialiseStack>:
				default:
					//nothing
					break;	
				
			}
			ontvang = '0';
    124e:	31 e1       	ldi	r19, 0x11	; 17
    1250:	fc 01       	movw	r30, r24
    1252:	30 83       	st	Z, r19

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
    1254:	31 97       	sbiw	r30, 0x01	; 1
    1256:	22 e2       	ldi	r18, 0x22	; 34
    1258:	20 83       	st	Z, r18
    125a:	31 97       	sbiw	r30, 0x01	; 1
    125c:	a3 e3       	ldi	r26, 0x33	; 51
    125e:	a0 83       	st	Z, r26
    1260:	31 97       	sbiw	r30, 0x01	; 1
    1262:	60 83       	st	Z, r22
    1264:	31 97       	sbiw	r30, 0x01	; 1
    1266:	70 83       	st	Z, r23
    1268:	31 97       	sbiw	r30, 0x01	; 1
    126a:	10 82       	st	Z, r1
    126c:	31 97       	sbiw	r30, 0x01	; 1
    126e:	10 82       	st	Z, r1
    1270:	31 97       	sbiw	r30, 0x01	; 1
    1272:	60 e8       	ldi	r22, 0x80	; 128
    1274:	60 83       	st	Z, r22
    1276:	31 97       	sbiw	r30, 0x01	; 1
    1278:	10 82       	st	Z, r1
    127a:	31 97       	sbiw	r30, 0x01	; 1
    127c:	10 82       	st	Z, r1
    127e:	31 97       	sbiw	r30, 0x01	; 1
    1280:	10 82       	st	Z, r1
    1282:	31 97       	sbiw	r30, 0x01	; 1
    1284:	62 e0       	ldi	r22, 0x02	; 2
    1286:	60 83       	st	Z, r22
    1288:	31 97       	sbiw	r30, 0x01	; 1
    128a:	63 e0       	ldi	r22, 0x03	; 3
    128c:	60 83       	st	Z, r22
    128e:	31 97       	sbiw	r30, 0x01	; 1
    1290:	64 e0       	ldi	r22, 0x04	; 4
    1292:	60 83       	st	Z, r22
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	65 e0       	ldi	r22, 0x05	; 5
    1298:	60 83       	st	Z, r22
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	66 e0       	ldi	r22, 0x06	; 6
    129e:	60 83       	st	Z, r22
    12a0:	31 97       	sbiw	r30, 0x01	; 1
    12a2:	67 e0       	ldi	r22, 0x07	; 7
    12a4:	60 83       	st	Z, r22
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	68 e0       	ldi	r22, 0x08	; 8
    12aa:	60 83       	st	Z, r22
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	69 e0       	ldi	r22, 0x09	; 9
    12b0:	60 83       	st	Z, r22
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	60 e1       	ldi	r22, 0x10	; 16
    12b6:	60 83       	st	Z, r22
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	30 83       	st	Z, r19
    12bc:	31 97       	sbiw	r30, 0x01	; 1
    12be:	32 e1       	ldi	r19, 0x12	; 18
    12c0:	30 83       	st	Z, r19
    12c2:	31 97       	sbiw	r30, 0x01	; 1
    12c4:	33 e1       	ldi	r19, 0x13	; 19
    12c6:	30 83       	st	Z, r19
    12c8:	31 97       	sbiw	r30, 0x01	; 1
    12ca:	34 e1       	ldi	r19, 0x14	; 20
    12cc:	30 83       	st	Z, r19
    12ce:	31 97       	sbiw	r30, 0x01	; 1
    12d0:	35 e1       	ldi	r19, 0x15	; 21
    12d2:	30 83       	st	Z, r19
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	36 e1       	ldi	r19, 0x16	; 22
    12d8:	30 83       	st	Z, r19
    12da:	31 97       	sbiw	r30, 0x01	; 1
    12dc:	37 e1       	ldi	r19, 0x17	; 23
    12de:	30 83       	st	Z, r19
    12e0:	31 97       	sbiw	r30, 0x01	; 1
    12e2:	38 e1       	ldi	r19, 0x18	; 24
    12e4:	30 83       	st	Z, r19
    12e6:	31 97       	sbiw	r30, 0x01	; 1
    12e8:	39 e1       	ldi	r19, 0x19	; 25
    12ea:	30 83       	st	Z, r19
    12ec:	31 97       	sbiw	r30, 0x01	; 1
    12ee:	30 e2       	ldi	r19, 0x20	; 32
    12f0:	30 83       	st	Z, r19
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	31 e2       	ldi	r19, 0x21	; 33
    12f6:	30 83       	st	Z, r19
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	20 83       	st	Z, r18
    12fc:	31 97       	sbiw	r30, 0x01	; 1
    12fe:	23 e2       	ldi	r18, 0x23	; 35
    1300:	20 83       	st	Z, r18
    1302:	31 97       	sbiw	r30, 0x01	; 1
    1304:	40 83       	st	Z, r20
    1306:	31 97       	sbiw	r30, 0x01	; 1
    1308:	50 83       	st	Z, r21
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	26 e2       	ldi	r18, 0x26	; 38
    130e:	20 83       	st	Z, r18
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	27 e2       	ldi	r18, 0x27	; 39
    1314:	20 83       	st	Z, r18
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	28 e2       	ldi	r18, 0x28	; 40
    131a:	20 83       	st	Z, r18
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	29 e2       	ldi	r18, 0x29	; 41
    1320:	20 83       	st	Z, r18
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	20 e3       	ldi	r18, 0x30	; 48
    1326:	20 83       	st	Z, r18
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	21 e3       	ldi	r18, 0x31	; 49
    132c:	20 83       	st	Z, r18
    132e:	89 97       	sbiw	r24, 0x29	; 41
    1330:	08 95       	ret

00001332 <xPortStartScheduler>:
    1332:	88 ec       	ldi	r24, 0xC8	; 200
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	90 93 6e 04 	sts	0x046E, r25	; 0x80046e <portTickRateHz+0x1>
    133a:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <portTickRateHz>
    133e:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    1342:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
    1346:	8d e4       	ldi	r24, 0x4D	; 77
    1348:	87 bd       	out	0x27, r24	; 39
    134a:	82 e0       	ldi	r24, 0x02	; 2
    134c:	84 bd       	out	0x24, r24	; 36
    134e:	85 e0       	ldi	r24, 0x05	; 5
    1350:	85 bd       	out	0x25, r24	; 37
    1352:	ee e6       	ldi	r30, 0x6E	; 110
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	80 81       	ld	r24, Z
    1358:	82 60       	ori	r24, 0x02	; 2
    135a:	80 83       	st	Z, r24
    135c:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1360:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1364:	cd 91       	ld	r28, X+
    1366:	cd bf       	out	0x3d, r28	; 61
    1368:	dd 91       	ld	r29, X+
    136a:	de bf       	out	0x3e, r29	; 62
    136c:	ff 91       	pop	r31
    136e:	ef 91       	pop	r30
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	bf 91       	pop	r27
    1376:	af 91       	pop	r26
    1378:	9f 91       	pop	r25
    137a:	8f 91       	pop	r24
    137c:	7f 91       	pop	r23
    137e:	6f 91       	pop	r22
    1380:	5f 91       	pop	r21
    1382:	4f 91       	pop	r20
    1384:	3f 91       	pop	r19
    1386:	2f 91       	pop	r18
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	df 90       	pop	r13
    1392:	cf 90       	pop	r12
    1394:	bf 90       	pop	r11
    1396:	af 90       	pop	r10
    1398:	9f 90       	pop	r9
    139a:	8f 90       	pop	r8
    139c:	7f 90       	pop	r7
    139e:	6f 90       	pop	r6
    13a0:	5f 90       	pop	r5
    13a2:	4f 90       	pop	r4
    13a4:	3f 90       	pop	r3
    13a6:	2f 90       	pop	r2
    13a8:	1f 90       	pop	r1
    13aa:	0f 90       	pop	r0
    13ac:	0c be       	out	0x3c, r0	; 60
    13ae:	0f 90       	pop	r0
    13b0:	0b be       	out	0x3b, r0	; 59
    13b2:	0f 90       	pop	r0
    13b4:	0f be       	out	0x3f, r0	; 63
    13b6:	0f 90       	pop	r0
    13b8:	08 95       	ret
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	08 95       	ret

000013be <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13be:	0f 92       	push	r0
    13c0:	0f b6       	in	r0, 0x3f	; 63
    13c2:	f8 94       	cli
    13c4:	0f 92       	push	r0
    13c6:	0b b6       	in	r0, 0x3b	; 59
    13c8:	0f 92       	push	r0
    13ca:	0c b6       	in	r0, 0x3c	; 60
    13cc:	0f 92       	push	r0
    13ce:	1f 92       	push	r1
    13d0:	11 24       	eor	r1, r1
    13d2:	2f 92       	push	r2
    13d4:	3f 92       	push	r3
    13d6:	4f 92       	push	r4
    13d8:	5f 92       	push	r5
    13da:	6f 92       	push	r6
    13dc:	7f 92       	push	r7
    13de:	8f 92       	push	r8
    13e0:	9f 92       	push	r9
    13e2:	af 92       	push	r10
    13e4:	bf 92       	push	r11
    13e6:	cf 92       	push	r12
    13e8:	df 92       	push	r13
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	2f 93       	push	r18
    13f4:	3f 93       	push	r19
    13f6:	4f 93       	push	r20
    13f8:	5f 93       	push	r21
    13fa:	6f 93       	push	r22
    13fc:	7f 93       	push	r23
    13fe:	8f 93       	push	r24
    1400:	9f 93       	push	r25
    1402:	af 93       	push	r26
    1404:	bf 93       	push	r27
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	ef 93       	push	r30
    140c:	ff 93       	push	r31
    140e:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1412:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1416:	0d b6       	in	r0, 0x3d	; 61
    1418:	0d 92       	st	X+, r0
    141a:	0e b6       	in	r0, 0x3e	; 62
    141c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    141e:	2a d7       	rcall	.+3668   	; 0x2274 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1420:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    1424:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1428:	cd 91       	ld	r28, X+
    142a:	cd bf       	out	0x3d, r28	; 61
    142c:	dd 91       	ld	r29, X+
    142e:	de bf       	out	0x3e, r29	; 62
    1430:	ff 91       	pop	r31
    1432:	ef 91       	pop	r30
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    1438:	bf 91       	pop	r27
    143a:	af 91       	pop	r26
    143c:	9f 91       	pop	r25
    143e:	8f 91       	pop	r24
    1440:	7f 91       	pop	r23
    1442:	6f 91       	pop	r22
    1444:	5f 91       	pop	r21
    1446:	4f 91       	pop	r20
    1448:	3f 91       	pop	r19
    144a:	2f 91       	pop	r18
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	ff 90       	pop	r15
    1452:	ef 90       	pop	r14
    1454:	df 90       	pop	r13
    1456:	cf 90       	pop	r12
    1458:	bf 90       	pop	r11
    145a:	af 90       	pop	r10
    145c:	9f 90       	pop	r9
    145e:	8f 90       	pop	r8
    1460:	7f 90       	pop	r7
    1462:	6f 90       	pop	r6
    1464:	5f 90       	pop	r5
    1466:	4f 90       	pop	r4
    1468:	3f 90       	pop	r3
    146a:	2f 90       	pop	r2
    146c:	1f 90       	pop	r1
    146e:	0f 90       	pop	r0
    1470:	0c be       	out	0x3c, r0	; 60
    1472:	0f 90       	pop	r0
    1474:	0b be       	out	0x3b, r0	; 59
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    147c:	08 95       	ret

0000147e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    147e:	0f 92       	push	r0
    1480:	0f b6       	in	r0, 0x3f	; 63
    1482:	f8 94       	cli
    1484:	0f 92       	push	r0
    1486:	0b b6       	in	r0, 0x3b	; 59
    1488:	0f 92       	push	r0
    148a:	0c b6       	in	r0, 0x3c	; 60
    148c:	0f 92       	push	r0
    148e:	1f 92       	push	r1
    1490:	11 24       	eor	r1, r1
    1492:	2f 92       	push	r2
    1494:	3f 92       	push	r3
    1496:	4f 92       	push	r4
    1498:	5f 92       	push	r5
    149a:	6f 92       	push	r6
    149c:	7f 92       	push	r7
    149e:	8f 92       	push	r8
    14a0:	9f 92       	push	r9
    14a2:	af 92       	push	r10
    14a4:	bf 92       	push	r11
    14a6:	cf 92       	push	r12
    14a8:	df 92       	push	r13
    14aa:	ef 92       	push	r14
    14ac:	ff 92       	push	r15
    14ae:	0f 93       	push	r16
    14b0:	1f 93       	push	r17
    14b2:	2f 93       	push	r18
    14b4:	3f 93       	push	r19
    14b6:	4f 93       	push	r20
    14b8:	5f 93       	push	r21
    14ba:	6f 93       	push	r22
    14bc:	7f 93       	push	r23
    14be:	8f 93       	push	r24
    14c0:	9f 93       	push	r25
    14c2:	af 93       	push	r26
    14c4:	bf 93       	push	r27
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	ef 93       	push	r30
    14cc:	ff 93       	push	r31
    14ce:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    14d2:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    14d6:	0d b6       	in	r0, 0x3d	; 61
    14d8:	0d 92       	st	X+, r0
    14da:	0e b6       	in	r0, 0x3e	; 62
    14dc:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    14de:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    14e0:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <ticksRemainingInSec>
    14e4:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <ticksRemainingInSec+0x1>
    14e8:	01 97       	sbiw	r24, 0x01	; 1
    14ea:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    14ee:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
    14f2:	89 2b       	or	r24, r25
    14f4:	51 f4       	brne	.+20     	; 0x150a <vPortYieldFromTick+0x8c>
	{
		system_tick();
    14f6:	0e 94 dd 01 	call	0x3ba	; 0x3ba <system_tick>
		ticksRemainingInSec = portTickRateHz;
    14fa:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <portTickRateHz>
    14fe:	90 91 6e 04 	lds	r25, 0x046E	; 0x80046e <portTickRateHz+0x1>
    1502:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <ticksRemainingInSec+0x1>
    1506:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    150a:	6e d5       	rcall	.+2780   	; 0x1fe8 <xTaskIncrementTick>
    150c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    150e:	b2 d6       	rcall	.+3428   	; 0x2274 <vTaskSwitchContext>
    1510:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    1514:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1518:	cd 91       	ld	r28, X+
    151a:	cd bf       	out	0x3d, r28	; 61
    151c:	dd 91       	ld	r29, X+
    151e:	de bf       	out	0x3e, r29	; 62
    1520:	ff 91       	pop	r31
    1522:	ef 91       	pop	r30
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	bf 91       	pop	r27
    152a:	af 91       	pop	r26
    152c:	9f 91       	pop	r25
    152e:	8f 91       	pop	r24
    1530:	7f 91       	pop	r23
    1532:	6f 91       	pop	r22
    1534:	5f 91       	pop	r21
    1536:	4f 91       	pop	r20
    1538:	3f 91       	pop	r19
    153a:	2f 91       	pop	r18
    153c:	1f 91       	pop	r17
    153e:	0f 91       	pop	r16
    1540:	ff 90       	pop	r15
    1542:	ef 90       	pop	r14
    1544:	df 90       	pop	r13
    1546:	cf 90       	pop	r12
    1548:	bf 90       	pop	r11
    154a:	af 90       	pop	r10
    154c:	9f 90       	pop	r9
    154e:	8f 90       	pop	r8
    1550:	7f 90       	pop	r7
    1552:	6f 90       	pop	r6
    1554:	5f 90       	pop	r5
    1556:	4f 90       	pop	r4
    1558:	3f 90       	pop	r3
    155a:	2f 90       	pop	r2
    155c:	1f 90       	pop	r1
    155e:	0f 90       	pop	r0
    1560:	0c be       	out	0x3c, r0	; 60
    1562:	0f 90       	pop	r0
    1564:	0b be       	out	0x3b, r0	; 59
    1566:	0f 90       	pop	r0
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	0f 90       	pop	r0
    156c:	08 95       	ret

0000156e <__vector_21>:

	__asm__ __volatile__ ( "ret" );
    156e:	87 df       	rcall	.-242    	; 0x147e <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    1570:	18 95       	reti

00001572 <prvCopyDataToQueue>:
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
    1572:	0f 93       	push	r16
    1574:	1f 93       	push	r17
    1576:	cf 93       	push	r28
    1578:	df 93       	push	r29
    157a:	ec 01       	movw	r28, r24
    157c:	04 2f       	mov	r16, r20
    157e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1580:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1582:	41 11       	cpse	r20, r1
    1584:	0b c0       	rjmp	.+22     	; 0x159c <prvCopyDataToQueue+0x2a>
    1586:	88 81       	ld	r24, Y
    1588:	99 81       	ldd	r25, Y+1	; 0x01
    158a:	89 2b       	or	r24, r25
    158c:	09 f0       	breq	.+2      	; 0x1590 <prvCopyDataToQueue+0x1e>
    158e:	41 c0       	rjmp	.+130    	; 0x1612 <prvCopyDataToQueue+0xa0>
    1590:	8a 81       	ldd	r24, Y+2	; 0x02
    1592:	9b 81       	ldd	r25, Y+3	; 0x03
    1594:	90 d7       	rcall	.+3872   	; 0x24b6 <xTaskPriorityDisinherit>
    1596:	1b 82       	std	Y+3, r1	; 0x03
    1598:	1a 82       	std	Y+2, r1	; 0x02
    159a:	42 c0       	rjmp	.+132    	; 0x1620 <prvCopyDataToQueue+0xae>
    159c:	01 11       	cpse	r16, r1
    159e:	17 c0       	rjmp	.+46     	; 0x15ce <prvCopyDataToQueue+0x5c>
    15a0:	50 e0       	ldi	r21, 0x00	; 0
    15a2:	8c 81       	ldd	r24, Y+4	; 0x04
    15a4:	9d 81       	ldd	r25, Y+5	; 0x05
    15a6:	0e 94 ff 13 	call	0x27fe	; 0x27fe <memcpy>
    15aa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15ac:	8c 81       	ldd	r24, Y+4	; 0x04
    15ae:	9d 81       	ldd	r25, Y+5	; 0x05
    15b0:	82 0f       	add	r24, r18
    15b2:	91 1d       	adc	r25, r1
    15b4:	9d 83       	std	Y+5, r25	; 0x05
    15b6:	8c 83       	std	Y+4, r24	; 0x04
    15b8:	2a 81       	ldd	r18, Y+2	; 0x02
    15ba:	3b 81       	ldd	r19, Y+3	; 0x03
    15bc:	82 17       	cp	r24, r18
    15be:	93 07       	cpc	r25, r19
    15c0:	50 f1       	brcs	.+84     	; 0x1616 <prvCopyDataToQueue+0xa4>
    15c2:	88 81       	ld	r24, Y
    15c4:	99 81       	ldd	r25, Y+1	; 0x01
    15c6:	9d 83       	std	Y+5, r25	; 0x05
    15c8:	8c 83       	std	Y+4, r24	; 0x04
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	29 c0       	rjmp	.+82     	; 0x1620 <prvCopyDataToQueue+0xae>
    15ce:	50 e0       	ldi	r21, 0x00	; 0
    15d0:	8e 81       	ldd	r24, Y+6	; 0x06
    15d2:	9f 81       	ldd	r25, Y+7	; 0x07
    15d4:	0e 94 ff 13 	call	0x27fe	; 0x27fe <memcpy>
    15d8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	91 95       	neg	r25
    15de:	81 95       	neg	r24
    15e0:	91 09       	sbc	r25, r1
    15e2:	2e 81       	ldd	r18, Y+6	; 0x06
    15e4:	3f 81       	ldd	r19, Y+7	; 0x07
    15e6:	28 0f       	add	r18, r24
    15e8:	39 1f       	adc	r19, r25
    15ea:	3f 83       	std	Y+7, r19	; 0x07
    15ec:	2e 83       	std	Y+6, r18	; 0x06
    15ee:	48 81       	ld	r20, Y
    15f0:	59 81       	ldd	r21, Y+1	; 0x01
    15f2:	24 17       	cp	r18, r20
    15f4:	35 07       	cpc	r19, r21
    15f6:	30 f4       	brcc	.+12     	; 0x1604 <prvCopyDataToQueue+0x92>
    15f8:	2a 81       	ldd	r18, Y+2	; 0x02
    15fa:	3b 81       	ldd	r19, Y+3	; 0x03
    15fc:	82 0f       	add	r24, r18
    15fe:	93 1f       	adc	r25, r19
    1600:	9f 83       	std	Y+7, r25	; 0x07
    1602:	8e 83       	std	Y+6, r24	; 0x06
    1604:	02 30       	cpi	r16, 0x02	; 2
    1606:	49 f4       	brne	.+18     	; 0x161a <prvCopyDataToQueue+0xa8>
    1608:	11 23       	and	r17, r17
    160a:	49 f0       	breq	.+18     	; 0x161e <prvCopyDataToQueue+0xac>
    160c:	11 50       	subi	r17, 0x01	; 1
    160e:	80 e0       	ldi	r24, 0x00	; 0
    1610:	07 c0       	rjmp	.+14     	; 0x1620 <prvCopyDataToQueue+0xae>
    1612:	80 e0       	ldi	r24, 0x00	; 0
    1614:	05 c0       	rjmp	.+10     	; 0x1620 <prvCopyDataToQueue+0xae>
    1616:	80 e0       	ldi	r24, 0x00	; 0
    1618:	03 c0       	rjmp	.+6      	; 0x1620 <prvCopyDataToQueue+0xae>
    161a:	80 e0       	ldi	r24, 0x00	; 0
    161c:	01 c0       	rjmp	.+2      	; 0x1620 <prvCopyDataToQueue+0xae>
    161e:	80 e0       	ldi	r24, 0x00	; 0
    1620:	1f 5f       	subi	r17, 0xFF	; 255
    1622:	1a 8f       	std	Y+26, r17	; 0x1a
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	08 95       	ret

0000162e <prvUnlockQueue>:
    162e:	ef 92       	push	r14
    1630:	ff 92       	push	r15
    1632:	0f 93       	push	r16
    1634:	1f 93       	push	r17
    1636:	cf 93       	push	r28
    1638:	8c 01       	movw	r16, r24
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	0f 92       	push	r0
    1640:	fc 01       	movw	r30, r24
    1642:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1644:	1c 16       	cp	r1, r28
    1646:	9c f4       	brge	.+38     	; 0x166e <prvUnlockQueue+0x40>
    1648:	81 89       	ldd	r24, Z+17	; 0x11
    164a:	81 11       	cpse	r24, r1
    164c:	06 c0       	rjmp	.+12     	; 0x165a <prvUnlockQueue+0x2c>
    164e:	0f c0       	rjmp	.+30     	; 0x166e <prvUnlockQueue+0x40>
    1650:	f8 01       	movw	r30, r16
    1652:	81 89       	ldd	r24, Z+17	; 0x11
    1654:	81 11       	cpse	r24, r1
    1656:	05 c0       	rjmp	.+10     	; 0x1662 <prvUnlockQueue+0x34>
    1658:	0a c0       	rjmp	.+20     	; 0x166e <prvUnlockQueue+0x40>
    165a:	78 01       	movw	r14, r16
    165c:	f1 e1       	ldi	r31, 0x11	; 17
    165e:	ef 0e       	add	r14, r31
    1660:	f1 1c       	adc	r15, r1
    1662:	c7 01       	movw	r24, r14
    1664:	99 d6       	rcall	.+3378   	; 0x2398 <xTaskRemoveFromEventList>
    1666:	81 11       	cpse	r24, r1
    1668:	22 d7       	rcall	.+3652   	; 0x24ae <vTaskMissedYield>
    166a:	c1 50       	subi	r28, 0x01	; 1
    166c:	89 f7       	brne	.-30     	; 0x1650 <prvUnlockQueue+0x22>
    166e:	8f ef       	ldi	r24, 0xFF	; 255
    1670:	f8 01       	movw	r30, r16
    1672:	86 8f       	std	Z+30, r24	; 0x1e
    1674:	0f 90       	pop	r0
    1676:	0f be       	out	0x3f, r0	; 63
    1678:	0f b6       	in	r0, 0x3f	; 63
    167a:	f8 94       	cli
    167c:	0f 92       	push	r0
    167e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1680:	1c 16       	cp	r1, r28
    1682:	9c f4       	brge	.+38     	; 0x16aa <prvUnlockQueue+0x7c>
    1684:	80 85       	ldd	r24, Z+8	; 0x08
    1686:	81 11       	cpse	r24, r1
    1688:	06 c0       	rjmp	.+12     	; 0x1696 <prvUnlockQueue+0x68>
    168a:	0f c0       	rjmp	.+30     	; 0x16aa <prvUnlockQueue+0x7c>
    168c:	f8 01       	movw	r30, r16
    168e:	80 85       	ldd	r24, Z+8	; 0x08
    1690:	81 11       	cpse	r24, r1
    1692:	05 c0       	rjmp	.+10     	; 0x169e <prvUnlockQueue+0x70>
    1694:	0a c0       	rjmp	.+20     	; 0x16aa <prvUnlockQueue+0x7c>
    1696:	78 01       	movw	r14, r16
    1698:	f8 e0       	ldi	r31, 0x08	; 8
    169a:	ef 0e       	add	r14, r31
    169c:	f1 1c       	adc	r15, r1
    169e:	c7 01       	movw	r24, r14
    16a0:	7b d6       	rcall	.+3318   	; 0x2398 <xTaskRemoveFromEventList>
    16a2:	81 11       	cpse	r24, r1
    16a4:	04 d7       	rcall	.+3592   	; 0x24ae <vTaskMissedYield>
    16a6:	c1 50       	subi	r28, 0x01	; 1
    16a8:	89 f7       	brne	.-30     	; 0x168c <prvUnlockQueue+0x5e>
    16aa:	8f ef       	ldi	r24, 0xFF	; 255
    16ac:	f8 01       	movw	r30, r16
    16ae:	85 8f       	std	Z+29, r24	; 0x1d
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63
    16b4:	cf 91       	pop	r28
    16b6:	1f 91       	pop	r17
    16b8:	0f 91       	pop	r16
    16ba:	ff 90       	pop	r15
    16bc:	ef 90       	pop	r14
    16be:	08 95       	ret

000016c0 <xQueueGenericReset>:
    16c0:	cf 93       	push	r28
    16c2:	df 93       	push	r29
    16c4:	ec 01       	movw	r28, r24
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	f8 94       	cli
    16ca:	0f 92       	push	r0
    16cc:	48 81       	ld	r20, Y
    16ce:	59 81       	ldd	r21, Y+1	; 0x01
    16d0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    16d6:	72 9f       	mul	r23, r18
    16d8:	c0 01       	movw	r24, r0
    16da:	73 9f       	mul	r23, r19
    16dc:	90 0d       	add	r25, r0
    16de:	11 24       	eor	r1, r1
    16e0:	fa 01       	movw	r30, r20
    16e2:	e8 0f       	add	r30, r24
    16e4:	f9 1f       	adc	r31, r25
    16e6:	fb 83       	std	Y+3, r31	; 0x03
    16e8:	ea 83       	std	Y+2, r30	; 0x02
    16ea:	1a 8e       	std	Y+26, r1	; 0x1a
    16ec:	5d 83       	std	Y+5, r21	; 0x05
    16ee:	4c 83       	std	Y+4, r20	; 0x04
    16f0:	82 1b       	sub	r24, r18
    16f2:	93 0b       	sbc	r25, r19
    16f4:	84 0f       	add	r24, r20
    16f6:	95 1f       	adc	r25, r21
    16f8:	9f 83       	std	Y+7, r25	; 0x07
    16fa:	8e 83       	std	Y+6, r24	; 0x06
    16fc:	8f ef       	ldi	r24, 0xFF	; 255
    16fe:	8d 8f       	std	Y+29, r24	; 0x1d
    1700:	8e 8f       	std	Y+30, r24	; 0x1e
    1702:	61 11       	cpse	r22, r1
    1704:	0a c0       	rjmp	.+20     	; 0x171a <xQueueGenericReset+0x5a>
    1706:	88 85       	ldd	r24, Y+8	; 0x08
    1708:	88 23       	and	r24, r24
    170a:	79 f0       	breq	.+30     	; 0x172a <xQueueGenericReset+0x6a>
    170c:	ce 01       	movw	r24, r28
    170e:	08 96       	adiw	r24, 0x08	; 8
    1710:	43 d6       	rcall	.+3206   	; 0x2398 <xTaskRemoveFromEventList>
    1712:	88 23       	and	r24, r24
    1714:	51 f0       	breq	.+20     	; 0x172a <xQueueGenericReset+0x6a>
    1716:	53 de       	rcall	.-858    	; 0x13be <vPortYield>
    1718:	08 c0       	rjmp	.+16     	; 0x172a <xQueueGenericReset+0x6a>
    171a:	ce 01       	movw	r24, r28
    171c:	08 96       	adiw	r24, 0x08	; 8
    171e:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1722:	ce 01       	movw	r24, r28
    1724:	41 96       	adiw	r24, 0x11	; 17
    1726:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	81 e0       	ldi	r24, 0x01	; 1
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	08 95       	ret

00001736 <xQueueGenericCreate>:
    1736:	0f 93       	push	r16
    1738:	1f 93       	push	r17
    173a:	cf 93       	push	r28
    173c:	df 93       	push	r29
    173e:	08 2f       	mov	r16, r24
    1740:	16 2f       	mov	r17, r22
    1742:	66 23       	and	r22, r22
    1744:	b9 f0       	breq	.+46     	; 0x1774 <xQueueGenericCreate+0x3e>
    1746:	86 9f       	mul	r24, r22
    1748:	c0 01       	movw	r24, r0
    174a:	11 24       	eor	r1, r1
    174c:	4f 96       	adiw	r24, 0x1f	; 31
    174e:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <pvPortMalloc>
    1752:	ec 01       	movw	r28, r24
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	39 f4       	brne	.+14     	; 0x1766 <xQueueGenericCreate+0x30>
    1758:	14 c0       	rjmp	.+40     	; 0x1782 <xQueueGenericCreate+0x4c>
    175a:	0b 8f       	std	Y+27, r16	; 0x1b
    175c:	1c 8f       	std	Y+28, r17	; 0x1c
    175e:	61 e0       	ldi	r22, 0x01	; 1
    1760:	ce 01       	movw	r24, r28
    1762:	ae df       	rcall	.-164    	; 0x16c0 <xQueueGenericReset>
    1764:	0e c0       	rjmp	.+28     	; 0x1782 <xQueueGenericCreate+0x4c>
    1766:	4f 96       	adiw	r24, 0x1f	; 31
    1768:	99 83       	std	Y+1, r25	; 0x01
    176a:	88 83       	st	Y, r24
    176c:	f6 cf       	rjmp	.-20     	; 0x175a <xQueueGenericCreate+0x24>
    176e:	d9 83       	std	Y+1, r29	; 0x01
    1770:	c8 83       	st	Y, r28
    1772:	f3 cf       	rjmp	.-26     	; 0x175a <xQueueGenericCreate+0x24>
    1774:	8f e1       	ldi	r24, 0x1F	; 31
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <pvPortMalloc>
    177c:	ec 01       	movw	r28, r24
    177e:	89 2b       	or	r24, r25
    1780:	b1 f7       	brne	.-20     	; 0x176e <xQueueGenericCreate+0x38>
    1782:	ce 01       	movw	r24, r28
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	1f 91       	pop	r17
    178a:	0f 91       	pop	r16
    178c:	08 95       	ret

0000178e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    178e:	9f 92       	push	r9
    1790:	af 92       	push	r10
    1792:	bf 92       	push	r11
    1794:	cf 92       	push	r12
    1796:	df 92       	push	r13
    1798:	ef 92       	push	r14
    179a:	ff 92       	push	r15
    179c:	0f 93       	push	r16
    179e:	1f 93       	push	r17
    17a0:	cf 93       	push	r28
    17a2:	df 93       	push	r29
    17a4:	00 d0       	rcall	.+0      	; 0x17a6 <xQueueGenericSend+0x18>
    17a6:	1f 92       	push	r1
    17a8:	1f 92       	push	r1
    17aa:	cd b7       	in	r28, 0x3d	; 61
    17ac:	de b7       	in	r29, 0x3e	; 62
    17ae:	8c 01       	movw	r16, r24
    17b0:	6b 01       	movw	r12, r22
    17b2:	5d 83       	std	Y+5, r21	; 0x05
    17b4:	4c 83       	std	Y+4, r20	; 0x04
    17b6:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    17b8:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17ba:	99 24       	eor	r9, r9
    17bc:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17be:	7c 01       	movw	r14, r24
    17c0:	88 e0       	ldi	r24, 0x08	; 8
    17c2:	e8 0e       	add	r14, r24
    17c4:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	f8 94       	cli
    17ca:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17cc:	f8 01       	movw	r30, r16
    17ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    17d0:	83 8d       	ldd	r24, Z+27	; 0x1b
    17d2:	98 17       	cp	r25, r24
    17d4:	18 f0       	brcs	.+6      	; 0x17dc <xQueueGenericSend+0x4e>
    17d6:	f2 e0       	ldi	r31, 0x02	; 2
    17d8:	af 12       	cpse	r10, r31
    17da:	15 c0       	rjmp	.+42     	; 0x1806 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17dc:	4a 2d       	mov	r20, r10
    17de:	b6 01       	movw	r22, r12
    17e0:	c8 01       	movw	r24, r16
    17e2:	c7 de       	rcall	.-626    	; 0x1572 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17e4:	f8 01       	movw	r30, r16
    17e6:	91 89       	ldd	r25, Z+17	; 0x11
    17e8:	99 23       	and	r25, r25
    17ea:	39 f0       	breq	.+14     	; 0x17fa <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ec:	c8 01       	movw	r24, r16
    17ee:	41 96       	adiw	r24, 0x11	; 17
    17f0:	d3 d5       	rcall	.+2982   	; 0x2398 <xTaskRemoveFromEventList>
    17f2:	88 23       	and	r24, r24
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    17f4:	21 f0       	breq	.+8      	; 0x17fe <xQueueGenericSend+0x70>
    17f6:	e3 dd       	rcall	.-1082   	; 0x13be <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    17f8:	02 c0       	rjmp	.+4      	; 0x17fe <xQueueGenericSend+0x70>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    17fa:	81 11       	cpse	r24, r1
    17fc:	e0 dd       	rcall	.-1088   	; 0x13be <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    17fe:	0f 90       	pop	r0
    1800:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	45 c0       	rjmp	.+138    	; 0x1890 <xQueueGenericSend+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1806:	8c 81       	ldd	r24, Y+4	; 0x04
    1808:	9d 81       	ldd	r25, Y+5	; 0x05
    180a:	89 2b       	or	r24, r25
    180c:	21 f4       	brne	.+8      	; 0x1816 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    180e:	0f 90       	pop	r0
    1810:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1812:	80 e0       	ldi	r24, 0x00	; 0
    1814:	3d c0       	rjmp	.+122    	; 0x1890 <xQueueGenericSend+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    1816:	b1 10       	cpse	r11, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1818:	04 c0       	rjmp	.+8      	; 0x1822 <xQueueGenericSend+0x94>
    181a:	ce 01       	movw	r24, r28
    181c:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    181e:	04 d6       	rcall	.+3080   	; 0x2428 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1820:	b9 2c       	mov	r11, r9
    1822:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1824:	0f be       	out	0x3f, r0	; 63
    1826:	da d3       	rcall	.+1972   	; 0x1fdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1828:	0f b6       	in	r0, 0x3f	; 63
    182a:	f8 94       	cli
    182c:	0f 92       	push	r0
    182e:	f8 01       	movw	r30, r16
    1830:	85 8d       	ldd	r24, Z+29	; 0x1d
    1832:	8f 3f       	cpi	r24, 0xFF	; 255
    1834:	09 f4       	brne	.+2      	; 0x1838 <xQueueGenericSend+0xaa>
    1836:	15 8e       	std	Z+29, r1	; 0x1d
    1838:	f8 01       	movw	r30, r16
    183a:	86 8d       	ldd	r24, Z+30	; 0x1e
    183c:	8f 3f       	cpi	r24, 0xFF	; 255
    183e:	09 f4       	brne	.+2      	; 0x1842 <xQueueGenericSend+0xb4>
    1840:	16 8e       	std	Z+30, r1	; 0x1e
    1842:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1844:	0f be       	out	0x3f, r0	; 63
    1846:	be 01       	movw	r22, r28
    1848:	6c 5f       	subi	r22, 0xFC	; 252
    184a:	7f 4f       	sbci	r23, 0xFF	; 255
    184c:	ce 01       	movw	r24, r28
    184e:	01 96       	adiw	r24, 0x01	; 1
    1850:	f6 d5       	rcall	.+3052   	; 0x243e <xTaskCheckForTimeOut>
    1852:	81 11       	cpse	r24, r1
    1854:	19 c0       	rjmp	.+50     	; 0x1888 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    185c:	f8 01       	movw	r30, r16
    185e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1860:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1862:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1864:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1866:	98 13       	cpse	r25, r24
    1868:	0b c0       	rjmp	.+22     	; 0x1880 <xQueueGenericSend+0xf2>
    186a:	6c 81       	ldd	r22, Y+4	; 0x04
    186c:	7d 81       	ldd	r23, Y+5	; 0x05
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    186e:	c7 01       	movw	r24, r14
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1870:	82 d5       	rcall	.+2820   	; 0x2376 <vTaskPlaceOnEventList>
    1872:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    1874:	dc de       	rcall	.-584    	; 0x162e <prvUnlockQueue>
    1876:	72 d4       	rcall	.+2276   	; 0x215c <xTaskResumeAll>
    1878:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    187a:	a5 cf       	rjmp	.-182    	; 0x17c6 <xQueueGenericSend+0x38>
    187c:	a0 dd       	rcall	.-1216   	; 0x13be <vPortYield>
    187e:	a3 cf       	rjmp	.-186    	; 0x17c6 <xQueueGenericSend+0x38>
				( void ) xTaskResumeAll();
    1880:	c8 01       	movw	r24, r16
    1882:	d5 de       	rcall	.-598    	; 0x162e <prvUnlockQueue>
    1884:	6b d4       	rcall	.+2262   	; 0x215c <xTaskResumeAll>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1886:	9f cf       	rjmp	.-194    	; 0x17c6 <xQueueGenericSend+0x38>
    1888:	c8 01       	movw	r24, r16
    188a:	d1 de       	rcall	.-606    	; 0x162e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    188c:	67 d4       	rcall	.+2254   	; 0x215c <xTaskResumeAll>
    188e:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1890:	0f 90       	pop	r0
		}
	}
}
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	df 91       	pop	r29
    189c:	cf 91       	pop	r28
    189e:	1f 91       	pop	r17
    18a0:	0f 91       	pop	r16
    18a2:	ff 90       	pop	r15
    18a4:	ef 90       	pop	r14
    18a6:	df 90       	pop	r13
    18a8:	cf 90       	pop	r12
    18aa:	bf 90       	pop	r11
    18ac:	af 90       	pop	r10
    18ae:	9f 90       	pop	r9
    18b0:	08 95       	ret

000018b2 <__vector_26>:
    18b2:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    18b4:	0f 92       	push	r0
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	0f 92       	push	r0
    18ba:	11 24       	eor	r1, r1
    18bc:	0b b6       	in	r0, 0x3b	; 59
    18be:	0f 92       	push	r0
    18c0:	2f 93       	push	r18
    18c2:	8f 93       	push	r24
    18c4:	9f 93       	push	r25
    18c6:	af 93       	push	r26
    18c8:	bf 93       	push	r27
    18ca:	ef 93       	push	r30
    18cc:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18ce:	0f b6       	in	r0, 0x3f	; 63
    18d0:	f8 94       	cli
    18d2:	0f 92       	push	r0
	{
	    count = buffer->count;
    18d4:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <xSerialPort+0xd>
    18d8:	90 91 7f 04 	lds	r25, 0x047F	; 0x80047f <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    18dc:	0f 90       	pop	r0
    18de:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    18e0:	89 2b       	or	r24, r25
    18e2:	31 f4       	brne	.+12     	; 0x18f0 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    18e4:	e1 ec       	ldi	r30, 0xC1	; 193
    18e6:	f0 e0       	ldi	r31, 0x00	; 0
    18e8:	80 81       	ld	r24, Z
    18ea:	8f 7d       	andi	r24, 0xDF	; 223
    18ec:	80 83       	st	Z, r24
    18ee:	1c c0       	rjmp	.+56     	; 0x1928 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    18f0:	ee e7       	ldi	r30, 0x7E	; 126
    18f2:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    18f4:	a4 81       	ldd	r26, Z+4	; 0x04
    18f6:	b5 81       	ldd	r27, Z+5	; 0x05
    18f8:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    18fa:	b5 83       	std	Z+5, r27	; 0x05
    18fc:	a4 83       	std	Z+4, r26	; 0x04
    18fe:	80 85       	ldd	r24, Z+8	; 0x08
    1900:	91 85       	ldd	r25, Z+9	; 0x09
    1902:	a8 17       	cp	r26, r24
    1904:	b9 07       	cpc	r27, r25
    1906:	21 f4       	brne	.+8      	; 0x1910 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    1908:	86 81       	ldd	r24, Z+6	; 0x06
    190a:	97 81       	ldd	r25, Z+7	; 0x07
    190c:	95 83       	std	Z+5, r25	; 0x05
    190e:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	0f 92       	push	r0
	{
	    buffer->count--;
    1916:	80 81       	ld	r24, Z
    1918:	91 81       	ldd	r25, Z+1	; 0x01
    191a:	01 97       	sbiw	r24, 0x01	; 1
    191c:	91 83       	std	Z+1, r25	; 0x01
    191e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1920:	0f 90       	pop	r0
    1922:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1924:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    1928:	ff 91       	pop	r31
    192a:	ef 91       	pop	r30
    192c:	bf 91       	pop	r27
    192e:	af 91       	pop	r26
    1930:	9f 91       	pop	r25
    1932:	8f 91       	pop	r24
    1934:	2f 91       	pop	r18
    1936:	0f 90       	pop	r0
    1938:	0b be       	out	0x3b, r0	; 59
    193a:	0f 90       	pop	r0
    193c:	0f be       	out	0x3f, r0	; 63
    193e:	0f 90       	pop	r0
    1940:	1f 90       	pop	r1
    1942:	18 95       	reti

00001944 <__vector_37>:
//}
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    1944:	1f 92       	push	r1
    1946:	0f 92       	push	r0
    1948:	0f b6       	in	r0, 0x3f	; 63
    194a:	0f 92       	push	r0
    194c:	11 24       	eor	r1, r1
    194e:	0b b6       	in	r0, 0x3b	; 59
    1950:	0f 92       	push	r0
    1952:	2f 93       	push	r18
    1954:	8f 93       	push	r24
    1956:	9f 93       	push	r25
    1958:	af 93       	push	r26
    195a:	bf 93       	push	r27
    195c:	ef 93       	push	r30
    195e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	0f 92       	push	r0
	{
	    count = buffer->count;
    1966:	80 91 e4 04 	lds	r24, 0x04E4	; 0x8004e4 <xSerial1Port+0xd>
    196a:	90 91 e5 04 	lds	r25, 0x04E5	; 0x8004e5 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    196e:	0f 90       	pop	r0
    1970:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1972:	89 2b       	or	r24, r25
    1974:	31 f4       	brne	.+12     	; 0x1982 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1976:	e9 ec       	ldi	r30, 0xC9	; 201
    1978:	f0 e0       	ldi	r31, 0x00	; 0
    197a:	80 81       	ld	r24, Z
    197c:	8f 7d       	andi	r24, 0xDF	; 223
    197e:	80 83       	st	Z, r24
    1980:	1c c0       	rjmp	.+56     	; 0x19ba <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1982:	e4 ee       	ldi	r30, 0xE4	; 228
    1984:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1986:	a4 81       	ldd	r26, Z+4	; 0x04
    1988:	b5 81       	ldd	r27, Z+5	; 0x05
    198a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    198c:	b5 83       	std	Z+5, r27	; 0x05
    198e:	a4 83       	std	Z+4, r26	; 0x04
    1990:	80 85       	ldd	r24, Z+8	; 0x08
    1992:	91 85       	ldd	r25, Z+9	; 0x09
    1994:	a8 17       	cp	r26, r24
    1996:	b9 07       	cpc	r27, r25
    1998:	21 f4       	brne	.+8      	; 0x19a2 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    199a:	86 81       	ldd	r24, Z+6	; 0x06
    199c:	97 81       	ldd	r25, Z+7	; 0x07
    199e:	95 83       	std	Z+5, r25	; 0x05
    19a0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    19a2:	0f b6       	in	r0, 0x3f	; 63
    19a4:	f8 94       	cli
    19a6:	0f 92       	push	r0
	{
	    buffer->count--;
    19a8:	80 81       	ld	r24, Z
    19aa:	91 81       	ldd	r25, Z+1	; 0x01
    19ac:	01 97       	sbiw	r24, 0x01	; 1
    19ae:	91 83       	std	Z+1, r25	; 0x01
    19b0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    19b2:	0f 90       	pop	r0
    19b4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    19b6:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    19ba:	ff 91       	pop	r31
    19bc:	ef 91       	pop	r30
    19be:	bf 91       	pop	r27
    19c0:	af 91       	pop	r26
    19c2:	9f 91       	pop	r25
    19c4:	8f 91       	pop	r24
    19c6:	2f 91       	pop	r18
    19c8:	0f 90       	pop	r0
    19ca:	0b be       	out	0x3b, r0	; 59
    19cc:	0f 90       	pop	r0
    19ce:	0f be       	out	0x3f, r0	; 63
    19d0:	0f 90       	pop	r0
    19d2:	1f 90       	pop	r1
    19d4:	18 95       	reti

000019d6 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    19d6:	1f 92       	push	r1
    19d8:	0f 92       	push	r0
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	0f 92       	push	r0
    19de:	11 24       	eor	r1, r1
    19e0:	0b b6       	in	r0, 0x3b	; 59
    19e2:	0f 92       	push	r0
    19e4:	2f 93       	push	r18
    19e6:	3f 93       	push	r19
    19e8:	4f 93       	push	r20
    19ea:	8f 93       	push	r24
    19ec:	9f 93       	push	r25
    19ee:	af 93       	push	r26
    19f0:	bf 93       	push	r27
    19f2:	ef 93       	push	r30
    19f4:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    19f6:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    19fa:	8c 71       	andi	r24, 0x1C	; 28
    19fc:	71 f0       	breq	.+28     	; 0x1a1a <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    19fe:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1a02:	88 23       	and	r24, r24
    1a04:	0c f0       	brlt	.+2      	; 0x1a08 <__vector_51+0x32>
    1a06:	36 c0       	rjmp	.+108    	; 0x1a74 <__vector_51+0x9e>
    1a08:	a6 ed       	ldi	r26, 0xD6	; 214
    1a0a:	b0 e0       	ldi	r27, 0x00	; 0
    1a0c:	e0 ed       	ldi	r30, 0xD0	; 208
    1a0e:	f0 e0       	ldi	r31, 0x00	; 0
    1a10:	8c 91       	ld	r24, X
    1a12:	80 81       	ld	r24, Z
    1a14:	88 23       	and	r24, r24
    1a16:	e4 f3       	brlt	.-8      	; 0x1a10 <__vector_51+0x3a>
    1a18:	2d c0       	rjmp	.+90     	; 0x1a74 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    1a1a:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	f8 94       	cli
    1a22:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a24:	e3 e9       	ldi	r30, 0x93	; 147
    1a26:	f4 e0       	ldi	r31, 0x04	; 4
    1a28:	21 81       	ldd	r18, Z+1	; 0x01
    1a2a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1a2c:	0f 90       	pop	r0
    1a2e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    1a30:	83 85       	ldd	r24, Z+11	; 0x0b
    1a32:	94 85       	ldd	r25, Z+12	; 0x0c
    1a34:	28 17       	cp	r18, r24
    1a36:	39 07       	cpc	r19, r25
    1a38:	e9 f0       	breq	.+58     	; 0x1a74 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a3a:	e4 e9       	ldi	r30, 0x94	; 148
    1a3c:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1a3e:	a2 81       	ldd	r26, Z+2	; 0x02
    1a40:	b3 81       	ldd	r27, Z+3	; 0x03
    1a42:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1a44:	82 81       	ldd	r24, Z+2	; 0x02
    1a46:	93 81       	ldd	r25, Z+3	; 0x03
    1a48:	01 96       	adiw	r24, 0x01	; 1
    1a4a:	93 83       	std	Z+3, r25	; 0x03
    1a4c:	82 83       	std	Z+2, r24	; 0x02
    1a4e:	20 85       	ldd	r18, Z+8	; 0x08
    1a50:	31 85       	ldd	r19, Z+9	; 0x09
    1a52:	82 17       	cp	r24, r18
    1a54:	93 07       	cpc	r25, r19
    1a56:	21 f4       	brne	.+8      	; 0x1a60 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    1a58:	86 81       	ldd	r24, Z+6	; 0x06
    1a5a:	97 81       	ldd	r25, Z+7	; 0x07
    1a5c:	93 83       	std	Z+3, r25	; 0x03
    1a5e:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1a60:	0f b6       	in	r0, 0x3f	; 63
    1a62:	f8 94       	cli
    1a64:	0f 92       	push	r0
	{
	    buffer->count++;
    1a66:	80 81       	ld	r24, Z
    1a68:	91 81       	ldd	r25, Z+1	; 0x01
    1a6a:	01 96       	adiw	r24, 0x01	; 1
    1a6c:	91 83       	std	Z+1, r25	; 0x01
    1a6e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1a74:	ff 91       	pop	r31
    1a76:	ef 91       	pop	r30
    1a78:	bf 91       	pop	r27
    1a7a:	af 91       	pop	r26
    1a7c:	9f 91       	pop	r25
    1a7e:	8f 91       	pop	r24
    1a80:	4f 91       	pop	r20
    1a82:	3f 91       	pop	r19
    1a84:	2f 91       	pop	r18
    1a86:	0f 90       	pop	r0
    1a88:	0b be       	out	0x3b, r0	; 59
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	0f 90       	pop	r0
    1a90:	1f 90       	pop	r1
    1a92:	18 95       	reti

00001a94 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1a94:	1f 92       	push	r1
    1a96:	0f 92       	push	r0
    1a98:	0f b6       	in	r0, 0x3f	; 63
    1a9a:	0f 92       	push	r0
    1a9c:	11 24       	eor	r1, r1
    1a9e:	0b b6       	in	r0, 0x3b	; 59
    1aa0:	0f 92       	push	r0
    1aa2:	2f 93       	push	r18
    1aa4:	8f 93       	push	r24
    1aa6:	9f 93       	push	r25
    1aa8:	af 93       	push	r26
    1aaa:	bf 93       	push	r27
    1aac:	ef 93       	push	r30
    1aae:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	0f 92       	push	r0
	{
	    count = buffer->count;
    1ab6:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <xSerial2Port+0xd>
    1aba:	90 91 a1 04 	lds	r25, 0x04A1	; 0x8004a1 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1abe:	0f 90       	pop	r0
    1ac0:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1ac2:	89 2b       	or	r24, r25
    1ac4:	31 f4       	brne	.+12     	; 0x1ad2 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1ac6:	e1 ed       	ldi	r30, 0xD1	; 209
    1ac8:	f0 e0       	ldi	r31, 0x00	; 0
    1aca:	80 81       	ld	r24, Z
    1acc:	8f 7d       	andi	r24, 0xDF	; 223
    1ace:	80 83       	st	Z, r24
    1ad0:	1c c0       	rjmp	.+56     	; 0x1b0a <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1ad2:	e0 ea       	ldi	r30, 0xA0	; 160
    1ad4:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1ad6:	a4 81       	ldd	r26, Z+4	; 0x04
    1ad8:	b5 81       	ldd	r27, Z+5	; 0x05
    1ada:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1adc:	b5 83       	std	Z+5, r27	; 0x05
    1ade:	a4 83       	std	Z+4, r26	; 0x04
    1ae0:	80 85       	ldd	r24, Z+8	; 0x08
    1ae2:	91 85       	ldd	r25, Z+9	; 0x09
    1ae4:	a8 17       	cp	r26, r24
    1ae6:	b9 07       	cpc	r27, r25
    1ae8:	21 f4       	brne	.+8      	; 0x1af2 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    1aea:	86 81       	ldd	r24, Z+6	; 0x06
    1aec:	97 81       	ldd	r25, Z+7	; 0x07
    1aee:	95 83       	std	Z+5, r25	; 0x05
    1af0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	0f 92       	push	r0
	{
	    buffer->count--;
    1af8:	80 81       	ld	r24, Z
    1afa:	91 81       	ldd	r25, Z+1	; 0x01
    1afc:	01 97       	sbiw	r24, 0x01	; 1
    1afe:	91 83       	std	Z+1, r25	; 0x01
    1b00:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    1b06:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    1b0a:	ff 91       	pop	r31
    1b0c:	ef 91       	pop	r30
    1b0e:	bf 91       	pop	r27
    1b10:	af 91       	pop	r26
    1b12:	9f 91       	pop	r25
    1b14:	8f 91       	pop	r24
    1b16:	2f 91       	pop	r18
    1b18:	0f 90       	pop	r0
    1b1a:	0b be       	out	0x3b, r0	; 59
    1b1c:	0f 90       	pop	r0
    1b1e:	0f be       	out	0x3f, r0	; 63
    1b20:	0f 90       	pop	r0
    1b22:	1f 90       	pop	r1
    1b24:	18 95       	reti

00001b26 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    1b26:	1f 92       	push	r1
    1b28:	0f 92       	push	r0
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	0f 92       	push	r0
    1b2e:	11 24       	eor	r1, r1
    1b30:	0b b6       	in	r0, 0x3b	; 59
    1b32:	0f 92       	push	r0
    1b34:	2f 93       	push	r18
    1b36:	3f 93       	push	r19
    1b38:	4f 93       	push	r20
    1b3a:	8f 93       	push	r24
    1b3c:	9f 93       	push	r25
    1b3e:	af 93       	push	r26
    1b40:	bf 93       	push	r27
    1b42:	ef 93       	push	r30
    1b44:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    1b46:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1b4a:	8c 71       	andi	r24, 0x1C	; 28
    1b4c:	71 f0       	breq	.+28     	; 0x1b6a <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    1b4e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1b52:	88 23       	and	r24, r24
    1b54:	0c f0       	brlt	.+2      	; 0x1b58 <__vector_54+0x32>
    1b56:	36 c0       	rjmp	.+108    	; 0x1bc4 <__vector_54+0x9e>
    1b58:	a6 e3       	ldi	r26, 0x36	; 54
    1b5a:	b1 e0       	ldi	r27, 0x01	; 1
    1b5c:	e0 e3       	ldi	r30, 0x30	; 48
    1b5e:	f1 e0       	ldi	r31, 0x01	; 1
    1b60:	8c 91       	ld	r24, X
    1b62:	80 81       	ld	r24, Z
    1b64:	88 23       	and	r24, r24
    1b66:	e4 f3       	brlt	.-8      	; 0x1b60 <__vector_54+0x3a>
    1b68:	2d c0       	rjmp	.+90     	; 0x1bc4 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1b6a:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1b6e:	0f b6       	in	r0, 0x3f	; 63
    1b70:	f8 94       	cli
    1b72:	0f 92       	push	r0
	{
	    count = buffer->count;
    1b74:	e5 eb       	ldi	r30, 0xB5	; 181
    1b76:	f4 e0       	ldi	r31, 0x04	; 4
    1b78:	21 81       	ldd	r18, Z+1	; 0x01
    1b7a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1b7c:	0f 90       	pop	r0
    1b7e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1b80:	83 85       	ldd	r24, Z+11	; 0x0b
    1b82:	94 85       	ldd	r25, Z+12	; 0x0c
    1b84:	28 17       	cp	r18, r24
    1b86:	39 07       	cpc	r19, r25
    1b88:	e9 f0       	breq	.+58     	; 0x1bc4 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1b8a:	e6 eb       	ldi	r30, 0xB6	; 182
    1b8c:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1b8e:	a2 81       	ldd	r26, Z+2	; 0x02
    1b90:	b3 81       	ldd	r27, Z+3	; 0x03
    1b92:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1b94:	82 81       	ldd	r24, Z+2	; 0x02
    1b96:	93 81       	ldd	r25, Z+3	; 0x03
    1b98:	01 96       	adiw	r24, 0x01	; 1
    1b9a:	93 83       	std	Z+3, r25	; 0x03
    1b9c:	82 83       	std	Z+2, r24	; 0x02
    1b9e:	20 85       	ldd	r18, Z+8	; 0x08
    1ba0:	31 85       	ldd	r19, Z+9	; 0x09
    1ba2:	82 17       	cp	r24, r18
    1ba4:	93 07       	cpc	r25, r19
    1ba6:	21 f4       	brne	.+8      	; 0x1bb0 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1ba8:	86 81       	ldd	r24, Z+6	; 0x06
    1baa:	97 81       	ldd	r25, Z+7	; 0x07
    1bac:	93 83       	std	Z+3, r25	; 0x03
    1bae:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1bb0:	0f b6       	in	r0, 0x3f	; 63
    1bb2:	f8 94       	cli
    1bb4:	0f 92       	push	r0
	{
	    buffer->count++;
    1bb6:	80 81       	ld	r24, Z
    1bb8:	91 81       	ldd	r25, Z+1	; 0x01
    1bba:	01 96       	adiw	r24, 0x01	; 1
    1bbc:	91 83       	std	Z+1, r25	; 0x01
    1bbe:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1bc0:	0f 90       	pop	r0
    1bc2:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1bc4:	ff 91       	pop	r31
    1bc6:	ef 91       	pop	r30
    1bc8:	bf 91       	pop	r27
    1bca:	af 91       	pop	r26
    1bcc:	9f 91       	pop	r25
    1bce:	8f 91       	pop	r24
    1bd0:	4f 91       	pop	r20
    1bd2:	3f 91       	pop	r19
    1bd4:	2f 91       	pop	r18
    1bd6:	0f 90       	pop	r0
    1bd8:	0b be       	out	0x3b, r0	; 59
    1bda:	0f 90       	pop	r0
    1bdc:	0f be       	out	0x3f, r0	; 63
    1bde:	0f 90       	pop	r0
    1be0:	1f 90       	pop	r1
    1be2:	18 95       	reti

00001be4 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1be4:	1f 92       	push	r1
    1be6:	0f 92       	push	r0
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	0f 92       	push	r0
    1bec:	11 24       	eor	r1, r1
    1bee:	0b b6       	in	r0, 0x3b	; 59
    1bf0:	0f 92       	push	r0
    1bf2:	2f 93       	push	r18
    1bf4:	8f 93       	push	r24
    1bf6:	9f 93       	push	r25
    1bf8:	af 93       	push	r26
    1bfa:	bf 93       	push	r27
    1bfc:	ef 93       	push	r30
    1bfe:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1c00:	0f b6       	in	r0, 0x3f	; 63
    1c02:	f8 94       	cli
    1c04:	0f 92       	push	r0
	{
	    count = buffer->count;
    1c06:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <xSerial3Port+0xd>
    1c0a:	90 91 c3 04 	lds	r25, 0x04C3	; 0x8004c3 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1c12:	89 2b       	or	r24, r25
    1c14:	31 f4       	brne	.+12     	; 0x1c22 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1c16:	e1 e3       	ldi	r30, 0x31	; 49
    1c18:	f1 e0       	ldi	r31, 0x01	; 1
    1c1a:	80 81       	ld	r24, Z
    1c1c:	8f 7d       	andi	r24, 0xDF	; 223
    1c1e:	80 83       	st	Z, r24
    1c20:	1c c0       	rjmp	.+56     	; 0x1c5a <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1c22:	e2 ec       	ldi	r30, 0xC2	; 194
    1c24:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1c26:	a4 81       	ldd	r26, Z+4	; 0x04
    1c28:	b5 81       	ldd	r27, Z+5	; 0x05
    1c2a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1c2c:	b5 83       	std	Z+5, r27	; 0x05
    1c2e:	a4 83       	std	Z+4, r26	; 0x04
    1c30:	80 85       	ldd	r24, Z+8	; 0x08
    1c32:	91 85       	ldd	r25, Z+9	; 0x09
    1c34:	a8 17       	cp	r26, r24
    1c36:	b9 07       	cpc	r27, r25
    1c38:	21 f4       	brne	.+8      	; 0x1c42 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1c3a:	86 81       	ldd	r24, Z+6	; 0x06
    1c3c:	97 81       	ldd	r25, Z+7	; 0x07
    1c3e:	95 83       	std	Z+5, r25	; 0x05
    1c40:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1c42:	0f b6       	in	r0, 0x3f	; 63
    1c44:	f8 94       	cli
    1c46:	0f 92       	push	r0
	{
	    buffer->count--;
    1c48:	80 81       	ld	r24, Z
    1c4a:	91 81       	ldd	r25, Z+1	; 0x01
    1c4c:	01 97       	sbiw	r24, 0x01	; 1
    1c4e:	91 83       	std	Z+1, r25	; 0x01
    1c50:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1c52:	0f 90       	pop	r0
    1c54:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1c56:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1c5a:	ff 91       	pop	r31
    1c5c:	ef 91       	pop	r30
    1c5e:	bf 91       	pop	r27
    1c60:	af 91       	pop	r26
    1c62:	9f 91       	pop	r25
    1c64:	8f 91       	pop	r24
    1c66:	2f 91       	pop	r18
    1c68:	0f 90       	pop	r0
    1c6a:	0b be       	out	0x3b, r0	; 59
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	0f 90       	pop	r0
    1c72:	1f 90       	pop	r1
    1c74:	18 95       	reti

00001c76 <prvResetNextTaskUnblockTime>:
    1c76:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1c7a:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1c7e:	80 81       	ld	r24, Z
    1c80:	81 11       	cpse	r24, r1
    1c82:	07 c0       	rjmp	.+14     	; 0x1c92 <prvResetNextTaskUnblockTime+0x1c>
    1c84:	8f ef       	ldi	r24, 0xFF	; 255
    1c86:	9f ef       	ldi	r25, 0xFF	; 255
    1c88:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1c8c:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1c90:	08 95       	ret
    1c92:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1c96:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1c9a:	05 80       	ldd	r0, Z+5	; 0x05
    1c9c:	f6 81       	ldd	r31, Z+6	; 0x06
    1c9e:	e0 2d       	mov	r30, r0
    1ca0:	06 80       	ldd	r0, Z+6	; 0x06
    1ca2:	f7 81       	ldd	r31, Z+7	; 0x07
    1ca4:	e0 2d       	mov	r30, r0
    1ca6:	82 81       	ldd	r24, Z+2	; 0x02
    1ca8:	93 81       	ldd	r25, Z+3	; 0x03
    1caa:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1cae:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1cb2:	08 95       	ret

00001cb4 <prvAddCurrentTaskToDelayedList>:
    1cb4:	ff 92       	push	r15
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	ec 01       	movw	r28, r24
    1cc0:	f6 2e       	mov	r15, r22
    1cc2:	00 91 cd 02 	lds	r16, 0x02CD	; 0x8002cd <xTickCount>
    1cc6:	10 91 ce 02 	lds	r17, 0x02CE	; 0x8002ce <xTickCount+0x1>
    1cca:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    1cce:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1cd2:	02 96       	adiw	r24, 0x02	; 2
    1cd4:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    1cd8:	cf 3f       	cpi	r28, 0xFF	; 255
    1cda:	8f ef       	ldi	r24, 0xFF	; 255
    1cdc:	d8 07       	cpc	r29, r24
    1cde:	69 f4       	brne	.+26     	; 0x1cfa <prvAddCurrentTaskToDelayedList+0x46>
    1ce0:	ff 20       	and	r15, r15
    1ce2:	59 f0       	breq	.+22     	; 0x1cfa <prvAddCurrentTaskToDelayedList+0x46>
    1ce4:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1ce8:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1cec:	6e 5f       	subi	r22, 0xFE	; 254
    1cee:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf0:	80 ed       	ldi	r24, 0xD0	; 208
    1cf2:	92 e0       	ldi	r25, 0x02	; 2
    1cf4:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    1cf8:	2f c0       	rjmp	.+94     	; 0x1d58 <prvAddCurrentTaskToDelayedList+0xa4>
    1cfa:	c0 0f       	add	r28, r16
    1cfc:	d1 1f       	adc	r29, r17
    1cfe:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1d02:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d06:	d3 83       	std	Z+3, r29	; 0x03
    1d08:	c2 83       	std	Z+2, r28	; 0x02
    1d0a:	c0 17       	cp	r28, r16
    1d0c:	d1 07       	cpc	r29, r17
    1d0e:	68 f4       	brcc	.+26     	; 0x1d2a <prvAddCurrentTaskToDelayedList+0x76>
    1d10:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1d14:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d18:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <pxOverflowDelayedTaskList>
    1d1c:	90 91 ed 02 	lds	r25, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    1d20:	6e 5f       	subi	r22, 0xFE	; 254
    1d22:	7f 4f       	sbci	r23, 0xFF	; 255
    1d24:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsert>
    1d28:	17 c0       	rjmp	.+46     	; 0x1d58 <prvAddCurrentTaskToDelayedList+0xa4>
    1d2a:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    1d2e:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1d32:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    1d36:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    1d3a:	6e 5f       	subi	r22, 0xFE	; 254
    1d3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d3e:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsert>
    1d42:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
    1d46:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1d4a:	c8 17       	cp	r28, r24
    1d4c:	d9 07       	cpc	r29, r25
    1d4e:	20 f4       	brcc	.+8      	; 0x1d58 <prvAddCurrentTaskToDelayedList+0xa4>
    1d50:	d0 93 c6 02 	sts	0x02C6, r29	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1d54:	c0 93 c5 02 	sts	0x02C5, r28	; 0x8002c5 <xNextTaskUnblockTime>
    1d58:	df 91       	pop	r29
    1d5a:	cf 91       	pop	r28
    1d5c:	1f 91       	pop	r17
    1d5e:	0f 91       	pop	r16
    1d60:	ff 90       	pop	r15
    1d62:	08 95       	ret

00001d64 <xTaskCreate>:
    1d64:	4f 92       	push	r4
    1d66:	5f 92       	push	r5
    1d68:	6f 92       	push	r6
    1d6a:	7f 92       	push	r7
    1d6c:	8f 92       	push	r8
    1d6e:	9f 92       	push	r9
    1d70:	af 92       	push	r10
    1d72:	bf 92       	push	r11
    1d74:	cf 92       	push	r12
    1d76:	df 92       	push	r13
    1d78:	ef 92       	push	r14
    1d7a:	ff 92       	push	r15
    1d7c:	0f 93       	push	r16
    1d7e:	cf 93       	push	r28
    1d80:	df 93       	push	r29
    1d82:	4c 01       	movw	r8, r24
    1d84:	6b 01       	movw	r12, r22
    1d86:	5a 01       	movw	r10, r20
    1d88:	29 01       	movw	r4, r18
    1d8a:	ca 01       	movw	r24, r20
    1d8c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <pvPortMalloc>
    1d90:	3c 01       	movw	r6, r24
    1d92:	89 2b       	or	r24, r25
    1d94:	09 f4       	brne	.+2      	; 0x1d98 <xTaskCreate+0x34>
    1d96:	e9 c0       	rjmp	.+466    	; 0x1f6a <xTaskCreate+0x206>
    1d98:	88 e2       	ldi	r24, 0x28	; 40
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <pvPortMalloc>
    1da0:	ec 01       	movw	r28, r24
    1da2:	89 2b       	or	r24, r25
    1da4:	a9 f0       	breq	.+42     	; 0x1dd0 <xTaskCreate+0x6c>
    1da6:	78 8e       	std	Y+24, r7	; 0x18
    1da8:	6f 8a       	std	Y+23, r6	; 0x17
    1daa:	a5 01       	movw	r20, r10
    1dac:	65 ea       	ldi	r22, 0xA5	; 165
    1dae:	70 e0       	ldi	r23, 0x00	; 0
    1db0:	c3 01       	movw	r24, r6
    1db2:	2e d5       	rcall	.+2652   	; 0x2810 <memset>
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	a8 1a       	sub	r10, r24
    1db8:	b1 08       	sbc	r11, r1
    1dba:	8f 89       	ldd	r24, Y+23	; 0x17
    1dbc:	98 8d       	ldd	r25, Y+24	; 0x18
    1dbe:	a8 0e       	add	r10, r24
    1dc0:	b9 1e       	adc	r11, r25
    1dc2:	d6 01       	movw	r26, r12
    1dc4:	8c 91       	ld	r24, X
    1dc6:	89 8f       	std	Y+25, r24	; 0x19
    1dc8:	8c 91       	ld	r24, X
    1dca:	81 11       	cpse	r24, r1
    1dcc:	05 c0       	rjmp	.+10     	; 0x1dd8 <xTaskCreate+0x74>
    1dce:	18 c0       	rjmp	.+48     	; 0x1e00 <xTaskCreate+0x9c>
    1dd0:	c3 01       	movw	r24, r6
    1dd2:	0e 94 0b 02 	call	0x416	; 0x416 <vPortFree>
    1dd6:	c9 c0       	rjmp	.+402    	; 0x1f6a <xTaskCreate+0x206>
    1dd8:	ae 01       	movw	r20, r28
    1dda:	46 5e       	subi	r20, 0xE6	; 230
    1ddc:	5f 4f       	sbci	r21, 0xFF	; 255
    1dde:	f6 01       	movw	r30, r12
    1de0:	31 96       	adiw	r30, 0x01	; 1
    1de2:	b8 e0       	ldi	r27, 0x08	; 8
    1de4:	cb 0e       	add	r12, r27
    1de6:	d1 1c       	adc	r13, r1
    1de8:	cf 01       	movw	r24, r30
    1dea:	21 91       	ld	r18, Z+
    1dec:	da 01       	movw	r26, r20
    1dee:	2d 93       	st	X+, r18
    1df0:	ad 01       	movw	r20, r26
    1df2:	dc 01       	movw	r26, r24
    1df4:	8c 91       	ld	r24, X
    1df6:	88 23       	and	r24, r24
    1df8:	19 f0       	breq	.+6      	; 0x1e00 <xTaskCreate+0x9c>
    1dfa:	ec 15       	cp	r30, r12
    1dfc:	fd 05       	cpc	r31, r13
    1dfe:	a1 f7       	brne	.-24     	; 0x1de8 <xTaskCreate+0x84>
    1e00:	18 a2       	std	Y+32, r1	; 0x20
    1e02:	04 30       	cpi	r16, 0x04	; 4
    1e04:	08 f0       	brcs	.+2      	; 0x1e08 <xTaskCreate+0xa4>
    1e06:	03 e0       	ldi	r16, 0x03	; 3
    1e08:	0e 8b       	std	Y+22, r16	; 0x16
    1e0a:	09 a3       	std	Y+33, r16	; 0x21
    1e0c:	1a a2       	std	Y+34, r1	; 0x22
    1e0e:	6e 01       	movw	r12, r28
    1e10:	b2 e0       	ldi	r27, 0x02	; 2
    1e12:	cb 0e       	add	r12, r27
    1e14:	d1 1c       	adc	r13, r1
    1e16:	c6 01       	movw	r24, r12
    1e18:	0e 94 48 03 	call	0x690	; 0x690 <vListInitialiseItem>
    1e1c:	ce 01       	movw	r24, r28
    1e1e:	0c 96       	adiw	r24, 0x0c	; 12
    1e20:	0e 94 48 03 	call	0x690	; 0x690 <vListInitialiseItem>
    1e24:	d9 87       	std	Y+9, r29	; 0x09
    1e26:	c8 87       	std	Y+8, r28	; 0x08
    1e28:	84 e0       	ldi	r24, 0x04	; 4
    1e2a:	90 e0       	ldi	r25, 0x00	; 0
    1e2c:	80 1b       	sub	r24, r16
    1e2e:	91 09       	sbc	r25, r1
    1e30:	9d 87       	std	Y+13, r25	; 0x0d
    1e32:	8c 87       	std	Y+12, r24	; 0x0c
    1e34:	db 8b       	std	Y+19, r29	; 0x13
    1e36:	ca 8b       	std	Y+18, r28	; 0x12
    1e38:	1b a2       	std	Y+35, r1	; 0x23
    1e3a:	1c a2       	std	Y+36, r1	; 0x24
    1e3c:	1d a2       	std	Y+37, r1	; 0x25
    1e3e:	1e a2       	std	Y+38, r1	; 0x26
    1e40:	1f a2       	std	Y+39, r1	; 0x27
    1e42:	a2 01       	movw	r20, r4
    1e44:	b4 01       	movw	r22, r8
    1e46:	c5 01       	movw	r24, r10
    1e48:	02 da       	rcall	.-3068   	; 0x124e <pxPortInitialiseStack>
    1e4a:	99 83       	std	Y+1, r25	; 0x01
    1e4c:	88 83       	st	Y, r24
    1e4e:	e1 14       	cp	r14, r1
    1e50:	f1 04       	cpc	r15, r1
    1e52:	19 f0       	breq	.+6      	; 0x1e5a <xTaskCreate+0xf6>
    1e54:	f7 01       	movw	r30, r14
    1e56:	d1 83       	std	Z+1, r29	; 0x01
    1e58:	c0 83       	st	Z, r28
    1e5a:	0f b6       	in	r0, 0x3f	; 63
    1e5c:	f8 94       	cli
    1e5e:	0f 92       	push	r0
    1e60:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxCurrentNumberOfTasks>
    1e6a:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    1e6e:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1e72:	89 2b       	or	r24, r25
    1e74:	d1 f5       	brne	.+116    	; 0x1eea <xTaskCreate+0x186>
    1e76:	d0 93 27 03 	sts	0x0327, r29	; 0x800327 <pxCurrentTCB+0x1>
    1e7a:	c0 93 26 03 	sts	0x0326, r28	; 0x800326 <pxCurrentTCB>
    1e7e:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    1e82:	81 30       	cpi	r24, 0x01	; 1
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <xTaskCreate+0x124>
    1e86:	41 c0       	rjmp	.+130    	; 0x1f0a <xTaskCreate+0x1a6>
    1e88:	82 e0       	ldi	r24, 0x02	; 2
    1e8a:	93 e0       	ldi	r25, 0x03	; 3
    1e8c:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1e90:	8b e0       	ldi	r24, 0x0B	; 11
    1e92:	93 e0       	ldi	r25, 0x03	; 3
    1e94:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1e98:	84 e1       	ldi	r24, 0x14	; 20
    1e9a:	93 e0       	ldi	r25, 0x03	; 3
    1e9c:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1ea0:	8d e1       	ldi	r24, 0x1D	; 29
    1ea2:	93 e0       	ldi	r25, 0x03	; 3
    1ea4:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1ea8:	89 ef       	ldi	r24, 0xF9	; 249
    1eaa:	92 e0       	ldi	r25, 0x02	; 2
    1eac:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1eb0:	80 ef       	ldi	r24, 0xF0	; 240
    1eb2:	92 e0       	ldi	r25, 0x02	; 2
    1eb4:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1eb8:	83 ee       	ldi	r24, 0xE3	; 227
    1eba:	92 e0       	ldi	r25, 0x02	; 2
    1ebc:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1ec0:	8a ed       	ldi	r24, 0xDA	; 218
    1ec2:	92 e0       	ldi	r25, 0x02	; 2
    1ec4:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1ec8:	80 ed       	ldi	r24, 0xD0	; 208
    1eca:	92 e0       	ldi	r25, 0x02	; 2
    1ecc:	0e 94 3a 03 	call	0x674	; 0x674 <vListInitialise>
    1ed0:	89 ef       	ldi	r24, 0xF9	; 249
    1ed2:	92 e0       	ldi	r25, 0x02	; 2
    1ed4:	90 93 ef 02 	sts	0x02EF, r25	; 0x8002ef <pxDelayedTaskList+0x1>
    1ed8:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <pxDelayedTaskList>
    1edc:	80 ef       	ldi	r24, 0xF0	; 240
    1ede:	92 e0       	ldi	r25, 0x02	; 2
    1ee0:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    1ee4:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
    1ee8:	10 c0       	rjmp	.+32     	; 0x1f0a <xTaskCreate+0x1a6>
    1eea:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <xSchedulerRunning>
    1eee:	81 11       	cpse	r24, r1
    1ef0:	0c c0       	rjmp	.+24     	; 0x1f0a <xTaskCreate+0x1a6>
    1ef2:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1ef6:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1efa:	96 89       	ldd	r25, Z+22	; 0x16
    1efc:	8e 89       	ldd	r24, Y+22	; 0x16
    1efe:	89 17       	cp	r24, r25
    1f00:	20 f0       	brcs	.+8      	; 0x1f0a <xTaskCreate+0x1a6>
    1f02:	d0 93 27 03 	sts	0x0327, r29	; 0x800327 <pxCurrentTCB+0x1>
    1f06:	c0 93 26 03 	sts	0x0326, r28	; 0x800326 <pxCurrentTCB>
    1f0a:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxTaskNumber>
    1f0e:	8f 5f       	subi	r24, 0xFF	; 255
    1f10:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <uxTaskNumber>
    1f14:	8e 89       	ldd	r24, Y+22	; 0x16
    1f16:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    1f1a:	98 17       	cp	r25, r24
    1f1c:	10 f4       	brcc	.+4      	; 0x1f22 <xTaskCreate+0x1be>
    1f1e:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	9c 01       	movw	r18, r24
    1f26:	22 0f       	add	r18, r18
    1f28:	33 1f       	adc	r19, r19
    1f2a:	22 0f       	add	r18, r18
    1f2c:	33 1f       	adc	r19, r19
    1f2e:	22 0f       	add	r18, r18
    1f30:	33 1f       	adc	r19, r19
    1f32:	82 0f       	add	r24, r18
    1f34:	93 1f       	adc	r25, r19
    1f36:	b6 01       	movw	r22, r12
    1f38:	8e 5f       	subi	r24, 0xFE	; 254
    1f3a:	9c 4f       	sbci	r25, 0xFC	; 252
    1f3c:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    1f40:	0f 90       	pop	r0
    1f42:	0f be       	out	0x3f, r0	; 63
    1f44:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <xSchedulerRunning>
    1f48:	88 23       	and	r24, r24
    1f4a:	59 f0       	breq	.+22     	; 0x1f62 <xTaskCreate+0x1fe>
    1f4c:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    1f50:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    1f54:	96 89       	ldd	r25, Z+22	; 0x16
    1f56:	8e 89       	ldd	r24, Y+22	; 0x16
    1f58:	98 17       	cp	r25, r24
    1f5a:	28 f4       	brcc	.+10     	; 0x1f66 <xTaskCreate+0x202>
    1f5c:	30 da       	rcall	.-2976   	; 0x13be <vPortYield>
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	05 c0       	rjmp	.+10     	; 0x1f6c <xTaskCreate+0x208>
    1f62:	81 e0       	ldi	r24, 0x01	; 1
    1f64:	03 c0       	rjmp	.+6      	; 0x1f6c <xTaskCreate+0x208>
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	01 c0       	rjmp	.+2      	; 0x1f6c <xTaskCreate+0x208>
    1f6a:	8f ef       	ldi	r24, 0xFF	; 255
    1f6c:	df 91       	pop	r29
    1f6e:	cf 91       	pop	r28
    1f70:	0f 91       	pop	r16
    1f72:	ff 90       	pop	r15
    1f74:	ef 90       	pop	r14
    1f76:	df 90       	pop	r13
    1f78:	cf 90       	pop	r12
    1f7a:	bf 90       	pop	r11
    1f7c:	af 90       	pop	r10
    1f7e:	9f 90       	pop	r9
    1f80:	8f 90       	pop	r8
    1f82:	7f 90       	pop	r7
    1f84:	6f 90       	pop	r6
    1f86:	5f 90       	pop	r5
    1f88:	4f 90       	pop	r4
    1f8a:	08 95       	ret

00001f8c <vTaskStartScheduler>:
    1f8c:	ef 92       	push	r14
    1f8e:	ff 92       	push	r15
    1f90:	0f 93       	push	r16
    1f92:	0f 2e       	mov	r0, r31
    1f94:	f3 ec       	ldi	r31, 0xC3	; 195
    1f96:	ef 2e       	mov	r14, r31
    1f98:	f2 e0       	ldi	r31, 0x02	; 2
    1f9a:	ff 2e       	mov	r15, r31
    1f9c:	f0 2d       	mov	r31, r0
    1f9e:	00 e0       	ldi	r16, 0x00	; 0
    1fa0:	20 e0       	ldi	r18, 0x00	; 0
    1fa2:	30 e0       	ldi	r19, 0x00	; 0
    1fa4:	45 e5       	ldi	r20, 0x55	; 85
    1fa6:	50 e0       	ldi	r21, 0x00	; 0
    1fa8:	67 e9       	ldi	r22, 0x97	; 151
    1faa:	72 e0       	ldi	r23, 0x02	; 2
    1fac:	81 e8       	ldi	r24, 0x81	; 129
    1fae:	91 e0       	ldi	r25, 0x01	; 1
    1fb0:	d9 de       	rcall	.-590    	; 0x1d64 <xTaskCreate>
    1fb2:	81 30       	cpi	r24, 0x01	; 1
    1fb4:	79 f4       	brne	.+30     	; 0x1fd4 <vTaskStartScheduler+0x48>
    1fb6:	f8 94       	cli
    1fb8:	8f ef       	ldi	r24, 0xFF	; 255
    1fba:	9f ef       	ldi	r25, 0xFF	; 255
    1fbc:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    1fc0:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <xSchedulerRunning>
    1fca:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <xTickCount+0x1>
    1fce:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <xTickCount>
    1fd2:	af d9       	rcall	.-3234   	; 0x1332 <xPortStartScheduler>
    1fd4:	0f 91       	pop	r16
    1fd6:	ff 90       	pop	r15
    1fd8:	ef 90       	pop	r14
    1fda:	08 95       	ret

00001fdc <vTaskSuspendAll>:
    1fdc:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    1fe0:	8f 5f       	subi	r24, 0xFF	; 255
    1fe2:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
    1fe6:	08 95       	ret

00001fe8 <xTaskIncrementTick>:
    1fe8:	cf 92       	push	r12
    1fea:	df 92       	push	r13
    1fec:	ef 92       	push	r14
    1fee:	ff 92       	push	r15
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    1ffc:	81 11       	cpse	r24, r1
    1ffe:	98 c0       	rjmp	.+304    	; 0x2130 <xTaskIncrementTick+0x148>
    2000:	e0 90 cd 02 	lds	r14, 0x02CD	; 0x8002cd <xTickCount>
    2004:	f0 90 ce 02 	lds	r15, 0x02CE	; 0x8002ce <xTickCount+0x1>
    2008:	8f ef       	ldi	r24, 0xFF	; 255
    200a:	e8 1a       	sub	r14, r24
    200c:	f8 0a       	sbc	r15, r24
    200e:	f0 92 ce 02 	sts	0x02CE, r15	; 0x8002ce <xTickCount+0x1>
    2012:	e0 92 cd 02 	sts	0x02CD, r14	; 0x8002cd <xTickCount>
    2016:	e1 14       	cp	r14, r1
    2018:	f1 04       	cpc	r15, r1
    201a:	b1 f4       	brne	.+44     	; 0x2048 <xTaskIncrementTick+0x60>
    201c:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    2020:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    2024:	20 91 ec 02 	lds	r18, 0x02EC	; 0x8002ec <pxOverflowDelayedTaskList>
    2028:	30 91 ed 02 	lds	r19, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    202c:	30 93 ef 02 	sts	0x02EF, r19	; 0x8002ef <pxDelayedTaskList+0x1>
    2030:	20 93 ee 02 	sts	0x02EE, r18	; 0x8002ee <pxDelayedTaskList>
    2034:	90 93 ed 02 	sts	0x02ED, r25	; 0x8002ed <pxOverflowDelayedTaskList+0x1>
    2038:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <pxOverflowDelayedTaskList>
    203c:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    2040:	8f 5f       	subi	r24, 0xFF	; 255
    2042:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNumOfOverflows>
    2046:	17 de       	rcall	.-978    	; 0x1c76 <prvResetNextTaskUnblockTime>
    2048:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
    204c:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    2050:	e8 16       	cp	r14, r24
    2052:	f9 06       	cpc	r15, r25
    2054:	10 f4       	brcc	.+4      	; 0x205a <xTaskIncrementTick+0x72>
    2056:	d1 2c       	mov	r13, r1
    2058:	53 c0       	rjmp	.+166    	; 0x2100 <xTaskIncrementTick+0x118>
    205a:	d1 2c       	mov	r13, r1
    205c:	cc 24       	eor	r12, r12
    205e:	c3 94       	inc	r12
    2060:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    2064:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    2068:	80 81       	ld	r24, Z
    206a:	81 11       	cpse	r24, r1
    206c:	07 c0       	rjmp	.+14     	; 0x207c <xTaskIncrementTick+0x94>
    206e:	8f ef       	ldi	r24, 0xFF	; 255
    2070:	9f ef       	ldi	r25, 0xFF	; 255
    2072:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    2076:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    207a:	42 c0       	rjmp	.+132    	; 0x2100 <xTaskIncrementTick+0x118>
    207c:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <pxDelayedTaskList>
    2080:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <pxDelayedTaskList+0x1>
    2084:	05 80       	ldd	r0, Z+5	; 0x05
    2086:	f6 81       	ldd	r31, Z+6	; 0x06
    2088:	e0 2d       	mov	r30, r0
    208a:	c6 81       	ldd	r28, Z+6	; 0x06
    208c:	d7 81       	ldd	r29, Z+7	; 0x07
    208e:	8a 81       	ldd	r24, Y+2	; 0x02
    2090:	9b 81       	ldd	r25, Y+3	; 0x03
    2092:	e8 16       	cp	r14, r24
    2094:	f9 06       	cpc	r15, r25
    2096:	28 f4       	brcc	.+10     	; 0x20a2 <xTaskIncrementTick+0xba>
    2098:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
    209c:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
    20a0:	2f c0       	rjmp	.+94     	; 0x2100 <xTaskIncrementTick+0x118>
    20a2:	8e 01       	movw	r16, r28
    20a4:	0e 5f       	subi	r16, 0xFE	; 254
    20a6:	1f 4f       	sbci	r17, 0xFF	; 255
    20a8:	c8 01       	movw	r24, r16
    20aa:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    20ae:	8c 89       	ldd	r24, Y+20	; 0x14
    20b0:	9d 89       	ldd	r25, Y+21	; 0x15
    20b2:	89 2b       	or	r24, r25
    20b4:	21 f0       	breq	.+8      	; 0x20be <xTaskIncrementTick+0xd6>
    20b6:	ce 01       	movw	r24, r28
    20b8:	0c 96       	adiw	r24, 0x0c	; 12
    20ba:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    20be:	8e 89       	ldd	r24, Y+22	; 0x16
    20c0:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    20c4:	98 17       	cp	r25, r24
    20c6:	10 f4       	brcc	.+4      	; 0x20cc <xTaskIncrementTick+0xe4>
    20c8:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    20cc:	90 e0       	ldi	r25, 0x00	; 0
    20ce:	9c 01       	movw	r18, r24
    20d0:	22 0f       	add	r18, r18
    20d2:	33 1f       	adc	r19, r19
    20d4:	22 0f       	add	r18, r18
    20d6:	33 1f       	adc	r19, r19
    20d8:	22 0f       	add	r18, r18
    20da:	33 1f       	adc	r19, r19
    20dc:	82 0f       	add	r24, r18
    20de:	93 1f       	adc	r25, r19
    20e0:	b8 01       	movw	r22, r16
    20e2:	8e 5f       	subi	r24, 0xFE	; 254
    20e4:	9c 4f       	sbci	r25, 0xFC	; 252
    20e6:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    20ea:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    20ee:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    20f2:	9e 89       	ldd	r25, Y+22	; 0x16
    20f4:	86 89       	ldd	r24, Z+22	; 0x16
    20f6:	98 17       	cp	r25, r24
    20f8:	08 f4       	brcc	.+2      	; 0x20fc <xTaskIncrementTick+0x114>
    20fa:	b2 cf       	rjmp	.-156    	; 0x2060 <xTaskIncrementTick+0x78>
    20fc:	dc 2c       	mov	r13, r12
    20fe:	b0 cf       	rjmp	.-160    	; 0x2060 <xTaskIncrementTick+0x78>
    2100:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2104:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2108:	86 89       	ldd	r24, Z+22	; 0x16
    210a:	90 e0       	ldi	r25, 0x00	; 0
    210c:	fc 01       	movw	r30, r24
    210e:	ee 0f       	add	r30, r30
    2110:	ff 1f       	adc	r31, r31
    2112:	ee 0f       	add	r30, r30
    2114:	ff 1f       	adc	r31, r31
    2116:	ee 0f       	add	r30, r30
    2118:	ff 1f       	adc	r31, r31
    211a:	8e 0f       	add	r24, r30
    211c:	9f 1f       	adc	r25, r31
    211e:	fc 01       	movw	r30, r24
    2120:	ee 5f       	subi	r30, 0xFE	; 254
    2122:	fc 4f       	sbci	r31, 0xFC	; 252
    2124:	80 81       	ld	r24, Z
    2126:	82 30       	cpi	r24, 0x02	; 2
    2128:	48 f0       	brcs	.+18     	; 0x213c <xTaskIncrementTick+0x154>
    212a:	dd 24       	eor	r13, r13
    212c:	d3 94       	inc	r13
    212e:	06 c0       	rjmp	.+12     	; 0x213c <xTaskIncrementTick+0x154>
    2130:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <uxPendedTicks>
    2134:	8f 5f       	subi	r24, 0xFF	; 255
    2136:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <uxPendedTicks>
    213a:	d1 2c       	mov	r13, r1
    213c:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
    2140:	88 23       	and	r24, r24
    2142:	11 f0       	breq	.+4      	; 0x2148 <xTaskIncrementTick+0x160>
    2144:	dd 24       	eor	r13, r13
    2146:	d3 94       	inc	r13
    2148:	8d 2d       	mov	r24, r13
    214a:	df 91       	pop	r29
    214c:	cf 91       	pop	r28
    214e:	1f 91       	pop	r17
    2150:	0f 91       	pop	r16
    2152:	ff 90       	pop	r15
    2154:	ef 90       	pop	r14
    2156:	df 90       	pop	r13
    2158:	cf 90       	pop	r12
    215a:	08 95       	ret

0000215c <xTaskResumeAll>:
    215c:	df 92       	push	r13
    215e:	ef 92       	push	r14
    2160:	ff 92       	push	r15
    2162:	0f 93       	push	r16
    2164:	1f 93       	push	r17
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	f8 94       	cli
    216e:	0f 92       	push	r0
    2170:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    2174:	81 50       	subi	r24, 0x01	; 1
    2176:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
    217a:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    217e:	81 11       	cpse	r24, r1
    2180:	5c c0       	rjmp	.+184    	; 0x223a <__stack+0x3b>
    2182:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxCurrentNumberOfTasks>
    2186:	81 11       	cpse	r24, r1
    2188:	33 c0       	rjmp	.+102    	; 0x21f0 <xTaskResumeAll+0x94>
    218a:	5a c0       	rjmp	.+180    	; 0x2240 <__stack+0x41>
    218c:	d7 01       	movw	r26, r14
    218e:	15 96       	adiw	r26, 0x05	; 5
    2190:	ed 91       	ld	r30, X+
    2192:	fc 91       	ld	r31, X
    2194:	16 97       	sbiw	r26, 0x06	; 6
    2196:	c6 81       	ldd	r28, Z+6	; 0x06
    2198:	d7 81       	ldd	r29, Z+7	; 0x07
    219a:	ce 01       	movw	r24, r28
    219c:	0c 96       	adiw	r24, 0x0c	; 12
    219e:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    21a2:	8e 01       	movw	r16, r28
    21a4:	0e 5f       	subi	r16, 0xFE	; 254
    21a6:	1f 4f       	sbci	r17, 0xFF	; 255
    21a8:	c8 01       	movw	r24, r16
    21aa:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    21ae:	8e 89       	ldd	r24, Y+22	; 0x16
    21b0:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    21b4:	98 17       	cp	r25, r24
    21b6:	10 f4       	brcc	.+4      	; 0x21bc <xTaskResumeAll+0x60>
    21b8:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	9c 01       	movw	r18, r24
    21c0:	22 0f       	add	r18, r18
    21c2:	33 1f       	adc	r19, r19
    21c4:	22 0f       	add	r18, r18
    21c6:	33 1f       	adc	r19, r19
    21c8:	22 0f       	add	r18, r18
    21ca:	33 1f       	adc	r19, r19
    21cc:	82 0f       	add	r24, r18
    21ce:	93 1f       	adc	r25, r19
    21d0:	b8 01       	movw	r22, r16
    21d2:	8e 5f       	subi	r24, 0xFE	; 254
    21d4:	9c 4f       	sbci	r25, 0xFC	; 252
    21d6:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    21da:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    21de:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    21e2:	9e 89       	ldd	r25, Y+22	; 0x16
    21e4:	86 89       	ldd	r24, Z+22	; 0x16
    21e6:	98 17       	cp	r25, r24
    21e8:	68 f0       	brcs	.+26     	; 0x2204 <__stack+0x5>
    21ea:	d0 92 c9 02 	sts	0x02C9, r13	; 0x8002c9 <xYieldPending>
    21ee:	0a c0       	rjmp	.+20     	; 0x2204 <__stack+0x5>
    21f0:	c0 e0       	ldi	r28, 0x00	; 0
    21f2:	d0 e0       	ldi	r29, 0x00	; 0
    21f4:	0f 2e       	mov	r0, r31
    21f6:	f3 ee       	ldi	r31, 0xE3	; 227
    21f8:	ef 2e       	mov	r14, r31
    21fa:	f2 e0       	ldi	r31, 0x02	; 2
    21fc:	ff 2e       	mov	r15, r31
    21fe:	f0 2d       	mov	r31, r0
    2200:	dd 24       	eor	r13, r13
    2202:	d3 94       	inc	r13
    2204:	f7 01       	movw	r30, r14
    2206:	80 81       	ld	r24, Z
    2208:	81 11       	cpse	r24, r1
    220a:	c0 cf       	rjmp	.-128    	; 0x218c <xTaskResumeAll+0x30>
    220c:	cd 2b       	or	r28, r29
    220e:	09 f0       	breq	.+2      	; 0x2212 <__stack+0x13>
    2210:	32 dd       	rcall	.-1436   	; 0x1c76 <prvResetNextTaskUnblockTime>
    2212:	c0 91 ca 02 	lds	r28, 0x02CA	; 0x8002ca <uxPendedTicks>
    2216:	cc 23       	and	r28, r28
    2218:	49 f0       	breq	.+18     	; 0x222c <__stack+0x2d>
    221a:	d1 e0       	ldi	r29, 0x01	; 1
    221c:	e5 de       	rcall	.-566    	; 0x1fe8 <xTaskIncrementTick>
    221e:	81 11       	cpse	r24, r1
    2220:	d0 93 c9 02 	sts	0x02C9, r29	; 0x8002c9 <xYieldPending>
    2224:	c1 50       	subi	r28, 0x01	; 1
    2226:	d1 f7       	brne	.-12     	; 0x221c <__stack+0x1d>
    2228:	10 92 ca 02 	sts	0x02CA, r1	; 0x8002ca <uxPendedTicks>
    222c:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
    2230:	88 23       	and	r24, r24
    2232:	29 f0       	breq	.+10     	; 0x223e <__stack+0x3f>
    2234:	c4 d8       	rcall	.-3704   	; 0x13be <vPortYield>
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	03 c0       	rjmp	.+6      	; 0x2240 <__stack+0x41>
    223a:	80 e0       	ldi	r24, 0x00	; 0
    223c:	01 c0       	rjmp	.+2      	; 0x2240 <__stack+0x41>
    223e:	80 e0       	ldi	r24, 0x00	; 0
    2240:	0f 90       	pop	r0
    2242:	0f be       	out	0x3f, r0	; 63
    2244:	df 91       	pop	r29
    2246:	cf 91       	pop	r28
    2248:	1f 91       	pop	r17
    224a:	0f 91       	pop	r16
    224c:	ff 90       	pop	r15
    224e:	ef 90       	pop	r14
    2250:	df 90       	pop	r13
    2252:	08 95       	ret

00002254 <vTaskDelay>:
    2254:	cf 93       	push	r28
    2256:	df 93       	push	r29
    2258:	ec 01       	movw	r28, r24
    225a:	89 2b       	or	r24, r25
    225c:	39 f0       	breq	.+14     	; 0x226c <vTaskDelay+0x18>
    225e:	be de       	rcall	.-644    	; 0x1fdc <vTaskSuspendAll>
    2260:	60 e0       	ldi	r22, 0x00	; 0
    2262:	ce 01       	movw	r24, r28
    2264:	27 dd       	rcall	.-1458   	; 0x1cb4 <prvAddCurrentTaskToDelayedList>
    2266:	7a df       	rcall	.-268    	; 0x215c <xTaskResumeAll>
    2268:	81 11       	cpse	r24, r1
    226a:	01 c0       	rjmp	.+2      	; 0x226e <vTaskDelay+0x1a>
    226c:	a8 d8       	rcall	.-3760   	; 0x13be <vPortYield>
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	08 95       	ret

00002274 <vTaskSwitchContext>:
    2274:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    2278:	88 23       	and	r24, r24
    227a:	21 f0       	breq	.+8      	; 0x2284 <vTaskSwitchContext+0x10>
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    2282:	08 95       	ret
    2284:	10 92 c9 02 	sts	0x02C9, r1	; 0x8002c9 <xYieldPending>
    2288:	a0 91 26 03 	lds	r26, 0x0326	; 0x800326 <pxCurrentTCB>
    228c:	b0 91 27 03 	lds	r27, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2290:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2294:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2298:	2d 91       	ld	r18, X+
    229a:	3c 91       	ld	r19, X
    229c:	87 89       	ldd	r24, Z+23	; 0x17
    229e:	90 8d       	ldd	r25, Z+24	; 0x18
    22a0:	82 17       	cp	r24, r18
    22a2:	93 07       	cpc	r25, r19
    22a4:	60 f0       	brcs	.+24     	; 0x22be <vTaskSwitchContext+0x4a>
    22a6:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    22aa:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22ae:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <pxCurrentTCB>
    22b2:	90 91 27 03 	lds	r25, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    22b6:	67 5e       	subi	r22, 0xE7	; 231
    22b8:	7f 4f       	sbci	r23, 0xFF	; 255
    22ba:	0e 94 3d 02 	call	0x47a	; 0x47a <vApplicationStackOverflowHook>
    22be:	20 91 cc 02 	lds	r18, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    22c2:	82 2f       	mov	r24, r18
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	fc 01       	movw	r30, r24
    22c8:	ee 0f       	add	r30, r30
    22ca:	ff 1f       	adc	r31, r31
    22cc:	ee 0f       	add	r30, r30
    22ce:	ff 1f       	adc	r31, r31
    22d0:	ee 0f       	add	r30, r30
    22d2:	ff 1f       	adc	r31, r31
    22d4:	e8 0f       	add	r30, r24
    22d6:	f9 1f       	adc	r31, r25
    22d8:	ee 5f       	subi	r30, 0xFE	; 254
    22da:	fc 4f       	sbci	r31, 0xFC	; 252
    22dc:	30 81       	ld	r19, Z
    22de:	31 11       	cpse	r19, r1
    22e0:	11 c0       	rjmp	.+34     	; 0x2304 <vTaskSwitchContext+0x90>
    22e2:	21 50       	subi	r18, 0x01	; 1
    22e4:	82 2f       	mov	r24, r18
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	fc 01       	movw	r30, r24
    22ea:	ee 0f       	add	r30, r30
    22ec:	ff 1f       	adc	r31, r31
    22ee:	ee 0f       	add	r30, r30
    22f0:	ff 1f       	adc	r31, r31
    22f2:	ee 0f       	add	r30, r30
    22f4:	ff 1f       	adc	r31, r31
    22f6:	e8 0f       	add	r30, r24
    22f8:	f9 1f       	adc	r31, r25
    22fa:	ee 5f       	subi	r30, 0xFE	; 254
    22fc:	fc 4f       	sbci	r31, 0xFC	; 252
    22fe:	30 81       	ld	r19, Z
    2300:	33 23       	and	r19, r19
    2302:	79 f3       	breq	.-34     	; 0x22e2 <vTaskSwitchContext+0x6e>
    2304:	ac 01       	movw	r20, r24
    2306:	44 0f       	add	r20, r20
    2308:	55 1f       	adc	r21, r21
    230a:	44 0f       	add	r20, r20
    230c:	55 1f       	adc	r21, r21
    230e:	44 0f       	add	r20, r20
    2310:	55 1f       	adc	r21, r21
    2312:	48 0f       	add	r20, r24
    2314:	59 1f       	adc	r21, r25
    2316:	da 01       	movw	r26, r20
    2318:	ae 5f       	subi	r26, 0xFE	; 254
    231a:	bc 4f       	sbci	r27, 0xFC	; 252
    231c:	11 96       	adiw	r26, 0x01	; 1
    231e:	ed 91       	ld	r30, X+
    2320:	fc 91       	ld	r31, X
    2322:	12 97       	sbiw	r26, 0x02	; 2
    2324:	02 80       	ldd	r0, Z+2	; 0x02
    2326:	f3 81       	ldd	r31, Z+3	; 0x03
    2328:	e0 2d       	mov	r30, r0
    232a:	12 96       	adiw	r26, 0x02	; 2
    232c:	fc 93       	st	X, r31
    232e:	ee 93       	st	-X, r30
    2330:	11 97       	sbiw	r26, 0x01	; 1
    2332:	4b 5f       	subi	r20, 0xFB	; 251
    2334:	5c 4f       	sbci	r21, 0xFC	; 252
    2336:	e4 17       	cp	r30, r20
    2338:	f5 07       	cpc	r31, r21
    233a:	29 f4       	brne	.+10     	; 0x2346 <vTaskSwitchContext+0xd2>
    233c:	42 81       	ldd	r20, Z+2	; 0x02
    233e:	53 81       	ldd	r21, Z+3	; 0x03
    2340:	fd 01       	movw	r30, r26
    2342:	52 83       	std	Z+2, r21	; 0x02
    2344:	41 83       	std	Z+1, r20	; 0x01
    2346:	fc 01       	movw	r30, r24
    2348:	ee 0f       	add	r30, r30
    234a:	ff 1f       	adc	r31, r31
    234c:	ee 0f       	add	r30, r30
    234e:	ff 1f       	adc	r31, r31
    2350:	ee 0f       	add	r30, r30
    2352:	ff 1f       	adc	r31, r31
    2354:	8e 0f       	add	r24, r30
    2356:	9f 1f       	adc	r25, r31
    2358:	fc 01       	movw	r30, r24
    235a:	ee 5f       	subi	r30, 0xFE	; 254
    235c:	fc 4f       	sbci	r31, 0xFC	; 252
    235e:	01 80       	ldd	r0, Z+1	; 0x01
    2360:	f2 81       	ldd	r31, Z+2	; 0x02
    2362:	e0 2d       	mov	r30, r0
    2364:	86 81       	ldd	r24, Z+6	; 0x06
    2366:	97 81       	ldd	r25, Z+7	; 0x07
    2368:	90 93 27 03 	sts	0x0327, r25	; 0x800327 <pxCurrentTCB+0x1>
    236c:	80 93 26 03 	sts	0x0326, r24	; 0x800326 <pxCurrentTCB>
    2370:	20 93 cc 02 	sts	0x02CC, r18	; 0x8002cc <uxTopReadyPriority>
    2374:	08 95       	ret

00002376 <vTaskPlaceOnEventList>:
    2376:	cf 93       	push	r28
    2378:	df 93       	push	r29
    237a:	eb 01       	movw	r28, r22
    237c:	60 91 26 03 	lds	r22, 0x0326	; 0x800326 <pxCurrentTCB>
    2380:	70 91 27 03 	lds	r23, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    2384:	64 5f       	subi	r22, 0xF4	; 244
    2386:	7f 4f       	sbci	r23, 0xFF	; 255
    2388:	0e 94 6d 03 	call	0x6da	; 0x6da <vListInsert>
    238c:	61 e0       	ldi	r22, 0x01	; 1
    238e:	ce 01       	movw	r24, r28
    2390:	91 dc       	rcall	.-1758   	; 0x1cb4 <prvAddCurrentTaskToDelayedList>
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	08 95       	ret

00002398 <xTaskRemoveFromEventList>:
    2398:	0f 93       	push	r16
    239a:	1f 93       	push	r17
    239c:	cf 93       	push	r28
    239e:	df 93       	push	r29
    23a0:	dc 01       	movw	r26, r24
    23a2:	15 96       	adiw	r26, 0x05	; 5
    23a4:	ed 91       	ld	r30, X+
    23a6:	fc 91       	ld	r31, X
    23a8:	16 97       	sbiw	r26, 0x06	; 6
    23aa:	c6 81       	ldd	r28, Z+6	; 0x06
    23ac:	d7 81       	ldd	r29, Z+7	; 0x07
    23ae:	8e 01       	movw	r16, r28
    23b0:	04 5f       	subi	r16, 0xF4	; 244
    23b2:	1f 4f       	sbci	r17, 0xFF	; 255
    23b4:	c8 01       	movw	r24, r16
    23b6:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    23ba:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
    23be:	81 11       	cpse	r24, r1
    23c0:	1c c0       	rjmp	.+56     	; 0x23fa <xTaskRemoveFromEventList+0x62>
    23c2:	0a 50       	subi	r16, 0x0A	; 10
    23c4:	11 09       	sbc	r17, r1
    23c6:	c8 01       	movw	r24, r16
    23c8:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
    23cc:	8e 89       	ldd	r24, Y+22	; 0x16
    23ce:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    23d2:	98 17       	cp	r25, r24
    23d4:	10 f4       	brcc	.+4      	; 0x23da <xTaskRemoveFromEventList+0x42>
    23d6:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    23da:	90 e0       	ldi	r25, 0x00	; 0
    23dc:	9c 01       	movw	r18, r24
    23de:	22 0f       	add	r18, r18
    23e0:	33 1f       	adc	r19, r19
    23e2:	22 0f       	add	r18, r18
    23e4:	33 1f       	adc	r19, r19
    23e6:	22 0f       	add	r18, r18
    23e8:	33 1f       	adc	r19, r19
    23ea:	82 0f       	add	r24, r18
    23ec:	93 1f       	adc	r25, r19
    23ee:	b8 01       	movw	r22, r16
    23f0:	8e 5f       	subi	r24, 0xFE	; 254
    23f2:	9c 4f       	sbci	r25, 0xFC	; 252
    23f4:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    23f8:	05 c0       	rjmp	.+10     	; 0x2404 <xTaskRemoveFromEventList+0x6c>
    23fa:	b8 01       	movw	r22, r16
    23fc:	83 ee       	ldi	r24, 0xE3	; 227
    23fe:	92 e0       	ldi	r25, 0x02	; 2
    2400:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
    2404:	e0 91 26 03 	lds	r30, 0x0326	; 0x800326 <pxCurrentTCB>
    2408:	f0 91 27 03 	lds	r31, 0x0327	; 0x800327 <pxCurrentTCB+0x1>
    240c:	9e 89       	ldd	r25, Y+22	; 0x16
    240e:	86 89       	ldd	r24, Z+22	; 0x16
    2410:	89 17       	cp	r24, r25
    2412:	20 f4       	brcc	.+8      	; 0x241c <xTaskRemoveFromEventList+0x84>
    2414:	81 e0       	ldi	r24, 0x01	; 1
    2416:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    241a:	01 c0       	rjmp	.+2      	; 0x241e <xTaskRemoveFromEventList+0x86>
    241c:	80 e0       	ldi	r24, 0x00	; 0
    241e:	df 91       	pop	r29
    2420:	cf 91       	pop	r28
    2422:	1f 91       	pop	r17
    2424:	0f 91       	pop	r16
    2426:	08 95       	ret

00002428 <vTaskSetTimeOutState>:
    2428:	20 91 c8 02 	lds	r18, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    242c:	fc 01       	movw	r30, r24
    242e:	20 83       	st	Z, r18
    2430:	20 91 cd 02 	lds	r18, 0x02CD	; 0x8002cd <xTickCount>
    2434:	30 91 ce 02 	lds	r19, 0x02CE	; 0x8002ce <xTickCount+0x1>
    2438:	32 83       	std	Z+2, r19	; 0x02
    243a:	21 83       	std	Z+1, r18	; 0x01
    243c:	08 95       	ret

0000243e <xTaskCheckForTimeOut>:
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	0f 92       	push	r0
    2444:	40 91 cd 02 	lds	r20, 0x02CD	; 0x8002cd <xTickCount>
    2448:	50 91 ce 02 	lds	r21, 0x02CE	; 0x8002ce <xTickCount+0x1>
    244c:	db 01       	movw	r26, r22
    244e:	2d 91       	ld	r18, X+
    2450:	3c 91       	ld	r19, X
    2452:	2f 3f       	cpi	r18, 0xFF	; 255
    2454:	bf ef       	ldi	r27, 0xFF	; 255
    2456:	3b 07       	cpc	r19, r27
    2458:	11 f1       	breq	.+68     	; 0x249e <xTaskCheckForTimeOut+0x60>
    245a:	e0 91 c8 02 	lds	r30, 0x02C8	; 0x8002c8 <xNumOfOverflows>
    245e:	dc 01       	movw	r26, r24
    2460:	fc 91       	ld	r31, X
    2462:	fe 17       	cp	r31, r30
    2464:	39 f0       	breq	.+14     	; 0x2474 <xTaskCheckForTimeOut+0x36>
    2466:	11 96       	adiw	r26, 0x01	; 1
    2468:	ed 91       	ld	r30, X+
    246a:	fc 91       	ld	r31, X
    246c:	12 97       	sbiw	r26, 0x02	; 2
    246e:	4e 17       	cp	r20, r30
    2470:	5f 07       	cpc	r21, r31
    2472:	b8 f4       	brcc	.+46     	; 0x24a2 <xTaskCheckForTimeOut+0x64>
    2474:	dc 01       	movw	r26, r24
    2476:	11 96       	adiw	r26, 0x01	; 1
    2478:	ed 91       	ld	r30, X+
    247a:	fc 91       	ld	r31, X
    247c:	12 97       	sbiw	r26, 0x02	; 2
    247e:	da 01       	movw	r26, r20
    2480:	ae 1b       	sub	r26, r30
    2482:	bf 0b       	sbc	r27, r31
    2484:	a2 17       	cp	r26, r18
    2486:	b3 07       	cpc	r27, r19
    2488:	70 f4       	brcc	.+28     	; 0x24a6 <xTaskCheckForTimeOut+0x68>
    248a:	db 01       	movw	r26, r22
    248c:	e4 1b       	sub	r30, r20
    248e:	f5 0b       	sbc	r31, r21
    2490:	2e 0f       	add	r18, r30
    2492:	3f 1f       	adc	r19, r31
    2494:	2d 93       	st	X+, r18
    2496:	3c 93       	st	X, r19
    2498:	c7 df       	rcall	.-114    	; 0x2428 <vTaskSetTimeOutState>
    249a:	80 e0       	ldi	r24, 0x00	; 0
    249c:	05 c0       	rjmp	.+10     	; 0x24a8 <xTaskCheckForTimeOut+0x6a>
    249e:	80 e0       	ldi	r24, 0x00	; 0
    24a0:	03 c0       	rjmp	.+6      	; 0x24a8 <xTaskCheckForTimeOut+0x6a>
    24a2:	81 e0       	ldi	r24, 0x01	; 1
    24a4:	01 c0       	rjmp	.+2      	; 0x24a8 <xTaskCheckForTimeOut+0x6a>
    24a6:	81 e0       	ldi	r24, 0x01	; 1
    24a8:	0f 90       	pop	r0
    24aa:	0f be       	out	0x3f, r0	; 63
    24ac:	08 95       	ret

000024ae <vTaskMissedYield>:
    24ae:	81 e0       	ldi	r24, 0x01	; 1
    24b0:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
    24b4:	08 95       	ret

000024b6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    24b6:	0f 93       	push	r16
    24b8:	1f 93       	push	r17
    24ba:	cf 93       	push	r28
    24bc:	df 93       	push	r29
    24be:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    24c0:	89 2b       	or	r24, r25
    24c2:	79 f1       	breq	.+94     	; 0x2522 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    24c4:	82 a1       	ldd	r24, Z+34	; 0x22
    24c6:	81 50       	subi	r24, 0x01	; 1
    24c8:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    24ca:	26 89       	ldd	r18, Z+22	; 0x16
    24cc:	91 a1       	ldd	r25, Z+33	; 0x21
    24ce:	29 17       	cp	r18, r25
    24d0:	51 f1       	breq	.+84     	; 0x2526 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    24d2:	81 11       	cpse	r24, r1
    24d4:	2a c0       	rjmp	.+84     	; 0x252a <xTaskPriorityDisinherit+0x74>
    24d6:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    24d8:	8f 01       	movw	r16, r30
    24da:	0e 5f       	subi	r16, 0xFE	; 254
    24dc:	1f 4f       	sbci	r17, 0xFF	; 255
    24de:	c8 01       	movw	r24, r16
    24e0:	0e 94 9e 03 	call	0x73c	; 0x73c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    24e4:	89 a1       	ldd	r24, Y+33	; 0x21
    24e6:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    24e8:	24 e0       	ldi	r18, 0x04	; 4
    24ea:	30 e0       	ldi	r19, 0x00	; 0
    24ec:	28 1b       	sub	r18, r24
    24ee:	31 09       	sbc	r19, r1
    24f0:	3d 87       	std	Y+13, r19	; 0x0d
    24f2:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    24f4:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <uxTopReadyPriority>
    24f8:	98 17       	cp	r25, r24
    24fa:	10 f4       	brcc	.+4      	; 0x2500 <xTaskPriorityDisinherit+0x4a>
    24fc:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <uxTopReadyPriority>
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	9c 01       	movw	r18, r24
    2504:	22 0f       	add	r18, r18
    2506:	33 1f       	adc	r19, r19
    2508:	22 0f       	add	r18, r18
    250a:	33 1f       	adc	r19, r19
    250c:	22 0f       	add	r18, r18
    250e:	33 1f       	adc	r19, r19
    2510:	82 0f       	add	r24, r18
    2512:	93 1f       	adc	r25, r19
    2514:	b8 01       	movw	r22, r16
    2516:	8e 5f       	subi	r24, 0xFE	; 254
    2518:	9c 4f       	sbci	r25, 0xFC	; 252
    251a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	05 c0       	rjmp	.+10     	; 0x252c <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2522:	80 e0       	ldi	r24, 0x00	; 0
    2524:	03 c0       	rjmp	.+6      	; 0x252c <xTaskPriorityDisinherit+0x76>
    2526:	80 e0       	ldi	r24, 0x00	; 0
    2528:	01 c0       	rjmp	.+2      	; 0x252c <xTaskPriorityDisinherit+0x76>
    252a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	1f 91       	pop	r17
    2532:	0f 91       	pop	r16
    2534:	08 95       	ret

00002536 <__udivmodsi4>:
    2536:	a1 e2       	ldi	r26, 0x21	; 33
    2538:	1a 2e       	mov	r1, r26
    253a:	aa 1b       	sub	r26, r26
    253c:	bb 1b       	sub	r27, r27
    253e:	fd 01       	movw	r30, r26
    2540:	0d c0       	rjmp	.+26     	; 0x255c <__udivmodsi4_ep>

00002542 <__udivmodsi4_loop>:
    2542:	aa 1f       	adc	r26, r26
    2544:	bb 1f       	adc	r27, r27
    2546:	ee 1f       	adc	r30, r30
    2548:	ff 1f       	adc	r31, r31
    254a:	a2 17       	cp	r26, r18
    254c:	b3 07       	cpc	r27, r19
    254e:	e4 07       	cpc	r30, r20
    2550:	f5 07       	cpc	r31, r21
    2552:	20 f0       	brcs	.+8      	; 0x255c <__udivmodsi4_ep>
    2554:	a2 1b       	sub	r26, r18
    2556:	b3 0b       	sbc	r27, r19
    2558:	e4 0b       	sbc	r30, r20
    255a:	f5 0b       	sbc	r31, r21

0000255c <__udivmodsi4_ep>:
    255c:	66 1f       	adc	r22, r22
    255e:	77 1f       	adc	r23, r23
    2560:	88 1f       	adc	r24, r24
    2562:	99 1f       	adc	r25, r25
    2564:	1a 94       	dec	r1
    2566:	69 f7       	brne	.-38     	; 0x2542 <__udivmodsi4_loop>
    2568:	60 95       	com	r22
    256a:	70 95       	com	r23
    256c:	80 95       	com	r24
    256e:	90 95       	com	r25
    2570:	9b 01       	movw	r18, r22
    2572:	ac 01       	movw	r20, r24
    2574:	bd 01       	movw	r22, r26
    2576:	cf 01       	movw	r24, r30
    2578:	08 95       	ret

0000257a <__tablejump2__>:
    257a:	ee 0f       	add	r30, r30
    257c:	ff 1f       	adc	r31, r31
    257e:	88 1f       	adc	r24, r24
    2580:	8b bf       	out	0x3b, r24	; 59
    2582:	07 90       	elpm	r0, Z+
    2584:	f6 91       	elpm	r31, Z
    2586:	e0 2d       	mov	r30, r0
    2588:	19 94       	eijmp

0000258a <__umulhisi3>:
    258a:	a2 9f       	mul	r26, r18
    258c:	b0 01       	movw	r22, r0
    258e:	b3 9f       	mul	r27, r19
    2590:	c0 01       	movw	r24, r0
    2592:	a3 9f       	mul	r26, r19
    2594:	70 0d       	add	r23, r0
    2596:	81 1d       	adc	r24, r1
    2598:	11 24       	eor	r1, r1
    259a:	91 1d       	adc	r25, r1
    259c:	b2 9f       	mul	r27, r18
    259e:	70 0d       	add	r23, r0
    25a0:	81 1d       	adc	r24, r1
    25a2:	11 24       	eor	r1, r1
    25a4:	91 1d       	adc	r25, r1
    25a6:	08 95       	ret

000025a8 <__muluhisi3>:
    25a8:	f0 df       	rcall	.-32     	; 0x258a <__umulhisi3>
    25aa:	a5 9f       	mul	r26, r21
    25ac:	90 0d       	add	r25, r0
    25ae:	b4 9f       	mul	r27, r20
    25b0:	90 0d       	add	r25, r0
    25b2:	a4 9f       	mul	r26, r20
    25b4:	80 0d       	add	r24, r0
    25b6:	91 1d       	adc	r25, r1
    25b8:	11 24       	eor	r1, r1
    25ba:	08 95       	ret

000025bc <malloc>:
    25bc:	0f 93       	push	r16
    25be:	1f 93       	push	r17
    25c0:	cf 93       	push	r28
    25c2:	df 93       	push	r29
    25c4:	82 30       	cpi	r24, 0x02	; 2
    25c6:	91 05       	cpc	r25, r1
    25c8:	10 f4       	brcc	.+4      	; 0x25ce <malloc+0x12>
    25ca:	82 e0       	ldi	r24, 0x02	; 2
    25cc:	90 e0       	ldi	r25, 0x00	; 0
    25ce:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <__flp>
    25d2:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <__flp+0x1>
    25d6:	20 e0       	ldi	r18, 0x00	; 0
    25d8:	30 e0       	ldi	r19, 0x00	; 0
    25da:	a0 e0       	ldi	r26, 0x00	; 0
    25dc:	b0 e0       	ldi	r27, 0x00	; 0
    25de:	30 97       	sbiw	r30, 0x00	; 0
    25e0:	19 f1       	breq	.+70     	; 0x2628 <malloc+0x6c>
    25e2:	40 81       	ld	r20, Z
    25e4:	51 81       	ldd	r21, Z+1	; 0x01
    25e6:	02 81       	ldd	r16, Z+2	; 0x02
    25e8:	13 81       	ldd	r17, Z+3	; 0x03
    25ea:	48 17       	cp	r20, r24
    25ec:	59 07       	cpc	r21, r25
    25ee:	c8 f0       	brcs	.+50     	; 0x2622 <malloc+0x66>
    25f0:	84 17       	cp	r24, r20
    25f2:	95 07       	cpc	r25, r21
    25f4:	69 f4       	brne	.+26     	; 0x2610 <malloc+0x54>
    25f6:	10 97       	sbiw	r26, 0x00	; 0
    25f8:	31 f0       	breq	.+12     	; 0x2606 <malloc+0x4a>
    25fa:	12 96       	adiw	r26, 0x02	; 2
    25fc:	0c 93       	st	X, r16
    25fe:	12 97       	sbiw	r26, 0x02	; 2
    2600:	13 96       	adiw	r26, 0x03	; 3
    2602:	1c 93       	st	X, r17
    2604:	27 c0       	rjmp	.+78     	; 0x2654 <malloc+0x98>
    2606:	00 93 fb 04 	sts	0x04FB, r16	; 0x8004fb <__flp>
    260a:	10 93 fc 04 	sts	0x04FC, r17	; 0x8004fc <__flp+0x1>
    260e:	22 c0       	rjmp	.+68     	; 0x2654 <malloc+0x98>
    2610:	21 15       	cp	r18, r1
    2612:	31 05       	cpc	r19, r1
    2614:	19 f0       	breq	.+6      	; 0x261c <malloc+0x60>
    2616:	42 17       	cp	r20, r18
    2618:	53 07       	cpc	r21, r19
    261a:	18 f4       	brcc	.+6      	; 0x2622 <malloc+0x66>
    261c:	9a 01       	movw	r18, r20
    261e:	bd 01       	movw	r22, r26
    2620:	ef 01       	movw	r28, r30
    2622:	df 01       	movw	r26, r30
    2624:	f8 01       	movw	r30, r16
    2626:	db cf       	rjmp	.-74     	; 0x25de <malloc+0x22>
    2628:	21 15       	cp	r18, r1
    262a:	31 05       	cpc	r19, r1
    262c:	f9 f0       	breq	.+62     	; 0x266c <malloc+0xb0>
    262e:	28 1b       	sub	r18, r24
    2630:	39 0b       	sbc	r19, r25
    2632:	24 30       	cpi	r18, 0x04	; 4
    2634:	31 05       	cpc	r19, r1
    2636:	80 f4       	brcc	.+32     	; 0x2658 <malloc+0x9c>
    2638:	8a 81       	ldd	r24, Y+2	; 0x02
    263a:	9b 81       	ldd	r25, Y+3	; 0x03
    263c:	61 15       	cp	r22, r1
    263e:	71 05       	cpc	r23, r1
    2640:	21 f0       	breq	.+8      	; 0x264a <malloc+0x8e>
    2642:	fb 01       	movw	r30, r22
    2644:	93 83       	std	Z+3, r25	; 0x03
    2646:	82 83       	std	Z+2, r24	; 0x02
    2648:	04 c0       	rjmp	.+8      	; 0x2652 <malloc+0x96>
    264a:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <__flp+0x1>
    264e:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <__flp>
    2652:	fe 01       	movw	r30, r28
    2654:	32 96       	adiw	r30, 0x02	; 2
    2656:	44 c0       	rjmp	.+136    	; 0x26e0 <malloc+0x124>
    2658:	fe 01       	movw	r30, r28
    265a:	e2 0f       	add	r30, r18
    265c:	f3 1f       	adc	r31, r19
    265e:	81 93       	st	Z+, r24
    2660:	91 93       	st	Z+, r25
    2662:	22 50       	subi	r18, 0x02	; 2
    2664:	31 09       	sbc	r19, r1
    2666:	39 83       	std	Y+1, r19	; 0x01
    2668:	28 83       	st	Y, r18
    266a:	3a c0       	rjmp	.+116    	; 0x26e0 <malloc+0x124>
    266c:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    2670:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    2674:	23 2b       	or	r18, r19
    2676:	41 f4       	brne	.+16     	; 0x2688 <malloc+0xcc>
    2678:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    267c:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    2680:	30 93 fa 04 	sts	0x04FA, r19	; 0x8004fa <__brkval+0x1>
    2684:	20 93 f9 04 	sts	0x04F9, r18	; 0x8004f9 <__brkval>
    2688:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    268c:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    2690:	21 15       	cp	r18, r1
    2692:	31 05       	cpc	r19, r1
    2694:	41 f4       	brne	.+16     	; 0x26a6 <malloc+0xea>
    2696:	2d b7       	in	r18, 0x3d	; 61
    2698:	3e b7       	in	r19, 0x3e	; 62
    269a:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    269e:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    26a2:	24 1b       	sub	r18, r20
    26a4:	35 0b       	sbc	r19, r21
    26a6:	e0 91 f9 04 	lds	r30, 0x04F9	; 0x8004f9 <__brkval>
    26aa:	f0 91 fa 04 	lds	r31, 0x04FA	; 0x8004fa <__brkval+0x1>
    26ae:	e2 17       	cp	r30, r18
    26b0:	f3 07       	cpc	r31, r19
    26b2:	a0 f4       	brcc	.+40     	; 0x26dc <malloc+0x120>
    26b4:	2e 1b       	sub	r18, r30
    26b6:	3f 0b       	sbc	r19, r31
    26b8:	28 17       	cp	r18, r24
    26ba:	39 07       	cpc	r19, r25
    26bc:	78 f0       	brcs	.+30     	; 0x26dc <malloc+0x120>
    26be:	ac 01       	movw	r20, r24
    26c0:	4e 5f       	subi	r20, 0xFE	; 254
    26c2:	5f 4f       	sbci	r21, 0xFF	; 255
    26c4:	24 17       	cp	r18, r20
    26c6:	35 07       	cpc	r19, r21
    26c8:	48 f0       	brcs	.+18     	; 0x26dc <malloc+0x120>
    26ca:	4e 0f       	add	r20, r30
    26cc:	5f 1f       	adc	r21, r31
    26ce:	50 93 fa 04 	sts	0x04FA, r21	; 0x8004fa <__brkval+0x1>
    26d2:	40 93 f9 04 	sts	0x04F9, r20	; 0x8004f9 <__brkval>
    26d6:	81 93       	st	Z+, r24
    26d8:	91 93       	st	Z+, r25
    26da:	02 c0       	rjmp	.+4      	; 0x26e0 <malloc+0x124>
    26dc:	e0 e0       	ldi	r30, 0x00	; 0
    26de:	f0 e0       	ldi	r31, 0x00	; 0
    26e0:	cf 01       	movw	r24, r30
    26e2:	df 91       	pop	r29
    26e4:	cf 91       	pop	r28
    26e6:	1f 91       	pop	r17
    26e8:	0f 91       	pop	r16
    26ea:	08 95       	ret

000026ec <free>:
    26ec:	cf 93       	push	r28
    26ee:	df 93       	push	r29
    26f0:	00 97       	sbiw	r24, 0x00	; 0
    26f2:	09 f4       	brne	.+2      	; 0x26f6 <free+0xa>
    26f4:	81 c0       	rjmp	.+258    	; 0x27f8 <free+0x10c>
    26f6:	fc 01       	movw	r30, r24
    26f8:	32 97       	sbiw	r30, 0x02	; 2
    26fa:	13 82       	std	Z+3, r1	; 0x03
    26fc:	12 82       	std	Z+2, r1	; 0x02
    26fe:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <__flp>
    2702:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <__flp+0x1>
    2706:	10 97       	sbiw	r26, 0x00	; 0
    2708:	81 f4       	brne	.+32     	; 0x272a <free+0x3e>
    270a:	20 81       	ld	r18, Z
    270c:	31 81       	ldd	r19, Z+1	; 0x01
    270e:	82 0f       	add	r24, r18
    2710:	93 1f       	adc	r25, r19
    2712:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    2716:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    271a:	28 17       	cp	r18, r24
    271c:	39 07       	cpc	r19, r25
    271e:	51 f5       	brne	.+84     	; 0x2774 <free+0x88>
    2720:	f0 93 fa 04 	sts	0x04FA, r31	; 0x8004fa <__brkval+0x1>
    2724:	e0 93 f9 04 	sts	0x04F9, r30	; 0x8004f9 <__brkval>
    2728:	67 c0       	rjmp	.+206    	; 0x27f8 <free+0x10c>
    272a:	ed 01       	movw	r28, r26
    272c:	20 e0       	ldi	r18, 0x00	; 0
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	ce 17       	cp	r28, r30
    2732:	df 07       	cpc	r29, r31
    2734:	40 f4       	brcc	.+16     	; 0x2746 <free+0x5a>
    2736:	4a 81       	ldd	r20, Y+2	; 0x02
    2738:	5b 81       	ldd	r21, Y+3	; 0x03
    273a:	9e 01       	movw	r18, r28
    273c:	41 15       	cp	r20, r1
    273e:	51 05       	cpc	r21, r1
    2740:	f1 f0       	breq	.+60     	; 0x277e <free+0x92>
    2742:	ea 01       	movw	r28, r20
    2744:	f5 cf       	rjmp	.-22     	; 0x2730 <free+0x44>
    2746:	d3 83       	std	Z+3, r29	; 0x03
    2748:	c2 83       	std	Z+2, r28	; 0x02
    274a:	40 81       	ld	r20, Z
    274c:	51 81       	ldd	r21, Z+1	; 0x01
    274e:	84 0f       	add	r24, r20
    2750:	95 1f       	adc	r25, r21
    2752:	c8 17       	cp	r28, r24
    2754:	d9 07       	cpc	r29, r25
    2756:	59 f4       	brne	.+22     	; 0x276e <free+0x82>
    2758:	88 81       	ld	r24, Y
    275a:	99 81       	ldd	r25, Y+1	; 0x01
    275c:	84 0f       	add	r24, r20
    275e:	95 1f       	adc	r25, r21
    2760:	02 96       	adiw	r24, 0x02	; 2
    2762:	91 83       	std	Z+1, r25	; 0x01
    2764:	80 83       	st	Z, r24
    2766:	8a 81       	ldd	r24, Y+2	; 0x02
    2768:	9b 81       	ldd	r25, Y+3	; 0x03
    276a:	93 83       	std	Z+3, r25	; 0x03
    276c:	82 83       	std	Z+2, r24	; 0x02
    276e:	21 15       	cp	r18, r1
    2770:	31 05       	cpc	r19, r1
    2772:	29 f4       	brne	.+10     	; 0x277e <free+0x92>
    2774:	f0 93 fc 04 	sts	0x04FC, r31	; 0x8004fc <__flp+0x1>
    2778:	e0 93 fb 04 	sts	0x04FB, r30	; 0x8004fb <__flp>
    277c:	3d c0       	rjmp	.+122    	; 0x27f8 <free+0x10c>
    277e:	e9 01       	movw	r28, r18
    2780:	fb 83       	std	Y+3, r31	; 0x03
    2782:	ea 83       	std	Y+2, r30	; 0x02
    2784:	49 91       	ld	r20, Y+
    2786:	59 91       	ld	r21, Y+
    2788:	c4 0f       	add	r28, r20
    278a:	d5 1f       	adc	r29, r21
    278c:	ec 17       	cp	r30, r28
    278e:	fd 07       	cpc	r31, r29
    2790:	61 f4       	brne	.+24     	; 0x27aa <free+0xbe>
    2792:	80 81       	ld	r24, Z
    2794:	91 81       	ldd	r25, Z+1	; 0x01
    2796:	84 0f       	add	r24, r20
    2798:	95 1f       	adc	r25, r21
    279a:	02 96       	adiw	r24, 0x02	; 2
    279c:	e9 01       	movw	r28, r18
    279e:	99 83       	std	Y+1, r25	; 0x01
    27a0:	88 83       	st	Y, r24
    27a2:	82 81       	ldd	r24, Z+2	; 0x02
    27a4:	93 81       	ldd	r25, Z+3	; 0x03
    27a6:	9b 83       	std	Y+3, r25	; 0x03
    27a8:	8a 83       	std	Y+2, r24	; 0x02
    27aa:	e0 e0       	ldi	r30, 0x00	; 0
    27ac:	f0 e0       	ldi	r31, 0x00	; 0
    27ae:	12 96       	adiw	r26, 0x02	; 2
    27b0:	8d 91       	ld	r24, X+
    27b2:	9c 91       	ld	r25, X
    27b4:	13 97       	sbiw	r26, 0x03	; 3
    27b6:	00 97       	sbiw	r24, 0x00	; 0
    27b8:	19 f0       	breq	.+6      	; 0x27c0 <free+0xd4>
    27ba:	fd 01       	movw	r30, r26
    27bc:	dc 01       	movw	r26, r24
    27be:	f7 cf       	rjmp	.-18     	; 0x27ae <free+0xc2>
    27c0:	8d 91       	ld	r24, X+
    27c2:	9c 91       	ld	r25, X
    27c4:	11 97       	sbiw	r26, 0x01	; 1
    27c6:	9d 01       	movw	r18, r26
    27c8:	2e 5f       	subi	r18, 0xFE	; 254
    27ca:	3f 4f       	sbci	r19, 0xFF	; 255
    27cc:	82 0f       	add	r24, r18
    27ce:	93 1f       	adc	r25, r19
    27d0:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <__brkval>
    27d4:	30 91 fa 04 	lds	r19, 0x04FA	; 0x8004fa <__brkval+0x1>
    27d8:	28 17       	cp	r18, r24
    27da:	39 07       	cpc	r19, r25
    27dc:	69 f4       	brne	.+26     	; 0x27f8 <free+0x10c>
    27de:	30 97       	sbiw	r30, 0x00	; 0
    27e0:	29 f4       	brne	.+10     	; 0x27ec <free+0x100>
    27e2:	10 92 fc 04 	sts	0x04FC, r1	; 0x8004fc <__flp+0x1>
    27e6:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <__flp>
    27ea:	02 c0       	rjmp	.+4      	; 0x27f0 <free+0x104>
    27ec:	13 82       	std	Z+3, r1	; 0x03
    27ee:	12 82       	std	Z+2, r1	; 0x02
    27f0:	b0 93 fa 04 	sts	0x04FA, r27	; 0x8004fa <__brkval+0x1>
    27f4:	a0 93 f9 04 	sts	0x04F9, r26	; 0x8004f9 <__brkval>
    27f8:	df 91       	pop	r29
    27fa:	cf 91       	pop	r28
    27fc:	08 95       	ret

000027fe <memcpy>:
    27fe:	fb 01       	movw	r30, r22
    2800:	dc 01       	movw	r26, r24
    2802:	02 c0       	rjmp	.+4      	; 0x2808 <memcpy+0xa>
    2804:	01 90       	ld	r0, Z+
    2806:	0d 92       	st	X+, r0
    2808:	41 50       	subi	r20, 0x01	; 1
    280a:	50 40       	sbci	r21, 0x00	; 0
    280c:	d8 f7       	brcc	.-10     	; 0x2804 <memcpy+0x6>
    280e:	08 95       	ret

00002810 <memset>:
    2810:	dc 01       	movw	r26, r24
    2812:	01 c0       	rjmp	.+2      	; 0x2816 <memset+0x6>
    2814:	6d 93       	st	X+, r22
    2816:	41 50       	subi	r20, 0x01	; 1
    2818:	50 40       	sbci	r21, 0x00	; 0
    281a:	e0 f7       	brcc	.-8      	; 0x2814 <memset+0x4>
    281c:	08 95       	ret

0000281e <__itoa_ncheck>:
    281e:	bb 27       	eor	r27, r27
    2820:	4a 30       	cpi	r20, 0x0A	; 10
    2822:	31 f4       	brne	.+12     	; 0x2830 <__itoa_ncheck+0x12>
    2824:	99 23       	and	r25, r25
    2826:	22 f4       	brpl	.+8      	; 0x2830 <__itoa_ncheck+0x12>
    2828:	bd e2       	ldi	r27, 0x2D	; 45
    282a:	90 95       	com	r25
    282c:	81 95       	neg	r24
    282e:	9f 4f       	sbci	r25, 0xFF	; 255
    2830:	01 c0       	rjmp	.+2      	; 0x2834 <__utoa_common>

00002832 <__utoa_ncheck>:
    2832:	bb 27       	eor	r27, r27

00002834 <__utoa_common>:
    2834:	fb 01       	movw	r30, r22
    2836:	55 27       	eor	r21, r21
    2838:	aa 27       	eor	r26, r26
    283a:	88 0f       	add	r24, r24
    283c:	99 1f       	adc	r25, r25
    283e:	aa 1f       	adc	r26, r26
    2840:	a4 17       	cp	r26, r20
    2842:	10 f0       	brcs	.+4      	; 0x2848 <__utoa_common+0x14>
    2844:	a4 1b       	sub	r26, r20
    2846:	83 95       	inc	r24
    2848:	50 51       	subi	r21, 0x10	; 16
    284a:	b9 f7       	brne	.-18     	; 0x283a <__utoa_common+0x6>
    284c:	a0 5d       	subi	r26, 0xD0	; 208
    284e:	aa 33       	cpi	r26, 0x3A	; 58
    2850:	08 f0       	brcs	.+2      	; 0x2854 <__utoa_common+0x20>
    2852:	a9 5d       	subi	r26, 0xD9	; 217
    2854:	a1 93       	st	Z+, r26
    2856:	00 97       	sbiw	r24, 0x00	; 0
    2858:	79 f7       	brne	.-34     	; 0x2838 <__utoa_common+0x4>
    285a:	b1 11       	cpse	r27, r1
    285c:	b1 93       	st	Z+, r27
    285e:	11 92       	st	Z+, r1
    2860:	cb 01       	movw	r24, r22
    2862:	00 c0       	rjmp	.+0      	; 0x2864 <strrev>

00002864 <strrev>:
    2864:	dc 01       	movw	r26, r24
    2866:	fc 01       	movw	r30, r24
    2868:	67 2f       	mov	r22, r23
    286a:	71 91       	ld	r23, Z+
    286c:	77 23       	and	r23, r23
    286e:	e1 f7       	brne	.-8      	; 0x2868 <strrev+0x4>
    2870:	32 97       	sbiw	r30, 0x02	; 2
    2872:	04 c0       	rjmp	.+8      	; 0x287c <strrev+0x18>
    2874:	7c 91       	ld	r23, X
    2876:	6d 93       	st	X+, r22
    2878:	70 83       	st	Z, r23
    287a:	62 91       	ld	r22, -Z
    287c:	ae 17       	cp	r26, r30
    287e:	bf 07       	cpc	r27, r31
    2880:	c8 f3       	brcs	.-14     	; 0x2874 <strrev+0x10>
    2882:	08 95       	ret

00002884 <_exit>:
    2884:	f8 94       	cli

00002886 <__stop_program>:
    2886:	ff cf       	rjmp	.-2      	; 0x2886 <__stop_program>
