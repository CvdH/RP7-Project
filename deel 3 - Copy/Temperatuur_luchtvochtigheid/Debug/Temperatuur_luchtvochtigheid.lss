
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000082  00800200  00002a76  00002b0a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a76  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000231  00800282  00800282  00002b8c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002b8c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002bbc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00002bfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000078b0  00000000  00000000  000031ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f30  00000000  00000000  0000aa5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004752  00000000  00000000  0000c98c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001544  00000000  00000000  000110e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f7b  00000000  00000000  00012624  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007514  00000000  00000000  0001459f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000888  00000000  00000000  0001bab3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8a c1       	rjmp	.+788    	; 0x31a <__bad_interrupt>
       6:	00 00       	nop
       8:	88 c1       	rjmp	.+784    	; 0x31a <__bad_interrupt>
       a:	00 00       	nop
       c:	86 c1       	rjmp	.+780    	; 0x31a <__bad_interrupt>
       e:	00 00       	nop
      10:	84 c1       	rjmp	.+776    	; 0x31a <__bad_interrupt>
      12:	00 00       	nop
      14:	82 c1       	rjmp	.+772    	; 0x31a <__bad_interrupt>
      16:	00 00       	nop
      18:	80 c1       	rjmp	.+768    	; 0x31a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7e c1       	rjmp	.+764    	; 0x31a <__bad_interrupt>
      1e:	00 00       	nop
      20:	7c c1       	rjmp	.+760    	; 0x31a <__bad_interrupt>
      22:	00 00       	nop
      24:	75 c4       	rjmp	.+2282   	; 0x910 <__vector_9>
      26:	00 00       	nop
      28:	78 c1       	rjmp	.+752    	; 0x31a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	76 c1       	rjmp	.+748    	; 0x31a <__bad_interrupt>
      2e:	00 00       	nop
      30:	74 c1       	rjmp	.+744    	; 0x31a <__bad_interrupt>
      32:	00 00       	nop
      34:	72 c1       	rjmp	.+740    	; 0x31a <__bad_interrupt>
      36:	00 00       	nop
      38:	70 c1       	rjmp	.+736    	; 0x31a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6e c1       	rjmp	.+732    	; 0x31a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6c c1       	rjmp	.+728    	; 0x31a <__bad_interrupt>
      42:	00 00       	nop
      44:	c6 c6       	rjmp	.+3468   	; 0xdd2 <__vector_17>
      46:	00 00       	nop
      48:	68 c1       	rjmp	.+720    	; 0x31a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	66 c1       	rjmp	.+716    	; 0x31a <__bad_interrupt>
      4e:	00 00       	nop
      50:	64 c1       	rjmp	.+712    	; 0x31a <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 8b 08 	jmp	0x1116	; 0x1116 <__vector_21>
      58:	60 c1       	rjmp	.+704    	; 0x31a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5e c1       	rjmp	.+700    	; 0x31a <__bad_interrupt>
      5e:	00 00       	nop
      60:	5c c1       	rjmp	.+696    	; 0x31a <__bad_interrupt>
      62:	00 00       	nop
      64:	19 c4       	rjmp	.+2098   	; 0x898 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 05 0b 	jmp	0x160a	; 0x160a <__vector_26>
      6c:	56 c1       	rjmp	.+684    	; 0x31a <__bad_interrupt>
      6e:	00 00       	nop
      70:	54 c1       	rjmp	.+680    	; 0x31a <__bad_interrupt>
      72:	00 00       	nop
      74:	52 c1       	rjmp	.+676    	; 0x31a <__bad_interrupt>
      76:	00 00       	nop
      78:	50 c1       	rjmp	.+672    	; 0x31a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4e c1       	rjmp	.+668    	; 0x31a <__bad_interrupt>
      7e:	00 00       	nop
      80:	4c c1       	rjmp	.+664    	; 0x31a <__bad_interrupt>
      82:	00 00       	nop
      84:	4a c1       	rjmp	.+660    	; 0x31a <__bad_interrupt>
      86:	00 00       	nop
      88:	48 c1       	rjmp	.+656    	; 0x31a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f2 c4       	rjmp	.+2532   	; 0xa72 <__vector_35>
      8e:	00 00       	nop
      90:	0c 94 4e 0b 	jmp	0x169c	; 0x169c <__vector_36>
      94:	0c 94 ad 0b 	jmp	0x175a	; 0x175a <__vector_37>
      98:	40 c1       	rjmp	.+640    	; 0x31a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ac c1       	rjmp	.+856    	; 0x3f6 <__vector_39>
      9e:	00 00       	nop
      a0:	3c c1       	rjmp	.+632    	; 0x31a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	38 c1       	rjmp	.+624    	; 0x31a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	36 c1       	rjmp	.+620    	; 0x31a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	34 c1       	rjmp	.+616    	; 0x31a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	32 c1       	rjmp	.+612    	; 0x31a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	30 c1       	rjmp	.+608    	; 0x31a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2e c1       	rjmp	.+604    	; 0x31a <__bad_interrupt>
      be:	00 00       	nop
      c0:	2c c1       	rjmp	.+600    	; 0x31a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2a c1       	rjmp	.+596    	; 0x31a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	28 c1       	rjmp	.+592    	; 0x31a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 f6 0b 	jmp	0x17ec	; 0x17ec <__vector_51>
      d0:	0c 94 55 0c 	jmp	0x18aa	; 0x18aa <__vector_52>
      d4:	22 c1       	rjmp	.+580    	; 0x31a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 9e 0c 	jmp	0x193c	; 0x193c <__vector_54>
      dc:	0c 94 fd 0c 	jmp	0x19fa	; 0x19fa <__vector_55>
      e0:	1c c1       	rjmp	.+568    	; 0x31a <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1a 02       	muls	r17, r26
      e6:	d5 02       	muls	r29, r21
      e8:	d5 02       	muls	r29, r21
      ea:	d5 02       	muls	r29, r21
      ec:	d5 02       	muls	r29, r21
      ee:	d5 02       	muls	r29, r21
      f0:	d5 02       	muls	r29, r21
      f2:	d5 02       	muls	r29, r21
      f4:	1a 02       	muls	r17, r26
      f6:	d5 02       	muls	r29, r21
      f8:	d5 02       	muls	r29, r21
      fa:	d5 02       	muls	r29, r21
      fc:	d5 02       	muls	r29, r21
      fe:	d5 02       	muls	r29, r21
     100:	d5 02       	muls	r29, r21
     102:	d5 02       	muls	r29, r21
     104:	1c 02       	muls	r17, r28
     106:	d5 02       	muls	r29, r21
     108:	d5 02       	muls	r29, r21
     10a:	d5 02       	muls	r29, r21
     10c:	d5 02       	muls	r29, r21
     10e:	d5 02       	muls	r29, r21
     110:	d5 02       	muls	r29, r21
     112:	d5 02       	muls	r29, r21
     114:	39 02       	muls	r19, r25
     116:	d5 02       	muls	r29, r21
     118:	d5 02       	muls	r29, r21
     11a:	d5 02       	muls	r29, r21
     11c:	d5 02       	muls	r29, r21
     11e:	d5 02       	muls	r29, r21
     120:	d5 02       	muls	r29, r21
     122:	d5 02       	muls	r29, r21
     124:	1c 02       	muls	r17, r28
     126:	d5 02       	muls	r29, r21
     128:	d5 02       	muls	r29, r21
     12a:	d5 02       	muls	r29, r21
     12c:	d5 02       	muls	r29, r21
     12e:	d5 02       	muls	r29, r21
     130:	d5 02       	muls	r29, r21
     132:	d5 02       	muls	r29, r21
     134:	39 02       	muls	r19, r25
     136:	d5 02       	muls	r29, r21
     138:	d5 02       	muls	r29, r21
     13a:	d5 02       	muls	r29, r21
     13c:	d5 02       	muls	r29, r21
     13e:	d5 02       	muls	r29, r21
     140:	d5 02       	muls	r29, r21
     142:	d5 02       	muls	r29, r21
     144:	d1 02       	muls	r29, r17
     146:	d5 02       	muls	r29, r21
     148:	d5 02       	muls	r29, r21
     14a:	d5 02       	muls	r29, r21
     14c:	d5 02       	muls	r29, r21
     14e:	d5 02       	muls	r29, r21
     150:	d5 02       	muls	r29, r21
     152:	d5 02       	muls	r29, r21
     154:	4d 02       	muls	r20, r29
     156:	d5 02       	muls	r29, r21
     158:	d5 02       	muls	r29, r21
     15a:	d5 02       	muls	r29, r21
     15c:	d5 02       	muls	r29, r21
     15e:	d5 02       	muls	r29, r21
     160:	d5 02       	muls	r29, r21
     162:	d5 02       	muls	r29, r21
     164:	70 02       	muls	r23, r16
     166:	d5 02       	muls	r29, r21
     168:	d5 02       	muls	r29, r21
     16a:	d5 02       	muls	r29, r21
     16c:	d5 02       	muls	r29, r21
     16e:	d5 02       	muls	r29, r21
     170:	d5 02       	muls	r29, r21
     172:	d5 02       	muls	r29, r21
     174:	41 02       	muls	r20, r17
     176:	d5 02       	muls	r29, r21
     178:	d5 02       	muls	r29, r21
     17a:	d5 02       	muls	r29, r21
     17c:	d5 02       	muls	r29, r21
     17e:	d5 02       	muls	r29, r21
     180:	d5 02       	muls	r29, r21
     182:	d5 02       	muls	r29, r21
     184:	5f 02       	muls	r21, r31
     186:	d5 02       	muls	r29, r21
     188:	d5 02       	muls	r29, r21
     18a:	d5 02       	muls	r29, r21
     18c:	d5 02       	muls	r29, r21
     18e:	d5 02       	muls	r29, r21
     190:	d5 02       	muls	r29, r21
     192:	d5 02       	muls	r29, r21
     194:	a7 02       	muls	r26, r23
     196:	d5 02       	muls	r29, r21
     198:	d5 02       	muls	r29, r21
     19a:	d5 02       	muls	r29, r21
     19c:	d5 02       	muls	r29, r21
     19e:	d5 02       	muls	r29, r21
     1a0:	d5 02       	muls	r29, r21
     1a2:	d5 02       	muls	r29, r21
     1a4:	a7 02       	muls	r26, r23
     1a6:	d5 02       	muls	r29, r21
     1a8:	d5 02       	muls	r29, r21
     1aa:	d5 02       	muls	r29, r21
     1ac:	d5 02       	muls	r29, r21
     1ae:	d5 02       	muls	r29, r21
     1b0:	d5 02       	muls	r29, r21
     1b2:	d5 02       	muls	r29, r21
     1b4:	a2 02       	muls	r26, r18
     1b6:	d5 02       	muls	r29, r21
     1b8:	d5 02       	muls	r29, r21
     1ba:	d5 02       	muls	r29, r21
     1bc:	d5 02       	muls	r29, r21
     1be:	d5 02       	muls	r29, r21
     1c0:	d5 02       	muls	r29, r21
     1c2:	d5 02       	muls	r29, r21
     1c4:	a2 02       	muls	r26, r18
     1c6:	d5 02       	muls	r29, r21
     1c8:	d5 02       	muls	r29, r21
     1ca:	d5 02       	muls	r29, r21
     1cc:	d5 02       	muls	r29, r21
     1ce:	d5 02       	muls	r29, r21
     1d0:	d5 02       	muls	r29, r21
     1d2:	d5 02       	muls	r29, r21
     1d4:	b2 02       	muls	r27, r18
     1d6:	d5 02       	muls	r29, r21
     1d8:	d5 02       	muls	r29, r21
     1da:	d5 02       	muls	r29, r21
     1dc:	d5 02       	muls	r29, r21
     1de:	d5 02       	muls	r29, r21
     1e0:	d5 02       	muls	r29, r21
     1e2:	d5 02       	muls	r29, r21
     1e4:	c7 02       	muls	r28, r23
     1e6:	d5 02       	muls	r29, r21
     1e8:	d5 02       	muls	r29, r21
     1ea:	d5 02       	muls	r29, r21
     1ec:	d5 02       	muls	r29, r21
     1ee:	d5 02       	muls	r29, r21
     1f0:	d5 02       	muls	r29, r21
     1f2:	d5 02       	muls	r29, r21
     1f4:	b2 02       	muls	r27, r18
     1f6:	d5 02       	muls	r29, r21
     1f8:	d5 02       	muls	r29, r21
     1fa:	d5 02       	muls	r29, r21
     1fc:	d5 02       	muls	r29, r21
     1fe:	d5 02       	muls	r29, r21
     200:	d5 02       	muls	r29, r21
     202:	d5 02       	muls	r29, r21
     204:	c7 02       	muls	r28, r23
     206:	d5 02       	muls	r29, r21
     208:	d5 02       	muls	r29, r21
     20a:	d5 02       	muls	r29, r21
     20c:	d5 02       	muls	r29, r21
     20e:	d5 02       	muls	r29, r21
     210:	d5 02       	muls	r29, r21
     212:	d5 02       	muls	r29, r21
     214:	cb 02       	muls	r28, r27
     216:	d5 02       	muls	r29, r21
     218:	d5 02       	muls	r29, r21
     21a:	d5 02       	muls	r29, r21
     21c:	d5 02       	muls	r29, r21
     21e:	d5 02       	muls	r29, r21
     220:	d5 02       	muls	r29, r21
     222:	d5 02       	muls	r29, r21
     224:	78 02       	muls	r23, r24
     226:	d5 02       	muls	r29, r21
     228:	d5 02       	muls	r29, r21
     22a:	d5 02       	muls	r29, r21
     22c:	d5 02       	muls	r29, r21
     22e:	d5 02       	muls	r29, r21
     230:	d5 02       	muls	r29, r21
     232:	d5 02       	muls	r29, r21
     234:	78 02       	muls	r23, r24
     236:	d5 02       	muls	r29, r21
     238:	d5 02       	muls	r29, r21
     23a:	d5 02       	muls	r29, r21
     23c:	d5 02       	muls	r29, r21
     23e:	d5 02       	muls	r29, r21
     240:	d5 02       	muls	r29, r21
     242:	d5 02       	muls	r29, r21
     244:	7a 02       	muls	r23, r26
     246:	d5 02       	muls	r29, r21
     248:	d5 02       	muls	r29, r21
     24a:	d5 02       	muls	r29, r21
     24c:	d5 02       	muls	r29, r21
     24e:	d5 02       	muls	r29, r21
     250:	d5 02       	muls	r29, r21
     252:	d5 02       	muls	r29, r21
     254:	8a 02       	muls	r24, r26
     256:	d5 02       	muls	r29, r21
     258:	d5 02       	muls	r29, r21
     25a:	d5 02       	muls	r29, r21
     25c:	d5 02       	muls	r29, r21
     25e:	d5 02       	muls	r29, r21
     260:	d5 02       	muls	r29, r21
     262:	d5 02       	muls	r29, r21
     264:	9e 02       	muls	r25, r30

00000266 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     266:	02 ec       	ldi	r16, 0xC2	; 194
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	fa ee       	ldi	r31, 0xEA	; 234
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	fe d1       	rcall	.+1020   	; 0x69e <uxListRemove>
     2a2:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <uxCurrentNumberOfTasks>
     2ac:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5c d0       	rcall	.+184    	; 0x378 <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5a d0       	rcall	.+180    	; 0x378 <vPortFree>
     2c4:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	48 d6       	rcall	.+3216   	; 0xf66 <vPortYield>
     2d6:	5f d0       	rcall	.+190    	; 0x396 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	e6 e7       	ldi	r30, 0x76	; 118
     2f2:	fa e2       	ldi	r31, 0x2A	; 42
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	a2 38       	cpi	r26, 0x82	; 130
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	24 e0       	ldi	r18, 0x04	; 4
     306:	a2 e8       	ldi	r26, 0x82	; 130
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a3 3b       	cpi	r26, 0xB3	; 179
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	3b d4       	rcall	.+2166   	; 0xb8c <main>
     316:	0c 94 39 15 	jmp	0x2a72	; 0x2a72 <_exit>

0000031a <__bad_interrupt>:
     31a:	72 ce       	rjmp	.-796    	; 0x0 <__vectors>

0000031c <system_tick>:
     31c:	8f 93       	push	r24
     31e:	8f b7       	in	r24, 0x3f	; 63
     320:	8f 93       	push	r24
     322:	f8 94       	cli
     324:	80 91 af 04 	lds	r24, 0x04AF	; 0x8004af <__system_time>
     328:	8f 5f       	subi	r24, 0xFF	; 255
     32a:	80 93 af 04 	sts	0x04AF, r24	; 0x8004af <__system_time>
     32e:	80 91 b0 04 	lds	r24, 0x04B0	; 0x8004b0 <__system_time+0x1>
     332:	8f 4f       	sbci	r24, 0xFF	; 255
     334:	80 93 b0 04 	sts	0x04B0, r24	; 0x8004b0 <__system_time+0x1>
     338:	80 91 b1 04 	lds	r24, 0x04B1	; 0x8004b1 <__system_time+0x2>
     33c:	8f 4f       	sbci	r24, 0xFF	; 255
     33e:	80 93 b1 04 	sts	0x04B1, r24	; 0x8004b1 <__system_time+0x2>
     342:	80 91 b2 04 	lds	r24, 0x04B2	; 0x8004b2 <__system_time+0x3>
     346:	8f 4f       	sbci	r24, 0xFF	; 255
     348:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <__system_time+0x3>
     34c:	8f 91       	pop	r24
     34e:	8f bf       	out	0x3f, r24	; 63
     350:	8f 91       	pop	r24
     352:	08 95       	ret

00000354 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     35e:	ce 01       	movw	r24, r28
     360:	0e 94 d5 13 	call	0x27aa	; 0x27aa <malloc>
     364:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     366:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36a:	20 97       	sbiw	r28, 0x00	; 0
     36c:	09 f4       	brne	.+2      	; 0x370 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     36e:	2c d0       	rcall	.+88     	; 0x3c8 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     370:	ce 01       	movw	r24, r28
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
	if( pv )
     37c:	00 97       	sbiw	r24, 0x00	; 0
     37e:	41 f0       	breq	.+16     	; 0x390 <vPortFree+0x18>
     380:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     382:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vTaskSuspendAll>
		{
			free( pv );
     386:	ce 01       	movw	r24, r28
     388:	0e 94 6d 14 	call	0x28da	; 0x28da <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38c:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <xTaskResumeAll>
	}
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39c:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a0:	80 b7       	in	r24, 0x30	; 48
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a6:	80 b7       	in	r24, 0x30	; 48
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ac:	83 b7       	in	r24, 0x33	; 51
     3ae:	81 7f       	andi	r24, 0xF1	; 241
     3b0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0

	sleep_enable();
     3b8:	83 b7       	in	r24, 0x33	; 51
     3ba:	81 60       	ori	r24, 0x01	; 1
     3bc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3be:	0f 90       	pop	r0
     3c0:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c2:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c4:	13 be       	out	0x33, r1	; 51
     3c6:	08 95       	ret

000003c8 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3ca:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3cc:	83 ed       	ldi	r24, 0xD3	; 211
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <vApplicationMallocFailedHook+0x8>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <vApplicationMallocFailedHook+0xe>
     3d6:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3d8:	1f 9a       	sbi	0x03, 7	; 3
     3da:	f8 cf       	rjmp	.-16     	; 0x3cc <vApplicationMallocFailedHook+0x4>

000003dc <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3dc:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3de:	2f 9a       	sbi	0x05, 7	; 5
     3e0:	2f e7       	ldi	r18, 0x7F	; 127
     3e2:	8a e1       	ldi	r24, 0x1A	; 26
     3e4:	96 e0       	ldi	r25, 0x06	; 6
     3e6:	21 50       	subi	r18, 0x01	; 1
     3e8:	80 40       	sbci	r24, 0x00	; 0
     3ea:	90 40       	sbci	r25, 0x00	; 0
     3ec:	e1 f7       	brne	.-8      	; 0x3e6 <vApplicationStackOverflowHook+0xa>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <vApplicationStackOverflowHook+0x14>
     3f0:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f2:	1f 9a       	sbi	0x03, 7	; 3
     3f4:	f5 cf       	rjmp	.-22     	; 0x3e0 <vApplicationStackOverflowHook+0x4>

000003f6 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f6:	1f 92       	push	r1
     3f8:	0f 92       	push	r0
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	0b b6       	in	r0, 0x3b	; 59
     402:	0f 92       	push	r0
     404:	2f 93       	push	r18
     406:	3f 93       	push	r19
     408:	8f 93       	push	r24
     40a:	9f 93       	push	r25
     40c:	af 93       	push	r26
     40e:	bf 93       	push	r27
     410:	ef 93       	push	r30
     412:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     414:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     418:	8e 2f       	mov	r24, r30
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	38 97       	sbiw	r30, 0x08	; 8
     420:	e1 3c       	cpi	r30, 0xC1	; 193
     422:	f1 05       	cpc	r31, r1
     424:	08 f0       	brcs	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	c1 c0       	rjmp	.+386    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     428:	88 27       	eor	r24, r24
     42a:	ee 58       	subi	r30, 0x8E	; 142
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	8f 4f       	sbci	r24, 0xFF	; 255
     430:	0c 94 b4 13 	jmp	0x2768	; 0x2768 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     434:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     438:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     43c:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     440:	e8 17       	cp	r30, r24
     442:	70 f4       	brcc	.+28     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	8e 0f       	add	r24, r30
     448:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	ea 57       	subi	r30, 0x7A	; 122
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     458:	85 e8       	ldi	r24, 0x85	; 133
     45a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     45e:	ac c0       	rjmp	.+344    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     460:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     464:	81 60       	ori	r24, 0x01	; 1
     466:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46a:	84 e9       	ldi	r24, 0x94	; 148
     46c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     470:	a3 c0       	rjmp	.+326    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     476:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47a:	85 ee       	ldi	r24, 0xE5	; 229
     47c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     480:	9b c0       	rjmp	.+310    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     482:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e 0f       	add	r24, r30
     48a:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     492:	f0 e0       	ldi	r31, 0x00	; 0
     494:	ea 57       	subi	r30, 0x7A	; 122
     496:	fd 4f       	sbci	r31, 0xFD	; 253
     498:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49a:	20 91 82 02 	lds	r18, 0x0282	; 0x800282 <__data_end>
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	28 17       	cp	r18, r24
     4aa:	39 07       	cpc	r19, r25
     4ac:	24 f4       	brge	.+8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4ae:	85 ec       	ldi	r24, 0xC5	; 197
     4b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b4:	81 c0       	rjmp	.+258    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b6:	85 e8       	ldi	r24, 0x85	; 133
     4b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4bc:	7d c0       	rjmp	.+250    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4be:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c2:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	ea 57       	subi	r30, 0x7A	; 122
     4ca:	fd 4f       	sbci	r31, 0xFD	; 253
     4cc:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4ce:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     4d2:	81 60       	ori	r24, 0x01	; 1
     4d4:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4de:	6c c0       	rjmp	.+216    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e4:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4e8:	85 ed       	ldi	r24, 0xD5	; 213
     4ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4ee:	64 c0       	rjmp	.+200    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f0:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f4:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     4f8:	81 e0       	ldi	r24, 0x01	; 1
     4fa:	8e 0f       	add	r24, r30
     4fc:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	ea 57       	subi	r30, 0x7A	; 122
     504:	fd 4f       	sbci	r31, 0xFD	; 253
     506:	80 81       	ld	r24, Z
     508:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50c:	85 ec       	ldi	r24, 0xC5	; 197
     50e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     512:	52 c0       	rjmp	.+164    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     514:	90 91 82 02 	lds	r25, 0x0282	; 0x800282 <__data_end>
     518:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     51c:	98 13       	cpse	r25, r24
     51e:	06 c0       	rjmp	.+12     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     520:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     524:	81 60       	ori	r24, 0x01	; 1
     526:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     530:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53a:	3e c0       	rjmp	.+124    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53c:	85 ec       	ldi	r24, 0xC5	; 197
     53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     544:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     548:	84 60       	ori	r24, 0x04	; 4
     54a:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     54e:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     558:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55c:	85 ec       	ldi	r24, 0xC5	; 197
     55e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     564:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e 0f       	add	r24, r30
     56c:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     570:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	ea 57       	subi	r30, 0x7A	; 122
     578:	fd 4f       	sbci	r31, 0xFD	; 253
     57a:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57c:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     580:	81 60       	ori	r24, 0x01	; 1
     582:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     586:	85 ec       	ldi	r24, 0xC5	; 197
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58c:	15 c0       	rjmp	.+42     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     58e:	85 e8       	ldi	r24, 0x85	; 133
     590:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     594:	11 c0       	rjmp	.+34     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     596:	84 e0       	ldi	r24, 0x04	; 4
     598:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a2:	85 ee       	ldi	r24, 0xE5	; 229
     5a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5a8:	07 c0       	rjmp	.+14     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5aa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ae:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b2:	85 ed       	ldi	r24, 0xD5	; 213
     5b4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	3f 91       	pop	r19
     5c6:	2f 91       	pop	r18
     5c8:	0f 90       	pop	r0
     5ca:	0b be       	out	0x3b, r0	; 59
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	03 96       	adiw	r24, 0x03	; 3
     5da:	92 83       	std	Z+2, r25	; 0x02
     5dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5de:	2f ef       	ldi	r18, 0xFF	; 255
     5e0:	3f ef       	ldi	r19, 0xFF	; 255
     5e2:	34 83       	std	Z+4, r19	; 0x04
     5e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e6:	96 83       	std	Z+6, r25	; 0x06
     5e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ea:	90 87       	std	Z+8, r25	; 0x08
     5ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5ee:	10 82       	st	Z, r1
     5f0:	08 95       	ret

000005f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f2:	fc 01       	movw	r30, r24
     5f4:	11 86       	std	Z+9, r1	; 0x09
     5f6:	10 86       	std	Z+8, r1	; 0x08
     5f8:	08 95       	ret

000005fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	9c 01       	movw	r18, r24
     600:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     602:	dc 01       	movw	r26, r24
     604:	11 96       	adiw	r26, 0x01	; 1
     606:	cd 91       	ld	r28, X+
     608:	dc 91       	ld	r29, X
     60a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60c:	d3 83       	std	Z+3, r29	; 0x03
     60e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     610:	8c 81       	ldd	r24, Y+4	; 0x04
     612:	9d 81       	ldd	r25, Y+5	; 0x05
     614:	95 83       	std	Z+5, r25	; 0x05
     616:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	dc 01       	movw	r26, r24
     61e:	13 96       	adiw	r26, 0x03	; 3
     620:	7c 93       	st	X, r23
     622:	6e 93       	st	-X, r22
     624:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     626:	7d 83       	std	Y+5, r23	; 0x05
     628:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	31 87       	std	Z+9, r19	; 0x09
     62c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	f9 01       	movw	r30, r18
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     642:	48 81       	ld	r20, Y
     644:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     646:	4f 3f       	cpi	r20, 0xFF	; 255
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	52 07       	cpc	r21, r18
     64c:	21 f4       	brne	.+8      	; 0x656 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     64e:	fc 01       	movw	r30, r24
     650:	a7 81       	ldd	r26, Z+7	; 0x07
     652:	b0 85       	ldd	r27, Z+8	; 0x08
     654:	0d c0       	rjmp	.+26     	; 0x670 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     656:	dc 01       	movw	r26, r24
     658:	13 96       	adiw	r26, 0x03	; 3
     65a:	01 c0       	rjmp	.+2      	; 0x65e <vListInsert+0x22>
     65c:	df 01       	movw	r26, r30
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	ed 91       	ld	r30, X+
     662:	fc 91       	ld	r31, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	20 81       	ld	r18, Z
     668:	31 81       	ldd	r19, Z+1	; 0x01
     66a:	42 17       	cp	r20, r18
     66c:	53 07       	cpc	r21, r19
     66e:	b0 f7       	brcc	.-20     	; 0x65c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     670:	12 96       	adiw	r26, 0x02	; 2
     672:	ed 91       	ld	r30, X+
     674:	fc 91       	ld	r31, X
     676:	13 97       	sbiw	r26, 0x03	; 3
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67c:	d5 83       	std	Z+5, r29	; 0x05
     67e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     680:	bd 83       	std	Y+5, r27	; 0x05
     682:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     684:	13 96       	adiw	r26, 0x03	; 3
     686:	dc 93       	st	X, r29
     688:	ce 93       	st	-X, r28
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68c:	99 87       	std	Y+9, r25	; 0x09
     68e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     690:	fc 01       	movw	r30, r24
     692:	20 81       	ld	r18, Z
     694:	2f 5f       	subi	r18, 0xFF	; 255
     696:	20 83       	st	Z, r18
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a4:	a0 85       	ldd	r26, Z+8	; 0x08
     6a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6a8:	c2 81       	ldd	r28, Z+2	; 0x02
     6aa:	d3 81       	ldd	r29, Z+3	; 0x03
     6ac:	84 81       	ldd	r24, Z+4	; 0x04
     6ae:	95 81       	ldd	r25, Z+5	; 0x05
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b4:	c4 81       	ldd	r28, Z+4	; 0x04
     6b6:	d5 81       	ldd	r29, Z+5	; 0x05
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	9b 83       	std	Y+3, r25	; 0x03
     6be:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2
     6c8:	e8 17       	cp	r30, r24
     6ca:	f9 07       	cpc	r31, r25
     6cc:	31 f4       	brne	.+12     	; 0x6da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6ce:	84 81       	ldd	r24, Z+4	; 0x04
     6d0:	95 81       	ldd	r25, Z+5	; 0x05
     6d2:	12 96       	adiw	r26, 0x02	; 2
     6d4:	9c 93       	st	X, r25
     6d6:	8e 93       	st	-X, r24
     6d8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6da:	11 86       	std	Z+9, r1	; 0x09
     6dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6de:	8c 91       	ld	r24, X
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <initQ>:
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     6ea:	40 e0       	ldi	r20, 0x00	; 0
     6ec:	62 e0       	ldi	r22, 0x02	; 2
     6ee:	8a e0       	ldi	r24, 0x0A	; 10
     6f0:	1c d6       	rcall	.+3128   	; 0x132a <xQueueGenericCreate>
     6f2:	90 93 1b 04 	sts	0x041B, r25	; 0x80041b <sonarAfstand+0x1>
     6f6:	80 93 1a 04 	sts	0x041A, r24	; 0x80041a <sonarAfstand>
     6fa:	89 2b       	or	r24, r25
     6fc:	41 f4       	brne	.+16     	; 0x70e <initQ+0x24>
     6fe:	40 e0       	ldi	r20, 0x00	; 0
     700:	62 e0       	ldi	r22, 0x02	; 2
     702:	8a e0       	ldi	r24, 0x0A	; 10
     704:	12 d6       	rcall	.+3108   	; 0x132a <xQueueGenericCreate>
     706:	90 93 1b 04 	sts	0x041B, r25	; 0x80041b <sonarAfstand+0x1>
     70a:	80 93 1a 04 	sts	0x041A, r24	; 0x80041a <sonarAfstand>
     70e:	40 e0       	ldi	r20, 0x00	; 0
     710:	62 e0       	ldi	r22, 0x02	; 2
     712:	8a e0       	ldi	r24, 0x0A	; 10
     714:	0a d6       	rcall	.+3092   	; 0x132a <xQueueGenericCreate>
     716:	90 93 19 04 	sts	0x0419, r25	; 0x800419 <servoHoek+0x1>
     71a:	80 93 18 04 	sts	0x0418, r24	; 0x800418 <servoHoek>
     71e:	89 2b       	or	r24, r25
     720:	41 f4       	brne	.+16     	; 0x732 <initQ+0x48>
     722:	40 e0       	ldi	r20, 0x00	; 0
     724:	62 e0       	ldi	r22, 0x02	; 2
     726:	8a e0       	ldi	r24, 0x0A	; 10
     728:	00 d6       	rcall	.+3072   	; 0x132a <xQueueGenericCreate>
     72a:	90 93 19 04 	sts	0x0419, r25	; 0x800419 <servoHoek+0x1>
     72e:	80 93 18 04 	sts	0x0418, r24	; 0x800418 <servoHoek>
     732:	08 95       	ret

00000734 <UART_Init>:
     734:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     738:	87 e6       	ldi	r24, 0x67	; 103
     73a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     73e:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     742:	86 e0       	ldi	r24, 0x06	; 6
     744:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     748:	88 e1       	ldi	r24, 0x18	; 24
     74a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     74e:	08 95       	ret

00000750 <UART_Transmit>:
     750:	e0 ec       	ldi	r30, 0xC0	; 192
     752:	f0 e0       	ldi	r31, 0x00	; 0
     754:	90 81       	ld	r25, Z
     756:	95 ff       	sbrs	r25, 5
     758:	fd cf       	rjmp	.-6      	; 0x754 <UART_Transmit+0x4>
     75a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     75e:	08 95       	ret

00000760 <UART_Transmit_String>:
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	88 81       	ld	r24, Y
     768:	88 23       	and	r24, r24
     76a:	29 f0       	breq	.+10     	; 0x776 <UART_Transmit_String+0x16>
     76c:	21 96       	adiw	r28, 0x01	; 1
     76e:	f0 df       	rcall	.-32     	; 0x750 <UART_Transmit>
     770:	89 91       	ld	r24, Y+
     772:	81 11       	cpse	r24, r1
     774:	fc cf       	rjmp	.-8      	; 0x76e <UART_Transmit_String+0xe>
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	08 95       	ret

0000077c <UART_Transmit_Integer>:
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
     784:	61 97       	sbiw	r28, 0x11	; 17
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	f8 94       	cli
     78a:	de bf       	out	0x3e, r29	; 62
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	cd bf       	out	0x3d, r28	; 61
     790:	dc 01       	movw	r26, r24
     792:	cb 01       	movw	r24, r22
     794:	4a e0       	ldi	r20, 0x0A	; 10
     796:	be 01       	movw	r22, r28
     798:	6f 5f       	subi	r22, 0xFF	; 255
     79a:	7f 4f       	sbci	r23, 0xFF	; 255
     79c:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <__itoa_ncheck>
     7a0:	ce 01       	movw	r24, r28
     7a2:	01 96       	adiw	r24, 0x01	; 1
     7a4:	dd df       	rcall	.-70     	; 0x760 <UART_Transmit_String>
     7a6:	61 96       	adiw	r28, 0x11	; 17
     7a8:	0f b6       	in	r0, 0x3f	; 63
     7aa:	f8 94       	cli
     7ac:	de bf       	out	0x3e, r29	; 62
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	cd bf       	out	0x3d, r28	; 61
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	08 95       	ret

000007b8 <servoTaak>:
     7b8:	0a e8       	ldi	r16, 0x8A	; 138
     7ba:	10 e0       	ldi	r17, 0x00	; 0
     7bc:	c0 e0       	ldi	r28, 0x00	; 0
     7be:	d0 e0       	ldi	r29, 0x00	; 0
     7c0:	20 e0       	ldi	r18, 0x00	; 0
     7c2:	4f ef       	ldi	r20, 0xFF	; 255
     7c4:	5f ef       	ldi	r21, 0xFF	; 255
     7c6:	60 e0       	ldi	r22, 0x00	; 0
     7c8:	70 e0       	ldi	r23, 0x00	; 0
     7ca:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     7ce:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     7d2:	68 d6       	rcall	.+3280   	; 0x14a4 <xQueueGenericReceive>
     7d4:	d0 93 17 04 	sts	0x0417, r29	; 0x800417 <hoek+0x1>
     7d8:	c0 93 16 04 	sts	0x0416, r28	; 0x800416 <hoek>
     7dc:	ce 01       	movw	r24, r28
     7de:	99 27       	eor	r25, r25
     7e0:	22 27       	eor	r18, r18
     7e2:	33 27       	eor	r19, r19
     7e4:	28 1b       	sub	r18, r24
     7e6:	39 0b       	sbc	r19, r25
     7e8:	22 0f       	add	r18, r18
     7ea:	33 1f       	adc	r19, r19
     7ec:	22 0f       	add	r18, r18
     7ee:	33 1f       	adc	r19, r19
     7f0:	22 0f       	add	r18, r18
     7f2:	33 1f       	adc	r19, r19
     7f4:	82 0f       	add	r24, r18
     7f6:	93 1f       	adc	r25, r19
     7f8:	95 5b       	subi	r25, 0xB5	; 181
     7fa:	f8 01       	movw	r30, r16
     7fc:	91 83       	std	Z+1, r25	; 0x01
     7fe:	80 83       	st	Z, r24
     800:	ff ef       	ldi	r31, 0xFF	; 255
     802:	29 e6       	ldi	r18, 0x69	; 105
     804:	88 e1       	ldi	r24, 0x18	; 24
     806:	f1 50       	subi	r31, 0x01	; 1
     808:	20 40       	sbci	r18, 0x00	; 0
     80a:	80 40       	sbci	r24, 0x00	; 0
     80c:	e1 f7       	brne	.-8      	; 0x806 <servoTaak+0x4e>
     80e:	00 c0       	rjmp	.+0      	; 0x810 <servoTaak+0x58>
     810:	00 00       	nop
     812:	81 e2       	ldi	r24, 0x21	; 33
     814:	92 e0       	ldi	r25, 0x02	; 2
     816:	a4 df       	rcall	.-184    	; 0x760 <UART_Transmit_String>
     818:	60 91 16 04 	lds	r22, 0x0416	; 0x800416 <hoek>
     81c:	70 91 17 04 	lds	r23, 0x0417	; 0x800417 <hoek+0x1>
     820:	07 2e       	mov	r0, r23
     822:	00 0c       	add	r0, r0
     824:	88 0b       	sbc	r24, r24
     826:	99 0b       	sbc	r25, r25
     828:	a9 df       	rcall	.-174    	; 0x77c <UART_Transmit_Integer>
     82a:	88 e2       	ldi	r24, 0x28	; 40
     82c:	92 e0       	ldi	r25, 0x02	; 2
     82e:	98 df       	rcall	.-208    	; 0x760 <UART_Transmit_String>
     830:	60 91 1d 04 	lds	r22, 0x041D	; 0x80041d <afstand>
     834:	70 91 1e 04 	lds	r23, 0x041E	; 0x80041e <afstand+0x1>
     838:	07 2e       	mov	r0, r23
     83a:	00 0c       	add	r0, r0
     83c:	88 0b       	sbc	r24, r24
     83e:	99 0b       	sbc	r25, r25
     840:	9d df       	rcall	.-198    	; 0x77c <UART_Transmit_Integer>
     842:	83 e3       	ldi	r24, 0x33	; 51
     844:	92 e0       	ldi	r25, 0x02	; 2
     846:	8c df       	rcall	.-232    	; 0x760 <UART_Transmit_String>
     848:	60 91 12 04 	lds	r22, 0x0412	; 0x800412 <temperatuur>
     84c:	70 91 13 04 	lds	r23, 0x0413	; 0x800413 <temperatuur+0x1>
     850:	07 2e       	mov	r0, r23
     852:	00 0c       	add	r0, r0
     854:	88 0b       	sbc	r24, r24
     856:	99 0b       	sbc	r25, r25
     858:	91 df       	rcall	.-222    	; 0x77c <UART_Transmit_Integer>
     85a:	82 e4       	ldi	r24, 0x42	; 66
     85c:	92 e0       	ldi	r25, 0x02	; 2
     85e:	80 df       	rcall	.-256    	; 0x760 <UART_Transmit_String>
     860:	60 91 14 04 	lds	r22, 0x0414	; 0x800414 <humidity>
     864:	70 91 15 04 	lds	r23, 0x0415	; 0x800415 <humidity+0x1>
     868:	07 2e       	mov	r0, r23
     86a:	00 0c       	add	r0, r0
     86c:	88 0b       	sbc	r24, r24
     86e:	99 0b       	sbc	r25, r25
     870:	85 df       	rcall	.-246    	; 0x77c <UART_Transmit_Integer>
     872:	8e e4       	ldi	r24, 0x4E	; 78
     874:	92 e0       	ldi	r25, 0x02	; 2
     876:	74 df       	rcall	.-280    	; 0x760 <UART_Transmit_String>
     878:	20 e0       	ldi	r18, 0x00	; 0
     87a:	40 e0       	ldi	r20, 0x00	; 0
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     886:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     88a:	7a d5       	rcall	.+2804   	; 0x1380 <xQueueGenericSend>
     88c:	6b 96       	adiw	r28, 0x1b	; 27
     88e:	c3 3f       	cpi	r28, 0xF3	; 243
     890:	d1 05       	cpc	r29, r1
     892:	09 f0       	breq	.+2      	; 0x896 <servoTaak+0xde>
     894:	95 cf       	rjmp	.-214    	; 0x7c0 <servoTaak+0x8>
     896:	92 cf       	rjmp	.-220    	; 0x7bc <servoTaak+0x4>

00000898 <__vector_25>:
     898:	1f 92       	push	r1
     89a:	0f 92       	push	r0
     89c:	0f b6       	in	r0, 0x3f	; 63
     89e:	0f 92       	push	r0
     8a0:	11 24       	eor	r1, r1
     8a2:	0b b6       	in	r0, 0x3b	; 59
     8a4:	0f 92       	push	r0
     8a6:	2f 93       	push	r18
     8a8:	3f 93       	push	r19
     8aa:	4f 93       	push	r20
     8ac:	5f 93       	push	r21
     8ae:	6f 93       	push	r22
     8b0:	7f 93       	push	r23
     8b2:	8f 93       	push	r24
     8b4:	9f 93       	push	r25
     8b6:	af 93       	push	r26
     8b8:	bf 93       	push	r27
     8ba:	ef 93       	push	r30
     8bc:	ff 93       	push	r31
     8be:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     8c2:	80 93 1c 04 	sts	0x041C, r24	; 0x80041c <ontvang>
     8c6:	44 df       	rcall	.-376    	; 0x750 <UART_Transmit>
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	90 93 a9 02 	sts	0x02A9, r25	; 0x8002a9 <state+0x1>
     8d0:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <state>
     8d4:	ff 91       	pop	r31
     8d6:	ef 91       	pop	r30
     8d8:	bf 91       	pop	r27
     8da:	af 91       	pop	r26
     8dc:	9f 91       	pop	r25
     8de:	8f 91       	pop	r24
     8e0:	7f 91       	pop	r23
     8e2:	6f 91       	pop	r22
     8e4:	5f 91       	pop	r21
     8e6:	4f 91       	pop	r20
     8e8:	3f 91       	pop	r19
     8ea:	2f 91       	pop	r18
     8ec:	0f 90       	pop	r0
     8ee:	0b be       	out	0x3b, r0	; 59
     8f0:	0f 90       	pop	r0
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	0f 90       	pop	r0
     8f6:	1f 90       	pop	r1
     8f8:	18 95       	reti

000008fa <INT1_init>:
     8fa:	e8 e6       	ldi	r30, 0x68	; 104
     8fc:	f0 e0       	ldi	r31, 0x00	; 0
     8fe:	80 81       	ld	r24, Z
     900:	81 60       	ori	r24, 0x01	; 1
     902:	80 83       	st	Z, r24
     904:	eb e6       	ldi	r30, 0x6B	; 107
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	80 81       	ld	r24, Z
     90a:	82 60       	ori	r24, 0x02	; 2
     90c:	80 83       	st	Z, r24
     90e:	08 95       	ret

00000910 <__vector_9>:
     910:	1f 92       	push	r1
     912:	0f 92       	push	r0
     914:	0f b6       	in	r0, 0x3f	; 63
     916:	0f 92       	push	r0
     918:	11 24       	eor	r1, r1
     91a:	0b b6       	in	r0, 0x3b	; 59
     91c:	0f 92       	push	r0
     91e:	2f 93       	push	r18
     920:	3f 93       	push	r19
     922:	4f 93       	push	r20
     924:	5f 93       	push	r21
     926:	6f 93       	push	r22
     928:	7f 93       	push	r23
     92a:	8f 93       	push	r24
     92c:	9f 93       	push	r25
     92e:	af 93       	push	r26
     930:	bf 93       	push	r27
     932:	ef 93       	push	r30
     934:	ff 93       	push	r31
     936:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <running>
     93a:	88 23       	and	r24, r24
     93c:	d1 f1       	breq	.+116    	; 0x9b2 <__vector_9+0xa2>
     93e:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <up>
     942:	81 11       	cpse	r24, r1
     944:	10 c0       	rjmp	.+32     	; 0x966 <__vector_9+0x56>
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <up>
     94c:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <timerCounter>
     950:	10 92 a3 02 	sts	0x02A3, r1	; 0x8002a3 <timerCounter+0x1>
     954:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <timerCounter+0x2>
     958:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <timerCounter+0x3>
     95c:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     960:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     964:	26 c0       	rjmp	.+76     	; 0x9b2 <__vector_9+0xa2>
     966:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <up>
     96a:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <timerCounter>
     96e:	30 91 a3 02 	lds	r19, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     972:	40 91 a4 02 	lds	r20, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     976:	50 91 a5 02 	lds	r21, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     97a:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     97e:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     982:	af ef       	ldi	r26, 0xFF	; 255
     984:	bf ef       	ldi	r27, 0xFF	; 255
     986:	0e 94 cb 13 	call	0x2796	; 0x2796 <__muluhisi3>
     98a:	6e 0f       	add	r22, r30
     98c:	7f 1f       	adc	r23, r31
     98e:	81 1d       	adc	r24, r1
     990:	91 1d       	adc	r25, r1
     992:	24 e7       	ldi	r18, 0x74	; 116
     994:	30 e0       	ldi	r19, 0x00	; 0
     996:	40 e0       	ldi	r20, 0x00	; 0
     998:	50 e0       	ldi	r21, 0x00	; 0
     99a:	0e 94 92 13 	call	0x2724	; 0x2724 <__udivmodsi4>
     99e:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <result>
     9a2:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <result+0x1>
     9a6:	40 93 a0 02 	sts	0x02A0, r20	; 0x8002a0 <result+0x2>
     9aa:	50 93 a1 02 	sts	0x02A1, r21	; 0x8002a1 <result+0x3>
     9ae:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <running>
     9b2:	ff 91       	pop	r31
     9b4:	ef 91       	pop	r30
     9b6:	bf 91       	pop	r27
     9b8:	af 91       	pop	r26
     9ba:	9f 91       	pop	r25
     9bc:	8f 91       	pop	r24
     9be:	7f 91       	pop	r23
     9c0:	6f 91       	pop	r22
     9c2:	5f 91       	pop	r21
     9c4:	4f 91       	pop	r20
     9c6:	3f 91       	pop	r19
     9c8:	2f 91       	pop	r18
     9ca:	0f 90       	pop	r0
     9cc:	0b be       	out	0x3b, r0	; 59
     9ce:	0f 90       	pop	r0
     9d0:	0f be       	out	0x3f, r0	; 63
     9d2:	0f 90       	pop	r0
     9d4:	1f 90       	pop	r1
     9d6:	18 95       	reti

000009d8 <pulse>:
     9d8:	28 98       	cbi	0x05, 0	; 5
     9da:	85 e0       	ldi	r24, 0x05	; 5
     9dc:	8a 95       	dec	r24
     9de:	f1 f7       	brne	.-4      	; 0x9dc <pulse+0x4>
     9e0:	00 00       	nop
     9e2:	28 9a       	sbi	0x05, 0	; 5
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <running>
     9ea:	85 e3       	ldi	r24, 0x35	; 53
     9ec:	8a 95       	dec	r24
     9ee:	f1 f7       	brne	.-4      	; 0x9ec <pulse+0x14>
     9f0:	00 00       	nop
     9f2:	28 98       	cbi	0x05, 0	; 5
     9f4:	08 95       	ret

000009f6 <sonarTaak>:
     9f6:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <running>
     9fa:	81 11       	cpse	r24, r1
     9fc:	fc cf       	rjmp	.-8      	; 0x9f6 <sonarTaak>
     9fe:	20 e0       	ldi	r18, 0x00	; 0
     a00:	4f ef       	ldi	r20, 0xFF	; 255
     a02:	5f ef       	ldi	r21, 0xFF	; 255
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     a0c:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     a10:	49 d5       	rcall	.+2706   	; 0x14a4 <xQueueGenericReceive>
     a12:	2f ef       	ldi	r18, 0xFF	; 255
     a14:	80 e7       	ldi	r24, 0x70	; 112
     a16:	92 e0       	ldi	r25, 0x02	; 2
     a18:	21 50       	subi	r18, 0x01	; 1
     a1a:	80 40       	sbci	r24, 0x00	; 0
     a1c:	90 40       	sbci	r25, 0x00	; 0
     a1e:	e1 f7       	brne	.-8      	; 0xa18 <sonarTaak+0x22>
     a20:	00 c0       	rjmp	.+0      	; 0xa22 <sonarTaak+0x2c>
     a22:	00 00       	nop
     a24:	d9 df       	rcall	.-78     	; 0x9d8 <pulse>
     a26:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <result>
     a2a:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <result+0x1>
     a2e:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <result+0x2>
     a32:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <result+0x3>
     a36:	90 93 1e 04 	sts	0x041E, r25	; 0x80041e <afstand+0x1>
     a3a:	80 93 1d 04 	sts	0x041D, r24	; 0x80041d <afstand>
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	40 e0       	ldi	r20, 0x00	; 0
     a42:	50 e0       	ldi	r21, 0x00	; 0
     a44:	60 e0       	ldi	r22, 0x00	; 0
     a46:	70 e0       	ldi	r23, 0x00	; 0
     a48:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     a4c:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     a50:	97 d4       	rcall	.+2350   	; 0x1380 <xQueueGenericSend>
     a52:	d1 cf       	rjmp	.-94     	; 0x9f6 <sonarTaak>

00000a54 <timer3_init>:
     a54:	e1 e9       	ldi	r30, 0x91	; 145
     a56:	f0 e0       	ldi	r31, 0x00	; 0
     a58:	80 81       	ld	r24, Z
     a5a:	82 60       	ori	r24, 0x02	; 2
     a5c:	80 83       	st	Z, r24
     a5e:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a62:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a66:	e1 e7       	ldi	r30, 0x71	; 113
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	80 81       	ld	r24, Z
     a6c:	81 60       	ori	r24, 0x01	; 1
     a6e:	80 83       	st	Z, r24
     a70:	08 95       	ret

00000a72 <__vector_35>:
     a72:	1f 92       	push	r1
     a74:	0f 92       	push	r0
     a76:	0f b6       	in	r0, 0x3f	; 63
     a78:	0f 92       	push	r0
     a7a:	11 24       	eor	r1, r1
     a7c:	0b b6       	in	r0, 0x3b	; 59
     a7e:	0f 92       	push	r0
     a80:	2f 93       	push	r18
     a82:	3f 93       	push	r19
     a84:	4f 93       	push	r20
     a86:	5f 93       	push	r21
     a88:	6f 93       	push	r22
     a8a:	7f 93       	push	r23
     a8c:	8f 93       	push	r24
     a8e:	9f 93       	push	r25
     a90:	af 93       	push	r26
     a92:	bf 93       	push	r27
     a94:	ef 93       	push	r30
     a96:	ff 93       	push	r31
     a98:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <up>
     a9c:	88 23       	and	r24, r24
     a9e:	e9 f1       	breq	.+122    	; 0xb1a <__vector_35+0xa8>
     aa0:	80 91 a2 02 	lds	r24, 0x02A2	; 0x8002a2 <timerCounter>
     aa4:	90 91 a3 02 	lds	r25, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     aa8:	a0 91 a4 02 	lds	r26, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     aac:	b0 91 a5 02 	lds	r27, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     ab0:	01 96       	adiw	r24, 0x01	; 1
     ab2:	a1 1d       	adc	r26, r1
     ab4:	b1 1d       	adc	r27, r1
     ab6:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <timerCounter>
     aba:	90 93 a3 02 	sts	0x02A3, r25	; 0x8002a3 <timerCounter+0x1>
     abe:	a0 93 a4 02 	sts	0x02A4, r26	; 0x8002a4 <timerCounter+0x2>
     ac2:	b0 93 a5 02 	sts	0x02A5, r27	; 0x8002a5 <timerCounter+0x3>
     ac6:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <timerCounter>
     aca:	30 91 a3 02 	lds	r19, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     ace:	40 91 a4 02 	lds	r20, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     ad2:	50 91 a5 02 	lds	r21, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     ad6:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     ada:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     ade:	af ef       	ldi	r26, 0xFF	; 255
     ae0:	bf ef       	ldi	r27, 0xFF	; 255
     ae2:	0e 94 cb 13 	call	0x2796	; 0x2796 <__muluhisi3>
     ae6:	dc 01       	movw	r26, r24
     ae8:	cb 01       	movw	r24, r22
     aea:	8e 0f       	add	r24, r30
     aec:	9f 1f       	adc	r25, r31
     aee:	a1 1d       	adc	r26, r1
     af0:	b1 1d       	adc	r27, r1
     af2:	81 30       	cpi	r24, 0x01	; 1
     af4:	94 4d       	sbci	r25, 0xD4	; 212
     af6:	a0 43       	sbci	r26, 0x30	; 48
     af8:	b1 05       	cpc	r27, r1
     afa:	78 f0       	brcs	.+30     	; 0xb1a <__vector_35+0xa8>
     afc:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <up>
     b00:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <running>
     b04:	8f ef       	ldi	r24, 0xFF	; 255
     b06:	9f ef       	ldi	r25, 0xFF	; 255
     b08:	dc 01       	movw	r26, r24
     b0a:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <result>
     b0e:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <result+0x1>
     b12:	a0 93 a0 02 	sts	0x02A0, r26	; 0x8002a0 <result+0x2>
     b16:	b0 93 a1 02 	sts	0x02A1, r27	; 0x8002a1 <result+0x3>
     b1a:	ff 91       	pop	r31
     b1c:	ef 91       	pop	r30
     b1e:	bf 91       	pop	r27
     b20:	af 91       	pop	r26
     b22:	9f 91       	pop	r25
     b24:	8f 91       	pop	r24
     b26:	7f 91       	pop	r23
     b28:	6f 91       	pop	r22
     b2a:	5f 91       	pop	r21
     b2c:	4f 91       	pop	r20
     b2e:	3f 91       	pop	r19
     b30:	2f 91       	pop	r18
     b32:	0f 90       	pop	r0
     b34:	0b be       	out	0x3b, r0	; 59
     b36:	0f 90       	pop	r0
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	0f 90       	pop	r0
     b3c:	1f 90       	pop	r1
     b3e:	18 95       	reti

00000b40 <initServo>:
}

void initServo()
{
	DDRB |= (1 << PB6);
     b40:	26 9a       	sbi	0x04, 6	; 4
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
     b42:	82 e3       	ldi	r24, 0x32	; 50
     b44:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = (1 << WGM13) | (1 << CS11);
     b48:	82 e1       	ldi	r24, 0x12	; 18
     b4a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	ICR1 = 20000;
     b4e:	80 e2       	ldi	r24, 0x20	; 32
     b50:	9e e4       	ldi	r25, 0x4E	; 78
     b52:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     b56:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	TCNT1 = 0;
     b5a:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     b5e:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	9b e4       	ldi	r25, 0x4B	; 75
     b66:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     b6a:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
	TCCR1B = (1 << WGM13) | (1 << CS11);
	ICR1 = 20000;
	TCNT1 = 0;
	turnServo(0);
	TIMSK1 |= (1 << 1);
     b6e:	ef e6       	ldi	r30, 0x6F	; 111
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	82 60       	ori	r24, 0x02	; 2
     b76:	80 83       	st	Z, r24
     b78:	08 95       	ret

00000b7a <init_master>:
}



void init_master() {
	TWSR = 0;
     b7a:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
     b7e:	88 e4       	ldi	r24, 0x48	; 72
     b80:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
	TWCR = (1<<TWEN);
     b84:	84 e0       	ldi	r24, 0x04	; 4
     b86:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     b8a:	08 95       	ret

00000b8c <main>:
//echo = digital pin 52
//servo = digital pin 12


int main() 
{
     b8c:	ef 92       	push	r14
     b8e:	ff 92       	push	r15
     b90:	0f 93       	push	r16
	sem = xSemaphoreCreateBinary();
     b92:	43 e0       	ldi	r20, 0x03	; 3
     b94:	60 e0       	ldi	r22, 0x00	; 0
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	c8 d3       	rcall	.+1936   	; 0x132a <xQueueGenericCreate>
     b9a:	90 93 11 03 	sts	0x0311, r25	; 0x800311 <sem+0x1>
     b9e:	80 93 10 03 	sts	0x0310, r24	; 0x800310 <sem>
	xSemaphoreGive(sem);
     ba2:	20 e0       	ldi	r18, 0x00	; 0
     ba4:	40 e0       	ldi	r20, 0x00	; 0
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	60 e0       	ldi	r22, 0x00	; 0
     baa:	70 e0       	ldi	r23, 0x00	; 0
     bac:	e9 d3       	rcall	.+2002   	; 0x1380 <xQueueGenericSend>
	DDRD|= 0x03;
     bae:	8a b1       	in	r24, 0x0a	; 10
     bb0:	83 60       	ori	r24, 0x03	; 3
	DDRB |= (1 << TRIGGER);											// Trigger pin
	UART_Init();
     bb2:	8a b9       	out	0x0a, r24	; 10
	INT1_init();
     bb4:	20 9a       	sbi	0x04, 0	; 4
	timer3_init();
     bb6:	be dd       	rcall	.-1156   	; 0x734 <UART_Init>
	initServo();
     bb8:	a0 de       	rcall	.-704    	; 0x8fa <INT1_init>
     bba:	4c df       	rcall	.-360    	; 0xa54 <timer3_init>
	sei();
     bbc:	c1 df       	rcall	.-126    	; 0xb40 <initServo>
	initQ();
     bbe:	78 94       	sei
     bc0:	94 dd       	rcall	.-1240   	; 0x6ea <initQ>
	init_master();
     bc2:	db df       	rcall	.-74     	; 0xb7a <init_master>
     bc4:	e1 2c       	mov	r14, r1
	// Replace with your application code

	//xTaskCreate(queueTaak,"Queue Taken",256,NULL,3,NULL);			//task voor lezen uit sonar queue en schrijven naar servo queue
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,3,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
     bc6:	f1 2c       	mov	r15, r1
     bc8:	03 e0       	ldi	r16, 0x03	; 3
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	40 e0       	ldi	r20, 0x00	; 0
     bd0:	51 e0       	ldi	r21, 0x01	; 1
     bd2:	61 e5       	ldi	r22, 0x51	; 81
     bd4:	72 e0       	ldi	r23, 0x02	; 2
     bd6:	8b ef       	ldi	r24, 0xFB	; 251
     bd8:	94 e0       	ldi	r25, 0x04	; 4
     bda:	cf d7       	rcall	.+3998   	; 0x1b7a <xTaskCreate>
     bdc:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,3,NULL);			//code van Joris & Benjamin
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	40 e0       	ldi	r20, 0x00	; 0
     be2:	51 e0       	ldi	r21, 0x01	; 1
     be4:	6e e5       	ldi	r22, 0x5E	; 94
     be6:	72 e0       	ldi	r23, 0x02	; 2
     be8:	8c ed       	ldi	r24, 0xDC	; 220
     bea:	93 e0       	ldi	r25, 0x03	; 3
     bec:	c6 d7       	rcall	.+3980   	; 0x1b7a <xTaskCreate>
     bee:	20 e0       	ldi	r18, 0x00	; 0
     bf0:	30 e0       	ldi	r19, 0x00	; 0
	xTaskCreate(temperatuurTaak,"temperatuur Sensor",256,NULL,3,NULL);
     bf2:	40 e0       	ldi	r20, 0x00	; 0
     bf4:	51 e0       	ldi	r21, 0x01	; 1
     bf6:	6a e6       	ldi	r22, 0x6A	; 106
     bf8:	72 e0       	ldi	r23, 0x02	; 2
     bfa:	8c e7       	ldi	r24, 0x7C	; 124
     bfc:	96 e0       	ldi	r25, 0x06	; 6
     bfe:	bd d7       	rcall	.+3962   	; 0x1b7a <xTaskCreate>
     c00:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <vTaskStartScheduler>

	vTaskStartScheduler();
     c04:	80 e0       	ldi	r24, 0x00	; 0
     c06:	90 e0       	ldi	r25, 0x00	; 0
}
     c08:	0f 91       	pop	r16
     c0a:	ff 90       	pop	r15
     c0c:	ef 90       	pop	r14
     c0e:	08 95       	ret

00000c10 <ontvangen>:
     c10:	ef 92       	push	r14
     c12:	ff 92       	push	r15
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
	TWCR = (1<<TWEN);
}

void ontvangen(uint8_t ad,uint8_t b[],uint8_t max) {
     c14:	0f 93       	push	r16
     c16:	1f 93       	push	r17
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
	uint8_t op[15];
	
	//	UART_Transmit('a');

	TWCR |= (1<<TWSTA);
     c1c:	ec eb       	ldi	r30, 0xBC	; 188
     c1e:	f0 e0       	ldi	r31, 0x00	; 0
     c20:	90 81       	ld	r25, Z
     c22:	90 62       	ori	r25, 0x20	; 32
     c24:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     c26:	90 81       	ld	r25, Z
     c28:	99 23       	and	r25, r25
     c2a:	ec f7       	brge	.-6      	; 0xc26 <ontvangen+0x16>
	op[0] = TWSR;
     c2c:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>

	
	//UART_Transmit('b');

	TWDR=(ad<<1)+1;
     c30:	88 0f       	add	r24, r24
     c32:	8f 5f       	subi	r24, 0xFF	; 255
     c34:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     c38:	84 e8       	ldi	r24, 0x84	; 132
     c3a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     c3e:	ec eb       	ldi	r30, 0xBC	; 188
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
     c44:	88 23       	and	r24, r24
     c46:	ec f7       	brge	.-6      	; 0xc42 <ontvangen+0x32>

	op[1] = TWSR;
     c48:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	b[0]=TWDR;
     c4c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     c50:	db 01       	movw	r26, r22
     c52:	8c 93       	st	X, r24
	
	uint8_t tel=0;
     c54:	90 e0       	ldi	r25, 0x00	; 0
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     c56:	50 e0       	ldi	r21, 0x00	; 0
     c58:	41 50       	subi	r20, 0x01	; 1
     c5a:	51 09       	sbc	r21, r1
			TWCR=(1<<TWINT)|(1<<TWEN);
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     c5c:	ec eb       	ldi	r30, 0xBC	; 188
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	0f 2e       	mov	r0, r31
     c62:	f4 ec       	ldi	r31, 0xC4	; 196
     c64:	ff 2e       	mov	r15, r31
     c66:	f0 2d       	mov	r31, r0
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
			TWCR=(1<<TWINT)|(1<<TWEN);
     c68:	0f 2e       	mov	r0, r31
     c6a:	f4 e8       	ldi	r31, 0x84	; 132
     c6c:	ef 2e       	mov	r14, r31
     c6e:	f0 2d       	mov	r31, r0
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
		//UART_Transmit('c3');
		op[tel] = TWSR;
     c70:	09 eb       	ldi	r16, 0xB9	; 185
     c72:	10 e0       	ldi	r17, 0x00	; 0
		b[tel]=TWDR;
     c74:	cb eb       	ldi	r28, 0xBB	; 187
     c76:	d0 e0       	ldi	r29, 0x00	; 0
	
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     c78:	29 2f       	mov	r18, r25
     c7a:	30 e0       	ldi	r19, 0x00	; 0
     c7c:	24 17       	cp	r18, r20
     c7e:	35 07       	cpc	r19, r21
     c80:	11 f4       	brne	.+4      	; 0xc86 <ontvangen+0x76>
			TWCR=(1<<TWINT)|(1<<TWEN);
     c82:	e0 82       	st	Z, r14
     c84:	01 c0       	rjmp	.+2      	; 0xc88 <ontvangen+0x78>
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     c86:	f0 82       	st	Z, r15
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
     c88:	80 81       	ld	r24, Z
     c8a:	88 23       	and	r24, r24
     c8c:	ec f7       	brge	.-6      	; 0xc88 <ontvangen+0x78>
		//UART_Transmit('c3');
		op[tel] = TWSR;
     c8e:	d8 01       	movw	r26, r16
     c90:	8c 91       	ld	r24, X
		b[tel]=TWDR;
     c92:	28 81       	ld	r18, Y
     c94:	db 01       	movw	r26, r22
     c96:	a9 0f       	add	r26, r25
     c98:	b1 1d       	adc	r27, r1
     c9a:	2c 93       	st	X, r18
	}while(op[tel++] == 0x50);
     c9c:	9f 5f       	subi	r25, 0xFF	; 255
     c9e:	80 35       	cpi	r24, 0x50	; 80
     ca0:	59 f3       	breq	.-42     	; 0xc78 <ontvangen+0x68>

	
	//UART_Transmit('d');

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     ca2:	84 e9       	ldi	r24, 0x94	; 148
     ca4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>

	//   for(uint8_t i=0;i<tel;++i) {
	//	 writeString("\n\r");writeInteger(op[i],16);
	//	 writeString(" data ");writeInteger(b[i],10);
	//   }
}
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	ff 90       	pop	r15
     cb2:	ef 90       	pop	r14
     cb4:	08 95       	ret

00000cb6 <verzenden>:

void verzenden(uint8_t ad,uint8_t b) {
	//  uint8_t op[5];

	TWCR |= (1<<TWSTA);
     cb6:	ec eb       	ldi	r30, 0xBC	; 188
     cb8:	f0 e0       	ldi	r31, 0x00	; 0
     cba:	90 81       	ld	r25, Z
     cbc:	90 62       	ori	r25, 0x20	; 32
     cbe:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     cc0:	90 81       	ld	r25, Z
     cc2:	99 23       	and	r25, r25
     cc4:	ec f7       	brge	.-6      	; 0xcc0 <verzenden+0xa>
	//   op[0] = TWSR;
	TWDR=(ad<<1);
     cc6:	88 0f       	add	r24, r24
     cc8:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     ccc:	84 e8       	ldi	r24, 0x84	; 132
     cce:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     cd2:	ec eb       	ldi	r30, 0xBC	; 188
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	80 81       	ld	r24, Z
     cd8:	88 23       	and	r24, r24
     cda:	ec f7       	brge	.-6      	; 0xcd6 <verzenden+0x20>
	//    op[1] = TWSR;

	TWDR=b;
     cdc:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     ce0:	84 e8       	ldi	r24, 0x84	; 132
     ce2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     ce6:	ec eb       	ldi	r30, 0xBC	; 188
     ce8:	f0 e0       	ldi	r31, 0x00	; 0
     cea:	80 81       	ld	r24, Z
     cec:	88 23       	and	r24, r24
     cee:	ec f7       	brge	.-6      	; 0xcea <verzenden+0x34>
	//  op[2] = TWSR;

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     cf0:	84 e9       	ldi	r24, 0x94	; 148
     cf2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     cf6:	08 95       	ret

00000cf8 <temperatuurTaak>:

	vTaskStartScheduler();
}


void temperatuurTaak(){
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	1f 92       	push	r1
     cfe:	1f 92       	push	r1
     d00:	cd b7       	in	r28, 0x3d	; 61
     d02:	de b7       	in	r29, 0x3e	; 62

	uint8_t data[2];
	uint32_t waarde =0;

	while(1){
		xSemaphoreTake(sem, portMAX_DELAY);
     d04:	20 e0       	ldi	r18, 0x00	; 0
     d06:	4f ef       	ldi	r20, 0xFF	; 255
     d08:	5f ef       	ldi	r21, 0xFF	; 255
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	70 e0       	ldi	r23, 0x00	; 0
     d0e:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     d12:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     d16:	c6 d3       	rcall	.+1932   	; 0x14a4 <xQueueGenericReceive>
		verzenden(0x40, 0xE3);
     d18:	63 ee       	ldi	r22, 0xE3	; 227
     d1a:	80 e4       	ldi	r24, 0x40	; 64
     d1c:	cc df       	rcall	.-104    	; 0xcb6 <verzenden>
		ontvangen(0x40, data, 2);
     d1e:	42 e0       	ldi	r20, 0x02	; 2
     d20:	be 01       	movw	r22, r28
     d22:	6f 5f       	subi	r22, 0xFF	; 255
     d24:	7f 4f       	sbci	r23, 0xFF	; 255
     d26:	80 e4       	ldi	r24, 0x40	; 64
     d28:	73 df       	rcall	.-282    	; 0xc10 <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		temperatuur=((175.72*waarde)/65536.0) -46.85;
     d2a:	69 81       	ldd	r22, Y+1	; 0x01
     d2c:	70 e0       	ldi	r23, 0x00	; 0
     d2e:	76 2f       	mov	r23, r22
     d30:	66 27       	eor	r22, r22
     d32:	8a 81       	ldd	r24, Y+2	; 0x02
     d34:	68 2b       	or	r22, r24
     d36:	80 e0       	ldi	r24, 0x00	; 0
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	0e 94 a1 12 	call	0x2542	; 0x2542 <__floatunsisf>
     d3e:	22 e5       	ldi	r18, 0x52	; 82
     d40:	38 eb       	ldi	r19, 0xB8	; 184
     d42:	4f e2       	ldi	r20, 0x2F	; 47
     d44:	53 e4       	ldi	r21, 0x43	; 67
     d46:	0e 94 2f 13 	call	0x265e	; 0x265e <__mulsf3>
     d4a:	20 e0       	ldi	r18, 0x00	; 0
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	40 e8       	ldi	r20, 0x80	; 128
     d50:	57 e3       	ldi	r21, 0x37	; 55
     d52:	0e 94 2f 13 	call	0x265e	; 0x265e <__mulsf3>
     d56:	26 e6       	ldi	r18, 0x66	; 102
     d58:	36 e6       	ldi	r19, 0x66	; 102
     d5a:	4b e3       	ldi	r20, 0x3B	; 59
     d5c:	52 e4       	ldi	r21, 0x42	; 66
     d5e:	0e 94 0b 12 	call	0x2416	; 0x2416 <__subsf3>
     d62:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__fixsfsi>
     d66:	70 93 13 04 	sts	0x0413, r23	; 0x800413 <temperatuur+0x1>
     d6a:	60 93 12 04 	sts	0x0412, r22	; 0x800412 <temperatuur>

		verzenden(0x40, 0xE5);
     d6e:	65 ee       	ldi	r22, 0xE5	; 229
     d70:	80 e4       	ldi	r24, 0x40	; 64
     d72:	a1 df       	rcall	.-190    	; 0xcb6 <verzenden>
		ontvangen(0x40, data, 2);
     d74:	42 e0       	ldi	r20, 0x02	; 2
     d76:	be 01       	movw	r22, r28
     d78:	6f 5f       	subi	r22, 0xFF	; 255
     d7a:	7f 4f       	sbci	r23, 0xFF	; 255
     d7c:	80 e4       	ldi	r24, 0x40	; 64
     d7e:	48 df       	rcall	.-368    	; 0xc10 <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		humidity=((125*waarde)/65536.0) -6;
     d80:	29 81       	ldd	r18, Y+1	; 0x01
     d82:	30 e0       	ldi	r19, 0x00	; 0
     d84:	32 2f       	mov	r19, r18
     d86:	22 27       	eor	r18, r18
     d88:	8a 81       	ldd	r24, Y+2	; 0x02
     d8a:	28 2b       	or	r18, r24
     d8c:	ad e7       	ldi	r26, 0x7D	; 125
     d8e:	b0 e0       	ldi	r27, 0x00	; 0
     d90:	0e 94 bc 13 	call	0x2778	; 0x2778 <__umulhisi3>
     d94:	0e 94 a1 12 	call	0x2542	; 0x2542 <__floatunsisf>
     d98:	20 e0       	ldi	r18, 0x00	; 0
     d9a:	30 e0       	ldi	r19, 0x00	; 0
     d9c:	40 e8       	ldi	r20, 0x80	; 128
     d9e:	57 e3       	ldi	r21, 0x37	; 55
     da0:	0e 94 2f 13 	call	0x265e	; 0x265e <__mulsf3>
     da4:	20 e0       	ldi	r18, 0x00	; 0
     da6:	30 e0       	ldi	r19, 0x00	; 0
     da8:	40 ec       	ldi	r20, 0xC0	; 192
     daa:	50 e4       	ldi	r21, 0x40	; 64
     dac:	0e 94 0b 12 	call	0x2416	; 0x2416 <__subsf3>
     db0:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__fixsfsi>
     db4:	70 93 15 04 	sts	0x0415, r23	; 0x800415 <humidity+0x1>
     db8:	60 93 14 04 	sts	0x0414, r22	; 0x800414 <humidity>
		xSemaphoreGive(sem);
     dbc:	20 e0       	ldi	r18, 0x00	; 0
     dbe:	40 e0       	ldi	r20, 0x00	; 0
     dc0:	50 e0       	ldi	r21, 0x00	; 0
     dc2:	60 e0       	ldi	r22, 0x00	; 0
     dc4:	70 e0       	ldi	r23, 0x00	; 0
     dc6:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <sem>
     dca:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <sem+0x1>
     dce:	d8 d2       	rcall	.+1456   	; 0x1380 <xQueueGenericSend>
     dd0:	99 cf       	rjmp	.-206    	; 0xd04 <temperatuurTaak+0xc>

00000dd2 <__vector_17>:
	// writeString(" ");writeInteger(op[1],16);
	// writeString(" ");writeInteger(op[2],16);
}

ISR(TIMER1_COMPA_vect)
{
     dd2:	1f 92       	push	r1
     dd4:	0f 92       	push	r0
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	0f 92       	push	r0
     dda:	11 24       	eor	r1, r1
     ddc:	8f 93       	push	r24
     dde:	9f 93       	push	r25
	PORTB ^= (1 << PB6);
     de0:	95 b1       	in	r25, 0x05	; 5
     de2:	80 e4       	ldi	r24, 0x40	; 64
     de4:	89 27       	eor	r24, r25
     de6:	85 b9       	out	0x05, r24	; 5
}
     de8:	9f 91       	pop	r25
     dea:	8f 91       	pop	r24
     dec:	0f 90       	pop	r0
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	0f 90       	pop	r0
     df2:	1f 90       	pop	r1
     df4:	18 95       	reti

00000df6 <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     df6:	31 e1       	ldi	r19, 0x11	; 17
     df8:	fc 01       	movw	r30, r24
     dfa:	30 83       	st	Z, r19
     dfc:	31 97       	sbiw	r30, 0x01	; 1
     dfe:	22 e2       	ldi	r18, 0x22	; 34
     e00:	20 83       	st	Z, r18
     e02:	31 97       	sbiw	r30, 0x01	; 1
     e04:	a3 e3       	ldi	r26, 0x33	; 51
     e06:	a0 83       	st	Z, r26
     e08:	31 97       	sbiw	r30, 0x01	; 1
     e0a:	60 83       	st	Z, r22
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	70 83       	st	Z, r23
     e10:	31 97       	sbiw	r30, 0x01	; 1
     e12:	10 82       	st	Z, r1
     e14:	31 97       	sbiw	r30, 0x01	; 1
     e16:	10 82       	st	Z, r1
     e18:	31 97       	sbiw	r30, 0x01	; 1
     e1a:	60 e8       	ldi	r22, 0x80	; 128
     e1c:	60 83       	st	Z, r22
     e1e:	31 97       	sbiw	r30, 0x01	; 1
     e20:	10 82       	st	Z, r1
     e22:	31 97       	sbiw	r30, 0x01	; 1
     e24:	10 82       	st	Z, r1
     e26:	31 97       	sbiw	r30, 0x01	; 1
     e28:	10 82       	st	Z, r1
     e2a:	31 97       	sbiw	r30, 0x01	; 1
     e2c:	62 e0       	ldi	r22, 0x02	; 2
     e2e:	60 83       	st	Z, r22
     e30:	31 97       	sbiw	r30, 0x01	; 1
     e32:	63 e0       	ldi	r22, 0x03	; 3
     e34:	60 83       	st	Z, r22
     e36:	31 97       	sbiw	r30, 0x01	; 1
     e38:	64 e0       	ldi	r22, 0x04	; 4
     e3a:	60 83       	st	Z, r22
     e3c:	31 97       	sbiw	r30, 0x01	; 1
     e3e:	65 e0       	ldi	r22, 0x05	; 5
     e40:	60 83       	st	Z, r22
     e42:	31 97       	sbiw	r30, 0x01	; 1
     e44:	66 e0       	ldi	r22, 0x06	; 6
     e46:	60 83       	st	Z, r22
     e48:	31 97       	sbiw	r30, 0x01	; 1
     e4a:	67 e0       	ldi	r22, 0x07	; 7
     e4c:	60 83       	st	Z, r22
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	68 e0       	ldi	r22, 0x08	; 8
     e52:	60 83       	st	Z, r22
     e54:	31 97       	sbiw	r30, 0x01	; 1
     e56:	69 e0       	ldi	r22, 0x09	; 9
     e58:	60 83       	st	Z, r22
     e5a:	31 97       	sbiw	r30, 0x01	; 1
     e5c:	60 e1       	ldi	r22, 0x10	; 16
     e5e:	60 83       	st	Z, r22
     e60:	31 97       	sbiw	r30, 0x01	; 1
     e62:	30 83       	st	Z, r19
     e64:	31 97       	sbiw	r30, 0x01	; 1
     e66:	32 e1       	ldi	r19, 0x12	; 18
     e68:	30 83       	st	Z, r19
     e6a:	31 97       	sbiw	r30, 0x01	; 1
     e6c:	33 e1       	ldi	r19, 0x13	; 19
     e6e:	30 83       	st	Z, r19
     e70:	31 97       	sbiw	r30, 0x01	; 1
     e72:	34 e1       	ldi	r19, 0x14	; 20
     e74:	30 83       	st	Z, r19
     e76:	31 97       	sbiw	r30, 0x01	; 1
     e78:	35 e1       	ldi	r19, 0x15	; 21
     e7a:	30 83       	st	Z, r19
     e7c:	31 97       	sbiw	r30, 0x01	; 1
     e7e:	36 e1       	ldi	r19, 0x16	; 22
     e80:	30 83       	st	Z, r19
     e82:	31 97       	sbiw	r30, 0x01	; 1
     e84:	37 e1       	ldi	r19, 0x17	; 23
     e86:	30 83       	st	Z, r19
     e88:	31 97       	sbiw	r30, 0x01	; 1
     e8a:	38 e1       	ldi	r19, 0x18	; 24
     e8c:	30 83       	st	Z, r19
     e8e:	31 97       	sbiw	r30, 0x01	; 1
     e90:	39 e1       	ldi	r19, 0x19	; 25
     e92:	30 83       	st	Z, r19
     e94:	31 97       	sbiw	r30, 0x01	; 1
     e96:	30 e2       	ldi	r19, 0x20	; 32
     e98:	30 83       	st	Z, r19
     e9a:	31 97       	sbiw	r30, 0x01	; 1
     e9c:	31 e2       	ldi	r19, 0x21	; 33
     e9e:	30 83       	st	Z, r19
     ea0:	31 97       	sbiw	r30, 0x01	; 1
     ea2:	20 83       	st	Z, r18
     ea4:	31 97       	sbiw	r30, 0x01	; 1
     ea6:	23 e2       	ldi	r18, 0x23	; 35
     ea8:	20 83       	st	Z, r18
     eaa:	31 97       	sbiw	r30, 0x01	; 1
     eac:	40 83       	st	Z, r20
     eae:	31 97       	sbiw	r30, 0x01	; 1
     eb0:	50 83       	st	Z, r21
     eb2:	31 97       	sbiw	r30, 0x01	; 1
     eb4:	26 e2       	ldi	r18, 0x26	; 38
     eb6:	20 83       	st	Z, r18
     eb8:	31 97       	sbiw	r30, 0x01	; 1
     eba:	27 e2       	ldi	r18, 0x27	; 39
     ebc:	20 83       	st	Z, r18
     ebe:	31 97       	sbiw	r30, 0x01	; 1
     ec0:	28 e2       	ldi	r18, 0x28	; 40
     ec2:	20 83       	st	Z, r18
     ec4:	31 97       	sbiw	r30, 0x01	; 1
     ec6:	29 e2       	ldi	r18, 0x29	; 41
     ec8:	20 83       	st	Z, r18
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	20 e3       	ldi	r18, 0x30	; 48
     ece:	20 83       	st	Z, r18
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	21 e3       	ldi	r18, 0x31	; 49
     ed4:	20 83       	st	Z, r18
     ed6:	89 97       	sbiw	r24, 0x29	; 41
     ed8:	08 95       	ret

00000eda <xPortStartScheduler>:
     eda:	88 ec       	ldi	r24, 0xC8	; 200
     edc:	90 e0       	ldi	r25, 0x00	; 0
     ede:	90 93 20 04 	sts	0x0420, r25	; 0x800420 <portTickRateHz+0x1>
     ee2:	80 93 1f 04 	sts	0x041F, r24	; 0x80041f <portTickRateHz>
     ee6:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <ticksRemainingInSec+0x1>
     eea:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <ticksRemainingInSec>
     eee:	8d e4       	ldi	r24, 0x4D	; 77
     ef0:	87 bd       	out	0x27, r24	; 39
     ef2:	82 e0       	ldi	r24, 0x02	; 2
     ef4:	84 bd       	out	0x24, r24	; 36
     ef6:	85 e0       	ldi	r24, 0x05	; 5
     ef8:	85 bd       	out	0x25, r24	; 37
     efa:	ee e6       	ldi	r30, 0x6E	; 110
     efc:	f0 e0       	ldi	r31, 0x00	; 0
     efe:	80 81       	ld	r24, Z
     f00:	82 60       	ori	r24, 0x02	; 2
     f02:	80 83       	st	Z, r24
     f04:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
     f08:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
     f0c:	cd 91       	ld	r28, X+
     f0e:	cd bf       	out	0x3d, r28	; 61
     f10:	dd 91       	ld	r29, X+
     f12:	de bf       	out	0x3e, r29	; 62
     f14:	ff 91       	pop	r31
     f16:	ef 91       	pop	r30
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	bf 91       	pop	r27
     f1e:	af 91       	pop	r26
     f20:	9f 91       	pop	r25
     f22:	8f 91       	pop	r24
     f24:	7f 91       	pop	r23
     f26:	6f 91       	pop	r22
     f28:	5f 91       	pop	r21
     f2a:	4f 91       	pop	r20
     f2c:	3f 91       	pop	r19
     f2e:	2f 91       	pop	r18
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
     f36:	ef 90       	pop	r14
     f38:	df 90       	pop	r13
     f3a:	cf 90       	pop	r12
     f3c:	bf 90       	pop	r11
     f3e:	af 90       	pop	r10
     f40:	9f 90       	pop	r9
     f42:	8f 90       	pop	r8
     f44:	7f 90       	pop	r7
     f46:	6f 90       	pop	r6
     f48:	5f 90       	pop	r5
     f4a:	4f 90       	pop	r4
     f4c:	3f 90       	pop	r3
     f4e:	2f 90       	pop	r2
     f50:	1f 90       	pop	r1
     f52:	0f 90       	pop	r0
     f54:	0c be       	out	0x3c, r0	; 60
     f56:	0f 90       	pop	r0
     f58:	0b be       	out	0x3b, r0	; 59
     f5a:	0f 90       	pop	r0
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	0f 90       	pop	r0
     f60:	08 95       	ret
     f62:	81 e0       	ldi	r24, 0x01	; 1
     f64:	08 95       	ret

00000f66 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f66:	0f 92       	push	r0
     f68:	0f b6       	in	r0, 0x3f	; 63
     f6a:	f8 94       	cli
     f6c:	0f 92       	push	r0
     f6e:	0b b6       	in	r0, 0x3b	; 59
     f70:	0f 92       	push	r0
     f72:	0c b6       	in	r0, 0x3c	; 60
     f74:	0f 92       	push	r0
     f76:	1f 92       	push	r1
     f78:	11 24       	eor	r1, r1
     f7a:	2f 92       	push	r2
     f7c:	3f 92       	push	r3
     f7e:	4f 92       	push	r4
     f80:	5f 92       	push	r5
     f82:	6f 92       	push	r6
     f84:	7f 92       	push	r7
     f86:	8f 92       	push	r8
     f88:	9f 92       	push	r9
     f8a:	af 92       	push	r10
     f8c:	bf 92       	push	r11
     f8e:	cf 92       	push	r12
     f90:	df 92       	push	r13
     f92:	ef 92       	push	r14
     f94:	ff 92       	push	r15
     f96:	0f 93       	push	r16
     f98:	1f 93       	push	r17
     f9a:	2f 93       	push	r18
     f9c:	3f 93       	push	r19
     f9e:	4f 93       	push	r20
     fa0:	5f 93       	push	r21
     fa2:	6f 93       	push	r22
     fa4:	7f 93       	push	r23
     fa6:	8f 93       	push	r24
     fa8:	9f 93       	push	r25
     faa:	af 93       	push	r26
     fac:	bf 93       	push	r27
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	ef 93       	push	r30
     fb4:	ff 93       	push	r31
     fb6:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
     fba:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
     fbe:	0d b6       	in	r0, 0x3d	; 61
     fc0:	0d 92       	st	X+, r0
     fc2:	0e b6       	in	r0, 0x3e	; 62
     fc4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     fc6:	0e 94 36 10 	call	0x206c	; 0x206c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     fca:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
     fce:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
     fd2:	cd 91       	ld	r28, X+
     fd4:	cd bf       	out	0x3d, r28	; 61
     fd6:	dd 91       	ld	r29, X+
     fd8:	de bf       	out	0x3e, r29	; 62
     fda:	ff 91       	pop	r31
     fdc:	ef 91       	pop	r30
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	bf 91       	pop	r27
     fe4:	af 91       	pop	r26
     fe6:	9f 91       	pop	r25
     fe8:	8f 91       	pop	r24
     fea:	7f 91       	pop	r23
     fec:	6f 91       	pop	r22
     fee:	5f 91       	pop	r21
     ff0:	4f 91       	pop	r20
     ff2:	3f 91       	pop	r19
     ff4:	2f 91       	pop	r18
     ff6:	1f 91       	pop	r17
     ff8:	0f 91       	pop	r16
     ffa:	ff 90       	pop	r15
     ffc:	ef 90       	pop	r14
     ffe:	df 90       	pop	r13
    1000:	cf 90       	pop	r12
    1002:	bf 90       	pop	r11
    1004:	af 90       	pop	r10
    1006:	9f 90       	pop	r9
    1008:	8f 90       	pop	r8
    100a:	7f 90       	pop	r7
    100c:	6f 90       	pop	r6
    100e:	5f 90       	pop	r5
    1010:	4f 90       	pop	r4
    1012:	3f 90       	pop	r3
    1014:	2f 90       	pop	r2
    1016:	1f 90       	pop	r1
    1018:	0f 90       	pop	r0
    101a:	0c be       	out	0x3c, r0	; 60
    101c:	0f 90       	pop	r0
    101e:	0b be       	out	0x3b, r0	; 59
    1020:	0f 90       	pop	r0
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1026:	08 95       	ret

00001028 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1028:	0f 92       	push	r0
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	0f 92       	push	r0
    1030:	0b b6       	in	r0, 0x3b	; 59
    1032:	0f 92       	push	r0
    1034:	0c b6       	in	r0, 0x3c	; 60
    1036:	0f 92       	push	r0
    1038:	1f 92       	push	r1
    103a:	11 24       	eor	r1, r1
    103c:	2f 92       	push	r2
    103e:	3f 92       	push	r3
    1040:	4f 92       	push	r4
    1042:	5f 92       	push	r5
    1044:	6f 92       	push	r6
    1046:	7f 92       	push	r7
    1048:	8f 92       	push	r8
    104a:	9f 92       	push	r9
    104c:	af 92       	push	r10
    104e:	bf 92       	push	r11
    1050:	cf 92       	push	r12
    1052:	df 92       	push	r13
    1054:	ef 92       	push	r14
    1056:	ff 92       	push	r15
    1058:	0f 93       	push	r16
    105a:	1f 93       	push	r17
    105c:	2f 93       	push	r18
    105e:	3f 93       	push	r19
    1060:	4f 93       	push	r20
    1062:	5f 93       	push	r21
    1064:	6f 93       	push	r22
    1066:	7f 93       	push	r23
    1068:	8f 93       	push	r24
    106a:	9f 93       	push	r25
    106c:	af 93       	push	r26
    106e:	bf 93       	push	r27
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	ef 93       	push	r30
    1076:	ff 93       	push	r31
    1078:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    107c:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1080:	0d b6       	in	r0, 0x3d	; 61
    1082:	0d 92       	st	X+, r0
    1084:	0e b6       	in	r0, 0x3e	; 62
    1086:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1088:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    108a:	80 91 21 04 	lds	r24, 0x0421	; 0x800421 <ticksRemainingInSec>
    108e:	90 91 22 04 	lds	r25, 0x0422	; 0x800422 <ticksRemainingInSec+0x1>
    1092:	01 97       	sbiw	r24, 0x01	; 1
    1094:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <ticksRemainingInSec+0x1>
    1098:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <ticksRemainingInSec>
    109c:	89 2b       	or	r24, r25
    109e:	49 f4       	brne	.+18     	; 0x10b2 <vPortYieldFromTick+0x8a>
	{
		system_tick();
    10a0:	3d d9       	rcall	.-3462   	; 0x31c <system_tick>
		ticksRemainingInSec = portTickRateHz;
    10a2:	80 91 1f 04 	lds	r24, 0x041F	; 0x80041f <portTickRateHz>
    10a6:	90 91 20 04 	lds	r25, 0x0420	; 0x800420 <portTickRateHz+0x1>
    10aa:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <ticksRemainingInSec+0x1>
    10ae:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    10b2:	a5 d6       	rcall	.+3402   	; 0x1dfe <xTaskIncrementTick>
	{
		vTaskSwitchContext();
    10b4:	81 11       	cpse	r24, r1
    10b6:	da d7       	rcall	.+4020   	; 0x206c <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    10b8:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    10bc:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    10c0:	cd 91       	ld	r28, X+
    10c2:	cd bf       	out	0x3d, r28	; 61
    10c4:	dd 91       	ld	r29, X+
    10c6:	de bf       	out	0x3e, r29	; 62
    10c8:	ff 91       	pop	r31
    10ca:	ef 91       	pop	r30
    10cc:	df 91       	pop	r29
    10ce:	cf 91       	pop	r28
    10d0:	bf 91       	pop	r27
    10d2:	af 91       	pop	r26
    10d4:	9f 91       	pop	r25
    10d6:	8f 91       	pop	r24
    10d8:	7f 91       	pop	r23
    10da:	6f 91       	pop	r22
    10dc:	5f 91       	pop	r21
    10de:	4f 91       	pop	r20
    10e0:	3f 91       	pop	r19
    10e2:	2f 91       	pop	r18
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	8f 90       	pop	r8
    10f8:	7f 90       	pop	r7
    10fa:	6f 90       	pop	r6
    10fc:	5f 90       	pop	r5
    10fe:	4f 90       	pop	r4
    1100:	3f 90       	pop	r3
    1102:	2f 90       	pop	r2
    1104:	1f 90       	pop	r1
    1106:	0f 90       	pop	r0
    1108:	0c be       	out	0x3c, r0	; 60
    110a:	0f 90       	pop	r0
    110c:	0b be       	out	0x3b, r0	; 59
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1114:	08 95       	ret

00001116 <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1116:	88 df       	rcall	.-240    	; 0x1028 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1118:	18 95       	reti

0000111a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    111a:	0f b6       	in	r0, 0x3f	; 63
    111c:	f8 94       	cli
    111e:	0f 92       	push	r0
    1120:	fc 01       	movw	r30, r24
    1122:	92 8d       	ldd	r25, Z+26	; 0x1a
    1124:	0f 90       	pop	r0
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	91 11       	cpse	r25, r1
    112c:	80 e0       	ldi	r24, 0x00	; 0
    112e:	08 95       	ret

00001130 <prvCopyDataToQueue>:
    1130:	0f 93       	push	r16
    1132:	1f 93       	push	r17
    1134:	cf 93       	push	r28
    1136:	df 93       	push	r29
    1138:	ec 01       	movw	r28, r24
    113a:	04 2f       	mov	r16, r20
    113c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    113e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1140:	41 11       	cpse	r20, r1
    1142:	0c c0       	rjmp	.+24     	; 0x115c <prvCopyDataToQueue+0x2c>
    1144:	88 81       	ld	r24, Y
    1146:	99 81       	ldd	r25, Y+1	; 0x01
    1148:	89 2b       	or	r24, r25
    114a:	09 f0       	breq	.+2      	; 0x114e <prvCopyDataToQueue+0x1e>
    114c:	42 c0       	rjmp	.+132    	; 0x11d2 <prvCopyDataToQueue+0xa2>
    114e:	8a 81       	ldd	r24, Y+2	; 0x02
    1150:	9b 81       	ldd	r25, Y+3	; 0x03
    1152:	0e 94 b9 11 	call	0x2372	; 0x2372 <xTaskPriorityDisinherit>
    1156:	1b 82       	std	Y+3, r1	; 0x03
    1158:	1a 82       	std	Y+2, r1	; 0x02
    115a:	42 c0       	rjmp	.+132    	; 0x11e0 <prvCopyDataToQueue+0xb0>
    115c:	01 11       	cpse	r16, r1
    115e:	17 c0       	rjmp	.+46     	; 0x118e <prvCopyDataToQueue+0x5e>
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	8c 81       	ldd	r24, Y+4	; 0x04
    1164:	9d 81       	ldd	r25, Y+5	; 0x05
    1166:	0e 94 f6 14 	call	0x29ec	; 0x29ec <memcpy>
    116a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    116c:	8c 81       	ldd	r24, Y+4	; 0x04
    116e:	9d 81       	ldd	r25, Y+5	; 0x05
    1170:	82 0f       	add	r24, r18
    1172:	91 1d       	adc	r25, r1
    1174:	9d 83       	std	Y+5, r25	; 0x05
    1176:	8c 83       	std	Y+4, r24	; 0x04
    1178:	2a 81       	ldd	r18, Y+2	; 0x02
    117a:	3b 81       	ldd	r19, Y+3	; 0x03
    117c:	82 17       	cp	r24, r18
    117e:	93 07       	cpc	r25, r19
    1180:	50 f1       	brcs	.+84     	; 0x11d6 <prvCopyDataToQueue+0xa6>
    1182:	88 81       	ld	r24, Y
    1184:	99 81       	ldd	r25, Y+1	; 0x01
    1186:	9d 83       	std	Y+5, r25	; 0x05
    1188:	8c 83       	std	Y+4, r24	; 0x04
    118a:	80 e0       	ldi	r24, 0x00	; 0
    118c:	29 c0       	rjmp	.+82     	; 0x11e0 <prvCopyDataToQueue+0xb0>
    118e:	50 e0       	ldi	r21, 0x00	; 0
    1190:	8e 81       	ldd	r24, Y+6	; 0x06
    1192:	9f 81       	ldd	r25, Y+7	; 0x07
    1194:	0e 94 f6 14 	call	0x29ec	; 0x29ec <memcpy>
    1198:	8c 8d       	ldd	r24, Y+28	; 0x1c
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	91 95       	neg	r25
    119e:	81 95       	neg	r24
    11a0:	91 09       	sbc	r25, r1
    11a2:	2e 81       	ldd	r18, Y+6	; 0x06
    11a4:	3f 81       	ldd	r19, Y+7	; 0x07
    11a6:	28 0f       	add	r18, r24
    11a8:	39 1f       	adc	r19, r25
    11aa:	3f 83       	std	Y+7, r19	; 0x07
    11ac:	2e 83       	std	Y+6, r18	; 0x06
    11ae:	48 81       	ld	r20, Y
    11b0:	59 81       	ldd	r21, Y+1	; 0x01
    11b2:	24 17       	cp	r18, r20
    11b4:	35 07       	cpc	r19, r21
    11b6:	30 f4       	brcc	.+12     	; 0x11c4 <prvCopyDataToQueue+0x94>
    11b8:	2a 81       	ldd	r18, Y+2	; 0x02
    11ba:	3b 81       	ldd	r19, Y+3	; 0x03
    11bc:	82 0f       	add	r24, r18
    11be:	93 1f       	adc	r25, r19
    11c0:	9f 83       	std	Y+7, r25	; 0x07
    11c2:	8e 83       	std	Y+6, r24	; 0x06
    11c4:	02 30       	cpi	r16, 0x02	; 2
    11c6:	49 f4       	brne	.+18     	; 0x11da <prvCopyDataToQueue+0xaa>
    11c8:	11 23       	and	r17, r17
    11ca:	49 f0       	breq	.+18     	; 0x11de <prvCopyDataToQueue+0xae>
    11cc:	11 50       	subi	r17, 0x01	; 1
    11ce:	80 e0       	ldi	r24, 0x00	; 0
    11d0:	07 c0       	rjmp	.+14     	; 0x11e0 <prvCopyDataToQueue+0xb0>
    11d2:	80 e0       	ldi	r24, 0x00	; 0
    11d4:	05 c0       	rjmp	.+10     	; 0x11e0 <prvCopyDataToQueue+0xb0>
    11d6:	80 e0       	ldi	r24, 0x00	; 0
    11d8:	03 c0       	rjmp	.+6      	; 0x11e0 <prvCopyDataToQueue+0xb0>
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	01 c0       	rjmp	.+2      	; 0x11e0 <prvCopyDataToQueue+0xb0>
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	1f 5f       	subi	r17, 0xFF	; 255
    11e2:	1a 8f       	std	Y+26, r17	; 0x1a
    11e4:	df 91       	pop	r29
    11e6:	cf 91       	pop	r28
    11e8:	1f 91       	pop	r17
    11ea:	0f 91       	pop	r16
    11ec:	08 95       	ret

000011ee <prvCopyDataFromQueue>:
    11ee:	fc 01       	movw	r30, r24
    11f0:	44 8d       	ldd	r20, Z+28	; 0x1c
    11f2:	44 23       	and	r20, r20
    11f4:	a9 f0       	breq	.+42     	; 0x1220 <prvCopyDataFromQueue+0x32>
    11f6:	50 e0       	ldi	r21, 0x00	; 0
    11f8:	26 81       	ldd	r18, Z+6	; 0x06
    11fa:	37 81       	ldd	r19, Z+7	; 0x07
    11fc:	24 0f       	add	r18, r20
    11fe:	35 1f       	adc	r19, r21
    1200:	37 83       	std	Z+7, r19	; 0x07
    1202:	26 83       	std	Z+6, r18	; 0x06
    1204:	82 81       	ldd	r24, Z+2	; 0x02
    1206:	93 81       	ldd	r25, Z+3	; 0x03
    1208:	28 17       	cp	r18, r24
    120a:	39 07       	cpc	r19, r25
    120c:	20 f0       	brcs	.+8      	; 0x1216 <prvCopyDataFromQueue+0x28>
    120e:	80 81       	ld	r24, Z
    1210:	91 81       	ldd	r25, Z+1	; 0x01
    1212:	97 83       	std	Z+7, r25	; 0x07
    1214:	86 83       	std	Z+6, r24	; 0x06
    1216:	cb 01       	movw	r24, r22
    1218:	66 81       	ldd	r22, Z+6	; 0x06
    121a:	77 81       	ldd	r23, Z+7	; 0x07
    121c:	0c 94 f6 14 	jmp	0x29ec	; 0x29ec <memcpy>
    1220:	08 95       	ret

00001222 <prvUnlockQueue>:
    1222:	ef 92       	push	r14
    1224:	ff 92       	push	r15
    1226:	0f 93       	push	r16
    1228:	1f 93       	push	r17
    122a:	cf 93       	push	r28
    122c:	8c 01       	movw	r16, r24
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	0f 92       	push	r0
    1234:	fc 01       	movw	r30, r24
    1236:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1238:	1c 16       	cp	r1, r28
    123a:	a4 f4       	brge	.+40     	; 0x1264 <prvUnlockQueue+0x42>
    123c:	81 89       	ldd	r24, Z+17	; 0x11
    123e:	81 11       	cpse	r24, r1
    1240:	06 c0       	rjmp	.+12     	; 0x124e <prvUnlockQueue+0x2c>
    1242:	10 c0       	rjmp	.+32     	; 0x1264 <prvUnlockQueue+0x42>
    1244:	f8 01       	movw	r30, r16
    1246:	81 89       	ldd	r24, Z+17	; 0x11
    1248:	81 11       	cpse	r24, r1
    124a:	05 c0       	rjmp	.+10     	; 0x1256 <prvUnlockQueue+0x34>
    124c:	0b c0       	rjmp	.+22     	; 0x1264 <prvUnlockQueue+0x42>
    124e:	78 01       	movw	r14, r16
    1250:	f1 e1       	ldi	r31, 0x11	; 17
    1252:	ef 0e       	add	r14, r31
    1254:	f1 1c       	adc	r15, r1
    1256:	c7 01       	movw	r24, r14
    1258:	9b d7       	rcall	.+3894   	; 0x2190 <xTaskRemoveFromEventList>
    125a:	81 11       	cpse	r24, r1
    125c:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vTaskMissedYield>
    1260:	c1 50       	subi	r28, 0x01	; 1
    1262:	81 f7       	brne	.-32     	; 0x1244 <prvUnlockQueue+0x22>
    1264:	8f ef       	ldi	r24, 0xFF	; 255
    1266:	f8 01       	movw	r30, r16
    1268:	86 8f       	std	Z+30, r24	; 0x1e
    126a:	0f 90       	pop	r0
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	0f b6       	in	r0, 0x3f	; 63
    1270:	f8 94       	cli
    1272:	0f 92       	push	r0
    1274:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1276:	1c 16       	cp	r1, r28
    1278:	a4 f4       	brge	.+40     	; 0x12a2 <prvUnlockQueue+0x80>
    127a:	80 85       	ldd	r24, Z+8	; 0x08
    127c:	81 11       	cpse	r24, r1
    127e:	06 c0       	rjmp	.+12     	; 0x128c <prvUnlockQueue+0x6a>
    1280:	10 c0       	rjmp	.+32     	; 0x12a2 <prvUnlockQueue+0x80>
    1282:	f8 01       	movw	r30, r16
    1284:	80 85       	ldd	r24, Z+8	; 0x08
    1286:	81 11       	cpse	r24, r1
    1288:	05 c0       	rjmp	.+10     	; 0x1294 <prvUnlockQueue+0x72>
    128a:	0b c0       	rjmp	.+22     	; 0x12a2 <prvUnlockQueue+0x80>
    128c:	78 01       	movw	r14, r16
    128e:	f8 e0       	ldi	r31, 0x08	; 8
    1290:	ef 0e       	add	r14, r31
    1292:	f1 1c       	adc	r15, r1
    1294:	c7 01       	movw	r24, r14
    1296:	7c d7       	rcall	.+3832   	; 0x2190 <xTaskRemoveFromEventList>
    1298:	81 11       	cpse	r24, r1
    129a:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vTaskMissedYield>
    129e:	c1 50       	subi	r28, 0x01	; 1
    12a0:	81 f7       	brne	.-32     	; 0x1282 <prvUnlockQueue+0x60>
    12a2:	8f ef       	ldi	r24, 0xFF	; 255
    12a4:	f8 01       	movw	r30, r16
    12a6:	85 8f       	std	Z+29, r24	; 0x1d
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63
    12ac:	cf 91       	pop	r28
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	ff 90       	pop	r15
    12b4:	ef 90       	pop	r14
    12b6:	08 95       	ret

000012b8 <xQueueGenericReset>:
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	ec 01       	movw	r28, r24
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	f8 94       	cli
    12c2:	0f 92       	push	r0
    12c4:	48 81       	ld	r20, Y
    12c6:	59 81       	ldd	r21, Y+1	; 0x01
    12c8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12ca:	30 e0       	ldi	r19, 0x00	; 0
    12cc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    12ce:	72 9f       	mul	r23, r18
    12d0:	c0 01       	movw	r24, r0
    12d2:	73 9f       	mul	r23, r19
    12d4:	90 0d       	add	r25, r0
    12d6:	11 24       	eor	r1, r1
    12d8:	fa 01       	movw	r30, r20
    12da:	e8 0f       	add	r30, r24
    12dc:	f9 1f       	adc	r31, r25
    12de:	fb 83       	std	Y+3, r31	; 0x03
    12e0:	ea 83       	std	Y+2, r30	; 0x02
    12e2:	1a 8e       	std	Y+26, r1	; 0x1a
    12e4:	5d 83       	std	Y+5, r21	; 0x05
    12e6:	4c 83       	std	Y+4, r20	; 0x04
    12e8:	82 1b       	sub	r24, r18
    12ea:	93 0b       	sbc	r25, r19
    12ec:	84 0f       	add	r24, r20
    12ee:	95 1f       	adc	r25, r21
    12f0:	9f 83       	std	Y+7, r25	; 0x07
    12f2:	8e 83       	std	Y+6, r24	; 0x06
    12f4:	8f ef       	ldi	r24, 0xFF	; 255
    12f6:	8d 8f       	std	Y+29, r24	; 0x1d
    12f8:	8e 8f       	std	Y+30, r24	; 0x1e
    12fa:	61 11       	cpse	r22, r1
    12fc:	0a c0       	rjmp	.+20     	; 0x1312 <xQueueGenericReset+0x5a>
    12fe:	88 85       	ldd	r24, Y+8	; 0x08
    1300:	88 23       	and	r24, r24
    1302:	69 f0       	breq	.+26     	; 0x131e <xQueueGenericReset+0x66>
    1304:	ce 01       	movw	r24, r28
    1306:	08 96       	adiw	r24, 0x08	; 8
    1308:	43 d7       	rcall	.+3718   	; 0x2190 <xTaskRemoveFromEventList>
    130a:	88 23       	and	r24, r24
    130c:	41 f0       	breq	.+16     	; 0x131e <xQueueGenericReset+0x66>
    130e:	2b de       	rcall	.-938    	; 0xf66 <vPortYield>
    1310:	06 c0       	rjmp	.+12     	; 0x131e <xQueueGenericReset+0x66>
    1312:	ce 01       	movw	r24, r28
    1314:	08 96       	adiw	r24, 0x08	; 8
    1316:	5f d9       	rcall	.-3394   	; 0x5d6 <vListInitialise>
    1318:	ce 01       	movw	r24, r28
    131a:	41 96       	adiw	r24, 0x11	; 17
    131c:	5c d9       	rcall	.-3400   	; 0x5d6 <vListInitialise>
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	df 91       	pop	r29
    1326:	cf 91       	pop	r28
    1328:	08 95       	ret

0000132a <xQueueGenericCreate>:
    132a:	0f 93       	push	r16
    132c:	1f 93       	push	r17
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	08 2f       	mov	r16, r24
    1334:	16 2f       	mov	r17, r22
    1336:	66 23       	and	r22, r22
    1338:	b1 f0       	breq	.+44     	; 0x1366 <xQueueGenericCreate+0x3c>
    133a:	86 9f       	mul	r24, r22
    133c:	c0 01       	movw	r24, r0
    133e:	11 24       	eor	r1, r1
    1340:	4f 96       	adiw	r24, 0x1f	; 31
    1342:	08 d8       	rcall	.-4080   	; 0x354 <pvPortMalloc>
    1344:	ec 01       	movw	r28, r24
    1346:	00 97       	sbiw	r24, 0x00	; 0
    1348:	39 f4       	brne	.+14     	; 0x1358 <xQueueGenericCreate+0x2e>
    134a:	14 c0       	rjmp	.+40     	; 0x1374 <xQueueGenericCreate+0x4a>
    134c:	0b 8f       	std	Y+27, r16	; 0x1b
    134e:	1c 8f       	std	Y+28, r17	; 0x1c
    1350:	61 e0       	ldi	r22, 0x01	; 1
    1352:	ce 01       	movw	r24, r28
    1354:	b1 df       	rcall	.-158    	; 0x12b8 <xQueueGenericReset>
    1356:	0e c0       	rjmp	.+28     	; 0x1374 <xQueueGenericCreate+0x4a>
    1358:	4f 96       	adiw	r24, 0x1f	; 31
    135a:	99 83       	std	Y+1, r25	; 0x01
    135c:	88 83       	st	Y, r24
    135e:	f6 cf       	rjmp	.-20     	; 0x134c <xQueueGenericCreate+0x22>
    1360:	d9 83       	std	Y+1, r29	; 0x01
    1362:	c8 83       	st	Y, r28
    1364:	f3 cf       	rjmp	.-26     	; 0x134c <xQueueGenericCreate+0x22>
    1366:	8f e1       	ldi	r24, 0x1F	; 31
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    136e:	ec 01       	movw	r28, r24
    1370:	89 2b       	or	r24, r25
    1372:	b1 f7       	brne	.-20     	; 0x1360 <xQueueGenericCreate+0x36>
    1374:	ce 01       	movw	r24, r28
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	1f 91       	pop	r17
    137c:	0f 91       	pop	r16
    137e:	08 95       	ret

00001380 <xQueueGenericSend>:
    1380:	9f 92       	push	r9
    1382:	af 92       	push	r10
    1384:	bf 92       	push	r11
    1386:	cf 92       	push	r12
    1388:	df 92       	push	r13
    138a:	ef 92       	push	r14
    138c:	ff 92       	push	r15
    138e:	0f 93       	push	r16
    1390:	1f 93       	push	r17
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	00 d0       	rcall	.+0      	; 0x1398 <xQueueGenericSend+0x18>
    1398:	1f 92       	push	r1
    139a:	1f 92       	push	r1
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
    13a0:	8c 01       	movw	r16, r24
    13a2:	6b 01       	movw	r12, r22
    13a4:	5d 83       	std	Y+5, r21	; 0x05
    13a6:	4c 83       	std	Y+4, r20	; 0x04
    13a8:	a2 2e       	mov	r10, r18
    13aa:	b1 2c       	mov	r11, r1
    13ac:	99 24       	eor	r9, r9
    13ae:	93 94       	inc	r9
    13b0:	7c 01       	movw	r14, r24
    13b2:	88 e0       	ldi	r24, 0x08	; 8
    13b4:	e8 0e       	add	r14, r24
    13b6:	f1 1c       	adc	r15, r1
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	f8 94       	cli
    13bc:	0f 92       	push	r0
    13be:	f8 01       	movw	r30, r16
    13c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    13c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    13c4:	98 17       	cp	r25, r24
    13c6:	18 f0       	brcs	.+6      	; 0x13ce <xQueueGenericSend+0x4e>
    13c8:	f2 e0       	ldi	r31, 0x02	; 2
    13ca:	af 12       	cpse	r10, r31
    13cc:	15 c0       	rjmp	.+42     	; 0x13f8 <xQueueGenericSend+0x78>
    13ce:	4a 2d       	mov	r20, r10
    13d0:	b6 01       	movw	r22, r12
    13d2:	c8 01       	movw	r24, r16
    13d4:	ad de       	rcall	.-678    	; 0x1130 <prvCopyDataToQueue>
    13d6:	f8 01       	movw	r30, r16
    13d8:	91 89       	ldd	r25, Z+17	; 0x11
    13da:	99 23       	and	r25, r25
    13dc:	39 f0       	breq	.+14     	; 0x13ec <xQueueGenericSend+0x6c>
    13de:	c8 01       	movw	r24, r16
    13e0:	41 96       	adiw	r24, 0x11	; 17
    13e2:	d6 d6       	rcall	.+3500   	; 0x2190 <xTaskRemoveFromEventList>
    13e4:	88 23       	and	r24, r24
    13e6:	21 f0       	breq	.+8      	; 0x13f0 <xQueueGenericSend+0x70>
    13e8:	be dd       	rcall	.-1156   	; 0xf66 <vPortYield>
    13ea:	02 c0       	rjmp	.+4      	; 0x13f0 <xQueueGenericSend+0x70>
    13ec:	81 11       	cpse	r24, r1
    13ee:	bb dd       	rcall	.-1162   	; 0xf66 <vPortYield>
    13f0:	0f 90       	pop	r0
    13f2:	0f be       	out	0x3f, r0	; 63
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	45 c0       	rjmp	.+138    	; 0x1482 <xQueueGenericSend+0x102>
    13f8:	8c 81       	ldd	r24, Y+4	; 0x04
    13fa:	9d 81       	ldd	r25, Y+5	; 0x05
    13fc:	89 2b       	or	r24, r25
    13fe:	21 f4       	brne	.+8      	; 0x1408 <xQueueGenericSend+0x88>
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	80 e0       	ldi	r24, 0x00	; 0
    1406:	3d c0       	rjmp	.+122    	; 0x1482 <xQueueGenericSend+0x102>
    1408:	b1 10       	cpse	r11, r1
    140a:	04 c0       	rjmp	.+8      	; 0x1414 <xQueueGenericSend+0x94>
    140c:	ce 01       	movw	r24, r28
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	07 d7       	rcall	.+3598   	; 0x2220 <vTaskSetTimeOutState>
    1412:	b9 2c       	mov	r11, r9
    1414:	0f 90       	pop	r0
    1416:	0f be       	out	0x3f, r0	; 63
    1418:	ec d4       	rcall	.+2520   	; 0x1df2 <vTaskSuspendAll>
    141a:	0f b6       	in	r0, 0x3f	; 63
    141c:	f8 94       	cli
    141e:	0f 92       	push	r0
    1420:	f8 01       	movw	r30, r16
    1422:	85 8d       	ldd	r24, Z+29	; 0x1d
    1424:	8f 3f       	cpi	r24, 0xFF	; 255
    1426:	09 f4       	brne	.+2      	; 0x142a <xQueueGenericSend+0xaa>
    1428:	15 8e       	std	Z+29, r1	; 0x1d
    142a:	f8 01       	movw	r30, r16
    142c:	86 8d       	ldd	r24, Z+30	; 0x1e
    142e:	8f 3f       	cpi	r24, 0xFF	; 255
    1430:	09 f4       	brne	.+2      	; 0x1434 <xQueueGenericSend+0xb4>
    1432:	16 8e       	std	Z+30, r1	; 0x1e
    1434:	0f 90       	pop	r0
    1436:	0f be       	out	0x3f, r0	; 63
    1438:	be 01       	movw	r22, r28
    143a:	6c 5f       	subi	r22, 0xFC	; 252
    143c:	7f 4f       	sbci	r23, 0xFF	; 255
    143e:	ce 01       	movw	r24, r28
    1440:	01 96       	adiw	r24, 0x01	; 1
    1442:	f9 d6       	rcall	.+3570   	; 0x2236 <xTaskCheckForTimeOut>
    1444:	81 11       	cpse	r24, r1
    1446:	19 c0       	rjmp	.+50     	; 0x147a <xQueueGenericSend+0xfa>
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
    144e:	f8 01       	movw	r30, r16
    1450:	92 8d       	ldd	r25, Z+26	; 0x1a
    1452:	83 8d       	ldd	r24, Z+27	; 0x1b
    1454:	0f 90       	pop	r0
    1456:	0f be       	out	0x3f, r0	; 63
    1458:	98 13       	cpse	r25, r24
    145a:	0b c0       	rjmp	.+22     	; 0x1472 <xQueueGenericSend+0xf2>
    145c:	6c 81       	ldd	r22, Y+4	; 0x04
    145e:	7d 81       	ldd	r23, Y+5	; 0x05
    1460:	c7 01       	movw	r24, r14
    1462:	85 d6       	rcall	.+3338   	; 0x216e <vTaskPlaceOnEventList>
    1464:	c8 01       	movw	r24, r16
    1466:	dd de       	rcall	.-582    	; 0x1222 <prvUnlockQueue>
    1468:	84 d5       	rcall	.+2824   	; 0x1f72 <xTaskResumeAll>
    146a:	81 11       	cpse	r24, r1
    146c:	a5 cf       	rjmp	.-182    	; 0x13b8 <xQueueGenericSend+0x38>
    146e:	7b dd       	rcall	.-1290   	; 0xf66 <vPortYield>
    1470:	a3 cf       	rjmp	.-186    	; 0x13b8 <xQueueGenericSend+0x38>
    1472:	c8 01       	movw	r24, r16
    1474:	d6 de       	rcall	.-596    	; 0x1222 <prvUnlockQueue>
    1476:	7d d5       	rcall	.+2810   	; 0x1f72 <xTaskResumeAll>
    1478:	9f cf       	rjmp	.-194    	; 0x13b8 <xQueueGenericSend+0x38>
    147a:	c8 01       	movw	r24, r16
    147c:	d2 de       	rcall	.-604    	; 0x1222 <prvUnlockQueue>
    147e:	79 d5       	rcall	.+2802   	; 0x1f72 <xTaskResumeAll>
    1480:	80 e0       	ldi	r24, 0x00	; 0
    1482:	0f 90       	pop	r0
    1484:	0f 90       	pop	r0
    1486:	0f 90       	pop	r0
    1488:	0f 90       	pop	r0
    148a:	0f 90       	pop	r0
    148c:	df 91       	pop	r29
    148e:	cf 91       	pop	r28
    1490:	1f 91       	pop	r17
    1492:	0f 91       	pop	r16
    1494:	ff 90       	pop	r15
    1496:	ef 90       	pop	r14
    1498:	df 90       	pop	r13
    149a:	cf 90       	pop	r12
    149c:	bf 90       	pop	r11
    149e:	af 90       	pop	r10
    14a0:	9f 90       	pop	r9
    14a2:	08 95       	ret

000014a4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    14a4:	8f 92       	push	r8
    14a6:	9f 92       	push	r9
    14a8:	af 92       	push	r10
    14aa:	bf 92       	push	r11
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ef 92       	push	r14
    14b2:	ff 92       	push	r15
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	00 d0       	rcall	.+0      	; 0x14be <xQueueGenericReceive+0x1a>
    14be:	1f 92       	push	r1
    14c0:	1f 92       	push	r1
    14c2:	cd b7       	in	r28, 0x3d	; 61
    14c4:	de b7       	in	r29, 0x3e	; 62
    14c6:	8c 01       	movw	r16, r24
    14c8:	5b 01       	movw	r10, r22
    14ca:	5d 83       	std	Y+5, r21	; 0x05
    14cc:	4c 83       	std	Y+4, r20	; 0x04
    14ce:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    14d0:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    14d2:	99 24       	eor	r9, r9
    14d4:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14d6:	6c 01       	movw	r12, r24
    14d8:	81 e1       	ldi	r24, 0x11	; 17
    14da:	c8 0e       	add	r12, r24
    14dc:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    14e4:	f8 01       	movw	r30, r16
    14e6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    14e8:	ff 20       	and	r15, r15
    14ea:	61 f1       	breq	.+88     	; 0x1544 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14ec:	c6 80       	ldd	r12, Z+6	; 0x06
    14ee:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    14f0:	b5 01       	movw	r22, r10
    14f2:	c8 01       	movw	r24, r16
    14f4:	7c de       	rcall	.-776    	; 0x11ee <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    14f6:	81 10       	cpse	r8, r1
    14f8:	16 c0       	rjmp	.+44     	; 0x1526 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    14fa:	fa 94       	dec	r15
    14fc:	f8 01       	movw	r30, r16
    14fe:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1500:	80 81       	ld	r24, Z
    1502:	91 81       	ldd	r25, Z+1	; 0x01
    1504:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1506:	21 f4       	brne	.+8      	; 0x1510 <xQueueGenericReceive+0x6c>
    1508:	74 d7       	rcall	.+3816   	; 0x23f2 <pvTaskIncrementMutexHeldCount>
    150a:	f8 01       	movw	r30, r16
    150c:	93 83       	std	Z+3, r25	; 0x03
    150e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1510:	f8 01       	movw	r30, r16
    1512:	80 85       	ldd	r24, Z+8	; 0x08
    1514:	88 23       	and	r24, r24
    1516:	91 f0       	breq	.+36     	; 0x153c <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1518:	c8 01       	movw	r24, r16
    151a:	08 96       	adiw	r24, 0x08	; 8
    151c:	39 d6       	rcall	.+3186   	; 0x2190 <xTaskRemoveFromEventList>
    151e:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
    1520:	69 f0       	breq	.+26     	; 0x153c <xQueueGenericReceive+0x98>
    1522:	21 dd       	rcall	.-1470   	; 0xf66 <vPortYield>
    1524:	0b c0       	rjmp	.+22     	; 0x153c <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1526:	f8 01       	movw	r30, r16
    1528:	d7 82       	std	Z+7, r13	; 0x07
    152a:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    152c:	81 89       	ldd	r24, Z+17	; 0x11
    152e:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1530:	29 f0       	breq	.+10     	; 0x153c <xQueueGenericReceive+0x98>
    1532:	c8 01       	movw	r24, r16
    1534:	41 96       	adiw	r24, 0x11	; 17
    1536:	2c d6       	rcall	.+3160   	; 0x2190 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1538:	81 11       	cpse	r24, r1
    153a:	15 dd       	rcall	.-1494   	; 0xf66 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    153c:	0f 90       	pop	r0
    153e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	51 c0       	rjmp	.+162    	; 0x15e6 <xQueueGenericReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1544:	8c 81       	ldd	r24, Y+4	; 0x04
    1546:	9d 81       	ldd	r25, Y+5	; 0x05
    1548:	89 2b       	or	r24, r25
    154a:	21 f4       	brne	.+8      	; 0x1554 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    154c:	0f 90       	pop	r0
    154e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1550:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
    1552:	49 c0       	rjmp	.+146    	; 0x15e6 <xQueueGenericReceive+0x142>
    1554:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1556:	04 c0       	rjmp	.+8      	; 0x1560 <xQueueGenericReceive+0xbc>
    1558:	ce 01       	movw	r24, r28
    155a:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    155c:	61 d6       	rcall	.+3266   	; 0x2220 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    155e:	e9 2c       	mov	r14, r9
    1560:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1562:	0f be       	out	0x3f, r0	; 63
    1564:	46 d4       	rcall	.+2188   	; 0x1df2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1566:	0f b6       	in	r0, 0x3f	; 63
    1568:	f8 94       	cli
    156a:	0f 92       	push	r0
    156c:	f8 01       	movw	r30, r16
    156e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1570:	8f 3f       	cpi	r24, 0xFF	; 255
    1572:	09 f4       	brne	.+2      	; 0x1576 <xQueueGenericReceive+0xd2>
    1574:	15 8e       	std	Z+29, r1	; 0x1d
    1576:	f8 01       	movw	r30, r16
    1578:	86 8d       	ldd	r24, Z+30	; 0x1e
    157a:	8f 3f       	cpi	r24, 0xFF	; 255
    157c:	09 f4       	brne	.+2      	; 0x1580 <xQueueGenericReceive+0xdc>
    157e:	16 8e       	std	Z+30, r1	; 0x1e
    1580:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	be 01       	movw	r22, r28
    1586:	6c 5f       	subi	r22, 0xFC	; 252
    1588:	7f 4f       	sbci	r23, 0xFF	; 255
    158a:	ce 01       	movw	r24, r28
    158c:	01 96       	adiw	r24, 0x01	; 1
    158e:	53 d6       	rcall	.+3238   	; 0x2236 <xTaskCheckForTimeOut>
    1590:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1592:	20 c0       	rjmp	.+64     	; 0x15d4 <xQueueGenericReceive+0x130>
    1594:	c8 01       	movw	r24, r16
    1596:	c1 dd       	rcall	.-1150   	; 0x111a <prvIsQueueEmpty>
    1598:	88 23       	and	r24, r24
    159a:	c1 f0       	breq	.+48     	; 0x15cc <xQueueGenericReceive+0x128>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    159c:	f8 01       	movw	r30, r16
    159e:	80 81       	ld	r24, Z
    15a0:	91 81       	ldd	r25, Z+1	; 0x01
    15a2:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
    15a4:	41 f4       	brne	.+16     	; 0x15b6 <xQueueGenericReceive+0x112>
    15a6:	0f b6       	in	r0, 0x3f	; 63
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    15a8:	f8 94       	cli
    15aa:	0f 92       	push	r0
						}
						taskEXIT_CRITICAL();
    15ac:	82 81       	ldd	r24, Z+2	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15ae:	93 81       	ldd	r25, Z+3	; 0x03
    15b0:	7e d6       	rcall	.+3324   	; 0x22ae <vTaskPriorityInherit>
    15b2:	0f 90       	pop	r0
				prvUnlockQueue( pxQueue );
    15b4:	0f be       	out	0x3f, r0	; 63
				if( xTaskResumeAll() == pdFALSE )
    15b6:	6c 81       	ldd	r22, Y+4	; 0x04
    15b8:	7d 81       	ldd	r23, Y+5	; 0x05
    15ba:	c6 01       	movw	r24, r12
				{
					portYIELD_WITHIN_API();
    15bc:	d8 d5       	rcall	.+2992   	; 0x216e <vTaskPlaceOnEventList>
    15be:	c8 01       	movw	r24, r16
    15c0:	30 de       	rcall	.-928    	; 0x1222 <prvUnlockQueue>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15c2:	d7 d4       	rcall	.+2478   	; 0x1f72 <xTaskResumeAll>
    15c4:	81 11       	cpse	r24, r1
    15c6:	8b cf       	rjmp	.-234    	; 0x14de <xQueueGenericReceive+0x3a>
				( void ) xTaskResumeAll();
    15c8:	ce dc       	rcall	.-1636   	; 0xf66 <vPortYield>
    15ca:	89 cf       	rjmp	.-238    	; 0x14de <xQueueGenericReceive+0x3a>
    15cc:	c8 01       	movw	r24, r16
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    15ce:	29 de       	rcall	.-942    	; 0x1222 <prvUnlockQueue>
    15d0:	d0 d4       	rcall	.+2464   	; 0x1f72 <xTaskResumeAll>
    15d2:	85 cf       	rjmp	.-246    	; 0x14de <xQueueGenericReceive+0x3a>
			( void ) xTaskResumeAll();
    15d4:	c8 01       	movw	r24, r16
    15d6:	25 de       	rcall	.-950    	; 0x1222 <prvUnlockQueue>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15d8:	cc d4       	rcall	.+2456   	; 0x1f72 <xTaskResumeAll>
    15da:	c8 01       	movw	r24, r16
    15dc:	9e dd       	rcall	.-1220   	; 0x111a <prvIsQueueEmpty>
    15de:	88 23       	and	r24, r24
    15e0:	09 f4       	brne	.+2      	; 0x15e4 <xQueueGenericReceive+0x140>
    15e2:	7d cf       	rjmp	.-262    	; 0x14de <xQueueGenericReceive+0x3a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    15e4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    15e6:	0f 90       	pop	r0
    15e8:	0f 90       	pop	r0
    15ea:	0f 90       	pop	r0
    15ec:	0f 90       	pop	r0
    15ee:	0f 90       	pop	r0
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	1f 91       	pop	r17
    15f6:	0f 91       	pop	r16
    15f8:	ff 90       	pop	r15
    15fa:	ef 90       	pop	r14
    15fc:	df 90       	pop	r13
    15fe:	cf 90       	pop	r12
    1600:	bf 90       	pop	r11
    1602:	af 90       	pop	r10
    1604:	9f 90       	pop	r9
    1606:	8f 90       	pop	r8
    1608:	08 95       	ret

0000160a <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    160a:	1f 92       	push	r1
    160c:	0f 92       	push	r0
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	0f 92       	push	r0
    1612:	11 24       	eor	r1, r1
    1614:	0b b6       	in	r0, 0x3b	; 59
    1616:	0f 92       	push	r0
    1618:	2f 93       	push	r18
    161a:	8f 93       	push	r24
    161c:	9f 93       	push	r25
    161e:	af 93       	push	r26
    1620:	bf 93       	push	r27
    1622:	ef 93       	push	r30
    1624:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	0f 92       	push	r0
	{
	    count = buffer->count;
    162c:	80 91 30 04 	lds	r24, 0x0430	; 0x800430 <xSerialPort+0xd>
    1630:	90 91 31 04 	lds	r25, 0x0431	; 0x800431 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    1634:	0f 90       	pop	r0
    1636:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    1638:	89 2b       	or	r24, r25
    163a:	31 f4       	brne	.+12     	; 0x1648 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    163c:	e1 ec       	ldi	r30, 0xC1	; 193
    163e:	f0 e0       	ldi	r31, 0x00	; 0
    1640:	80 81       	ld	r24, Z
    1642:	8f 7d       	andi	r24, 0xDF	; 223
    1644:	80 83       	st	Z, r24
    1646:	1c c0       	rjmp	.+56     	; 0x1680 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1648:	e0 e3       	ldi	r30, 0x30	; 48
    164a:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    164c:	a4 81       	ldd	r26, Z+4	; 0x04
    164e:	b5 81       	ldd	r27, Z+5	; 0x05
    1650:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1652:	b5 83       	std	Z+5, r27	; 0x05
    1654:	a4 83       	std	Z+4, r26	; 0x04
    1656:	80 85       	ldd	r24, Z+8	; 0x08
    1658:	91 85       	ldd	r25, Z+9	; 0x09
    165a:	a8 17       	cp	r26, r24
    165c:	b9 07       	cpc	r27, r25
    165e:	21 f4       	brne	.+8      	; 0x1668 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    1660:	86 81       	ldd	r24, Z+6	; 0x06
    1662:	97 81       	ldd	r25, Z+7	; 0x07
    1664:	95 83       	std	Z+5, r25	; 0x05
    1666:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1668:	0f b6       	in	r0, 0x3f	; 63
    166a:	f8 94       	cli
    166c:	0f 92       	push	r0
	{
	    buffer->count--;
    166e:	80 81       	ld	r24, Z
    1670:	91 81       	ldd	r25, Z+1	; 0x01
    1672:	01 97       	sbiw	r24, 0x01	; 1
    1674:	91 83       	std	Z+1, r25	; 0x01
    1676:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1678:	0f 90       	pop	r0
    167a:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    167c:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    1680:	ff 91       	pop	r31
    1682:	ef 91       	pop	r30
    1684:	bf 91       	pop	r27
    1686:	af 91       	pop	r26
    1688:	9f 91       	pop	r25
    168a:	8f 91       	pop	r24
    168c:	2f 91       	pop	r18
    168e:	0f 90       	pop	r0
    1690:	0b be       	out	0x3b, r0	; 59
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
    1696:	0f 90       	pop	r0
    1698:	1f 90       	pop	r1
    169a:	18 95       	reti

0000169c <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    169c:	1f 92       	push	r1
    169e:	0f 92       	push	r0
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	0f 92       	push	r0
    16a4:	11 24       	eor	r1, r1
    16a6:	0b b6       	in	r0, 0x3b	; 59
    16a8:	0f 92       	push	r0
    16aa:	2f 93       	push	r18
    16ac:	3f 93       	push	r19
    16ae:	4f 93       	push	r20
    16b0:	8f 93       	push	r24
    16b2:	9f 93       	push	r25
    16b4:	af 93       	push	r26
    16b6:	bf 93       	push	r27
    16b8:	ef 93       	push	r30
    16ba:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    16bc:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    16c0:	8c 71       	andi	r24, 0x1C	; 28
    16c2:	71 f0       	breq	.+28     	; 0x16e0 <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    16c4:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    16c8:	88 23       	and	r24, r24
    16ca:	0c f0       	brlt	.+2      	; 0x16ce <__vector_36+0x32>
    16cc:	36 c0       	rjmp	.+108    	; 0x173a <__vector_36+0x9e>
    16ce:	ae ec       	ldi	r26, 0xCE	; 206
    16d0:	b0 e0       	ldi	r27, 0x00	; 0
    16d2:	e8 ec       	ldi	r30, 0xC8	; 200
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	8c 91       	ld	r24, X
    16d8:	80 81       	ld	r24, Z
    16da:	88 23       	and	r24, r24
    16dc:	e4 f3       	brlt	.-8      	; 0x16d6 <__vector_36+0x3a>
    16de:	2d c0       	rjmp	.+90     	; 0x173a <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    16e0:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	f8 94       	cli
    16e8:	0f 92       	push	r0
	{
	    count = buffer->count;
    16ea:	e9 e8       	ldi	r30, 0x89	; 137
    16ec:	f4 e0       	ldi	r31, 0x04	; 4
    16ee:	21 81       	ldd	r18, Z+1	; 0x01
    16f0:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    16f2:	0f 90       	pop	r0
    16f4:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    16f6:	83 85       	ldd	r24, Z+11	; 0x0b
    16f8:	94 85       	ldd	r25, Z+12	; 0x0c
    16fa:	28 17       	cp	r18, r24
    16fc:	39 07       	cpc	r19, r25
    16fe:	e9 f0       	breq	.+58     	; 0x173a <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1700:	ea e8       	ldi	r30, 0x8A	; 138
    1702:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1704:	a2 81       	ldd	r26, Z+2	; 0x02
    1706:	b3 81       	ldd	r27, Z+3	; 0x03
    1708:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    170a:	82 81       	ldd	r24, Z+2	; 0x02
    170c:	93 81       	ldd	r25, Z+3	; 0x03
    170e:	01 96       	adiw	r24, 0x01	; 1
    1710:	93 83       	std	Z+3, r25	; 0x03
    1712:	82 83       	std	Z+2, r24	; 0x02
    1714:	20 85       	ldd	r18, Z+8	; 0x08
    1716:	31 85       	ldd	r19, Z+9	; 0x09
    1718:	82 17       	cp	r24, r18
    171a:	93 07       	cpc	r25, r19
    171c:	21 f4       	brne	.+8      	; 0x1726 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    171e:	86 81       	ldd	r24, Z+6	; 0x06
    1720:	97 81       	ldd	r25, Z+7	; 0x07
    1722:	93 83       	std	Z+3, r25	; 0x03
    1724:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
	{
	    buffer->count++;
    172c:	80 81       	ld	r24, Z
    172e:	91 81       	ldd	r25, Z+1	; 0x01
    1730:	01 96       	adiw	r24, 0x01	; 1
    1732:	91 83       	std	Z+1, r25	; 0x01
    1734:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1736:	0f 90       	pop	r0
    1738:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    173a:	ff 91       	pop	r31
    173c:	ef 91       	pop	r30
    173e:	bf 91       	pop	r27
    1740:	af 91       	pop	r26
    1742:	9f 91       	pop	r25
    1744:	8f 91       	pop	r24
    1746:	4f 91       	pop	r20
    1748:	3f 91       	pop	r19
    174a:	2f 91       	pop	r18
    174c:	0f 90       	pop	r0
    174e:	0b be       	out	0x3b, r0	; 59
    1750:	0f 90       	pop	r0
    1752:	0f be       	out	0x3f, r0	; 63
    1754:	0f 90       	pop	r0
    1756:	1f 90       	pop	r1
    1758:	18 95       	reti

0000175a <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    175a:	1f 92       	push	r1
    175c:	0f 92       	push	r0
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	0f 92       	push	r0
    1762:	11 24       	eor	r1, r1
    1764:	0b b6       	in	r0, 0x3b	; 59
    1766:	0f 92       	push	r0
    1768:	2f 93       	push	r18
    176a:	8f 93       	push	r24
    176c:	9f 93       	push	r25
    176e:	af 93       	push	r26
    1770:	bf 93       	push	r27
    1772:	ef 93       	push	r30
    1774:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1776:	0f b6       	in	r0, 0x3f	; 63
    1778:	f8 94       	cli
    177a:	0f 92       	push	r0
	{
	    count = buffer->count;
    177c:	80 91 96 04 	lds	r24, 0x0496	; 0x800496 <xSerial1Port+0xd>
    1780:	90 91 97 04 	lds	r25, 0x0497	; 0x800497 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1784:	0f 90       	pop	r0
    1786:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1788:	89 2b       	or	r24, r25
    178a:	31 f4       	brne	.+12     	; 0x1798 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    178c:	e9 ec       	ldi	r30, 0xC9	; 201
    178e:	f0 e0       	ldi	r31, 0x00	; 0
    1790:	80 81       	ld	r24, Z
    1792:	8f 7d       	andi	r24, 0xDF	; 223
    1794:	80 83       	st	Z, r24
    1796:	1c c0       	rjmp	.+56     	; 0x17d0 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1798:	e6 e9       	ldi	r30, 0x96	; 150
    179a:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    179c:	a4 81       	ldd	r26, Z+4	; 0x04
    179e:	b5 81       	ldd	r27, Z+5	; 0x05
    17a0:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    17a2:	b5 83       	std	Z+5, r27	; 0x05
    17a4:	a4 83       	std	Z+4, r26	; 0x04
    17a6:	80 85       	ldd	r24, Z+8	; 0x08
    17a8:	91 85       	ldd	r25, Z+9	; 0x09
    17aa:	a8 17       	cp	r26, r24
    17ac:	b9 07       	cpc	r27, r25
    17ae:	21 f4       	brne	.+8      	; 0x17b8 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    17b0:	86 81       	ldd	r24, Z+6	; 0x06
    17b2:	97 81       	ldd	r25, Z+7	; 0x07
    17b4:	95 83       	std	Z+5, r25	; 0x05
    17b6:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	f8 94       	cli
    17bc:	0f 92       	push	r0
	{
	    buffer->count--;
    17be:	80 81       	ld	r24, Z
    17c0:	91 81       	ldd	r25, Z+1	; 0x01
    17c2:	01 97       	sbiw	r24, 0x01	; 1
    17c4:	91 83       	std	Z+1, r25	; 0x01
    17c6:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    17c8:	0f 90       	pop	r0
    17ca:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    17cc:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    17d0:	ff 91       	pop	r31
    17d2:	ef 91       	pop	r30
    17d4:	bf 91       	pop	r27
    17d6:	af 91       	pop	r26
    17d8:	9f 91       	pop	r25
    17da:	8f 91       	pop	r24
    17dc:	2f 91       	pop	r18
    17de:	0f 90       	pop	r0
    17e0:	0b be       	out	0x3b, r0	; 59
    17e2:	0f 90       	pop	r0
    17e4:	0f be       	out	0x3f, r0	; 63
    17e6:	0f 90       	pop	r0
    17e8:	1f 90       	pop	r1
    17ea:	18 95       	reti

000017ec <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    17ec:	1f 92       	push	r1
    17ee:	0f 92       	push	r0
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	0f 92       	push	r0
    17f4:	11 24       	eor	r1, r1
    17f6:	0b b6       	in	r0, 0x3b	; 59
    17f8:	0f 92       	push	r0
    17fa:	2f 93       	push	r18
    17fc:	3f 93       	push	r19
    17fe:	4f 93       	push	r20
    1800:	8f 93       	push	r24
    1802:	9f 93       	push	r25
    1804:	af 93       	push	r26
    1806:	bf 93       	push	r27
    1808:	ef 93       	push	r30
    180a:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    180c:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1810:	8c 71       	andi	r24, 0x1C	; 28
    1812:	71 f0       	breq	.+28     	; 0x1830 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1814:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1818:	88 23       	and	r24, r24
    181a:	0c f0       	brlt	.+2      	; 0x181e <__vector_51+0x32>
    181c:	36 c0       	rjmp	.+108    	; 0x188a <__vector_51+0x9e>
    181e:	a6 ed       	ldi	r26, 0xD6	; 214
    1820:	b0 e0       	ldi	r27, 0x00	; 0
    1822:	e0 ed       	ldi	r30, 0xD0	; 208
    1824:	f0 e0       	ldi	r31, 0x00	; 0
    1826:	8c 91       	ld	r24, X
    1828:	80 81       	ld	r24, Z
    182a:	88 23       	and	r24, r24
    182c:	e4 f3       	brlt	.-8      	; 0x1826 <__vector_51+0x3a>
    182e:	2d c0       	rjmp	.+90     	; 0x188a <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    1830:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
	{
	    count = buffer->count;
    183a:	e5 e4       	ldi	r30, 0x45	; 69
    183c:	f4 e0       	ldi	r31, 0x04	; 4
    183e:	21 81       	ldd	r18, Z+1	; 0x01
    1840:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    1846:	83 85       	ldd	r24, Z+11	; 0x0b
    1848:	94 85       	ldd	r25, Z+12	; 0x0c
    184a:	28 17       	cp	r18, r24
    184c:	39 07       	cpc	r19, r25
    184e:	e9 f0       	breq	.+58     	; 0x188a <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1850:	e6 e4       	ldi	r30, 0x46	; 70
    1852:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1854:	a2 81       	ldd	r26, Z+2	; 0x02
    1856:	b3 81       	ldd	r27, Z+3	; 0x03
    1858:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    185a:	82 81       	ldd	r24, Z+2	; 0x02
    185c:	93 81       	ldd	r25, Z+3	; 0x03
    185e:	01 96       	adiw	r24, 0x01	; 1
    1860:	93 83       	std	Z+3, r25	; 0x03
    1862:	82 83       	std	Z+2, r24	; 0x02
    1864:	20 85       	ldd	r18, Z+8	; 0x08
    1866:	31 85       	ldd	r19, Z+9	; 0x09
    1868:	82 17       	cp	r24, r18
    186a:	93 07       	cpc	r25, r19
    186c:	21 f4       	brne	.+8      	; 0x1876 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    186e:	86 81       	ldd	r24, Z+6	; 0x06
    1870:	97 81       	ldd	r25, Z+7	; 0x07
    1872:	93 83       	std	Z+3, r25	; 0x03
    1874:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
	{
	    buffer->count++;
    187c:	80 81       	ld	r24, Z
    187e:	91 81       	ldd	r25, Z+1	; 0x01
    1880:	01 96       	adiw	r24, 0x01	; 1
    1882:	91 83       	std	Z+1, r25	; 0x01
    1884:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    188a:	ff 91       	pop	r31
    188c:	ef 91       	pop	r30
    188e:	bf 91       	pop	r27
    1890:	af 91       	pop	r26
    1892:	9f 91       	pop	r25
    1894:	8f 91       	pop	r24
    1896:	4f 91       	pop	r20
    1898:	3f 91       	pop	r19
    189a:	2f 91       	pop	r18
    189c:	0f 90       	pop	r0
    189e:	0b be       	out	0x3b, r0	; 59
    18a0:	0f 90       	pop	r0
    18a2:	0f be       	out	0x3f, r0	; 63
    18a4:	0f 90       	pop	r0
    18a6:	1f 90       	pop	r1
    18a8:	18 95       	reti

000018aa <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    18aa:	1f 92       	push	r1
    18ac:	0f 92       	push	r0
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	0f 92       	push	r0
    18b2:	11 24       	eor	r1, r1
    18b4:	0b b6       	in	r0, 0x3b	; 59
    18b6:	0f 92       	push	r0
    18b8:	2f 93       	push	r18
    18ba:	8f 93       	push	r24
    18bc:	9f 93       	push	r25
    18be:	af 93       	push	r26
    18c0:	bf 93       	push	r27
    18c2:	ef 93       	push	r30
    18c4:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18c6:	0f b6       	in	r0, 0x3f	; 63
    18c8:	f8 94       	cli
    18ca:	0f 92       	push	r0
	{
	    count = buffer->count;
    18cc:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <xSerial2Port+0xd>
    18d0:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    18d4:	0f 90       	pop	r0
    18d6:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    18d8:	89 2b       	or	r24, r25
    18da:	31 f4       	brne	.+12     	; 0x18e8 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    18dc:	e1 ed       	ldi	r30, 0xD1	; 209
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	80 81       	ld	r24, Z
    18e2:	8f 7d       	andi	r24, 0xDF	; 223
    18e4:	80 83       	st	Z, r24
    18e6:	1c c0       	rjmp	.+56     	; 0x1920 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    18e8:	e2 e5       	ldi	r30, 0x52	; 82
    18ea:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    18ec:	a4 81       	ldd	r26, Z+4	; 0x04
    18ee:	b5 81       	ldd	r27, Z+5	; 0x05
    18f0:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    18f2:	b5 83       	std	Z+5, r27	; 0x05
    18f4:	a4 83       	std	Z+4, r26	; 0x04
    18f6:	80 85       	ldd	r24, Z+8	; 0x08
    18f8:	91 85       	ldd	r25, Z+9	; 0x09
    18fa:	a8 17       	cp	r26, r24
    18fc:	b9 07       	cpc	r27, r25
    18fe:	21 f4       	brne	.+8      	; 0x1908 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    1900:	86 81       	ldd	r24, Z+6	; 0x06
    1902:	97 81       	ldd	r25, Z+7	; 0x07
    1904:	95 83       	std	Z+5, r25	; 0x05
    1906:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
	{
	    buffer->count--;
    190e:	80 81       	ld	r24, Z
    1910:	91 81       	ldd	r25, Z+1	; 0x01
    1912:	01 97       	sbiw	r24, 0x01	; 1
    1914:	91 83       	std	Z+1, r25	; 0x01
    1916:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1918:	0f 90       	pop	r0
    191a:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    191c:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    1920:	ff 91       	pop	r31
    1922:	ef 91       	pop	r30
    1924:	bf 91       	pop	r27
    1926:	af 91       	pop	r26
    1928:	9f 91       	pop	r25
    192a:	8f 91       	pop	r24
    192c:	2f 91       	pop	r18
    192e:	0f 90       	pop	r0
    1930:	0b be       	out	0x3b, r0	; 59
    1932:	0f 90       	pop	r0
    1934:	0f be       	out	0x3f, r0	; 63
    1936:	0f 90       	pop	r0
    1938:	1f 90       	pop	r1
    193a:	18 95       	reti

0000193c <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    193c:	1f 92       	push	r1
    193e:	0f 92       	push	r0
    1940:	0f b6       	in	r0, 0x3f	; 63
    1942:	0f 92       	push	r0
    1944:	11 24       	eor	r1, r1
    1946:	0b b6       	in	r0, 0x3b	; 59
    1948:	0f 92       	push	r0
    194a:	2f 93       	push	r18
    194c:	3f 93       	push	r19
    194e:	4f 93       	push	r20
    1950:	8f 93       	push	r24
    1952:	9f 93       	push	r25
    1954:	af 93       	push	r26
    1956:	bf 93       	push	r27
    1958:	ef 93       	push	r30
    195a:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    195c:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1960:	8c 71       	andi	r24, 0x1C	; 28
    1962:	71 f0       	breq	.+28     	; 0x1980 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    1964:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1968:	88 23       	and	r24, r24
    196a:	0c f0       	brlt	.+2      	; 0x196e <__vector_54+0x32>
    196c:	36 c0       	rjmp	.+108    	; 0x19da <__vector_54+0x9e>
    196e:	a6 e3       	ldi	r26, 0x36	; 54
    1970:	b1 e0       	ldi	r27, 0x01	; 1
    1972:	e0 e3       	ldi	r30, 0x30	; 48
    1974:	f1 e0       	ldi	r31, 0x01	; 1
    1976:	8c 91       	ld	r24, X
    1978:	80 81       	ld	r24, Z
    197a:	88 23       	and	r24, r24
    197c:	e4 f3       	brlt	.-8      	; 0x1976 <__vector_54+0x3a>
    197e:	2d c0       	rjmp	.+90     	; 0x19da <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1980:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
	{
	    count = buffer->count;
    198a:	e7 e6       	ldi	r30, 0x67	; 103
    198c:	f4 e0       	ldi	r31, 0x04	; 4
    198e:	21 81       	ldd	r18, Z+1	; 0x01
    1990:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1996:	83 85       	ldd	r24, Z+11	; 0x0b
    1998:	94 85       	ldd	r25, Z+12	; 0x0c
    199a:	28 17       	cp	r18, r24
    199c:	39 07       	cpc	r19, r25
    199e:	e9 f0       	breq	.+58     	; 0x19da <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    19a0:	e8 e6       	ldi	r30, 0x68	; 104
    19a2:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    19a4:	a2 81       	ldd	r26, Z+2	; 0x02
    19a6:	b3 81       	ldd	r27, Z+3	; 0x03
    19a8:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    19aa:	82 81       	ldd	r24, Z+2	; 0x02
    19ac:	93 81       	ldd	r25, Z+3	; 0x03
    19ae:	01 96       	adiw	r24, 0x01	; 1
    19b0:	93 83       	std	Z+3, r25	; 0x03
    19b2:	82 83       	std	Z+2, r24	; 0x02
    19b4:	20 85       	ldd	r18, Z+8	; 0x08
    19b6:	31 85       	ldd	r19, Z+9	; 0x09
    19b8:	82 17       	cp	r24, r18
    19ba:	93 07       	cpc	r25, r19
    19bc:	21 f4       	brne	.+8      	; 0x19c6 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    19be:	86 81       	ldd	r24, Z+6	; 0x06
    19c0:	97 81       	ldd	r25, Z+7	; 0x07
    19c2:	93 83       	std	Z+3, r25	; 0x03
    19c4:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	0f 92       	push	r0
	{
	    buffer->count++;
    19cc:	80 81       	ld	r24, Z
    19ce:	91 81       	ldd	r25, Z+1	; 0x01
    19d0:	01 96       	adiw	r24, 0x01	; 1
    19d2:	91 83       	std	Z+1, r25	; 0x01
    19d4:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    19da:	ff 91       	pop	r31
    19dc:	ef 91       	pop	r30
    19de:	bf 91       	pop	r27
    19e0:	af 91       	pop	r26
    19e2:	9f 91       	pop	r25
    19e4:	8f 91       	pop	r24
    19e6:	4f 91       	pop	r20
    19e8:	3f 91       	pop	r19
    19ea:	2f 91       	pop	r18
    19ec:	0f 90       	pop	r0
    19ee:	0b be       	out	0x3b, r0	; 59
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	0f 90       	pop	r0
    19f6:	1f 90       	pop	r1
    19f8:	18 95       	reti

000019fa <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    19fa:	1f 92       	push	r1
    19fc:	0f 92       	push	r0
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	0f 92       	push	r0
    1a02:	11 24       	eor	r1, r1
    1a04:	0b b6       	in	r0, 0x3b	; 59
    1a06:	0f 92       	push	r0
    1a08:	2f 93       	push	r18
    1a0a:	8f 93       	push	r24
    1a0c:	9f 93       	push	r25
    1a0e:	af 93       	push	r26
    1a10:	bf 93       	push	r27
    1a12:	ef 93       	push	r30
    1a14:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a1c:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <xSerial3Port+0xd>
    1a20:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1a24:	0f 90       	pop	r0
    1a26:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1a28:	89 2b       	or	r24, r25
    1a2a:	31 f4       	brne	.+12     	; 0x1a38 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1a2c:	e1 e3       	ldi	r30, 0x31	; 49
    1a2e:	f1 e0       	ldi	r31, 0x01	; 1
    1a30:	80 81       	ld	r24, Z
    1a32:	8f 7d       	andi	r24, 0xDF	; 223
    1a34:	80 83       	st	Z, r24
    1a36:	1c c0       	rjmp	.+56     	; 0x1a70 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a38:	e4 e7       	ldi	r30, 0x74	; 116
    1a3a:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1a3c:	a4 81       	ldd	r26, Z+4	; 0x04
    1a3e:	b5 81       	ldd	r27, Z+5	; 0x05
    1a40:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1a42:	b5 83       	std	Z+5, r27	; 0x05
    1a44:	a4 83       	std	Z+4, r26	; 0x04
    1a46:	80 85       	ldd	r24, Z+8	; 0x08
    1a48:	91 85       	ldd	r25, Z+9	; 0x09
    1a4a:	a8 17       	cp	r26, r24
    1a4c:	b9 07       	cpc	r27, r25
    1a4e:	21 f4       	brne	.+8      	; 0x1a58 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1a50:	86 81       	ldd	r24, Z+6	; 0x06
    1a52:	97 81       	ldd	r25, Z+7	; 0x07
    1a54:	95 83       	std	Z+5, r25	; 0x05
    1a56:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
	{
	    buffer->count--;
    1a5e:	80 81       	ld	r24, Z
    1a60:	91 81       	ldd	r25, Z+1	; 0x01
    1a62:	01 97       	sbiw	r24, 0x01	; 1
    1a64:	91 83       	std	Z+1, r25	; 0x01
    1a66:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1a6c:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1a70:	ff 91       	pop	r31
    1a72:	ef 91       	pop	r30
    1a74:	bf 91       	pop	r27
    1a76:	af 91       	pop	r26
    1a78:	9f 91       	pop	r25
    1a7a:	8f 91       	pop	r24
    1a7c:	2f 91       	pop	r18
    1a7e:	0f 90       	pop	r0
    1a80:	0b be       	out	0x3b, r0	; 59
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	0f 90       	pop	r0
    1a88:	1f 90       	pop	r1
    1a8a:	18 95       	reti

00001a8c <prvResetNextTaskUnblockTime>:
    1a8c:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1a90:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1a94:	80 81       	ld	r24, Z
    1a96:	81 11       	cpse	r24, r1
    1a98:	07 c0       	rjmp	.+14     	; 0x1aa8 <prvResetNextTaskUnblockTime+0x1c>
    1a9a:	8f ef       	ldi	r24, 0xFF	; 255
    1a9c:	9f ef       	ldi	r25, 0xFF	; 255
    1a9e:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1aa2:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1aa6:	08 95       	ret
    1aa8:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1aac:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1ab0:	05 80       	ldd	r0, Z+5	; 0x05
    1ab2:	f6 81       	ldd	r31, Z+6	; 0x06
    1ab4:	e0 2d       	mov	r30, r0
    1ab6:	06 80       	ldd	r0, Z+6	; 0x06
    1ab8:	f7 81       	ldd	r31, Z+7	; 0x07
    1aba:	e0 2d       	mov	r30, r0
    1abc:	82 81       	ldd	r24, Z+2	; 0x02
    1abe:	93 81       	ldd	r25, Z+3	; 0x03
    1ac0:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1ac4:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1ac8:	08 95       	ret

00001aca <prvAddCurrentTaskToDelayedList>:
    1aca:	ff 92       	push	r15
    1acc:	0f 93       	push	r16
    1ace:	1f 93       	push	r17
    1ad0:	cf 93       	push	r28
    1ad2:	df 93       	push	r29
    1ad4:	ec 01       	movw	r28, r24
    1ad6:	f6 2e       	mov	r15, r22
    1ad8:	00 91 b5 02 	lds	r16, 0x02B5	; 0x8002b5 <xTickCount>
    1adc:	10 91 b6 02 	lds	r17, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    1ae0:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    1ae4:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1ae8:	02 96       	adiw	r24, 0x02	; 2
    1aea:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1aee:	cf 3f       	cpi	r28, 0xFF	; 255
    1af0:	8f ef       	ldi	r24, 0xFF	; 255
    1af2:	d8 07       	cpc	r29, r24
    1af4:	69 f4       	brne	.+26     	; 0x1b10 <prvAddCurrentTaskToDelayedList+0x46>
    1af6:	ff 20       	and	r15, r15
    1af8:	59 f0       	breq	.+22     	; 0x1b10 <prvAddCurrentTaskToDelayedList+0x46>
    1afa:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    1afe:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1b02:	6e 5f       	subi	r22, 0xFE	; 254
    1b04:	7f 4f       	sbci	r23, 0xFF	; 255
    1b06:	88 eb       	ldi	r24, 0xB8	; 184
    1b08:	92 e0       	ldi	r25, 0x02	; 2
    1b0a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1b0e:	2f c0       	rjmp	.+94     	; 0x1b6e <prvAddCurrentTaskToDelayedList+0xa4>
    1b10:	c0 0f       	add	r28, r16
    1b12:	d1 1f       	adc	r29, r17
    1b14:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1b18:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1b1c:	d3 83       	std	Z+3, r29	; 0x03
    1b1e:	c2 83       	std	Z+2, r28	; 0x02
    1b20:	c0 17       	cp	r28, r16
    1b22:	d1 07       	cpc	r29, r17
    1b24:	68 f4       	brcc	.+26     	; 0x1b40 <prvAddCurrentTaskToDelayedList+0x76>
    1b26:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    1b2a:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1b2e:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxOverflowDelayedTaskList>
    1b32:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1b36:	6e 5f       	subi	r22, 0xFE	; 254
    1b38:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3a:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1b3e:	17 c0       	rjmp	.+46     	; 0x1b6e <prvAddCurrentTaskToDelayedList+0xa4>
    1b40:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    1b44:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1b48:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1b4c:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1b50:	6e 5f       	subi	r22, 0xFE	; 254
    1b52:	7f 4f       	sbci	r23, 0xFF	; 255
    1b54:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1b58:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <xNextTaskUnblockTime>
    1b5c:	90 91 ae 02 	lds	r25, 0x02AE	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1b60:	c8 17       	cp	r28, r24
    1b62:	d9 07       	cpc	r29, r25
    1b64:	20 f4       	brcc	.+8      	; 0x1b6e <prvAddCurrentTaskToDelayedList+0xa4>
    1b66:	d0 93 ae 02 	sts	0x02AE, r29	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1b6a:	c0 93 ad 02 	sts	0x02AD, r28	; 0x8002ad <xNextTaskUnblockTime>
    1b6e:	df 91       	pop	r29
    1b70:	cf 91       	pop	r28
    1b72:	1f 91       	pop	r17
    1b74:	0f 91       	pop	r16
    1b76:	ff 90       	pop	r15
    1b78:	08 95       	ret

00001b7a <xTaskCreate>:
    1b7a:	4f 92       	push	r4
    1b7c:	5f 92       	push	r5
    1b7e:	6f 92       	push	r6
    1b80:	7f 92       	push	r7
    1b82:	8f 92       	push	r8
    1b84:	9f 92       	push	r9
    1b86:	af 92       	push	r10
    1b88:	bf 92       	push	r11
    1b8a:	cf 92       	push	r12
    1b8c:	df 92       	push	r13
    1b8e:	ef 92       	push	r14
    1b90:	ff 92       	push	r15
    1b92:	0f 93       	push	r16
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	4c 01       	movw	r8, r24
    1b9a:	6b 01       	movw	r12, r22
    1b9c:	5a 01       	movw	r10, r20
    1b9e:	29 01       	movw	r4, r18
    1ba0:	ca 01       	movw	r24, r20
    1ba2:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1ba6:	3c 01       	movw	r6, r24
    1ba8:	89 2b       	or	r24, r25
    1baa:	09 f4       	brne	.+2      	; 0x1bae <xTaskCreate+0x34>
    1bac:	e9 c0       	rjmp	.+466    	; 0x1d80 <xTaskCreate+0x206>
    1bae:	88 e2       	ldi	r24, 0x28	; 40
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1bb6:	ec 01       	movw	r28, r24
    1bb8:	89 2b       	or	r24, r25
    1bba:	a9 f0       	breq	.+42     	; 0x1be6 <xTaskCreate+0x6c>
    1bbc:	78 8e       	std	Y+24, r7	; 0x18
    1bbe:	6f 8a       	std	Y+23, r6	; 0x17
    1bc0:	a5 01       	movw	r20, r10
    1bc2:	65 ea       	ldi	r22, 0xA5	; 165
    1bc4:	70 e0       	ldi	r23, 0x00	; 0
    1bc6:	c3 01       	movw	r24, r6
    1bc8:	1a d7       	rcall	.+3636   	; 0x29fe <memset>
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	a8 1a       	sub	r10, r24
    1bce:	b1 08       	sbc	r11, r1
    1bd0:	8f 89       	ldd	r24, Y+23	; 0x17
    1bd2:	98 8d       	ldd	r25, Y+24	; 0x18
    1bd4:	a8 0e       	add	r10, r24
    1bd6:	b9 1e       	adc	r11, r25
    1bd8:	d6 01       	movw	r26, r12
    1bda:	8c 91       	ld	r24, X
    1bdc:	89 8f       	std	Y+25, r24	; 0x19
    1bde:	8c 91       	ld	r24, X
    1be0:	81 11       	cpse	r24, r1
    1be2:	05 c0       	rjmp	.+10     	; 0x1bee <xTaskCreate+0x74>
    1be4:	18 c0       	rjmp	.+48     	; 0x1c16 <xTaskCreate+0x9c>
    1be6:	c3 01       	movw	r24, r6
    1be8:	0e 94 bc 01 	call	0x378	; 0x378 <vPortFree>
    1bec:	c9 c0       	rjmp	.+402    	; 0x1d80 <xTaskCreate+0x206>
    1bee:	ae 01       	movw	r20, r28
    1bf0:	46 5e       	subi	r20, 0xE6	; 230
    1bf2:	5f 4f       	sbci	r21, 0xFF	; 255
    1bf4:	f6 01       	movw	r30, r12
    1bf6:	31 96       	adiw	r30, 0x01	; 1
    1bf8:	b8 e0       	ldi	r27, 0x08	; 8
    1bfa:	cb 0e       	add	r12, r27
    1bfc:	d1 1c       	adc	r13, r1
    1bfe:	cf 01       	movw	r24, r30
    1c00:	21 91       	ld	r18, Z+
    1c02:	da 01       	movw	r26, r20
    1c04:	2d 93       	st	X+, r18
    1c06:	ad 01       	movw	r20, r26
    1c08:	dc 01       	movw	r26, r24
    1c0a:	8c 91       	ld	r24, X
    1c0c:	88 23       	and	r24, r24
    1c0e:	19 f0       	breq	.+6      	; 0x1c16 <xTaskCreate+0x9c>
    1c10:	ec 15       	cp	r30, r12
    1c12:	fd 05       	cpc	r31, r13
    1c14:	a1 f7       	brne	.-24     	; 0x1bfe <xTaskCreate+0x84>
    1c16:	18 a2       	std	Y+32, r1	; 0x20
    1c18:	04 30       	cpi	r16, 0x04	; 4
    1c1a:	08 f0       	brcs	.+2      	; 0x1c1e <xTaskCreate+0xa4>
    1c1c:	03 e0       	ldi	r16, 0x03	; 3
    1c1e:	0e 8b       	std	Y+22, r16	; 0x16
    1c20:	09 a3       	std	Y+33, r16	; 0x21
    1c22:	1a a2       	std	Y+34, r1	; 0x22
    1c24:	6e 01       	movw	r12, r28
    1c26:	b2 e0       	ldi	r27, 0x02	; 2
    1c28:	cb 0e       	add	r12, r27
    1c2a:	d1 1c       	adc	r13, r1
    1c2c:	c6 01       	movw	r24, r12
    1c2e:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1c32:	ce 01       	movw	r24, r28
    1c34:	0c 96       	adiw	r24, 0x0c	; 12
    1c36:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1c3a:	d9 87       	std	Y+9, r29	; 0x09
    1c3c:	c8 87       	std	Y+8, r28	; 0x08
    1c3e:	84 e0       	ldi	r24, 0x04	; 4
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	80 1b       	sub	r24, r16
    1c44:	91 09       	sbc	r25, r1
    1c46:	9d 87       	std	Y+13, r25	; 0x0d
    1c48:	8c 87       	std	Y+12, r24	; 0x0c
    1c4a:	db 8b       	std	Y+19, r29	; 0x13
    1c4c:	ca 8b       	std	Y+18, r28	; 0x12
    1c4e:	1b a2       	std	Y+35, r1	; 0x23
    1c50:	1c a2       	std	Y+36, r1	; 0x24
    1c52:	1d a2       	std	Y+37, r1	; 0x25
    1c54:	1e a2       	std	Y+38, r1	; 0x26
    1c56:	1f a2       	std	Y+39, r1	; 0x27
    1c58:	a2 01       	movw	r20, r4
    1c5a:	b4 01       	movw	r22, r8
    1c5c:	c5 01       	movw	r24, r10
    1c5e:	cb d8       	rcall	.-3690   	; 0xdf6 <pxPortInitialiseStack>
    1c60:	99 83       	std	Y+1, r25	; 0x01
    1c62:	88 83       	st	Y, r24
    1c64:	e1 14       	cp	r14, r1
    1c66:	f1 04       	cpc	r15, r1
    1c68:	19 f0       	breq	.+6      	; 0x1c70 <xTaskCreate+0xf6>
    1c6a:	f7 01       	movw	r30, r14
    1c6c:	d1 83       	std	Z+1, r29	; 0x01
    1c6e:	c0 83       	st	Z, r28
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	0f 92       	push	r0
    1c76:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1c7a:	8f 5f       	subi	r24, 0xFF	; 255
    1c7c:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <uxCurrentNumberOfTasks>
    1c80:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    1c84:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1c88:	89 2b       	or	r24, r25
    1c8a:	d1 f5       	brne	.+116    	; 0x1d00 <xTaskCreate+0x186>
    1c8c:	d0 93 0f 03 	sts	0x030F, r29	; 0x80030f <pxCurrentTCB+0x1>
    1c90:	c0 93 0e 03 	sts	0x030E, r28	; 0x80030e <pxCurrentTCB>
    1c94:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1c98:	81 30       	cpi	r24, 0x01	; 1
    1c9a:	09 f0       	breq	.+2      	; 0x1c9e <xTaskCreate+0x124>
    1c9c:	41 c0       	rjmp	.+130    	; 0x1d20 <xTaskCreate+0x1a6>
    1c9e:	8a ee       	ldi	r24, 0xEA	; 234
    1ca0:	92 e0       	ldi	r25, 0x02	; 2
    1ca2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1ca6:	83 ef       	ldi	r24, 0xF3	; 243
    1ca8:	92 e0       	ldi	r25, 0x02	; 2
    1caa:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cae:	8c ef       	ldi	r24, 0xFC	; 252
    1cb0:	92 e0       	ldi	r25, 0x02	; 2
    1cb2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cb6:	85 e0       	ldi	r24, 0x05	; 5
    1cb8:	93 e0       	ldi	r25, 0x03	; 3
    1cba:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cbe:	81 ee       	ldi	r24, 0xE1	; 225
    1cc0:	92 e0       	ldi	r25, 0x02	; 2
    1cc2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cc6:	88 ed       	ldi	r24, 0xD8	; 216
    1cc8:	92 e0       	ldi	r25, 0x02	; 2
    1cca:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cce:	8b ec       	ldi	r24, 0xCB	; 203
    1cd0:	92 e0       	ldi	r25, 0x02	; 2
    1cd2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cd6:	82 ec       	ldi	r24, 0xC2	; 194
    1cd8:	92 e0       	ldi	r25, 0x02	; 2
    1cda:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1cde:	88 eb       	ldi	r24, 0xB8	; 184
    1ce0:	92 e0       	ldi	r25, 0x02	; 2
    1ce2:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1ce6:	81 ee       	ldi	r24, 0xE1	; 225
    1ce8:	92 e0       	ldi	r25, 0x02	; 2
    1cea:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <pxDelayedTaskList+0x1>
    1cee:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <pxDelayedTaskList>
    1cf2:	88 ed       	ldi	r24, 0xD8	; 216
    1cf4:	92 e0       	ldi	r25, 0x02	; 2
    1cf6:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1cfa:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <pxOverflowDelayedTaskList>
    1cfe:	10 c0       	rjmp	.+32     	; 0x1d20 <xTaskCreate+0x1a6>
    1d00:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <xSchedulerRunning>
    1d04:	81 11       	cpse	r24, r1
    1d06:	0c c0       	rjmp	.+24     	; 0x1d20 <xTaskCreate+0x1a6>
    1d08:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1d0c:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1d10:	96 89       	ldd	r25, Z+22	; 0x16
    1d12:	8e 89       	ldd	r24, Y+22	; 0x16
    1d14:	89 17       	cp	r24, r25
    1d16:	20 f0       	brcs	.+8      	; 0x1d20 <xTaskCreate+0x1a6>
    1d18:	d0 93 0f 03 	sts	0x030F, r29	; 0x80030f <pxCurrentTCB+0x1>
    1d1c:	c0 93 0e 03 	sts	0x030E, r28	; 0x80030e <pxCurrentTCB>
    1d20:	80 91 af 02 	lds	r24, 0x02AF	; 0x8002af <uxTaskNumber>
    1d24:	8f 5f       	subi	r24, 0xFF	; 255
    1d26:	80 93 af 02 	sts	0x02AF, r24	; 0x8002af <uxTaskNumber>
    1d2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d2c:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1d30:	98 17       	cp	r25, r24
    1d32:	10 f4       	brcc	.+4      	; 0x1d38 <xTaskCreate+0x1be>
    1d34:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	9c 01       	movw	r18, r24
    1d3c:	22 0f       	add	r18, r18
    1d3e:	33 1f       	adc	r19, r19
    1d40:	22 0f       	add	r18, r18
    1d42:	33 1f       	adc	r19, r19
    1d44:	22 0f       	add	r18, r18
    1d46:	33 1f       	adc	r19, r19
    1d48:	82 0f       	add	r24, r18
    1d4a:	93 1f       	adc	r25, r19
    1d4c:	b6 01       	movw	r22, r12
    1d4e:	86 51       	subi	r24, 0x16	; 22
    1d50:	9d 4f       	sbci	r25, 0xFD	; 253
    1d52:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1d56:	0f 90       	pop	r0
    1d58:	0f be       	out	0x3f, r0	; 63
    1d5a:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <xSchedulerRunning>
    1d5e:	88 23       	and	r24, r24
    1d60:	59 f0       	breq	.+22     	; 0x1d78 <xTaskCreate+0x1fe>
    1d62:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1d66:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1d6a:	96 89       	ldd	r25, Z+22	; 0x16
    1d6c:	8e 89       	ldd	r24, Y+22	; 0x16
    1d6e:	98 17       	cp	r25, r24
    1d70:	28 f4       	brcc	.+10     	; 0x1d7c <xTaskCreate+0x202>
    1d72:	f9 d8       	rcall	.-3598   	; 0xf66 <vPortYield>
    1d74:	81 e0       	ldi	r24, 0x01	; 1
    1d76:	05 c0       	rjmp	.+10     	; 0x1d82 <xTaskCreate+0x208>
    1d78:	81 e0       	ldi	r24, 0x01	; 1
    1d7a:	03 c0       	rjmp	.+6      	; 0x1d82 <xTaskCreate+0x208>
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	01 c0       	rjmp	.+2      	; 0x1d82 <xTaskCreate+0x208>
    1d80:	8f ef       	ldi	r24, 0xFF	; 255
    1d82:	df 91       	pop	r29
    1d84:	cf 91       	pop	r28
    1d86:	0f 91       	pop	r16
    1d88:	ff 90       	pop	r15
    1d8a:	ef 90       	pop	r14
    1d8c:	df 90       	pop	r13
    1d8e:	cf 90       	pop	r12
    1d90:	bf 90       	pop	r11
    1d92:	af 90       	pop	r10
    1d94:	9f 90       	pop	r9
    1d96:	8f 90       	pop	r8
    1d98:	7f 90       	pop	r7
    1d9a:	6f 90       	pop	r6
    1d9c:	5f 90       	pop	r5
    1d9e:	4f 90       	pop	r4
    1da0:	08 95       	ret

00001da2 <vTaskStartScheduler>:
    1da2:	ef 92       	push	r14
    1da4:	ff 92       	push	r15
    1da6:	0f 93       	push	r16
    1da8:	0f 2e       	mov	r0, r31
    1daa:	fb ea       	ldi	r31, 0xAB	; 171
    1dac:	ef 2e       	mov	r14, r31
    1dae:	f2 e0       	ldi	r31, 0x02	; 2
    1db0:	ff 2e       	mov	r15, r31
    1db2:	f0 2d       	mov	r31, r0
    1db4:	00 e0       	ldi	r16, 0x00	; 0
    1db6:	20 e0       	ldi	r18, 0x00	; 0
    1db8:	30 e0       	ldi	r19, 0x00	; 0
    1dba:	45 e5       	ldi	r20, 0x55	; 85
    1dbc:	50 e0       	ldi	r21, 0x00	; 0
    1dbe:	6d e7       	ldi	r22, 0x7D	; 125
    1dc0:	72 e0       	ldi	r23, 0x02	; 2
    1dc2:	83 e3       	ldi	r24, 0x33	; 51
    1dc4:	91 e0       	ldi	r25, 0x01	; 1
    1dc6:	d9 de       	rcall	.-590    	; 0x1b7a <xTaskCreate>
    1dc8:	81 30       	cpi	r24, 0x01	; 1
    1dca:	79 f4       	brne	.+30     	; 0x1dea <vTaskStartScheduler+0x48>
    1dcc:	f8 94       	cli
    1dce:	8f ef       	ldi	r24, 0xFF	; 255
    1dd0:	9f ef       	ldi	r25, 0xFF	; 255
    1dd2:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1dd6:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1dda:	81 e0       	ldi	r24, 0x01	; 1
    1ddc:	80 93 b3 02 	sts	0x02B3, r24	; 0x8002b3 <xSchedulerRunning>
    1de0:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <xTickCount+0x1>
    1de4:	10 92 b5 02 	sts	0x02B5, r1	; 0x8002b5 <xTickCount>
    1de8:	78 d8       	rcall	.-3856   	; 0xeda <xPortStartScheduler>
    1dea:	0f 91       	pop	r16
    1dec:	ff 90       	pop	r15
    1dee:	ef 90       	pop	r14
    1df0:	08 95       	ret

00001df2 <vTaskSuspendAll>:
    1df2:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1df6:	8f 5f       	subi	r24, 0xFF	; 255
    1df8:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <uxSchedulerSuspended>
    1dfc:	08 95       	ret

00001dfe <xTaskIncrementTick>:
    1dfe:	cf 92       	push	r12
    1e00:	df 92       	push	r13
    1e02:	ef 92       	push	r14
    1e04:	ff 92       	push	r15
    1e06:	0f 93       	push	r16
    1e08:	1f 93       	push	r17
    1e0a:	cf 93       	push	r28
    1e0c:	df 93       	push	r29
    1e0e:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1e12:	81 11       	cpse	r24, r1
    1e14:	98 c0       	rjmp	.+304    	; 0x1f46 <xTaskIncrementTick+0x148>
    1e16:	e0 90 b5 02 	lds	r14, 0x02B5	; 0x8002b5 <xTickCount>
    1e1a:	f0 90 b6 02 	lds	r15, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    1e1e:	8f ef       	ldi	r24, 0xFF	; 255
    1e20:	e8 1a       	sub	r14, r24
    1e22:	f8 0a       	sbc	r15, r24
    1e24:	f0 92 b6 02 	sts	0x02B6, r15	; 0x8002b6 <xTickCount+0x1>
    1e28:	e0 92 b5 02 	sts	0x02B5, r14	; 0x8002b5 <xTickCount>
    1e2c:	e1 14       	cp	r14, r1
    1e2e:	f1 04       	cpc	r15, r1
    1e30:	b1 f4       	brne	.+44     	; 0x1e5e <xTaskIncrementTick+0x60>
    1e32:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1e36:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1e3a:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <pxOverflowDelayedTaskList>
    1e3e:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1e42:	30 93 d7 02 	sts	0x02D7, r19	; 0x8002d7 <pxDelayedTaskList+0x1>
    1e46:	20 93 d6 02 	sts	0x02D6, r18	; 0x8002d6 <pxDelayedTaskList>
    1e4a:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1e4e:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <pxOverflowDelayedTaskList>
    1e52:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    1e56:	8f 5f       	subi	r24, 0xFF	; 255
    1e58:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <xNumOfOverflows>
    1e5c:	17 de       	rcall	.-978    	; 0x1a8c <prvResetNextTaskUnblockTime>
    1e5e:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <xNextTaskUnblockTime>
    1e62:	90 91 ae 02 	lds	r25, 0x02AE	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1e66:	e8 16       	cp	r14, r24
    1e68:	f9 06       	cpc	r15, r25
    1e6a:	10 f4       	brcc	.+4      	; 0x1e70 <xTaskIncrementTick+0x72>
    1e6c:	d1 2c       	mov	r13, r1
    1e6e:	53 c0       	rjmp	.+166    	; 0x1f16 <xTaskIncrementTick+0x118>
    1e70:	d1 2c       	mov	r13, r1
    1e72:	cc 24       	eor	r12, r12
    1e74:	c3 94       	inc	r12
    1e76:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1e7a:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1e7e:	80 81       	ld	r24, Z
    1e80:	81 11       	cpse	r24, r1
    1e82:	07 c0       	rjmp	.+14     	; 0x1e92 <xTaskIncrementTick+0x94>
    1e84:	8f ef       	ldi	r24, 0xFF	; 255
    1e86:	9f ef       	ldi	r25, 0xFF	; 255
    1e88:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1e8c:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1e90:	42 c0       	rjmp	.+132    	; 0x1f16 <xTaskIncrementTick+0x118>
    1e92:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1e96:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1e9a:	05 80       	ldd	r0, Z+5	; 0x05
    1e9c:	f6 81       	ldd	r31, Z+6	; 0x06
    1e9e:	e0 2d       	mov	r30, r0
    1ea0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ea2:	d7 81       	ldd	r29, Z+7	; 0x07
    1ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ea8:	e8 16       	cp	r14, r24
    1eaa:	f9 06       	cpc	r15, r25
    1eac:	28 f4       	brcc	.+10     	; 0x1eb8 <xTaskIncrementTick+0xba>
    1eae:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1eb2:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1eb6:	2f c0       	rjmp	.+94     	; 0x1f16 <xTaskIncrementTick+0x118>
    1eb8:	8e 01       	movw	r16, r28
    1eba:	0e 5f       	subi	r16, 0xFE	; 254
    1ebc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebe:	c8 01       	movw	r24, r16
    1ec0:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1ec4:	8c 89       	ldd	r24, Y+20	; 0x14
    1ec6:	9d 89       	ldd	r25, Y+21	; 0x15
    1ec8:	89 2b       	or	r24, r25
    1eca:	21 f0       	breq	.+8      	; 0x1ed4 <xTaskIncrementTick+0xd6>
    1ecc:	ce 01       	movw	r24, r28
    1ece:	0c 96       	adiw	r24, 0x0c	; 12
    1ed0:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1ed4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ed6:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1eda:	98 17       	cp	r25, r24
    1edc:	10 f4       	brcc	.+4      	; 0x1ee2 <xTaskIncrementTick+0xe4>
    1ede:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	9c 01       	movw	r18, r24
    1ee6:	22 0f       	add	r18, r18
    1ee8:	33 1f       	adc	r19, r19
    1eea:	22 0f       	add	r18, r18
    1eec:	33 1f       	adc	r19, r19
    1eee:	22 0f       	add	r18, r18
    1ef0:	33 1f       	adc	r19, r19
    1ef2:	82 0f       	add	r24, r18
    1ef4:	93 1f       	adc	r25, r19
    1ef6:	b8 01       	movw	r22, r16
    1ef8:	86 51       	subi	r24, 0x16	; 22
    1efa:	9d 4f       	sbci	r25, 0xFD	; 253
    1efc:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1f00:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1f04:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1f08:	9e 89       	ldd	r25, Y+22	; 0x16
    1f0a:	86 89       	ldd	r24, Z+22	; 0x16
    1f0c:	98 17       	cp	r25, r24
    1f0e:	08 f4       	brcc	.+2      	; 0x1f12 <xTaskIncrementTick+0x114>
    1f10:	b2 cf       	rjmp	.-156    	; 0x1e76 <xTaskIncrementTick+0x78>
    1f12:	dc 2c       	mov	r13, r12
    1f14:	b0 cf       	rjmp	.-160    	; 0x1e76 <xTaskIncrementTick+0x78>
    1f16:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1f1a:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1f1e:	86 89       	ldd	r24, Z+22	; 0x16
    1f20:	90 e0       	ldi	r25, 0x00	; 0
    1f22:	fc 01       	movw	r30, r24
    1f24:	ee 0f       	add	r30, r30
    1f26:	ff 1f       	adc	r31, r31
    1f28:	ee 0f       	add	r30, r30
    1f2a:	ff 1f       	adc	r31, r31
    1f2c:	ee 0f       	add	r30, r30
    1f2e:	ff 1f       	adc	r31, r31
    1f30:	8e 0f       	add	r24, r30
    1f32:	9f 1f       	adc	r25, r31
    1f34:	fc 01       	movw	r30, r24
    1f36:	e6 51       	subi	r30, 0x16	; 22
    1f38:	fd 4f       	sbci	r31, 0xFD	; 253
    1f3a:	80 81       	ld	r24, Z
    1f3c:	82 30       	cpi	r24, 0x02	; 2
    1f3e:	48 f0       	brcs	.+18     	; 0x1f52 <xTaskIncrementTick+0x154>
    1f40:	dd 24       	eor	r13, r13
    1f42:	d3 94       	inc	r13
    1f44:	06 c0       	rjmp	.+12     	; 0x1f52 <xTaskIncrementTick+0x154>
    1f46:	80 91 b2 02 	lds	r24, 0x02B2	; 0x8002b2 <uxPendedTicks>
    1f4a:	8f 5f       	subi	r24, 0xFF	; 255
    1f4c:	80 93 b2 02 	sts	0x02B2, r24	; 0x8002b2 <uxPendedTicks>
    1f50:	d1 2c       	mov	r13, r1
    1f52:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <xYieldPending>
    1f56:	88 23       	and	r24, r24
    1f58:	11 f0       	breq	.+4      	; 0x1f5e <xTaskIncrementTick+0x160>
    1f5a:	dd 24       	eor	r13, r13
    1f5c:	d3 94       	inc	r13
    1f5e:	8d 2d       	mov	r24, r13
    1f60:	df 91       	pop	r29
    1f62:	cf 91       	pop	r28
    1f64:	1f 91       	pop	r17
    1f66:	0f 91       	pop	r16
    1f68:	ff 90       	pop	r15
    1f6a:	ef 90       	pop	r14
    1f6c:	df 90       	pop	r13
    1f6e:	cf 90       	pop	r12
    1f70:	08 95       	ret

00001f72 <xTaskResumeAll>:
    1f72:	df 92       	push	r13
    1f74:	ef 92       	push	r14
    1f76:	ff 92       	push	r15
    1f78:	0f 93       	push	r16
    1f7a:	1f 93       	push	r17
    1f7c:	cf 93       	push	r28
    1f7e:	df 93       	push	r29
    1f80:	0f b6       	in	r0, 0x3f	; 63
    1f82:	f8 94       	cli
    1f84:	0f 92       	push	r0
    1f86:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1f8a:	81 50       	subi	r24, 0x01	; 1
    1f8c:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <uxSchedulerSuspended>
    1f90:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1f94:	81 11       	cpse	r24, r1
    1f96:	5d c0       	rjmp	.+186    	; 0x2052 <xTaskResumeAll+0xe0>
    1f98:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1f9c:	81 11       	cpse	r24, r1
    1f9e:	33 c0       	rjmp	.+102    	; 0x2006 <xTaskResumeAll+0x94>
    1fa0:	5b c0       	rjmp	.+182    	; 0x2058 <xTaskResumeAll+0xe6>
    1fa2:	d7 01       	movw	r26, r14
    1fa4:	15 96       	adiw	r26, 0x05	; 5
    1fa6:	ed 91       	ld	r30, X+
    1fa8:	fc 91       	ld	r31, X
    1faa:	16 97       	sbiw	r26, 0x06	; 6
    1fac:	c6 81       	ldd	r28, Z+6	; 0x06
    1fae:	d7 81       	ldd	r29, Z+7	; 0x07
    1fb0:	ce 01       	movw	r24, r28
    1fb2:	0c 96       	adiw	r24, 0x0c	; 12
    1fb4:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1fb8:	8e 01       	movw	r16, r28
    1fba:	0e 5f       	subi	r16, 0xFE	; 254
    1fbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1fbe:	c8 01       	movw	r24, r16
    1fc0:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1fc4:	8e 89       	ldd	r24, Y+22	; 0x16
    1fc6:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1fca:	98 17       	cp	r25, r24
    1fcc:	10 f4       	brcc	.+4      	; 0x1fd2 <xTaskResumeAll+0x60>
    1fce:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	9c 01       	movw	r18, r24
    1fd6:	22 0f       	add	r18, r18
    1fd8:	33 1f       	adc	r19, r19
    1fda:	22 0f       	add	r18, r18
    1fdc:	33 1f       	adc	r19, r19
    1fde:	22 0f       	add	r18, r18
    1fe0:	33 1f       	adc	r19, r19
    1fe2:	82 0f       	add	r24, r18
    1fe4:	93 1f       	adc	r25, r19
    1fe6:	b8 01       	movw	r22, r16
    1fe8:	86 51       	subi	r24, 0x16	; 22
    1fea:	9d 4f       	sbci	r25, 0xFD	; 253
    1fec:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1ff0:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1ff4:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1ff8:	9e 89       	ldd	r25, Y+22	; 0x16
    1ffa:	86 89       	ldd	r24, Z+22	; 0x16
    1ffc:	98 17       	cp	r25, r24
    1ffe:	68 f0       	brcs	.+26     	; 0x201a <xTaskResumeAll+0xa8>
    2000:	d0 92 b1 02 	sts	0x02B1, r13	; 0x8002b1 <xYieldPending>
    2004:	0a c0       	rjmp	.+20     	; 0x201a <xTaskResumeAll+0xa8>
    2006:	c0 e0       	ldi	r28, 0x00	; 0
    2008:	d0 e0       	ldi	r29, 0x00	; 0
    200a:	0f 2e       	mov	r0, r31
    200c:	fb ec       	ldi	r31, 0xCB	; 203
    200e:	ef 2e       	mov	r14, r31
    2010:	f2 e0       	ldi	r31, 0x02	; 2
    2012:	ff 2e       	mov	r15, r31
    2014:	f0 2d       	mov	r31, r0
    2016:	dd 24       	eor	r13, r13
    2018:	d3 94       	inc	r13
    201a:	f7 01       	movw	r30, r14
    201c:	80 81       	ld	r24, Z
    201e:	81 11       	cpse	r24, r1
    2020:	c0 cf       	rjmp	.-128    	; 0x1fa2 <xTaskResumeAll+0x30>
    2022:	cd 2b       	or	r28, r29
    2024:	09 f0       	breq	.+2      	; 0x2028 <xTaskResumeAll+0xb6>
    2026:	32 dd       	rcall	.-1436   	; 0x1a8c <prvResetNextTaskUnblockTime>
    2028:	c0 91 b2 02 	lds	r28, 0x02B2	; 0x8002b2 <uxPendedTicks>
    202c:	cc 23       	and	r28, r28
    202e:	49 f0       	breq	.+18     	; 0x2042 <xTaskResumeAll+0xd0>
    2030:	d1 e0       	ldi	r29, 0x01	; 1
    2032:	e5 de       	rcall	.-566    	; 0x1dfe <xTaskIncrementTick>
    2034:	81 11       	cpse	r24, r1
    2036:	d0 93 b1 02 	sts	0x02B1, r29	; 0x8002b1 <xYieldPending>
    203a:	c1 50       	subi	r28, 0x01	; 1
    203c:	d1 f7       	brne	.-12     	; 0x2032 <xTaskResumeAll+0xc0>
    203e:	10 92 b2 02 	sts	0x02B2, r1	; 0x8002b2 <uxPendedTicks>
    2042:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <xYieldPending>
    2046:	88 23       	and	r24, r24
    2048:	31 f0       	breq	.+12     	; 0x2056 <xTaskResumeAll+0xe4>
    204a:	0e 94 b3 07 	call	0xf66	; 0xf66 <vPortYield>
    204e:	81 e0       	ldi	r24, 0x01	; 1
    2050:	03 c0       	rjmp	.+6      	; 0x2058 <xTaskResumeAll+0xe6>
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	01 c0       	rjmp	.+2      	; 0x2058 <xTaskResumeAll+0xe6>
    2056:	80 e0       	ldi	r24, 0x00	; 0
    2058:	0f 90       	pop	r0
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	df 91       	pop	r29
    205e:	cf 91       	pop	r28
    2060:	1f 91       	pop	r17
    2062:	0f 91       	pop	r16
    2064:	ff 90       	pop	r15
    2066:	ef 90       	pop	r14
    2068:	df 90       	pop	r13
    206a:	08 95       	ret

0000206c <vTaskSwitchContext>:
    206c:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    2070:	88 23       	and	r24, r24
    2072:	21 f0       	breq	.+8      	; 0x207c <vTaskSwitchContext+0x10>
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    207a:	08 95       	ret
    207c:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <xYieldPending>
    2080:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    2084:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2088:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    208c:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2090:	2d 91       	ld	r18, X+
    2092:	3c 91       	ld	r19, X
    2094:	87 89       	ldd	r24, Z+23	; 0x17
    2096:	90 8d       	ldd	r25, Z+24	; 0x18
    2098:	82 17       	cp	r24, r18
    209a:	93 07       	cpc	r25, r19
    209c:	60 f0       	brcs	.+24     	; 0x20b6 <vTaskSwitchContext+0x4a>
    209e:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    20a2:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    20a6:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    20aa:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    20ae:	67 5e       	subi	r22, 0xE7	; 231
    20b0:	7f 4f       	sbci	r23, 0xFF	; 255
    20b2:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vApplicationStackOverflowHook>
    20b6:	20 91 b4 02 	lds	r18, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    20ba:	82 2f       	mov	r24, r18
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	fc 01       	movw	r30, r24
    20c0:	ee 0f       	add	r30, r30
    20c2:	ff 1f       	adc	r31, r31
    20c4:	ee 0f       	add	r30, r30
    20c6:	ff 1f       	adc	r31, r31
    20c8:	ee 0f       	add	r30, r30
    20ca:	ff 1f       	adc	r31, r31
    20cc:	e8 0f       	add	r30, r24
    20ce:	f9 1f       	adc	r31, r25
    20d0:	e6 51       	subi	r30, 0x16	; 22
    20d2:	fd 4f       	sbci	r31, 0xFD	; 253
    20d4:	30 81       	ld	r19, Z
    20d6:	31 11       	cpse	r19, r1
    20d8:	11 c0       	rjmp	.+34     	; 0x20fc <vTaskSwitchContext+0x90>
    20da:	21 50       	subi	r18, 0x01	; 1
    20dc:	82 2f       	mov	r24, r18
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	fc 01       	movw	r30, r24
    20e2:	ee 0f       	add	r30, r30
    20e4:	ff 1f       	adc	r31, r31
    20e6:	ee 0f       	add	r30, r30
    20e8:	ff 1f       	adc	r31, r31
    20ea:	ee 0f       	add	r30, r30
    20ec:	ff 1f       	adc	r31, r31
    20ee:	e8 0f       	add	r30, r24
    20f0:	f9 1f       	adc	r31, r25
    20f2:	e6 51       	subi	r30, 0x16	; 22
    20f4:	fd 4f       	sbci	r31, 0xFD	; 253
    20f6:	30 81       	ld	r19, Z
    20f8:	33 23       	and	r19, r19
    20fa:	79 f3       	breq	.-34     	; 0x20da <vTaskSwitchContext+0x6e>
    20fc:	ac 01       	movw	r20, r24
    20fe:	44 0f       	add	r20, r20
    2100:	55 1f       	adc	r21, r21
    2102:	44 0f       	add	r20, r20
    2104:	55 1f       	adc	r21, r21
    2106:	44 0f       	add	r20, r20
    2108:	55 1f       	adc	r21, r21
    210a:	48 0f       	add	r20, r24
    210c:	59 1f       	adc	r21, r25
    210e:	da 01       	movw	r26, r20
    2110:	a6 51       	subi	r26, 0x16	; 22
    2112:	bd 4f       	sbci	r27, 0xFD	; 253
    2114:	11 96       	adiw	r26, 0x01	; 1
    2116:	ed 91       	ld	r30, X+
    2118:	fc 91       	ld	r31, X
    211a:	12 97       	sbiw	r26, 0x02	; 2
    211c:	02 80       	ldd	r0, Z+2	; 0x02
    211e:	f3 81       	ldd	r31, Z+3	; 0x03
    2120:	e0 2d       	mov	r30, r0
    2122:	12 96       	adiw	r26, 0x02	; 2
    2124:	fc 93       	st	X, r31
    2126:	ee 93       	st	-X, r30
    2128:	11 97       	sbiw	r26, 0x01	; 1
    212a:	43 51       	subi	r20, 0x13	; 19
    212c:	5d 4f       	sbci	r21, 0xFD	; 253
    212e:	e4 17       	cp	r30, r20
    2130:	f5 07       	cpc	r31, r21
    2132:	29 f4       	brne	.+10     	; 0x213e <vTaskSwitchContext+0xd2>
    2134:	42 81       	ldd	r20, Z+2	; 0x02
    2136:	53 81       	ldd	r21, Z+3	; 0x03
    2138:	fd 01       	movw	r30, r26
    213a:	52 83       	std	Z+2, r21	; 0x02
    213c:	41 83       	std	Z+1, r20	; 0x01
    213e:	fc 01       	movw	r30, r24
    2140:	ee 0f       	add	r30, r30
    2142:	ff 1f       	adc	r31, r31
    2144:	ee 0f       	add	r30, r30
    2146:	ff 1f       	adc	r31, r31
    2148:	ee 0f       	add	r30, r30
    214a:	ff 1f       	adc	r31, r31
    214c:	8e 0f       	add	r24, r30
    214e:	9f 1f       	adc	r25, r31
    2150:	fc 01       	movw	r30, r24
    2152:	e6 51       	subi	r30, 0x16	; 22
    2154:	fd 4f       	sbci	r31, 0xFD	; 253
    2156:	01 80       	ldd	r0, Z+1	; 0x01
    2158:	f2 81       	ldd	r31, Z+2	; 0x02
    215a:	e0 2d       	mov	r30, r0
    215c:	86 81       	ldd	r24, Z+6	; 0x06
    215e:	97 81       	ldd	r25, Z+7	; 0x07
    2160:	90 93 0f 03 	sts	0x030F, r25	; 0x80030f <pxCurrentTCB+0x1>
    2164:	80 93 0e 03 	sts	0x030E, r24	; 0x80030e <pxCurrentTCB>
    2168:	20 93 b4 02 	sts	0x02B4, r18	; 0x8002b4 <uxTopReadyPriority>
    216c:	08 95       	ret

0000216e <vTaskPlaceOnEventList>:
    216e:	cf 93       	push	r28
    2170:	df 93       	push	r29
    2172:	eb 01       	movw	r28, r22
    2174:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    2178:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    217c:	64 5f       	subi	r22, 0xF4	; 244
    217e:	7f 4f       	sbci	r23, 0xFF	; 255
    2180:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    2184:	61 e0       	ldi	r22, 0x01	; 1
    2186:	ce 01       	movw	r24, r28
    2188:	a0 dc       	rcall	.-1728   	; 0x1aca <prvAddCurrentTaskToDelayedList>
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	08 95       	ret

00002190 <xTaskRemoveFromEventList>:
    2190:	0f 93       	push	r16
    2192:	1f 93       	push	r17
    2194:	cf 93       	push	r28
    2196:	df 93       	push	r29
    2198:	dc 01       	movw	r26, r24
    219a:	15 96       	adiw	r26, 0x05	; 5
    219c:	ed 91       	ld	r30, X+
    219e:	fc 91       	ld	r31, X
    21a0:	16 97       	sbiw	r26, 0x06	; 6
    21a2:	c6 81       	ldd	r28, Z+6	; 0x06
    21a4:	d7 81       	ldd	r29, Z+7	; 0x07
    21a6:	8e 01       	movw	r16, r28
    21a8:	04 5f       	subi	r16, 0xF4	; 244
    21aa:	1f 4f       	sbci	r17, 0xFF	; 255
    21ac:	c8 01       	movw	r24, r16
    21ae:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    21b2:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    21b6:	81 11       	cpse	r24, r1
    21b8:	1c c0       	rjmp	.+56     	; 0x21f2 <xTaskRemoveFromEventList+0x62>
    21ba:	0a 50       	subi	r16, 0x0A	; 10
    21bc:	11 09       	sbc	r17, r1
    21be:	c8 01       	movw	r24, r16
    21c0:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    21c4:	8e 89       	ldd	r24, Y+22	; 0x16
    21c6:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    21ca:	98 17       	cp	r25, r24
    21cc:	10 f4       	brcc	.+4      	; 0x21d2 <xTaskRemoveFromEventList+0x42>
    21ce:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	9c 01       	movw	r18, r24
    21d6:	22 0f       	add	r18, r18
    21d8:	33 1f       	adc	r19, r19
    21da:	22 0f       	add	r18, r18
    21dc:	33 1f       	adc	r19, r19
    21de:	22 0f       	add	r18, r18
    21e0:	33 1f       	adc	r19, r19
    21e2:	82 0f       	add	r24, r18
    21e4:	93 1f       	adc	r25, r19
    21e6:	b8 01       	movw	r22, r16
    21e8:	86 51       	subi	r24, 0x16	; 22
    21ea:	9d 4f       	sbci	r25, 0xFD	; 253
    21ec:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    21f0:	05 c0       	rjmp	.+10     	; 0x21fc <xTaskRemoveFromEventList+0x6c>
    21f2:	b8 01       	movw	r22, r16
    21f4:	8b ec       	ldi	r24, 0xCB	; 203
    21f6:	92 e0       	ldi	r25, 0x02	; 2
    21f8:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    21fc:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    2200:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2204:	9e 89       	ldd	r25, Y+22	; 0x16
    2206:	86 89       	ldd	r24, Z+22	; 0x16
    2208:	89 17       	cp	r24, r25
    220a:	20 f4       	brcc	.+8      	; 0x2214 <__stack+0x15>
    220c:	81 e0       	ldi	r24, 0x01	; 1
    220e:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    2212:	01 c0       	rjmp	.+2      	; 0x2216 <__stack+0x17>
    2214:	80 e0       	ldi	r24, 0x00	; 0
    2216:	df 91       	pop	r29
    2218:	cf 91       	pop	r28
    221a:	1f 91       	pop	r17
    221c:	0f 91       	pop	r16
    221e:	08 95       	ret

00002220 <vTaskSetTimeOutState>:
    2220:	20 91 b0 02 	lds	r18, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    2224:	fc 01       	movw	r30, r24
    2226:	20 83       	st	Z, r18
    2228:	20 91 b5 02 	lds	r18, 0x02B5	; 0x8002b5 <xTickCount>
    222c:	30 91 b6 02 	lds	r19, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    2230:	32 83       	std	Z+2, r19	; 0x02
    2232:	21 83       	std	Z+1, r18	; 0x01
    2234:	08 95       	ret

00002236 <xTaskCheckForTimeOut>:
    2236:	0f b6       	in	r0, 0x3f	; 63
    2238:	f8 94       	cli
    223a:	0f 92       	push	r0
    223c:	40 91 b5 02 	lds	r20, 0x02B5	; 0x8002b5 <xTickCount>
    2240:	50 91 b6 02 	lds	r21, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    2244:	db 01       	movw	r26, r22
    2246:	2d 91       	ld	r18, X+
    2248:	3c 91       	ld	r19, X
    224a:	2f 3f       	cpi	r18, 0xFF	; 255
    224c:	bf ef       	ldi	r27, 0xFF	; 255
    224e:	3b 07       	cpc	r19, r27
    2250:	11 f1       	breq	.+68     	; 0x2296 <xTaskCheckForTimeOut+0x60>
    2252:	e0 91 b0 02 	lds	r30, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    2256:	dc 01       	movw	r26, r24
    2258:	fc 91       	ld	r31, X
    225a:	fe 17       	cp	r31, r30
    225c:	39 f0       	breq	.+14     	; 0x226c <xTaskCheckForTimeOut+0x36>
    225e:	11 96       	adiw	r26, 0x01	; 1
    2260:	ed 91       	ld	r30, X+
    2262:	fc 91       	ld	r31, X
    2264:	12 97       	sbiw	r26, 0x02	; 2
    2266:	4e 17       	cp	r20, r30
    2268:	5f 07       	cpc	r21, r31
    226a:	b8 f4       	brcc	.+46     	; 0x229a <xTaskCheckForTimeOut+0x64>
    226c:	dc 01       	movw	r26, r24
    226e:	11 96       	adiw	r26, 0x01	; 1
    2270:	ed 91       	ld	r30, X+
    2272:	fc 91       	ld	r31, X
    2274:	12 97       	sbiw	r26, 0x02	; 2
    2276:	da 01       	movw	r26, r20
    2278:	ae 1b       	sub	r26, r30
    227a:	bf 0b       	sbc	r27, r31
    227c:	a2 17       	cp	r26, r18
    227e:	b3 07       	cpc	r27, r19
    2280:	70 f4       	brcc	.+28     	; 0x229e <xTaskCheckForTimeOut+0x68>
    2282:	db 01       	movw	r26, r22
    2284:	e4 1b       	sub	r30, r20
    2286:	f5 0b       	sbc	r31, r21
    2288:	2e 0f       	add	r18, r30
    228a:	3f 1f       	adc	r19, r31
    228c:	2d 93       	st	X+, r18
    228e:	3c 93       	st	X, r19
    2290:	c7 df       	rcall	.-114    	; 0x2220 <vTaskSetTimeOutState>
    2292:	80 e0       	ldi	r24, 0x00	; 0
    2294:	05 c0       	rjmp	.+10     	; 0x22a0 <xTaskCheckForTimeOut+0x6a>
    2296:	80 e0       	ldi	r24, 0x00	; 0
    2298:	03 c0       	rjmp	.+6      	; 0x22a0 <xTaskCheckForTimeOut+0x6a>
    229a:	81 e0       	ldi	r24, 0x01	; 1
    229c:	01 c0       	rjmp	.+2      	; 0x22a0 <xTaskCheckForTimeOut+0x6a>
    229e:	81 e0       	ldi	r24, 0x01	; 1
    22a0:	0f 90       	pop	r0
    22a2:	0f be       	out	0x3f, r0	; 63
    22a4:	08 95       	ret

000022a6 <vTaskMissedYield>:
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    22ac:	08 95       	ret

000022ae <vTaskPriorityInherit>:
    22ae:	0f 93       	push	r16
    22b0:	1f 93       	push	r17
    22b2:	cf 93       	push	r28
    22b4:	df 93       	push	r29
    22b6:	fc 01       	movw	r30, r24
    22b8:	89 2b       	or	r24, r25
    22ba:	09 f4       	brne	.+2      	; 0x22be <vTaskPriorityInherit+0x10>
    22bc:	55 c0       	rjmp	.+170    	; 0x2368 <vTaskPriorityInherit+0xba>
    22be:	26 89       	ldd	r18, Z+22	; 0x16
    22c0:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    22c4:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    22c8:	56 96       	adiw	r26, 0x16	; 22
    22ca:	8c 91       	ld	r24, X
    22cc:	28 17       	cp	r18, r24
    22ce:	08 f0       	brcs	.+2      	; 0x22d2 <vTaskPriorityInherit+0x24>
    22d0:	4b c0       	rjmp	.+150    	; 0x2368 <vTaskPriorityInherit+0xba>
    22d2:	84 85       	ldd	r24, Z+12	; 0x0c
    22d4:	95 85       	ldd	r25, Z+13	; 0x0d
    22d6:	99 23       	and	r25, r25
    22d8:	64 f0       	brlt	.+24     	; 0x22f2 <vTaskPriorityInherit+0x44>
    22da:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    22de:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    22e2:	56 96       	adiw	r26, 0x16	; 22
    22e4:	3c 91       	ld	r19, X
    22e6:	84 e0       	ldi	r24, 0x04	; 4
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	83 1b       	sub	r24, r19
    22ec:	91 09       	sbc	r25, r1
    22ee:	95 87       	std	Z+13, r25	; 0x0d
    22f0:	84 87       	std	Z+12, r24	; 0x0c
    22f2:	30 e0       	ldi	r19, 0x00	; 0
    22f4:	c9 01       	movw	r24, r18
    22f6:	88 0f       	add	r24, r24
    22f8:	99 1f       	adc	r25, r25
    22fa:	88 0f       	add	r24, r24
    22fc:	99 1f       	adc	r25, r25
    22fe:	88 0f       	add	r24, r24
    2300:	99 1f       	adc	r25, r25
    2302:	28 0f       	add	r18, r24
    2304:	39 1f       	adc	r19, r25
    2306:	26 51       	subi	r18, 0x16	; 22
    2308:	3d 4f       	sbci	r19, 0xFD	; 253
    230a:	82 85       	ldd	r24, Z+10	; 0x0a
    230c:	93 85       	ldd	r25, Z+11	; 0x0b
    230e:	82 17       	cp	r24, r18
    2310:	93 07       	cpc	r25, r19
    2312:	19 f5       	brne	.+70     	; 0x235a <vTaskPriorityInherit+0xac>
    2314:	8f 01       	movw	r16, r30
    2316:	ef 01       	movw	r28, r30
    2318:	22 96       	adiw	r28, 0x02	; 2
    231a:	ce 01       	movw	r24, r28
    231c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2320:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    2324:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2328:	86 89       	ldd	r24, Z+22	; 0x16
    232a:	f8 01       	movw	r30, r16
    232c:	86 8b       	std	Z+22, r24	; 0x16
    232e:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    2332:	98 17       	cp	r25, r24
    2334:	10 f4       	brcc	.+4      	; 0x233a <vTaskPriorityInherit+0x8c>
    2336:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    233a:	90 e0       	ldi	r25, 0x00	; 0
    233c:	9c 01       	movw	r18, r24
    233e:	22 0f       	add	r18, r18
    2340:	33 1f       	adc	r19, r19
    2342:	22 0f       	add	r18, r18
    2344:	33 1f       	adc	r19, r19
    2346:	22 0f       	add	r18, r18
    2348:	33 1f       	adc	r19, r19
    234a:	82 0f       	add	r24, r18
    234c:	93 1f       	adc	r25, r19
    234e:	be 01       	movw	r22, r28
    2350:	86 51       	subi	r24, 0x16	; 22
    2352:	9d 4f       	sbci	r25, 0xFD	; 253
    2354:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2358:	07 c0       	rjmp	.+14     	; 0x2368 <vTaskPriorityInherit+0xba>
    235a:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    235e:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2362:	56 96       	adiw	r26, 0x16	; 22
    2364:	8c 91       	ld	r24, X
    2366:	86 8b       	std	Z+22, r24	; 0x16
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	1f 91       	pop	r17
    236e:	0f 91       	pop	r16
    2370:	08 95       	ret

00002372 <xTaskPriorityDisinherit>:
    2372:	0f 93       	push	r16
    2374:	1f 93       	push	r17
    2376:	cf 93       	push	r28
    2378:	df 93       	push	r29
    237a:	fc 01       	movw	r30, r24
    237c:	89 2b       	or	r24, r25
    237e:	79 f1       	breq	.+94     	; 0x23de <xTaskPriorityDisinherit+0x6c>
    2380:	82 a1       	ldd	r24, Z+34	; 0x22
    2382:	81 50       	subi	r24, 0x01	; 1
    2384:	82 a3       	std	Z+34, r24	; 0x22
    2386:	26 89       	ldd	r18, Z+22	; 0x16
    2388:	91 a1       	ldd	r25, Z+33	; 0x21
    238a:	29 17       	cp	r18, r25
    238c:	51 f1       	breq	.+84     	; 0x23e2 <xTaskPriorityDisinherit+0x70>
    238e:	81 11       	cpse	r24, r1
    2390:	2a c0       	rjmp	.+84     	; 0x23e6 <xTaskPriorityDisinherit+0x74>
    2392:	ef 01       	movw	r28, r30
    2394:	8f 01       	movw	r16, r30
    2396:	0e 5f       	subi	r16, 0xFE	; 254
    2398:	1f 4f       	sbci	r17, 0xFF	; 255
    239a:	c8 01       	movw	r24, r16
    239c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    23a0:	89 a1       	ldd	r24, Y+33	; 0x21
    23a2:	8e 8b       	std	Y+22, r24	; 0x16
    23a4:	24 e0       	ldi	r18, 0x04	; 4
    23a6:	30 e0       	ldi	r19, 0x00	; 0
    23a8:	28 1b       	sub	r18, r24
    23aa:	31 09       	sbc	r19, r1
    23ac:	3d 87       	std	Y+13, r19	; 0x0d
    23ae:	2c 87       	std	Y+12, r18	; 0x0c
    23b0:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    23b4:	98 17       	cp	r25, r24
    23b6:	10 f4       	brcc	.+4      	; 0x23bc <xTaskPriorityDisinherit+0x4a>
    23b8:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	9c 01       	movw	r18, r24
    23c0:	22 0f       	add	r18, r18
    23c2:	33 1f       	adc	r19, r19
    23c4:	22 0f       	add	r18, r18
    23c6:	33 1f       	adc	r19, r19
    23c8:	22 0f       	add	r18, r18
    23ca:	33 1f       	adc	r19, r19
    23cc:	82 0f       	add	r24, r18
    23ce:	93 1f       	adc	r25, r19
    23d0:	b8 01       	movw	r22, r16
    23d2:	86 51       	subi	r24, 0x16	; 22
    23d4:	9d 4f       	sbci	r25, 0xFD	; 253
    23d6:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    23da:	81 e0       	ldi	r24, 0x01	; 1
    23dc:	05 c0       	rjmp	.+10     	; 0x23e8 <xTaskPriorityDisinherit+0x76>
    23de:	80 e0       	ldi	r24, 0x00	; 0
    23e0:	03 c0       	rjmp	.+6      	; 0x23e8 <xTaskPriorityDisinherit+0x76>
    23e2:	80 e0       	ldi	r24, 0x00	; 0
    23e4:	01 c0       	rjmp	.+2      	; 0x23e8 <xTaskPriorityDisinherit+0x76>
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	08 95       	ret

000023f2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    23f2:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    23f6:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    23fa:	89 2b       	or	r24, r25
    23fc:	39 f0       	breq	.+14     	; 0x240c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    23fe:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    2402:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    2406:	82 a1       	ldd	r24, Z+34	; 0x22
    2408:	8f 5f       	subi	r24, 0xFF	; 255
    240a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    240c:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    2410:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
	}
    2414:	08 95       	ret

00002416 <__subsf3>:
    2416:	50 58       	subi	r21, 0x80	; 128

00002418 <__addsf3>:
    2418:	bb 27       	eor	r27, r27
    241a:	aa 27       	eor	r26, r26
    241c:	0e d0       	rcall	.+28     	; 0x243a <__addsf3x>
    241e:	e5 c0       	rjmp	.+458    	; 0x25ea <__fp_round>
    2420:	d6 d0       	rcall	.+428    	; 0x25ce <__fp_pscA>
    2422:	30 f0       	brcs	.+12     	; 0x2430 <__addsf3+0x18>
    2424:	db d0       	rcall	.+438    	; 0x25dc <__fp_pscB>
    2426:	20 f0       	brcs	.+8      	; 0x2430 <__addsf3+0x18>
    2428:	31 f4       	brne	.+12     	; 0x2436 <__addsf3+0x1e>
    242a:	9f 3f       	cpi	r25, 0xFF	; 255
    242c:	11 f4       	brne	.+4      	; 0x2432 <__addsf3+0x1a>
    242e:	1e f4       	brtc	.+6      	; 0x2436 <__addsf3+0x1e>
    2430:	cb c0       	rjmp	.+406    	; 0x25c8 <__fp_nan>
    2432:	0e f4       	brtc	.+2      	; 0x2436 <__addsf3+0x1e>
    2434:	e0 95       	com	r30
    2436:	e7 fb       	bst	r30, 7
    2438:	c1 c0       	rjmp	.+386    	; 0x25bc <__fp_inf>

0000243a <__addsf3x>:
    243a:	e9 2f       	mov	r30, r25
    243c:	e7 d0       	rcall	.+462    	; 0x260c <__fp_split3>
    243e:	80 f3       	brcs	.-32     	; 0x2420 <__addsf3+0x8>
    2440:	ba 17       	cp	r27, r26
    2442:	62 07       	cpc	r22, r18
    2444:	73 07       	cpc	r23, r19
    2446:	84 07       	cpc	r24, r20
    2448:	95 07       	cpc	r25, r21
    244a:	18 f0       	brcs	.+6      	; 0x2452 <__addsf3x+0x18>
    244c:	71 f4       	brne	.+28     	; 0x246a <__addsf3x+0x30>
    244e:	9e f5       	brtc	.+102    	; 0x24b6 <__addsf3x+0x7c>
    2450:	ff c0       	rjmp	.+510    	; 0x2650 <__fp_zero>
    2452:	0e f4       	brtc	.+2      	; 0x2456 <__addsf3x+0x1c>
    2454:	e0 95       	com	r30
    2456:	0b 2e       	mov	r0, r27
    2458:	ba 2f       	mov	r27, r26
    245a:	a0 2d       	mov	r26, r0
    245c:	0b 01       	movw	r0, r22
    245e:	b9 01       	movw	r22, r18
    2460:	90 01       	movw	r18, r0
    2462:	0c 01       	movw	r0, r24
    2464:	ca 01       	movw	r24, r20
    2466:	a0 01       	movw	r20, r0
    2468:	11 24       	eor	r1, r1
    246a:	ff 27       	eor	r31, r31
    246c:	59 1b       	sub	r21, r25
    246e:	99 f0       	breq	.+38     	; 0x2496 <__addsf3x+0x5c>
    2470:	59 3f       	cpi	r21, 0xF9	; 249
    2472:	50 f4       	brcc	.+20     	; 0x2488 <__addsf3x+0x4e>
    2474:	50 3e       	cpi	r21, 0xE0	; 224
    2476:	68 f1       	brcs	.+90     	; 0x24d2 <__addsf3x+0x98>
    2478:	1a 16       	cp	r1, r26
    247a:	f0 40       	sbci	r31, 0x00	; 0
    247c:	a2 2f       	mov	r26, r18
    247e:	23 2f       	mov	r18, r19
    2480:	34 2f       	mov	r19, r20
    2482:	44 27       	eor	r20, r20
    2484:	58 5f       	subi	r21, 0xF8	; 248
    2486:	f3 cf       	rjmp	.-26     	; 0x246e <__addsf3x+0x34>
    2488:	46 95       	lsr	r20
    248a:	37 95       	ror	r19
    248c:	27 95       	ror	r18
    248e:	a7 95       	ror	r26
    2490:	f0 40       	sbci	r31, 0x00	; 0
    2492:	53 95       	inc	r21
    2494:	c9 f7       	brne	.-14     	; 0x2488 <__addsf3x+0x4e>
    2496:	7e f4       	brtc	.+30     	; 0x24b6 <__addsf3x+0x7c>
    2498:	1f 16       	cp	r1, r31
    249a:	ba 0b       	sbc	r27, r26
    249c:	62 0b       	sbc	r22, r18
    249e:	73 0b       	sbc	r23, r19
    24a0:	84 0b       	sbc	r24, r20
    24a2:	ba f0       	brmi	.+46     	; 0x24d2 <__addsf3x+0x98>
    24a4:	91 50       	subi	r25, 0x01	; 1
    24a6:	a1 f0       	breq	.+40     	; 0x24d0 <__addsf3x+0x96>
    24a8:	ff 0f       	add	r31, r31
    24aa:	bb 1f       	adc	r27, r27
    24ac:	66 1f       	adc	r22, r22
    24ae:	77 1f       	adc	r23, r23
    24b0:	88 1f       	adc	r24, r24
    24b2:	c2 f7       	brpl	.-16     	; 0x24a4 <__addsf3x+0x6a>
    24b4:	0e c0       	rjmp	.+28     	; 0x24d2 <__addsf3x+0x98>
    24b6:	ba 0f       	add	r27, r26
    24b8:	62 1f       	adc	r22, r18
    24ba:	73 1f       	adc	r23, r19
    24bc:	84 1f       	adc	r24, r20
    24be:	48 f4       	brcc	.+18     	; 0x24d2 <__addsf3x+0x98>
    24c0:	87 95       	ror	r24
    24c2:	77 95       	ror	r23
    24c4:	67 95       	ror	r22
    24c6:	b7 95       	ror	r27
    24c8:	f7 95       	ror	r31
    24ca:	9e 3f       	cpi	r25, 0xFE	; 254
    24cc:	08 f0       	brcs	.+2      	; 0x24d0 <__addsf3x+0x96>
    24ce:	b3 cf       	rjmp	.-154    	; 0x2436 <__addsf3+0x1e>
    24d0:	93 95       	inc	r25
    24d2:	88 0f       	add	r24, r24
    24d4:	08 f0       	brcs	.+2      	; 0x24d8 <__addsf3x+0x9e>
    24d6:	99 27       	eor	r25, r25
    24d8:	ee 0f       	add	r30, r30
    24da:	97 95       	ror	r25
    24dc:	87 95       	ror	r24
    24de:	08 95       	ret

000024e0 <__fixsfsi>:
    24e0:	04 d0       	rcall	.+8      	; 0x24ea <__fixunssfsi>
    24e2:	68 94       	set
    24e4:	b1 11       	cpse	r27, r1
    24e6:	b5 c0       	rjmp	.+362    	; 0x2652 <__fp_szero>
    24e8:	08 95       	ret

000024ea <__fixunssfsi>:
    24ea:	98 d0       	rcall	.+304    	; 0x261c <__fp_splitA>
    24ec:	88 f0       	brcs	.+34     	; 0x2510 <__fixunssfsi+0x26>
    24ee:	9f 57       	subi	r25, 0x7F	; 127
    24f0:	90 f0       	brcs	.+36     	; 0x2516 <__fixunssfsi+0x2c>
    24f2:	b9 2f       	mov	r27, r25
    24f4:	99 27       	eor	r25, r25
    24f6:	b7 51       	subi	r27, 0x17	; 23
    24f8:	a0 f0       	brcs	.+40     	; 0x2522 <__fixunssfsi+0x38>
    24fa:	d1 f0       	breq	.+52     	; 0x2530 <__fixunssfsi+0x46>
    24fc:	66 0f       	add	r22, r22
    24fe:	77 1f       	adc	r23, r23
    2500:	88 1f       	adc	r24, r24
    2502:	99 1f       	adc	r25, r25
    2504:	1a f0       	brmi	.+6      	; 0x250c <__fixunssfsi+0x22>
    2506:	ba 95       	dec	r27
    2508:	c9 f7       	brne	.-14     	; 0x24fc <__fixunssfsi+0x12>
    250a:	12 c0       	rjmp	.+36     	; 0x2530 <__fixunssfsi+0x46>
    250c:	b1 30       	cpi	r27, 0x01	; 1
    250e:	81 f0       	breq	.+32     	; 0x2530 <__fixunssfsi+0x46>
    2510:	9f d0       	rcall	.+318    	; 0x2650 <__fp_zero>
    2512:	b1 e0       	ldi	r27, 0x01	; 1
    2514:	08 95       	ret
    2516:	9c c0       	rjmp	.+312    	; 0x2650 <__fp_zero>
    2518:	67 2f       	mov	r22, r23
    251a:	78 2f       	mov	r23, r24
    251c:	88 27       	eor	r24, r24
    251e:	b8 5f       	subi	r27, 0xF8	; 248
    2520:	39 f0       	breq	.+14     	; 0x2530 <__fixunssfsi+0x46>
    2522:	b9 3f       	cpi	r27, 0xF9	; 249
    2524:	cc f3       	brlt	.-14     	; 0x2518 <__fixunssfsi+0x2e>
    2526:	86 95       	lsr	r24
    2528:	77 95       	ror	r23
    252a:	67 95       	ror	r22
    252c:	b3 95       	inc	r27
    252e:	d9 f7       	brne	.-10     	; 0x2526 <__fixunssfsi+0x3c>
    2530:	3e f4       	brtc	.+14     	; 0x2540 <__fixunssfsi+0x56>
    2532:	90 95       	com	r25
    2534:	80 95       	com	r24
    2536:	70 95       	com	r23
    2538:	61 95       	neg	r22
    253a:	7f 4f       	sbci	r23, 0xFF	; 255
    253c:	8f 4f       	sbci	r24, 0xFF	; 255
    253e:	9f 4f       	sbci	r25, 0xFF	; 255
    2540:	08 95       	ret

00002542 <__floatunsisf>:
    2542:	e8 94       	clt
    2544:	09 c0       	rjmp	.+18     	; 0x2558 <__floatsisf+0x12>

00002546 <__floatsisf>:
    2546:	97 fb       	bst	r25, 7
    2548:	3e f4       	brtc	.+14     	; 0x2558 <__floatsisf+0x12>
    254a:	90 95       	com	r25
    254c:	80 95       	com	r24
    254e:	70 95       	com	r23
    2550:	61 95       	neg	r22
    2552:	7f 4f       	sbci	r23, 0xFF	; 255
    2554:	8f 4f       	sbci	r24, 0xFF	; 255
    2556:	9f 4f       	sbci	r25, 0xFF	; 255
    2558:	99 23       	and	r25, r25
    255a:	a9 f0       	breq	.+42     	; 0x2586 <__floatsisf+0x40>
    255c:	f9 2f       	mov	r31, r25
    255e:	96 e9       	ldi	r25, 0x96	; 150
    2560:	bb 27       	eor	r27, r27
    2562:	93 95       	inc	r25
    2564:	f6 95       	lsr	r31
    2566:	87 95       	ror	r24
    2568:	77 95       	ror	r23
    256a:	67 95       	ror	r22
    256c:	b7 95       	ror	r27
    256e:	f1 11       	cpse	r31, r1
    2570:	f8 cf       	rjmp	.-16     	; 0x2562 <__floatsisf+0x1c>
    2572:	fa f4       	brpl	.+62     	; 0x25b2 <__floatsisf+0x6c>
    2574:	bb 0f       	add	r27, r27
    2576:	11 f4       	brne	.+4      	; 0x257c <__floatsisf+0x36>
    2578:	60 ff       	sbrs	r22, 0
    257a:	1b c0       	rjmp	.+54     	; 0x25b2 <__floatsisf+0x6c>
    257c:	6f 5f       	subi	r22, 0xFF	; 255
    257e:	7f 4f       	sbci	r23, 0xFF	; 255
    2580:	8f 4f       	sbci	r24, 0xFF	; 255
    2582:	9f 4f       	sbci	r25, 0xFF	; 255
    2584:	16 c0       	rjmp	.+44     	; 0x25b2 <__floatsisf+0x6c>
    2586:	88 23       	and	r24, r24
    2588:	11 f0       	breq	.+4      	; 0x258e <__floatsisf+0x48>
    258a:	96 e9       	ldi	r25, 0x96	; 150
    258c:	11 c0       	rjmp	.+34     	; 0x25b0 <__floatsisf+0x6a>
    258e:	77 23       	and	r23, r23
    2590:	21 f0       	breq	.+8      	; 0x259a <__floatsisf+0x54>
    2592:	9e e8       	ldi	r25, 0x8E	; 142
    2594:	87 2f       	mov	r24, r23
    2596:	76 2f       	mov	r23, r22
    2598:	05 c0       	rjmp	.+10     	; 0x25a4 <__floatsisf+0x5e>
    259a:	66 23       	and	r22, r22
    259c:	71 f0       	breq	.+28     	; 0x25ba <__floatsisf+0x74>
    259e:	96 e8       	ldi	r25, 0x86	; 134
    25a0:	86 2f       	mov	r24, r22
    25a2:	70 e0       	ldi	r23, 0x00	; 0
    25a4:	60 e0       	ldi	r22, 0x00	; 0
    25a6:	2a f0       	brmi	.+10     	; 0x25b2 <__floatsisf+0x6c>
    25a8:	9a 95       	dec	r25
    25aa:	66 0f       	add	r22, r22
    25ac:	77 1f       	adc	r23, r23
    25ae:	88 1f       	adc	r24, r24
    25b0:	da f7       	brpl	.-10     	; 0x25a8 <__floatsisf+0x62>
    25b2:	88 0f       	add	r24, r24
    25b4:	96 95       	lsr	r25
    25b6:	87 95       	ror	r24
    25b8:	97 f9       	bld	r25, 7
    25ba:	08 95       	ret

000025bc <__fp_inf>:
    25bc:	97 f9       	bld	r25, 7
    25be:	9f 67       	ori	r25, 0x7F	; 127
    25c0:	80 e8       	ldi	r24, 0x80	; 128
    25c2:	70 e0       	ldi	r23, 0x00	; 0
    25c4:	60 e0       	ldi	r22, 0x00	; 0
    25c6:	08 95       	ret

000025c8 <__fp_nan>:
    25c8:	9f ef       	ldi	r25, 0xFF	; 255
    25ca:	80 ec       	ldi	r24, 0xC0	; 192
    25cc:	08 95       	ret

000025ce <__fp_pscA>:
    25ce:	00 24       	eor	r0, r0
    25d0:	0a 94       	dec	r0
    25d2:	16 16       	cp	r1, r22
    25d4:	17 06       	cpc	r1, r23
    25d6:	18 06       	cpc	r1, r24
    25d8:	09 06       	cpc	r0, r25
    25da:	08 95       	ret

000025dc <__fp_pscB>:
    25dc:	00 24       	eor	r0, r0
    25de:	0a 94       	dec	r0
    25e0:	12 16       	cp	r1, r18
    25e2:	13 06       	cpc	r1, r19
    25e4:	14 06       	cpc	r1, r20
    25e6:	05 06       	cpc	r0, r21
    25e8:	08 95       	ret

000025ea <__fp_round>:
    25ea:	09 2e       	mov	r0, r25
    25ec:	03 94       	inc	r0
    25ee:	00 0c       	add	r0, r0
    25f0:	11 f4       	brne	.+4      	; 0x25f6 <__fp_round+0xc>
    25f2:	88 23       	and	r24, r24
    25f4:	52 f0       	brmi	.+20     	; 0x260a <__fp_round+0x20>
    25f6:	bb 0f       	add	r27, r27
    25f8:	40 f4       	brcc	.+16     	; 0x260a <__fp_round+0x20>
    25fa:	bf 2b       	or	r27, r31
    25fc:	11 f4       	brne	.+4      	; 0x2602 <__fp_round+0x18>
    25fe:	60 ff       	sbrs	r22, 0
    2600:	04 c0       	rjmp	.+8      	; 0x260a <__fp_round+0x20>
    2602:	6f 5f       	subi	r22, 0xFF	; 255
    2604:	7f 4f       	sbci	r23, 0xFF	; 255
    2606:	8f 4f       	sbci	r24, 0xFF	; 255
    2608:	9f 4f       	sbci	r25, 0xFF	; 255
    260a:	08 95       	ret

0000260c <__fp_split3>:
    260c:	57 fd       	sbrc	r21, 7
    260e:	90 58       	subi	r25, 0x80	; 128
    2610:	44 0f       	add	r20, r20
    2612:	55 1f       	adc	r21, r21
    2614:	59 f0       	breq	.+22     	; 0x262c <__fp_splitA+0x10>
    2616:	5f 3f       	cpi	r21, 0xFF	; 255
    2618:	71 f0       	breq	.+28     	; 0x2636 <__fp_splitA+0x1a>
    261a:	47 95       	ror	r20

0000261c <__fp_splitA>:
    261c:	88 0f       	add	r24, r24
    261e:	97 fb       	bst	r25, 7
    2620:	99 1f       	adc	r25, r25
    2622:	61 f0       	breq	.+24     	; 0x263c <__fp_splitA+0x20>
    2624:	9f 3f       	cpi	r25, 0xFF	; 255
    2626:	79 f0       	breq	.+30     	; 0x2646 <__fp_splitA+0x2a>
    2628:	87 95       	ror	r24
    262a:	08 95       	ret
    262c:	12 16       	cp	r1, r18
    262e:	13 06       	cpc	r1, r19
    2630:	14 06       	cpc	r1, r20
    2632:	55 1f       	adc	r21, r21
    2634:	f2 cf       	rjmp	.-28     	; 0x261a <__fp_split3+0xe>
    2636:	46 95       	lsr	r20
    2638:	f1 df       	rcall	.-30     	; 0x261c <__fp_splitA>
    263a:	08 c0       	rjmp	.+16     	; 0x264c <__fp_splitA+0x30>
    263c:	16 16       	cp	r1, r22
    263e:	17 06       	cpc	r1, r23
    2640:	18 06       	cpc	r1, r24
    2642:	99 1f       	adc	r25, r25
    2644:	f1 cf       	rjmp	.-30     	; 0x2628 <__fp_splitA+0xc>
    2646:	86 95       	lsr	r24
    2648:	71 05       	cpc	r23, r1
    264a:	61 05       	cpc	r22, r1
    264c:	08 94       	sec
    264e:	08 95       	ret

00002650 <__fp_zero>:
    2650:	e8 94       	clt

00002652 <__fp_szero>:
    2652:	bb 27       	eor	r27, r27
    2654:	66 27       	eor	r22, r22
    2656:	77 27       	eor	r23, r23
    2658:	cb 01       	movw	r24, r22
    265a:	97 f9       	bld	r25, 7
    265c:	08 95       	ret

0000265e <__mulsf3>:
    265e:	0b d0       	rcall	.+22     	; 0x2676 <__mulsf3x>
    2660:	c4 cf       	rjmp	.-120    	; 0x25ea <__fp_round>
    2662:	b5 df       	rcall	.-150    	; 0x25ce <__fp_pscA>
    2664:	28 f0       	brcs	.+10     	; 0x2670 <__mulsf3+0x12>
    2666:	ba df       	rcall	.-140    	; 0x25dc <__fp_pscB>
    2668:	18 f0       	brcs	.+6      	; 0x2670 <__mulsf3+0x12>
    266a:	95 23       	and	r25, r21
    266c:	09 f0       	breq	.+2      	; 0x2670 <__mulsf3+0x12>
    266e:	a6 cf       	rjmp	.-180    	; 0x25bc <__fp_inf>
    2670:	ab cf       	rjmp	.-170    	; 0x25c8 <__fp_nan>
    2672:	11 24       	eor	r1, r1
    2674:	ee cf       	rjmp	.-36     	; 0x2652 <__fp_szero>

00002676 <__mulsf3x>:
    2676:	ca df       	rcall	.-108    	; 0x260c <__fp_split3>
    2678:	a0 f3       	brcs	.-24     	; 0x2662 <__mulsf3+0x4>

0000267a <__mulsf3_pse>:
    267a:	95 9f       	mul	r25, r21
    267c:	d1 f3       	breq	.-12     	; 0x2672 <__mulsf3+0x14>
    267e:	95 0f       	add	r25, r21
    2680:	50 e0       	ldi	r21, 0x00	; 0
    2682:	55 1f       	adc	r21, r21
    2684:	62 9f       	mul	r22, r18
    2686:	f0 01       	movw	r30, r0
    2688:	72 9f       	mul	r23, r18
    268a:	bb 27       	eor	r27, r27
    268c:	f0 0d       	add	r31, r0
    268e:	b1 1d       	adc	r27, r1
    2690:	63 9f       	mul	r22, r19
    2692:	aa 27       	eor	r26, r26
    2694:	f0 0d       	add	r31, r0
    2696:	b1 1d       	adc	r27, r1
    2698:	aa 1f       	adc	r26, r26
    269a:	64 9f       	mul	r22, r20
    269c:	66 27       	eor	r22, r22
    269e:	b0 0d       	add	r27, r0
    26a0:	a1 1d       	adc	r26, r1
    26a2:	66 1f       	adc	r22, r22
    26a4:	82 9f       	mul	r24, r18
    26a6:	22 27       	eor	r18, r18
    26a8:	b0 0d       	add	r27, r0
    26aa:	a1 1d       	adc	r26, r1
    26ac:	62 1f       	adc	r22, r18
    26ae:	73 9f       	mul	r23, r19
    26b0:	b0 0d       	add	r27, r0
    26b2:	a1 1d       	adc	r26, r1
    26b4:	62 1f       	adc	r22, r18
    26b6:	83 9f       	mul	r24, r19
    26b8:	a0 0d       	add	r26, r0
    26ba:	61 1d       	adc	r22, r1
    26bc:	22 1f       	adc	r18, r18
    26be:	74 9f       	mul	r23, r20
    26c0:	33 27       	eor	r19, r19
    26c2:	a0 0d       	add	r26, r0
    26c4:	61 1d       	adc	r22, r1
    26c6:	23 1f       	adc	r18, r19
    26c8:	84 9f       	mul	r24, r20
    26ca:	60 0d       	add	r22, r0
    26cc:	21 1d       	adc	r18, r1
    26ce:	82 2f       	mov	r24, r18
    26d0:	76 2f       	mov	r23, r22
    26d2:	6a 2f       	mov	r22, r26
    26d4:	11 24       	eor	r1, r1
    26d6:	9f 57       	subi	r25, 0x7F	; 127
    26d8:	50 40       	sbci	r21, 0x00	; 0
    26da:	8a f0       	brmi	.+34     	; 0x26fe <__mulsf3_pse+0x84>
    26dc:	e1 f0       	breq	.+56     	; 0x2716 <__mulsf3_pse+0x9c>
    26de:	88 23       	and	r24, r24
    26e0:	4a f0       	brmi	.+18     	; 0x26f4 <__mulsf3_pse+0x7a>
    26e2:	ee 0f       	add	r30, r30
    26e4:	ff 1f       	adc	r31, r31
    26e6:	bb 1f       	adc	r27, r27
    26e8:	66 1f       	adc	r22, r22
    26ea:	77 1f       	adc	r23, r23
    26ec:	88 1f       	adc	r24, r24
    26ee:	91 50       	subi	r25, 0x01	; 1
    26f0:	50 40       	sbci	r21, 0x00	; 0
    26f2:	a9 f7       	brne	.-22     	; 0x26de <__mulsf3_pse+0x64>
    26f4:	9e 3f       	cpi	r25, 0xFE	; 254
    26f6:	51 05       	cpc	r21, r1
    26f8:	70 f0       	brcs	.+28     	; 0x2716 <__mulsf3_pse+0x9c>
    26fa:	60 cf       	rjmp	.-320    	; 0x25bc <__fp_inf>
    26fc:	aa cf       	rjmp	.-172    	; 0x2652 <__fp_szero>
    26fe:	5f 3f       	cpi	r21, 0xFF	; 255
    2700:	ec f3       	brlt	.-6      	; 0x26fc <__mulsf3_pse+0x82>
    2702:	98 3e       	cpi	r25, 0xE8	; 232
    2704:	dc f3       	brlt	.-10     	; 0x26fc <__mulsf3_pse+0x82>
    2706:	86 95       	lsr	r24
    2708:	77 95       	ror	r23
    270a:	67 95       	ror	r22
    270c:	b7 95       	ror	r27
    270e:	f7 95       	ror	r31
    2710:	e7 95       	ror	r30
    2712:	9f 5f       	subi	r25, 0xFF	; 255
    2714:	c1 f7       	brne	.-16     	; 0x2706 <__mulsf3_pse+0x8c>
    2716:	fe 2b       	or	r31, r30
    2718:	88 0f       	add	r24, r24
    271a:	91 1d       	adc	r25, r1
    271c:	96 95       	lsr	r25
    271e:	87 95       	ror	r24
    2720:	97 f9       	bld	r25, 7
    2722:	08 95       	ret

00002724 <__udivmodsi4>:
    2724:	a1 e2       	ldi	r26, 0x21	; 33
    2726:	1a 2e       	mov	r1, r26
    2728:	aa 1b       	sub	r26, r26
    272a:	bb 1b       	sub	r27, r27
    272c:	fd 01       	movw	r30, r26
    272e:	0d c0       	rjmp	.+26     	; 0x274a <__udivmodsi4_ep>

00002730 <__udivmodsi4_loop>:
    2730:	aa 1f       	adc	r26, r26
    2732:	bb 1f       	adc	r27, r27
    2734:	ee 1f       	adc	r30, r30
    2736:	ff 1f       	adc	r31, r31
    2738:	a2 17       	cp	r26, r18
    273a:	b3 07       	cpc	r27, r19
    273c:	e4 07       	cpc	r30, r20
    273e:	f5 07       	cpc	r31, r21
    2740:	20 f0       	brcs	.+8      	; 0x274a <__udivmodsi4_ep>
    2742:	a2 1b       	sub	r26, r18
    2744:	b3 0b       	sbc	r27, r19
    2746:	e4 0b       	sbc	r30, r20
    2748:	f5 0b       	sbc	r31, r21

0000274a <__udivmodsi4_ep>:
    274a:	66 1f       	adc	r22, r22
    274c:	77 1f       	adc	r23, r23
    274e:	88 1f       	adc	r24, r24
    2750:	99 1f       	adc	r25, r25
    2752:	1a 94       	dec	r1
    2754:	69 f7       	brne	.-38     	; 0x2730 <__udivmodsi4_loop>
    2756:	60 95       	com	r22
    2758:	70 95       	com	r23
    275a:	80 95       	com	r24
    275c:	90 95       	com	r25
    275e:	9b 01       	movw	r18, r22
    2760:	ac 01       	movw	r20, r24
    2762:	bd 01       	movw	r22, r26
    2764:	cf 01       	movw	r24, r30
    2766:	08 95       	ret

00002768 <__tablejump2__>:
    2768:	ee 0f       	add	r30, r30
    276a:	ff 1f       	adc	r31, r31
    276c:	88 1f       	adc	r24, r24
    276e:	8b bf       	out	0x3b, r24	; 59
    2770:	07 90       	elpm	r0, Z+
    2772:	f6 91       	elpm	r31, Z
    2774:	e0 2d       	mov	r30, r0
    2776:	19 94       	eijmp

00002778 <__umulhisi3>:
    2778:	a2 9f       	mul	r26, r18
    277a:	b0 01       	movw	r22, r0
    277c:	b3 9f       	mul	r27, r19
    277e:	c0 01       	movw	r24, r0
    2780:	a3 9f       	mul	r26, r19
    2782:	70 0d       	add	r23, r0
    2784:	81 1d       	adc	r24, r1
    2786:	11 24       	eor	r1, r1
    2788:	91 1d       	adc	r25, r1
    278a:	b2 9f       	mul	r27, r18
    278c:	70 0d       	add	r23, r0
    278e:	81 1d       	adc	r24, r1
    2790:	11 24       	eor	r1, r1
    2792:	91 1d       	adc	r25, r1
    2794:	08 95       	ret

00002796 <__muluhisi3>:
    2796:	f0 df       	rcall	.-32     	; 0x2778 <__umulhisi3>
    2798:	a5 9f       	mul	r26, r21
    279a:	90 0d       	add	r25, r0
    279c:	b4 9f       	mul	r27, r20
    279e:	90 0d       	add	r25, r0
    27a0:	a4 9f       	mul	r26, r20
    27a2:	80 0d       	add	r24, r0
    27a4:	91 1d       	adc	r25, r1
    27a6:	11 24       	eor	r1, r1
    27a8:	08 95       	ret

000027aa <malloc>:
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	82 30       	cpi	r24, 0x02	; 2
    27b4:	91 05       	cpc	r25, r1
    27b6:	10 f4       	brcc	.+4      	; 0x27bc <malloc+0x12>
    27b8:	82 e0       	ldi	r24, 0x02	; 2
    27ba:	90 e0       	ldi	r25, 0x00	; 0
    27bc:	e0 91 ad 04 	lds	r30, 0x04AD	; 0x8004ad <__flp>
    27c0:	f0 91 ae 04 	lds	r31, 0x04AE	; 0x8004ae <__flp+0x1>
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	a0 e0       	ldi	r26, 0x00	; 0
    27ca:	b0 e0       	ldi	r27, 0x00	; 0
    27cc:	30 97       	sbiw	r30, 0x00	; 0
    27ce:	19 f1       	breq	.+70     	; 0x2816 <malloc+0x6c>
    27d0:	40 81       	ld	r20, Z
    27d2:	51 81       	ldd	r21, Z+1	; 0x01
    27d4:	02 81       	ldd	r16, Z+2	; 0x02
    27d6:	13 81       	ldd	r17, Z+3	; 0x03
    27d8:	48 17       	cp	r20, r24
    27da:	59 07       	cpc	r21, r25
    27dc:	c8 f0       	brcs	.+50     	; 0x2810 <malloc+0x66>
    27de:	84 17       	cp	r24, r20
    27e0:	95 07       	cpc	r25, r21
    27e2:	69 f4       	brne	.+26     	; 0x27fe <malloc+0x54>
    27e4:	10 97       	sbiw	r26, 0x00	; 0
    27e6:	31 f0       	breq	.+12     	; 0x27f4 <malloc+0x4a>
    27e8:	12 96       	adiw	r26, 0x02	; 2
    27ea:	0c 93       	st	X, r16
    27ec:	12 97       	sbiw	r26, 0x02	; 2
    27ee:	13 96       	adiw	r26, 0x03	; 3
    27f0:	1c 93       	st	X, r17
    27f2:	27 c0       	rjmp	.+78     	; 0x2842 <malloc+0x98>
    27f4:	00 93 ad 04 	sts	0x04AD, r16	; 0x8004ad <__flp>
    27f8:	10 93 ae 04 	sts	0x04AE, r17	; 0x8004ae <__flp+0x1>
    27fc:	22 c0       	rjmp	.+68     	; 0x2842 <malloc+0x98>
    27fe:	21 15       	cp	r18, r1
    2800:	31 05       	cpc	r19, r1
    2802:	19 f0       	breq	.+6      	; 0x280a <malloc+0x60>
    2804:	42 17       	cp	r20, r18
    2806:	53 07       	cpc	r21, r19
    2808:	18 f4       	brcc	.+6      	; 0x2810 <malloc+0x66>
    280a:	9a 01       	movw	r18, r20
    280c:	bd 01       	movw	r22, r26
    280e:	ef 01       	movw	r28, r30
    2810:	df 01       	movw	r26, r30
    2812:	f8 01       	movw	r30, r16
    2814:	db cf       	rjmp	.-74     	; 0x27cc <malloc+0x22>
    2816:	21 15       	cp	r18, r1
    2818:	31 05       	cpc	r19, r1
    281a:	f9 f0       	breq	.+62     	; 0x285a <malloc+0xb0>
    281c:	28 1b       	sub	r18, r24
    281e:	39 0b       	sbc	r19, r25
    2820:	24 30       	cpi	r18, 0x04	; 4
    2822:	31 05       	cpc	r19, r1
    2824:	80 f4       	brcc	.+32     	; 0x2846 <malloc+0x9c>
    2826:	8a 81       	ldd	r24, Y+2	; 0x02
    2828:	9b 81       	ldd	r25, Y+3	; 0x03
    282a:	61 15       	cp	r22, r1
    282c:	71 05       	cpc	r23, r1
    282e:	21 f0       	breq	.+8      	; 0x2838 <malloc+0x8e>
    2830:	fb 01       	movw	r30, r22
    2832:	93 83       	std	Z+3, r25	; 0x03
    2834:	82 83       	std	Z+2, r24	; 0x02
    2836:	04 c0       	rjmp	.+8      	; 0x2840 <malloc+0x96>
    2838:	90 93 ae 04 	sts	0x04AE, r25	; 0x8004ae <__flp+0x1>
    283c:	80 93 ad 04 	sts	0x04AD, r24	; 0x8004ad <__flp>
    2840:	fe 01       	movw	r30, r28
    2842:	32 96       	adiw	r30, 0x02	; 2
    2844:	44 c0       	rjmp	.+136    	; 0x28ce <malloc+0x124>
    2846:	fe 01       	movw	r30, r28
    2848:	e2 0f       	add	r30, r18
    284a:	f3 1f       	adc	r31, r19
    284c:	81 93       	st	Z+, r24
    284e:	91 93       	st	Z+, r25
    2850:	22 50       	subi	r18, 0x02	; 2
    2852:	31 09       	sbc	r19, r1
    2854:	39 83       	std	Y+1, r19	; 0x01
    2856:	28 83       	st	Y, r18
    2858:	3a c0       	rjmp	.+116    	; 0x28ce <malloc+0x124>
    285a:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <__brkval>
    285e:	30 91 ac 04 	lds	r19, 0x04AC	; 0x8004ac <__brkval+0x1>
    2862:	23 2b       	or	r18, r19
    2864:	41 f4       	brne	.+16     	; 0x2876 <malloc+0xcc>
    2866:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    286a:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    286e:	30 93 ac 04 	sts	0x04AC, r19	; 0x8004ac <__brkval+0x1>
    2872:	20 93 ab 04 	sts	0x04AB, r18	; 0x8004ab <__brkval>
    2876:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    287a:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    287e:	21 15       	cp	r18, r1
    2880:	31 05       	cpc	r19, r1
    2882:	41 f4       	brne	.+16     	; 0x2894 <malloc+0xea>
    2884:	2d b7       	in	r18, 0x3d	; 61
    2886:	3e b7       	in	r19, 0x3e	; 62
    2888:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    288c:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2890:	24 1b       	sub	r18, r20
    2892:	35 0b       	sbc	r19, r21
    2894:	e0 91 ab 04 	lds	r30, 0x04AB	; 0x8004ab <__brkval>
    2898:	f0 91 ac 04 	lds	r31, 0x04AC	; 0x8004ac <__brkval+0x1>
    289c:	e2 17       	cp	r30, r18
    289e:	f3 07       	cpc	r31, r19
    28a0:	a0 f4       	brcc	.+40     	; 0x28ca <malloc+0x120>
    28a2:	2e 1b       	sub	r18, r30
    28a4:	3f 0b       	sbc	r19, r31
    28a6:	28 17       	cp	r18, r24
    28a8:	39 07       	cpc	r19, r25
    28aa:	78 f0       	brcs	.+30     	; 0x28ca <malloc+0x120>
    28ac:	ac 01       	movw	r20, r24
    28ae:	4e 5f       	subi	r20, 0xFE	; 254
    28b0:	5f 4f       	sbci	r21, 0xFF	; 255
    28b2:	24 17       	cp	r18, r20
    28b4:	35 07       	cpc	r19, r21
    28b6:	48 f0       	brcs	.+18     	; 0x28ca <malloc+0x120>
    28b8:	4e 0f       	add	r20, r30
    28ba:	5f 1f       	adc	r21, r31
    28bc:	50 93 ac 04 	sts	0x04AC, r21	; 0x8004ac <__brkval+0x1>
    28c0:	40 93 ab 04 	sts	0x04AB, r20	; 0x8004ab <__brkval>
    28c4:	81 93       	st	Z+, r24
    28c6:	91 93       	st	Z+, r25
    28c8:	02 c0       	rjmp	.+4      	; 0x28ce <malloc+0x124>
    28ca:	e0 e0       	ldi	r30, 0x00	; 0
    28cc:	f0 e0       	ldi	r31, 0x00	; 0
    28ce:	cf 01       	movw	r24, r30
    28d0:	df 91       	pop	r29
    28d2:	cf 91       	pop	r28
    28d4:	1f 91       	pop	r17
    28d6:	0f 91       	pop	r16
    28d8:	08 95       	ret

000028da <free>:
    28da:	cf 93       	push	r28
    28dc:	df 93       	push	r29
    28de:	00 97       	sbiw	r24, 0x00	; 0
    28e0:	09 f4       	brne	.+2      	; 0x28e4 <free+0xa>
    28e2:	81 c0       	rjmp	.+258    	; 0x29e6 <free+0x10c>
    28e4:	fc 01       	movw	r30, r24
    28e6:	32 97       	sbiw	r30, 0x02	; 2
    28e8:	13 82       	std	Z+3, r1	; 0x03
    28ea:	12 82       	std	Z+2, r1	; 0x02
    28ec:	a0 91 ad 04 	lds	r26, 0x04AD	; 0x8004ad <__flp>
    28f0:	b0 91 ae 04 	lds	r27, 0x04AE	; 0x8004ae <__flp+0x1>
    28f4:	10 97       	sbiw	r26, 0x00	; 0
    28f6:	81 f4       	brne	.+32     	; 0x2918 <free+0x3e>
    28f8:	20 81       	ld	r18, Z
    28fa:	31 81       	ldd	r19, Z+1	; 0x01
    28fc:	82 0f       	add	r24, r18
    28fe:	93 1f       	adc	r25, r19
    2900:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <__brkval>
    2904:	30 91 ac 04 	lds	r19, 0x04AC	; 0x8004ac <__brkval+0x1>
    2908:	28 17       	cp	r18, r24
    290a:	39 07       	cpc	r19, r25
    290c:	51 f5       	brne	.+84     	; 0x2962 <free+0x88>
    290e:	f0 93 ac 04 	sts	0x04AC, r31	; 0x8004ac <__brkval+0x1>
    2912:	e0 93 ab 04 	sts	0x04AB, r30	; 0x8004ab <__brkval>
    2916:	67 c0       	rjmp	.+206    	; 0x29e6 <free+0x10c>
    2918:	ed 01       	movw	r28, r26
    291a:	20 e0       	ldi	r18, 0x00	; 0
    291c:	30 e0       	ldi	r19, 0x00	; 0
    291e:	ce 17       	cp	r28, r30
    2920:	df 07       	cpc	r29, r31
    2922:	40 f4       	brcc	.+16     	; 0x2934 <free+0x5a>
    2924:	4a 81       	ldd	r20, Y+2	; 0x02
    2926:	5b 81       	ldd	r21, Y+3	; 0x03
    2928:	9e 01       	movw	r18, r28
    292a:	41 15       	cp	r20, r1
    292c:	51 05       	cpc	r21, r1
    292e:	f1 f0       	breq	.+60     	; 0x296c <free+0x92>
    2930:	ea 01       	movw	r28, r20
    2932:	f5 cf       	rjmp	.-22     	; 0x291e <free+0x44>
    2934:	d3 83       	std	Z+3, r29	; 0x03
    2936:	c2 83       	std	Z+2, r28	; 0x02
    2938:	40 81       	ld	r20, Z
    293a:	51 81       	ldd	r21, Z+1	; 0x01
    293c:	84 0f       	add	r24, r20
    293e:	95 1f       	adc	r25, r21
    2940:	c8 17       	cp	r28, r24
    2942:	d9 07       	cpc	r29, r25
    2944:	59 f4       	brne	.+22     	; 0x295c <free+0x82>
    2946:	88 81       	ld	r24, Y
    2948:	99 81       	ldd	r25, Y+1	; 0x01
    294a:	84 0f       	add	r24, r20
    294c:	95 1f       	adc	r25, r21
    294e:	02 96       	adiw	r24, 0x02	; 2
    2950:	91 83       	std	Z+1, r25	; 0x01
    2952:	80 83       	st	Z, r24
    2954:	8a 81       	ldd	r24, Y+2	; 0x02
    2956:	9b 81       	ldd	r25, Y+3	; 0x03
    2958:	93 83       	std	Z+3, r25	; 0x03
    295a:	82 83       	std	Z+2, r24	; 0x02
    295c:	21 15       	cp	r18, r1
    295e:	31 05       	cpc	r19, r1
    2960:	29 f4       	brne	.+10     	; 0x296c <free+0x92>
    2962:	f0 93 ae 04 	sts	0x04AE, r31	; 0x8004ae <__flp+0x1>
    2966:	e0 93 ad 04 	sts	0x04AD, r30	; 0x8004ad <__flp>
    296a:	3d c0       	rjmp	.+122    	; 0x29e6 <free+0x10c>
    296c:	e9 01       	movw	r28, r18
    296e:	fb 83       	std	Y+3, r31	; 0x03
    2970:	ea 83       	std	Y+2, r30	; 0x02
    2972:	49 91       	ld	r20, Y+
    2974:	59 91       	ld	r21, Y+
    2976:	c4 0f       	add	r28, r20
    2978:	d5 1f       	adc	r29, r21
    297a:	ec 17       	cp	r30, r28
    297c:	fd 07       	cpc	r31, r29
    297e:	61 f4       	brne	.+24     	; 0x2998 <free+0xbe>
    2980:	80 81       	ld	r24, Z
    2982:	91 81       	ldd	r25, Z+1	; 0x01
    2984:	84 0f       	add	r24, r20
    2986:	95 1f       	adc	r25, r21
    2988:	02 96       	adiw	r24, 0x02	; 2
    298a:	e9 01       	movw	r28, r18
    298c:	99 83       	std	Y+1, r25	; 0x01
    298e:	88 83       	st	Y, r24
    2990:	82 81       	ldd	r24, Z+2	; 0x02
    2992:	93 81       	ldd	r25, Z+3	; 0x03
    2994:	9b 83       	std	Y+3, r25	; 0x03
    2996:	8a 83       	std	Y+2, r24	; 0x02
    2998:	e0 e0       	ldi	r30, 0x00	; 0
    299a:	f0 e0       	ldi	r31, 0x00	; 0
    299c:	12 96       	adiw	r26, 0x02	; 2
    299e:	8d 91       	ld	r24, X+
    29a0:	9c 91       	ld	r25, X
    29a2:	13 97       	sbiw	r26, 0x03	; 3
    29a4:	00 97       	sbiw	r24, 0x00	; 0
    29a6:	19 f0       	breq	.+6      	; 0x29ae <free+0xd4>
    29a8:	fd 01       	movw	r30, r26
    29aa:	dc 01       	movw	r26, r24
    29ac:	f7 cf       	rjmp	.-18     	; 0x299c <free+0xc2>
    29ae:	8d 91       	ld	r24, X+
    29b0:	9c 91       	ld	r25, X
    29b2:	11 97       	sbiw	r26, 0x01	; 1
    29b4:	9d 01       	movw	r18, r26
    29b6:	2e 5f       	subi	r18, 0xFE	; 254
    29b8:	3f 4f       	sbci	r19, 0xFF	; 255
    29ba:	82 0f       	add	r24, r18
    29bc:	93 1f       	adc	r25, r19
    29be:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <__brkval>
    29c2:	30 91 ac 04 	lds	r19, 0x04AC	; 0x8004ac <__brkval+0x1>
    29c6:	28 17       	cp	r18, r24
    29c8:	39 07       	cpc	r19, r25
    29ca:	69 f4       	brne	.+26     	; 0x29e6 <free+0x10c>
    29cc:	30 97       	sbiw	r30, 0x00	; 0
    29ce:	29 f4       	brne	.+10     	; 0x29da <free+0x100>
    29d0:	10 92 ae 04 	sts	0x04AE, r1	; 0x8004ae <__flp+0x1>
    29d4:	10 92 ad 04 	sts	0x04AD, r1	; 0x8004ad <__flp>
    29d8:	02 c0       	rjmp	.+4      	; 0x29de <free+0x104>
    29da:	13 82       	std	Z+3, r1	; 0x03
    29dc:	12 82       	std	Z+2, r1	; 0x02
    29de:	b0 93 ac 04 	sts	0x04AC, r27	; 0x8004ac <__brkval+0x1>
    29e2:	a0 93 ab 04 	sts	0x04AB, r26	; 0x8004ab <__brkval>
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	08 95       	ret

000029ec <memcpy>:
    29ec:	fb 01       	movw	r30, r22
    29ee:	dc 01       	movw	r26, r24
    29f0:	02 c0       	rjmp	.+4      	; 0x29f6 <memcpy+0xa>
    29f2:	01 90       	ld	r0, Z+
    29f4:	0d 92       	st	X+, r0
    29f6:	41 50       	subi	r20, 0x01	; 1
    29f8:	50 40       	sbci	r21, 0x00	; 0
    29fa:	d8 f7       	brcc	.-10     	; 0x29f2 <memcpy+0x6>
    29fc:	08 95       	ret

000029fe <memset>:
    29fe:	dc 01       	movw	r26, r24
    2a00:	01 c0       	rjmp	.+2      	; 0x2a04 <memset+0x6>
    2a02:	6d 93       	st	X+, r22
    2a04:	41 50       	subi	r20, 0x01	; 1
    2a06:	50 40       	sbci	r21, 0x00	; 0
    2a08:	e0 f7       	brcc	.-8      	; 0x2a02 <memset+0x4>
    2a0a:	08 95       	ret

00002a0c <__itoa_ncheck>:
    2a0c:	bb 27       	eor	r27, r27
    2a0e:	4a 30       	cpi	r20, 0x0A	; 10
    2a10:	31 f4       	brne	.+12     	; 0x2a1e <__itoa_ncheck+0x12>
    2a12:	99 23       	and	r25, r25
    2a14:	22 f4       	brpl	.+8      	; 0x2a1e <__itoa_ncheck+0x12>
    2a16:	bd e2       	ldi	r27, 0x2D	; 45
    2a18:	90 95       	com	r25
    2a1a:	81 95       	neg	r24
    2a1c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a1e:	01 c0       	rjmp	.+2      	; 0x2a22 <__utoa_common>

00002a20 <__utoa_ncheck>:
    2a20:	bb 27       	eor	r27, r27

00002a22 <__utoa_common>:
    2a22:	fb 01       	movw	r30, r22
    2a24:	55 27       	eor	r21, r21
    2a26:	aa 27       	eor	r26, r26
    2a28:	88 0f       	add	r24, r24
    2a2a:	99 1f       	adc	r25, r25
    2a2c:	aa 1f       	adc	r26, r26
    2a2e:	a4 17       	cp	r26, r20
    2a30:	10 f0       	brcs	.+4      	; 0x2a36 <__utoa_common+0x14>
    2a32:	a4 1b       	sub	r26, r20
    2a34:	83 95       	inc	r24
    2a36:	50 51       	subi	r21, 0x10	; 16
    2a38:	b9 f7       	brne	.-18     	; 0x2a28 <__utoa_common+0x6>
    2a3a:	a0 5d       	subi	r26, 0xD0	; 208
    2a3c:	aa 33       	cpi	r26, 0x3A	; 58
    2a3e:	08 f0       	brcs	.+2      	; 0x2a42 <__utoa_common+0x20>
    2a40:	a9 5d       	subi	r26, 0xD9	; 217
    2a42:	a1 93       	st	Z+, r26
    2a44:	00 97       	sbiw	r24, 0x00	; 0
    2a46:	79 f7       	brne	.-34     	; 0x2a26 <__utoa_common+0x4>
    2a48:	b1 11       	cpse	r27, r1
    2a4a:	b1 93       	st	Z+, r27
    2a4c:	11 92       	st	Z+, r1
    2a4e:	cb 01       	movw	r24, r22
    2a50:	00 c0       	rjmp	.+0      	; 0x2a52 <strrev>

00002a52 <strrev>:
    2a52:	dc 01       	movw	r26, r24
    2a54:	fc 01       	movw	r30, r24
    2a56:	67 2f       	mov	r22, r23
    2a58:	71 91       	ld	r23, Z+
    2a5a:	77 23       	and	r23, r23
    2a5c:	e1 f7       	brne	.-8      	; 0x2a56 <strrev+0x4>
    2a5e:	32 97       	sbiw	r30, 0x02	; 2
    2a60:	04 c0       	rjmp	.+8      	; 0x2a6a <strrev+0x18>
    2a62:	7c 91       	ld	r23, X
    2a64:	6d 93       	st	X+, r22
    2a66:	70 83       	st	Z, r23
    2a68:	62 91       	ld	r22, -Z
    2a6a:	ae 17       	cp	r26, r30
    2a6c:	bf 07       	cpc	r27, r31
    2a6e:	c8 f3       	brcs	.-14     	; 0x2a62 <strrev+0x10>
    2a70:	08 95       	ret

00002a72 <_exit>:
    2a72:	f8 94       	cli

00002a74 <__stop_program>:
    2a74:	ff cf       	rjmp	.-2      	; 0x2a74 <__stop_program>
