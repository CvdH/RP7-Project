
opdr1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800200  000023d2  00002466  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000120  00800220  00800220  00002486  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002486  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000024b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000570  00000000  00000000  000024f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006900  00000000  00000000  00002a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012ec  00000000  00000000  00009368  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000044a3  00000000  00000000  0000a654  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001364  00000000  00000000  0000eaf8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001aed  00000000  00000000  0000fe5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000717e  00000000  00000000  00011949  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000858  00000000  00000000  00018ac7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6d c1       	rjmp	.+730    	; 0x2dc <__ctors_end>
       2:	00 00       	nop
       4:	8c c1       	rjmp	.+792    	; 0x31e <__bad_interrupt>
       6:	00 00       	nop
       8:	8a c1       	rjmp	.+788    	; 0x31e <__bad_interrupt>
       a:	00 00       	nop
       c:	88 c1       	rjmp	.+784    	; 0x31e <__bad_interrupt>
       e:	00 00       	nop
      10:	86 c1       	rjmp	.+780    	; 0x31e <__bad_interrupt>
      12:	00 00       	nop
      14:	84 c1       	rjmp	.+776    	; 0x31e <__bad_interrupt>
      16:	00 00       	nop
      18:	82 c1       	rjmp	.+772    	; 0x31e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	80 c1       	rjmp	.+768    	; 0x31e <__bad_interrupt>
      1e:	00 00       	nop
      20:	7e c1       	rjmp	.+764    	; 0x31e <__bad_interrupt>
      22:	00 00       	nop
      24:	7c c1       	rjmp	.+760    	; 0x31e <__bad_interrupt>
      26:	00 00       	nop
      28:	7a c1       	rjmp	.+756    	; 0x31e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	78 c1       	rjmp	.+752    	; 0x31e <__bad_interrupt>
      2e:	00 00       	nop
      30:	76 c1       	rjmp	.+748    	; 0x31e <__bad_interrupt>
      32:	00 00       	nop
      34:	74 c1       	rjmp	.+744    	; 0x31e <__bad_interrupt>
      36:	00 00       	nop
      38:	72 c1       	rjmp	.+740    	; 0x31e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	70 c1       	rjmp	.+736    	; 0x31e <__bad_interrupt>
      3e:	00 00       	nop
      40:	6e c1       	rjmp	.+732    	; 0x31e <__bad_interrupt>
      42:	00 00       	nop
      44:	6c c1       	rjmp	.+728    	; 0x31e <__bad_interrupt>
      46:	00 00       	nop
      48:	6a c1       	rjmp	.+724    	; 0x31e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	68 c1       	rjmp	.+720    	; 0x31e <__bad_interrupt>
      4e:	00 00       	nop
      50:	66 c1       	rjmp	.+716    	; 0x31e <__bad_interrupt>
      52:	00 00       	nop
      54:	c4 c4       	rjmp	.+2440   	; 0x9de <__vector_21>
      56:	00 00       	nop
      58:	62 c1       	rjmp	.+708    	; 0x31e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	60 c1       	rjmp	.+704    	; 0x31e <__bad_interrupt>
      5e:	00 00       	nop
      60:	5e c1       	rjmp	.+700    	; 0x31e <__bad_interrupt>
      62:	00 00       	nop
      64:	39 c7       	rjmp	.+3698   	; 0xed8 <__vector_25>
      66:	00 00       	nop
      68:	96 c7       	rjmp	.+3884   	; 0xf96 <__vector_26>
      6a:	00 00       	nop
      6c:	58 c1       	rjmp	.+688    	; 0x31e <__bad_interrupt>
      6e:	00 00       	nop
      70:	56 c1       	rjmp	.+684    	; 0x31e <__bad_interrupt>
      72:	00 00       	nop
      74:	54 c1       	rjmp	.+680    	; 0x31e <__bad_interrupt>
      76:	00 00       	nop
      78:	52 c1       	rjmp	.+676    	; 0x31e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	50 c1       	rjmp	.+672    	; 0x31e <__bad_interrupt>
      7e:	00 00       	nop
      80:	4e c1       	rjmp	.+668    	; 0x31e <__bad_interrupt>
      82:	00 00       	nop
      84:	4c c1       	rjmp	.+664    	; 0x31e <__bad_interrupt>
      86:	00 00       	nop
      88:	4a c1       	rjmp	.+660    	; 0x31e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	48 c1       	rjmp	.+656    	; 0x31e <__bad_interrupt>
      8e:	00 00       	nop
      90:	cb c7       	rjmp	.+3990   	; 0x1028 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 73 08 	jmp	0x10e6	; 0x10e6 <__vector_37>
      98:	42 c1       	rjmp	.+644    	; 0x31e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	95 c1       	rjmp	.+810    	; 0x3c8 <__vector_39>
      9e:	00 00       	nop
      a0:	3e c1       	rjmp	.+636    	; 0x31e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3c c1       	rjmp	.+632    	; 0x31e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3a c1       	rjmp	.+628    	; 0x31e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	38 c1       	rjmp	.+624    	; 0x31e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	36 c1       	rjmp	.+620    	; 0x31e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	34 c1       	rjmp	.+616    	; 0x31e <__bad_interrupt>
      b6:	00 00       	nop
      b8:	32 c1       	rjmp	.+612    	; 0x31e <__bad_interrupt>
      ba:	00 00       	nop
      bc:	30 c1       	rjmp	.+608    	; 0x31e <__bad_interrupt>
      be:	00 00       	nop
      c0:	2e c1       	rjmp	.+604    	; 0x31e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2c c1       	rjmp	.+600    	; 0x31e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2a c1       	rjmp	.+596    	; 0x31e <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 bc 08 	jmp	0x1178	; 0x1178 <__vector_51>
      d0:	0c 94 1b 09 	jmp	0x1236	; 0x1236 <__vector_52>
      d4:	24 c1       	rjmp	.+584    	; 0x31e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 64 09 	jmp	0x12c8	; 0x12c8 <__vector_54>
      dc:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <__vector_55>
      e0:	1e c1       	rjmp	.+572    	; 0x31e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	03 02       	muls	r16, r19
      e6:	be 02       	muls	r27, r30
      e8:	be 02       	muls	r27, r30
      ea:	be 02       	muls	r27, r30
      ec:	be 02       	muls	r27, r30
      ee:	be 02       	muls	r27, r30
      f0:	be 02       	muls	r27, r30
      f2:	be 02       	muls	r27, r30
      f4:	03 02       	muls	r16, r19
      f6:	be 02       	muls	r27, r30
      f8:	be 02       	muls	r27, r30
      fa:	be 02       	muls	r27, r30
      fc:	be 02       	muls	r27, r30
      fe:	be 02       	muls	r27, r30
     100:	be 02       	muls	r27, r30
     102:	be 02       	muls	r27, r30
     104:	05 02       	muls	r16, r21
     106:	be 02       	muls	r27, r30
     108:	be 02       	muls	r27, r30
     10a:	be 02       	muls	r27, r30
     10c:	be 02       	muls	r27, r30
     10e:	be 02       	muls	r27, r30
     110:	be 02       	muls	r27, r30
     112:	be 02       	muls	r27, r30
     114:	22 02       	muls	r18, r18
     116:	be 02       	muls	r27, r30
     118:	be 02       	muls	r27, r30
     11a:	be 02       	muls	r27, r30
     11c:	be 02       	muls	r27, r30
     11e:	be 02       	muls	r27, r30
     120:	be 02       	muls	r27, r30
     122:	be 02       	muls	r27, r30
     124:	05 02       	muls	r16, r21
     126:	be 02       	muls	r27, r30
     128:	be 02       	muls	r27, r30
     12a:	be 02       	muls	r27, r30
     12c:	be 02       	muls	r27, r30
     12e:	be 02       	muls	r27, r30
     130:	be 02       	muls	r27, r30
     132:	be 02       	muls	r27, r30
     134:	22 02       	muls	r18, r18
     136:	be 02       	muls	r27, r30
     138:	be 02       	muls	r27, r30
     13a:	be 02       	muls	r27, r30
     13c:	be 02       	muls	r27, r30
     13e:	be 02       	muls	r27, r30
     140:	be 02       	muls	r27, r30
     142:	be 02       	muls	r27, r30
     144:	ba 02       	muls	r27, r26
     146:	be 02       	muls	r27, r30
     148:	be 02       	muls	r27, r30
     14a:	be 02       	muls	r27, r30
     14c:	be 02       	muls	r27, r30
     14e:	be 02       	muls	r27, r30
     150:	be 02       	muls	r27, r30
     152:	be 02       	muls	r27, r30
     154:	36 02       	muls	r19, r22
     156:	be 02       	muls	r27, r30
     158:	be 02       	muls	r27, r30
     15a:	be 02       	muls	r27, r30
     15c:	be 02       	muls	r27, r30
     15e:	be 02       	muls	r27, r30
     160:	be 02       	muls	r27, r30
     162:	be 02       	muls	r27, r30
     164:	59 02       	muls	r21, r25
     166:	be 02       	muls	r27, r30
     168:	be 02       	muls	r27, r30
     16a:	be 02       	muls	r27, r30
     16c:	be 02       	muls	r27, r30
     16e:	be 02       	muls	r27, r30
     170:	be 02       	muls	r27, r30
     172:	be 02       	muls	r27, r30
     174:	2a 02       	muls	r18, r26
     176:	be 02       	muls	r27, r30
     178:	be 02       	muls	r27, r30
     17a:	be 02       	muls	r27, r30
     17c:	be 02       	muls	r27, r30
     17e:	be 02       	muls	r27, r30
     180:	be 02       	muls	r27, r30
     182:	be 02       	muls	r27, r30
     184:	48 02       	muls	r20, r24
     186:	be 02       	muls	r27, r30
     188:	be 02       	muls	r27, r30
     18a:	be 02       	muls	r27, r30
     18c:	be 02       	muls	r27, r30
     18e:	be 02       	muls	r27, r30
     190:	be 02       	muls	r27, r30
     192:	be 02       	muls	r27, r30
     194:	90 02       	muls	r25, r16
     196:	be 02       	muls	r27, r30
     198:	be 02       	muls	r27, r30
     19a:	be 02       	muls	r27, r30
     19c:	be 02       	muls	r27, r30
     19e:	be 02       	muls	r27, r30
     1a0:	be 02       	muls	r27, r30
     1a2:	be 02       	muls	r27, r30
     1a4:	90 02       	muls	r25, r16
     1a6:	be 02       	muls	r27, r30
     1a8:	be 02       	muls	r27, r30
     1aa:	be 02       	muls	r27, r30
     1ac:	be 02       	muls	r27, r30
     1ae:	be 02       	muls	r27, r30
     1b0:	be 02       	muls	r27, r30
     1b2:	be 02       	muls	r27, r30
     1b4:	8b 02       	muls	r24, r27
     1b6:	be 02       	muls	r27, r30
     1b8:	be 02       	muls	r27, r30
     1ba:	be 02       	muls	r27, r30
     1bc:	be 02       	muls	r27, r30
     1be:	be 02       	muls	r27, r30
     1c0:	be 02       	muls	r27, r30
     1c2:	be 02       	muls	r27, r30
     1c4:	8b 02       	muls	r24, r27
     1c6:	be 02       	muls	r27, r30
     1c8:	be 02       	muls	r27, r30
     1ca:	be 02       	muls	r27, r30
     1cc:	be 02       	muls	r27, r30
     1ce:	be 02       	muls	r27, r30
     1d0:	be 02       	muls	r27, r30
     1d2:	be 02       	muls	r27, r30
     1d4:	9b 02       	muls	r25, r27
     1d6:	be 02       	muls	r27, r30
     1d8:	be 02       	muls	r27, r30
     1da:	be 02       	muls	r27, r30
     1dc:	be 02       	muls	r27, r30
     1de:	be 02       	muls	r27, r30
     1e0:	be 02       	muls	r27, r30
     1e2:	be 02       	muls	r27, r30
     1e4:	b0 02       	muls	r27, r16
     1e6:	be 02       	muls	r27, r30
     1e8:	be 02       	muls	r27, r30
     1ea:	be 02       	muls	r27, r30
     1ec:	be 02       	muls	r27, r30
     1ee:	be 02       	muls	r27, r30
     1f0:	be 02       	muls	r27, r30
     1f2:	be 02       	muls	r27, r30
     1f4:	9b 02       	muls	r25, r27
     1f6:	be 02       	muls	r27, r30
     1f8:	be 02       	muls	r27, r30
     1fa:	be 02       	muls	r27, r30
     1fc:	be 02       	muls	r27, r30
     1fe:	be 02       	muls	r27, r30
     200:	be 02       	muls	r27, r30
     202:	be 02       	muls	r27, r30
     204:	b0 02       	muls	r27, r16
     206:	be 02       	muls	r27, r30
     208:	be 02       	muls	r27, r30
     20a:	be 02       	muls	r27, r30
     20c:	be 02       	muls	r27, r30
     20e:	be 02       	muls	r27, r30
     210:	be 02       	muls	r27, r30
     212:	be 02       	muls	r27, r30
     214:	b4 02       	muls	r27, r20
     216:	be 02       	muls	r27, r30
     218:	be 02       	muls	r27, r30
     21a:	be 02       	muls	r27, r30
     21c:	be 02       	muls	r27, r30
     21e:	be 02       	muls	r27, r30
     220:	be 02       	muls	r27, r30
     222:	be 02       	muls	r27, r30
     224:	61 02       	muls	r22, r17
     226:	be 02       	muls	r27, r30
     228:	be 02       	muls	r27, r30
     22a:	be 02       	muls	r27, r30
     22c:	be 02       	muls	r27, r30
     22e:	be 02       	muls	r27, r30
     230:	be 02       	muls	r27, r30
     232:	be 02       	muls	r27, r30
     234:	61 02       	muls	r22, r17
     236:	be 02       	muls	r27, r30
     238:	be 02       	muls	r27, r30
     23a:	be 02       	muls	r27, r30
     23c:	be 02       	muls	r27, r30
     23e:	be 02       	muls	r27, r30
     240:	be 02       	muls	r27, r30
     242:	be 02       	muls	r27, r30
     244:	63 02       	muls	r22, r19
     246:	be 02       	muls	r27, r30
     248:	be 02       	muls	r27, r30
     24a:	be 02       	muls	r27, r30
     24c:	be 02       	muls	r27, r30
     24e:	be 02       	muls	r27, r30
     250:	be 02       	muls	r27, r30
     252:	be 02       	muls	r27, r30
     254:	73 02       	muls	r23, r19
     256:	be 02       	muls	r27, r30
     258:	be 02       	muls	r27, r30
     25a:	be 02       	muls	r27, r30
     25c:	be 02       	muls	r27, r30
     25e:	be 02       	muls	r27, r30
     260:	be 02       	muls	r27, r30
     262:	be 02       	muls	r27, r30
     264:	87 02       	muls	r24, r23

00000266 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     266:	04 e5       	ldi	r16, 0x54	; 84
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	fc e7       	ldi	r31, 0x7C	; 124
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 08 0c 	call	0x1810	; 0x1810 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	e7 d1       	rcall	.+974    	; 0x670 <uxListRemove>
     2a2:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <uxCurrentNumberOfTasks>
     2ac:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5e d0       	rcall	.+188    	; 0x37c <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5c d0       	rcall	.+184    	; 0x37c <vPortFree>
     2c4:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	ab d2       	rcall	.+1366   	; 0x82c <vPortYield>
     2d6:	0e 94 4f 10 	call	0x209e	; 0x209e <vApplicationIdleHook>
     2da:	f4 cf       	rjmp	.-24     	; 0x2c4 <prvIdleTask+0x5e>

000002dc <__ctors_end>:
     2dc:	11 24       	eor	r1, r1
     2de:	1f be       	out	0x3f, r1	; 63
     2e0:	cf ef       	ldi	r28, 0xFF	; 255
     2e2:	d1 e2       	ldi	r29, 0x21	; 33
     2e4:	de bf       	out	0x3e, r29	; 62
     2e6:	cd bf       	out	0x3d, r28	; 61
     2e8:	00 e0       	ldi	r16, 0x00	; 0
     2ea:	0c bf       	out	0x3c, r16	; 60

000002ec <__do_copy_data>:
     2ec:	12 e0       	ldi	r17, 0x02	; 2
     2ee:	a0 e0       	ldi	r26, 0x00	; 0
     2f0:	b2 e0       	ldi	r27, 0x02	; 2
     2f2:	e2 ed       	ldi	r30, 0xD2	; 210
     2f4:	f3 e2       	ldi	r31, 0x23	; 35
     2f6:	00 e0       	ldi	r16, 0x00	; 0
     2f8:	0b bf       	out	0x3b, r16	; 59
     2fa:	02 c0       	rjmp	.+4      	; 0x300 <__do_copy_data+0x14>
     2fc:	07 90       	elpm	r0, Z+
     2fe:	0d 92       	st	X+, r0
     300:	a0 32       	cpi	r26, 0x20	; 32
     302:	b1 07       	cpc	r27, r17
     304:	d9 f7       	brne	.-10     	; 0x2fc <__do_copy_data+0x10>

00000306 <__do_clear_bss>:
     306:	23 e0       	ldi	r18, 0x03	; 3
     308:	a0 e2       	ldi	r26, 0x20	; 32
     30a:	b2 e0       	ldi	r27, 0x02	; 2
     30c:	01 c0       	rjmp	.+2      	; 0x310 <.do_clear_bss_start>

0000030e <.do_clear_bss_loop>:
     30e:	1d 92       	st	X+, r1

00000310 <.do_clear_bss_start>:
     310:	a0 34       	cpi	r26, 0x40	; 64
     312:	b2 07       	cpc	r27, r18
     314:	e1 f7       	brne	.-8      	; 0x30e <.do_clear_bss_loop>
     316:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <main>
     31a:	0c 94 e7 11 	jmp	0x23ce	; 0x23ce <_exit>

0000031e <__bad_interrupt>:
     31e:	70 ce       	rjmp	.-800    	; 0x0 <__vectors>

00000320 <system_tick>:
#include <avr/common.h>

    .global	system_tick
	.type	system_tick, @function
system_tick:
    push r24
     320:	8f 93       	push	r24
    in r24,_SFR_IO_ADDR(SREG)
     322:	8f b7       	in	r24, 0x3f	; 63
	push r24
     324:	8f 93       	push	r24
	cli
     326:	f8 94       	cli
    lds r24,__system_time+0
     328:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <__system_time>
    subi r24, (-1)
     32c:	8f 5f       	subi	r24, 0xFF	; 255
    sts __system_time+0,r24
     32e:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <__system_time>
    lds r24,__system_time+1
     332:	80 91 ab 02 	lds	r24, 0x02AB	; 0x8002ab <__system_time+0x1>
    sbci r24, (-1)
     336:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+1,r24
     338:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <__system_time+0x1>
    lds r24,__system_time+2
     33c:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <__system_time+0x2>
    sbci r24, (-1)
     340:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+2,r24
     342:	80 93 ac 02 	sts	0x02AC, r24	; 0x8002ac <__system_time+0x2>
    lds r24,__system_time+3
     346:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <__system_time+0x3>
    sbci r24, (-1)
     34a:	8f 4f       	sbci	r24, 0xFF	; 255
    sts __system_time+3,r24
     34c:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <__system_time+0x3>
    pop r24
     350:	8f 91       	pop	r24
    out _SFR_IO_ADDR(SREG),r24
     352:	8f bf       	out	0x3f, r24	; 63
    pop r24
     354:	8f 91       	pop	r24
    ret
     356:	08 95       	ret

00000358 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35e:	0e 94 08 0c 	call	0x1810	; 0x1810 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     362:	ce 01       	movw	r24, r28
     364:	0e 94 85 10 	call	0x210a	; 0x210a <malloc>
     368:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     36a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36e:	20 97       	sbiw	r28, 0x00	; 0
     370:	09 f4       	brne	.+2      	; 0x374 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     372:	13 d0       	rcall	.+38     	; 0x39a <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     374:	ce 01       	movw	r24, r28
     376:	df 91       	pop	r29
     378:	cf 91       	pop	r28
     37a:	08 95       	ret

0000037c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     37c:	cf 93       	push	r28
     37e:	df 93       	push	r29
	if( pv )
     380:	00 97       	sbiw	r24, 0x00	; 0
     382:	41 f0       	breq	.+16     	; 0x394 <vPortFree+0x18>
     384:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     386:	0e 94 08 0c 	call	0x1810	; 0x1810 <vTaskSuspendAll>
		{
			free( pv );
     38a:	ce 01       	movw	r24, r28
     38c:	0e 94 1d 11 	call	0x223a	; 0x223a <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     390:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskResumeAll>
	}
}
     394:	df 91       	pop	r29
     396:	cf 91       	pop	r28
     398:	08 95       	ret

0000039a <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     39a:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     39c:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     39e:	83 ed       	ldi	r24, 0xD3	; 211
     3a0:	90 e3       	ldi	r25, 0x30	; 48
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	f1 f7       	brne	.-4      	; 0x3a2 <vApplicationMallocFailedHook+0x8>
     3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <vApplicationMallocFailedHook+0xe>
     3a8:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3aa:	1f 9a       	sbi	0x03, 7	; 3
     3ac:	f8 cf       	rjmp	.-16     	; 0x39e <vApplicationMallocFailedHook+0x4>

000003ae <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3ae:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3b0:	2f 9a       	sbi	0x05, 7	; 5
     3b2:	2f e7       	ldi	r18, 0x7F	; 127
     3b4:	8a e1       	ldi	r24, 0x1A	; 26
     3b6:	96 e0       	ldi	r25, 0x06	; 6
     3b8:	21 50       	subi	r18, 0x01	; 1
     3ba:	80 40       	sbci	r24, 0x00	; 0
     3bc:	90 40       	sbci	r25, 0x00	; 0
     3be:	e1 f7       	brne	.-8      	; 0x3b8 <vApplicationStackOverflowHook+0xa>
     3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <vApplicationStackOverflowHook+0x14>
     3c2:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3c4:	1f 9a       	sbi	0x03, 7	; 3
     3c6:	f5 cf       	rjmp	.-22     	; 0x3b2 <vApplicationStackOverflowHook+0x4>

000003c8 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3c8:	1f 92       	push	r1
     3ca:	0f 92       	push	r0
     3cc:	0f b6       	in	r0, 0x3f	; 63
     3ce:	0f 92       	push	r0
     3d0:	11 24       	eor	r1, r1
     3d2:	0b b6       	in	r0, 0x3b	; 59
     3d4:	0f 92       	push	r0
     3d6:	2f 93       	push	r18
     3d8:	3f 93       	push	r19
     3da:	8f 93       	push	r24
     3dc:	9f 93       	push	r25
     3de:	af 93       	push	r26
     3e0:	bf 93       	push	r27
     3e2:	ef 93       	push	r30
     3e4:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     3e6:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     3ea:	8e 2f       	mov	r24, r30
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	fc 01       	movw	r30, r24
     3f0:	38 97       	sbiw	r30, 0x08	; 8
     3f2:	e1 3c       	cpi	r30, 0xC1	; 193
     3f4:	f1 05       	cpc	r31, r1
     3f6:	08 f0       	brcs	.+2      	; 0x3fa <__vector_39+0x32>
     3f8:	c1 c0       	rjmp	.+386    	; 0x57c <__FUSE_REGION_LENGTH__+0x17c>
     3fa:	88 27       	eor	r24, r24
     3fc:	ee 58       	subi	r30, 0x8E	; 142
     3fe:	ff 4f       	sbci	r31, 0xFF	; 255
     400:	8f 4f       	sbci	r24, 0xFF	; 255
     402:	0c 94 7d 10 	jmp	0x20fa	; 0x20fa <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     406:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     40a:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <__data_end>
     40e:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <I2C_msgSize>
     412:	e8 17       	cp	r30, r24
     414:	70 f4       	brcc	.+28     	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     416:	81 e0       	ldi	r24, 0x01	; 1
     418:	8e 0f       	add	r24, r30
     41a:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__data_end>
     41e:	f0 e0       	ldi	r31, 0x00	; 0
     420:	ec 5d       	subi	r30, 0xDC	; 220
     422:	fd 4f       	sbci	r31, 0xFD	; 253
     424:	80 81       	ld	r24, Z
     426:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     42a:	85 e8       	ldi	r24, 0x85	; 133
     42c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     430:	ac c0       	rjmp	.+344    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     432:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     436:	81 60       	ori	r24, 0x01	; 1
     438:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     43c:	84 e9       	ldi	r24, 0x94	; 148
     43e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     442:	a3 c0       	rjmp	.+326    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     444:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     448:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     44c:	85 ee       	ldi	r24, 0xE5	; 229
     44e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     452:	9b c0       	rjmp	.+310    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     454:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <__data_end>
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	8e 0f       	add	r24, r30
     45c:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__data_end>
     460:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     464:	f0 e0       	ldi	r31, 0x00	; 0
     466:	ec 5d       	subi	r30, 0xDC	; 220
     468:	fd 4f       	sbci	r31, 0xFD	; 253
     46a:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     46c:	20 91 20 02 	lds	r18, 0x0220	; 0x800220 <__data_end>
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <I2C_msgSize>
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	01 97       	sbiw	r24, 0x01	; 1
     47a:	28 17       	cp	r18, r24
     47c:	39 07       	cpc	r19, r25
     47e:	24 f4       	brge	.+8      	; 0x488 <__FUSE_REGION_LENGTH__+0x88>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     480:	85 ec       	ldi	r24, 0xC5	; 197
     482:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     486:	81 c0       	rjmp	.+258    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     488:	85 e8       	ldi	r24, 0x85	; 133
     48a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     48e:	7d c0       	rjmp	.+250    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     490:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     494:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <__data_end>
     498:	f0 e0       	ldi	r31, 0x00	; 0
     49a:	ec 5d       	subi	r30, 0xDC	; 220
     49c:	fd 4f       	sbci	r31, 0xFD	; 253
     49e:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4a0:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     4a4:	81 60       	ori	r24, 0x01	; 1
     4a6:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4aa:	84 ed       	ldi	r24, 0xD4	; 212
     4ac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4b0:	6c c0       	rjmp	.+216    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4b2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4b6:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4ba:	85 ed       	ldi	r24, 0xD5	; 213
     4bc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4c0:	64 c0       	rjmp	.+200    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4c2:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4c6:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <__data_end>
     4ca:	81 e0       	ldi	r24, 0x01	; 1
     4cc:	8e 0f       	add	r24, r30
     4ce:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__data_end>
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	ec 5d       	subi	r30, 0xDC	; 220
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	80 81       	ld	r24, Z
     4da:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     4de:	85 ec       	ldi	r24, 0xC5	; 197
     4e0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     4e4:	52 c0       	rjmp	.+164    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     4e6:	90 91 20 02 	lds	r25, 0x0220	; 0x800220 <__data_end>
     4ea:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <I2C_msgSize>
     4ee:	98 13       	cpse	r25, r24
     4f0:	06 c0       	rjmp	.+12     	; 0x4fe <__FUSE_REGION_LENGTH__+0xfe>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     4f2:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     4f6:	81 60       	ori	r24, 0x01	; 1
     4f8:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>
     4fc:	04 c0       	rjmp	.+8      	; 0x506 <__FUSE_REGION_LENGTH__+0x106>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     4fe:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     502:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     506:	84 e0       	ldi	r24, 0x04	; 4
     508:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     50c:	3e c0       	rjmp	.+124    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     50e:	85 ec       	ldi	r24, 0xC5	; 197
     510:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     514:	3a c0       	rjmp	.+116    	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     516:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     51a:	84 60       	ori	r24, 0x04	; 4
     51c:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     520:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     524:	82 60       	ori	r24, 0x02	; 2
     526:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     52a:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     52e:	85 ec       	ldi	r24, 0xC5	; 197
     530:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     534:	2a c0       	rjmp	.+84     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     536:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <__data_end>
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	8e 0f       	add	r24, r30
     53e:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__data_end>
     542:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	ec 5d       	subi	r30, 0xDC	; 220
     54a:	fd 4f       	sbci	r31, 0xFD	; 253
     54c:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     54e:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <I2C_statusReg>
     552:	81 60       	ori	r24, 0x01	; 1
     554:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     558:	85 ec       	ldi	r24, 0xC5	; 197
     55a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     55e:	15 c0       	rjmp	.+42     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     560:	85 e8       	ldi	r24, 0x85	; 133
     562:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     566:	11 c0       	rjmp	.+34     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     568:	84 e0       	ldi	r24, 0x04	; 4
     56a:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     56e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     572:	0b c0       	rjmp	.+22     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     574:	85 ee       	ldi	r24, 0xE5	; 229
     576:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     57a:	07 c0       	rjmp	.+14     	; 0x58a <__FUSE_REGION_LENGTH__+0x18a>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     57c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     580:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     584:	85 ed       	ldi	r24, 0xD5	; 213
     586:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     58a:	ff 91       	pop	r31
     58c:	ef 91       	pop	r30
     58e:	bf 91       	pop	r27
     590:	af 91       	pop	r26
     592:	9f 91       	pop	r25
     594:	8f 91       	pop	r24
     596:	3f 91       	pop	r19
     598:	2f 91       	pop	r18
     59a:	0f 90       	pop	r0
     59c:	0b be       	out	0x3b, r0	; 59
     59e:	0f 90       	pop	r0
     5a0:	0f be       	out	0x3f, r0	; 63
     5a2:	0f 90       	pop	r0
     5a4:	1f 90       	pop	r1
     5a6:	18 95       	reti

000005a8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5a8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5aa:	03 96       	adiw	r24, 0x03	; 3
     5ac:	92 83       	std	Z+2, r25	; 0x02
     5ae:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5b0:	2f ef       	ldi	r18, 0xFF	; 255
     5b2:	3f ef       	ldi	r19, 0xFF	; 255
     5b4:	34 83       	std	Z+4, r19	; 0x04
     5b6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b8:	96 83       	std	Z+6, r25	; 0x06
     5ba:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5bc:	90 87       	std	Z+8, r25	; 0x08
     5be:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5c0:	10 82       	st	Z, r1
     5c2:	08 95       	ret

000005c4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5c4:	fc 01       	movw	r30, r24
     5c6:	11 86       	std	Z+9, r1	; 0x09
     5c8:	10 86       	std	Z+8, r1	; 0x08
     5ca:	08 95       	ret

000005cc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5cc:	cf 93       	push	r28
     5ce:	df 93       	push	r29
     5d0:	9c 01       	movw	r18, r24
     5d2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     5d4:	dc 01       	movw	r26, r24
     5d6:	11 96       	adiw	r26, 0x01	; 1
     5d8:	cd 91       	ld	r28, X+
     5da:	dc 91       	ld	r29, X
     5dc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5de:	d3 83       	std	Z+3, r29	; 0x03
     5e0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5e2:	8c 81       	ldd	r24, Y+4	; 0x04
     5e4:	9d 81       	ldd	r25, Y+5	; 0x05
     5e6:	95 83       	std	Z+5, r25	; 0x05
     5e8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5ea:	8c 81       	ldd	r24, Y+4	; 0x04
     5ec:	9d 81       	ldd	r25, Y+5	; 0x05
     5ee:	dc 01       	movw	r26, r24
     5f0:	13 96       	adiw	r26, 0x03	; 3
     5f2:	7c 93       	st	X, r23
     5f4:	6e 93       	st	-X, r22
     5f6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     5f8:	7d 83       	std	Y+5, r23	; 0x05
     5fa:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5fc:	31 87       	std	Z+9, r19	; 0x09
     5fe:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     600:	f9 01       	movw	r30, r18
     602:	80 81       	ld	r24, Z
     604:	8f 5f       	subi	r24, 0xFF	; 255
     606:	80 83       	st	Z, r24
}
     608:	df 91       	pop	r29
     60a:	cf 91       	pop	r28
     60c:	08 95       	ret

0000060e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     614:	48 81       	ld	r20, Y
     616:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     618:	4f 3f       	cpi	r20, 0xFF	; 255
     61a:	2f ef       	ldi	r18, 0xFF	; 255
     61c:	52 07       	cpc	r21, r18
     61e:	21 f4       	brne	.+8      	; 0x628 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     620:	fc 01       	movw	r30, r24
     622:	a7 81       	ldd	r26, Z+7	; 0x07
     624:	b0 85       	ldd	r27, Z+8	; 0x08
     626:	0d c0       	rjmp	.+26     	; 0x642 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     628:	dc 01       	movw	r26, r24
     62a:	13 96       	adiw	r26, 0x03	; 3
     62c:	01 c0       	rjmp	.+2      	; 0x630 <vListInsert+0x22>
     62e:	df 01       	movw	r26, r30
     630:	12 96       	adiw	r26, 0x02	; 2
     632:	ed 91       	ld	r30, X+
     634:	fc 91       	ld	r31, X
     636:	13 97       	sbiw	r26, 0x03	; 3
     638:	20 81       	ld	r18, Z
     63a:	31 81       	ldd	r19, Z+1	; 0x01
     63c:	42 17       	cp	r20, r18
     63e:	53 07       	cpc	r21, r19
     640:	b0 f7       	brcc	.-20     	; 0x62e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     642:	12 96       	adiw	r26, 0x02	; 2
     644:	ed 91       	ld	r30, X+
     646:	fc 91       	ld	r31, X
     648:	13 97       	sbiw	r26, 0x03	; 3
     64a:	fb 83       	std	Y+3, r31	; 0x03
     64c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     64e:	d5 83       	std	Z+5, r29	; 0x05
     650:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     652:	bd 83       	std	Y+5, r27	; 0x05
     654:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     656:	13 96       	adiw	r26, 0x03	; 3
     658:	dc 93       	st	X, r29
     65a:	ce 93       	st	-X, r28
     65c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     65e:	99 87       	std	Y+9, r25	; 0x09
     660:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     662:	fc 01       	movw	r30, r24
     664:	20 81       	ld	r18, Z
     666:	2f 5f       	subi	r18, 0xFF	; 255
     668:	20 83       	st	Z, r18
}
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	08 95       	ret

00000670 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     676:	a0 85       	ldd	r26, Z+8	; 0x08
     678:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     67a:	c2 81       	ldd	r28, Z+2	; 0x02
     67c:	d3 81       	ldd	r29, Z+3	; 0x03
     67e:	84 81       	ldd	r24, Z+4	; 0x04
     680:	95 81       	ldd	r25, Z+5	; 0x05
     682:	9d 83       	std	Y+5, r25	; 0x05
     684:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     686:	c4 81       	ldd	r28, Z+4	; 0x04
     688:	d5 81       	ldd	r29, Z+5	; 0x05
     68a:	82 81       	ldd	r24, Z+2	; 0x02
     68c:	93 81       	ldd	r25, Z+3	; 0x03
     68e:	9b 83       	std	Y+3, r25	; 0x03
     690:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     692:	11 96       	adiw	r26, 0x01	; 1
     694:	8d 91       	ld	r24, X+
     696:	9c 91       	ld	r25, X
     698:	12 97       	sbiw	r26, 0x02	; 2
     69a:	e8 17       	cp	r30, r24
     69c:	f9 07       	cpc	r31, r25
     69e:	31 f4       	brne	.+12     	; 0x6ac <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6a0:	84 81       	ldd	r24, Z+4	; 0x04
     6a2:	95 81       	ldd	r25, Z+5	; 0x05
     6a4:	12 96       	adiw	r26, 0x02	; 2
     6a6:	9c 93       	st	X, r25
     6a8:	8e 93       	st	-X, r24
     6aa:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6ac:	11 86       	std	Z+9, r1	; 0x09
     6ae:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6b0:	8c 91       	ld	r24, X
     6b2:	81 50       	subi	r24, 0x01	; 1
     6b4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6b6:	df 91       	pop	r29
     6b8:	cf 91       	pop	r28
     6ba:	08 95       	ret

000006bc <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     6bc:	31 e1       	ldi	r19, 0x11	; 17
     6be:	fc 01       	movw	r30, r24
     6c0:	30 83       	st	Z, r19
     6c2:	31 97       	sbiw	r30, 0x01	; 1
     6c4:	22 e2       	ldi	r18, 0x22	; 34
     6c6:	20 83       	st	Z, r18
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	a3 e3       	ldi	r26, 0x33	; 51
     6cc:	a0 83       	st	Z, r26
     6ce:	31 97       	sbiw	r30, 0x01	; 1
     6d0:	60 83       	st	Z, r22
     6d2:	31 97       	sbiw	r30, 0x01	; 1
     6d4:	70 83       	st	Z, r23
     6d6:	31 97       	sbiw	r30, 0x01	; 1
     6d8:	10 82       	st	Z, r1
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	10 82       	st	Z, r1
     6de:	31 97       	sbiw	r30, 0x01	; 1
     6e0:	60 e8       	ldi	r22, 0x80	; 128
     6e2:	60 83       	st	Z, r22
     6e4:	31 97       	sbiw	r30, 0x01	; 1
     6e6:	10 82       	st	Z, r1
     6e8:	31 97       	sbiw	r30, 0x01	; 1
     6ea:	10 82       	st	Z, r1
     6ec:	31 97       	sbiw	r30, 0x01	; 1
     6ee:	10 82       	st	Z, r1
     6f0:	31 97       	sbiw	r30, 0x01	; 1
     6f2:	62 e0       	ldi	r22, 0x02	; 2
     6f4:	60 83       	st	Z, r22
     6f6:	31 97       	sbiw	r30, 0x01	; 1
     6f8:	63 e0       	ldi	r22, 0x03	; 3
     6fa:	60 83       	st	Z, r22
     6fc:	31 97       	sbiw	r30, 0x01	; 1
     6fe:	64 e0       	ldi	r22, 0x04	; 4
     700:	60 83       	st	Z, r22
     702:	31 97       	sbiw	r30, 0x01	; 1
     704:	65 e0       	ldi	r22, 0x05	; 5
     706:	60 83       	st	Z, r22
     708:	31 97       	sbiw	r30, 0x01	; 1
     70a:	66 e0       	ldi	r22, 0x06	; 6
     70c:	60 83       	st	Z, r22
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	67 e0       	ldi	r22, 0x07	; 7
     712:	60 83       	st	Z, r22
     714:	31 97       	sbiw	r30, 0x01	; 1
     716:	68 e0       	ldi	r22, 0x08	; 8
     718:	60 83       	st	Z, r22
     71a:	31 97       	sbiw	r30, 0x01	; 1
     71c:	69 e0       	ldi	r22, 0x09	; 9
     71e:	60 83       	st	Z, r22
     720:	31 97       	sbiw	r30, 0x01	; 1
     722:	60 e1       	ldi	r22, 0x10	; 16
     724:	60 83       	st	Z, r22
     726:	31 97       	sbiw	r30, 0x01	; 1
     728:	30 83       	st	Z, r19
     72a:	31 97       	sbiw	r30, 0x01	; 1
     72c:	32 e1       	ldi	r19, 0x12	; 18
     72e:	30 83       	st	Z, r19
     730:	31 97       	sbiw	r30, 0x01	; 1
     732:	33 e1       	ldi	r19, 0x13	; 19
     734:	30 83       	st	Z, r19
     736:	31 97       	sbiw	r30, 0x01	; 1
     738:	34 e1       	ldi	r19, 0x14	; 20
     73a:	30 83       	st	Z, r19
     73c:	31 97       	sbiw	r30, 0x01	; 1
     73e:	35 e1       	ldi	r19, 0x15	; 21
     740:	30 83       	st	Z, r19
     742:	31 97       	sbiw	r30, 0x01	; 1
     744:	36 e1       	ldi	r19, 0x16	; 22
     746:	30 83       	st	Z, r19
     748:	31 97       	sbiw	r30, 0x01	; 1
     74a:	37 e1       	ldi	r19, 0x17	; 23
     74c:	30 83       	st	Z, r19
     74e:	31 97       	sbiw	r30, 0x01	; 1
     750:	38 e1       	ldi	r19, 0x18	; 24
     752:	30 83       	st	Z, r19
     754:	31 97       	sbiw	r30, 0x01	; 1
     756:	39 e1       	ldi	r19, 0x19	; 25
     758:	30 83       	st	Z, r19
     75a:	31 97       	sbiw	r30, 0x01	; 1
     75c:	30 e2       	ldi	r19, 0x20	; 32
     75e:	30 83       	st	Z, r19
     760:	31 97       	sbiw	r30, 0x01	; 1
     762:	31 e2       	ldi	r19, 0x21	; 33
     764:	30 83       	st	Z, r19
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	20 83       	st	Z, r18
     76a:	31 97       	sbiw	r30, 0x01	; 1
     76c:	23 e2       	ldi	r18, 0x23	; 35
     76e:	20 83       	st	Z, r18
     770:	31 97       	sbiw	r30, 0x01	; 1
     772:	40 83       	st	Z, r20
     774:	31 97       	sbiw	r30, 0x01	; 1
     776:	50 83       	st	Z, r21
     778:	31 97       	sbiw	r30, 0x01	; 1
     77a:	26 e2       	ldi	r18, 0x26	; 38
     77c:	20 83       	st	Z, r18
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	27 e2       	ldi	r18, 0x27	; 39
     782:	20 83       	st	Z, r18
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	28 e2       	ldi	r18, 0x28	; 40
     788:	20 83       	st	Z, r18
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	29 e2       	ldi	r18, 0x29	; 41
     78e:	20 83       	st	Z, r18
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	20 e3       	ldi	r18, 0x30	; 48
     794:	20 83       	st	Z, r18
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	21 e3       	ldi	r18, 0x31	; 49
     79a:	20 83       	st	Z, r18
     79c:	89 97       	sbiw	r24, 0x29	; 41
     79e:	08 95       	ret

000007a0 <xPortStartScheduler>:
     7a0:	88 ec       	ldi	r24, 0xC8	; 200
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	90 93 af 02 	sts	0x02AF, r25	; 0x8002af <portTickRateHz+0x1>
     7a8:	80 93 ae 02 	sts	0x02AE, r24	; 0x8002ae <portTickRateHz>
     7ac:	90 93 b1 02 	sts	0x02B1, r25	; 0x8002b1 <ticksRemainingInSec+0x1>
     7b0:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <ticksRemainingInSec>
     7b4:	8d e4       	ldi	r24, 0x4D	; 77
     7b6:	87 bd       	out	0x27, r24	; 39
     7b8:	82 e0       	ldi	r24, 0x02	; 2
     7ba:	84 bd       	out	0x24, r24	; 36
     7bc:	85 e0       	ldi	r24, 0x05	; 5
     7be:	85 bd       	out	0x25, r24	; 37
     7c0:	ee e6       	ldi	r30, 0x6E	; 110
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	80 81       	ld	r24, Z
     7c6:	82 60       	ori	r24, 0x02	; 2
     7c8:	80 83       	st	Z, r24
     7ca:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     7ce:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     7d2:	cd 91       	ld	r28, X+
     7d4:	cd bf       	out	0x3d, r28	; 61
     7d6:	dd 91       	ld	r29, X+
     7d8:	de bf       	out	0x3e, r29	; 62
     7da:	ff 91       	pop	r31
     7dc:	ef 91       	pop	r30
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	bf 91       	pop	r27
     7e4:	af 91       	pop	r26
     7e6:	9f 91       	pop	r25
     7e8:	8f 91       	pop	r24
     7ea:	7f 91       	pop	r23
     7ec:	6f 91       	pop	r22
     7ee:	5f 91       	pop	r21
     7f0:	4f 91       	pop	r20
     7f2:	3f 91       	pop	r19
     7f4:	2f 91       	pop	r18
     7f6:	1f 91       	pop	r17
     7f8:	0f 91       	pop	r16
     7fa:	ff 90       	pop	r15
     7fc:	ef 90       	pop	r14
     7fe:	df 90       	pop	r13
     800:	cf 90       	pop	r12
     802:	bf 90       	pop	r11
     804:	af 90       	pop	r10
     806:	9f 90       	pop	r9
     808:	8f 90       	pop	r8
     80a:	7f 90       	pop	r7
     80c:	6f 90       	pop	r6
     80e:	5f 90       	pop	r5
     810:	4f 90       	pop	r4
     812:	3f 90       	pop	r3
     814:	2f 90       	pop	r2
     816:	1f 90       	pop	r1
     818:	0f 90       	pop	r0
     81a:	0c be       	out	0x3c, r0	; 60
     81c:	0f 90       	pop	r0
     81e:	0b be       	out	0x3b, r0	; 59
     820:	0f 90       	pop	r0
     822:	0f be       	out	0x3f, r0	; 63
     824:	0f 90       	pop	r0
     826:	08 95       	ret
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	08 95       	ret

0000082c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     82c:	0f 92       	push	r0
     82e:	0f b6       	in	r0, 0x3f	; 63
     830:	f8 94       	cli
     832:	0f 92       	push	r0
     834:	0b b6       	in	r0, 0x3b	; 59
     836:	0f 92       	push	r0
     838:	0c b6       	in	r0, 0x3c	; 60
     83a:	0f 92       	push	r0
     83c:	1f 92       	push	r1
     83e:	11 24       	eor	r1, r1
     840:	2f 92       	push	r2
     842:	3f 92       	push	r3
     844:	4f 92       	push	r4
     846:	5f 92       	push	r5
     848:	6f 92       	push	r6
     84a:	7f 92       	push	r7
     84c:	8f 92       	push	r8
     84e:	9f 92       	push	r9
     850:	af 92       	push	r10
     852:	bf 92       	push	r11
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	2f 93       	push	r18
     862:	3f 93       	push	r19
     864:	4f 93       	push	r20
     866:	5f 93       	push	r21
     868:	6f 93       	push	r22
     86a:	7f 93       	push	r23
     86c:	8f 93       	push	r24
     86e:	9f 93       	push	r25
     870:	af 93       	push	r26
     872:	bf 93       	push	r27
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
     878:	ef 93       	push	r30
     87a:	ff 93       	push	r31
     87c:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     880:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     884:	0d b6       	in	r0, 0x3d	; 61
     886:	0d 92       	st	X+, r0
     888:	0e b6       	in	r0, 0x3e	; 62
     88a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     88c:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     890:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     894:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     898:	cd 91       	ld	r28, X+
     89a:	cd bf       	out	0x3d, r28	; 61
     89c:	dd 91       	ld	r29, X+
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	ff 91       	pop	r31
     8a2:	ef 91       	pop	r30
     8a4:	df 91       	pop	r29
     8a6:	cf 91       	pop	r28
     8a8:	bf 91       	pop	r27
     8aa:	af 91       	pop	r26
     8ac:	9f 91       	pop	r25
     8ae:	8f 91       	pop	r24
     8b0:	7f 91       	pop	r23
     8b2:	6f 91       	pop	r22
     8b4:	5f 91       	pop	r21
     8b6:	4f 91       	pop	r20
     8b8:	3f 91       	pop	r19
     8ba:	2f 91       	pop	r18
     8bc:	1f 91       	pop	r17
     8be:	0f 91       	pop	r16
     8c0:	ff 90       	pop	r15
     8c2:	ef 90       	pop	r14
     8c4:	df 90       	pop	r13
     8c6:	cf 90       	pop	r12
     8c8:	bf 90       	pop	r11
     8ca:	af 90       	pop	r10
     8cc:	9f 90       	pop	r9
     8ce:	8f 90       	pop	r8
     8d0:	7f 90       	pop	r7
     8d2:	6f 90       	pop	r6
     8d4:	5f 90       	pop	r5
     8d6:	4f 90       	pop	r4
     8d8:	3f 90       	pop	r3
     8da:	2f 90       	pop	r2
     8dc:	1f 90       	pop	r1
     8de:	0f 90       	pop	r0
     8e0:	0c be       	out	0x3c, r0	; 60
     8e2:	0f 90       	pop	r0
     8e4:	0b be       	out	0x3b, r0	; 59
     8e6:	0f 90       	pop	r0
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     8ec:	08 95       	ret

000008ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     8ee:	0f 92       	push	r0
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	0f 92       	push	r0
     8f6:	0b b6       	in	r0, 0x3b	; 59
     8f8:	0f 92       	push	r0
     8fa:	0c b6       	in	r0, 0x3c	; 60
     8fc:	0f 92       	push	r0
     8fe:	1f 92       	push	r1
     900:	11 24       	eor	r1, r1
     902:	2f 92       	push	r2
     904:	3f 92       	push	r3
     906:	4f 92       	push	r4
     908:	5f 92       	push	r5
     90a:	6f 92       	push	r6
     90c:	7f 92       	push	r7
     90e:	8f 92       	push	r8
     910:	9f 92       	push	r9
     912:	af 92       	push	r10
     914:	bf 92       	push	r11
     916:	cf 92       	push	r12
     918:	df 92       	push	r13
     91a:	ef 92       	push	r14
     91c:	ff 92       	push	r15
     91e:	0f 93       	push	r16
     920:	1f 93       	push	r17
     922:	2f 93       	push	r18
     924:	3f 93       	push	r19
     926:	4f 93       	push	r20
     928:	5f 93       	push	r21
     92a:	6f 93       	push	r22
     92c:	7f 93       	push	r23
     92e:	8f 93       	push	r24
     930:	9f 93       	push	r25
     932:	af 93       	push	r26
     934:	bf 93       	push	r27
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	ef 93       	push	r30
     93c:	ff 93       	push	r31
     93e:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     942:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     946:	0d b6       	in	r0, 0x3d	; 61
     948:	0d 92       	st	X+, r0
     94a:	0e b6       	in	r0, 0x3e	; 62
     94c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     94e:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
     950:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <ticksRemainingInSec>
     954:	90 91 b1 02 	lds	r25, 0x02B1	; 0x8002b1 <ticksRemainingInSec+0x1>
     958:	01 97       	sbiw	r24, 0x01	; 1
     95a:	90 93 b1 02 	sts	0x02B1, r25	; 0x8002b1 <ticksRemainingInSec+0x1>
     95e:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <ticksRemainingInSec>
     962:	89 2b       	or	r24, r25
     964:	49 f4       	brne	.+18     	; 0x978 <vPortYieldFromTick+0x8a>
	{
		system_tick();
     966:	dc dc       	rcall	.-1608   	; 0x320 <system_tick>
		ticksRemainingInSec = portTickRateHz;
     968:	80 91 ae 02 	lds	r24, 0x02AE	; 0x8002ae <portTickRateHz>
     96c:	90 91 af 02 	lds	r25, 0x02AF	; 0x8002af <portTickRateHz+0x1>
     970:	90 93 b1 02 	sts	0x02B1, r25	; 0x8002b1 <ticksRemainingInSec+0x1>
     974:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
     978:	51 d7       	rcall	.+3746   	; 0x181c <xTaskIncrementTick>
     97a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     97c:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
     980:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
     984:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
     988:	cd 91       	ld	r28, X+
     98a:	cd bf       	out	0x3d, r28	; 61
     98c:	dd 91       	ld	r29, X+
     98e:	de bf       	out	0x3e, r29	; 62
     990:	ff 91       	pop	r31
     992:	ef 91       	pop	r30
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	bf 91       	pop	r27
     99a:	af 91       	pop	r26
     99c:	9f 91       	pop	r25
     99e:	8f 91       	pop	r24
     9a0:	7f 91       	pop	r23
     9a2:	6f 91       	pop	r22
     9a4:	5f 91       	pop	r21
     9a6:	4f 91       	pop	r20
     9a8:	3f 91       	pop	r19
     9aa:	2f 91       	pop	r18
     9ac:	1f 91       	pop	r17
     9ae:	0f 91       	pop	r16
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	bf 90       	pop	r11
     9ba:	af 90       	pop	r10
     9bc:	9f 90       	pop	r9
     9be:	8f 90       	pop	r8
     9c0:	7f 90       	pop	r7
     9c2:	6f 90       	pop	r6
     9c4:	5f 90       	pop	r5
     9c6:	4f 90       	pop	r4
     9c8:	3f 90       	pop	r3
     9ca:	2f 90       	pop	r2
     9cc:	1f 90       	pop	r1
     9ce:	0f 90       	pop	r0
     9d0:	0c be       	out	0x3c, r0	; 60
     9d2:	0f 90       	pop	r0
     9d4:	0b be       	out	0x3b, r0	; 59
     9d6:	0f 90       	pop	r0
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     9dc:	08 95       	ret

000009de <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     9de:	87 df       	rcall	.-242    	; 0x8ee <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     9e0:	18 95       	reti

000009e2 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	f8 94       	cli
     9e6:	0f 92       	push	r0
     9e8:	fc 01       	movw	r30, r24
     9ea:	92 8d       	ldd	r25, Z+26	; 0x1a
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	91 11       	cpse	r25, r1
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	08 95       	ret

000009f8 <prvCopyDataToQueue>:
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	ec 01       	movw	r28, r24
     a02:	04 2f       	mov	r16, r20
     a04:	1a 8d       	ldd	r17, Y+26	; 0x1a
     a06:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a08:	41 11       	cpse	r20, r1
     a0a:	0c c0       	rjmp	.+24     	; 0xa24 <prvCopyDataToQueue+0x2c>
     a0c:	88 81       	ld	r24, Y
     a0e:	99 81       	ldd	r25, Y+1	; 0x01
     a10:	89 2b       	or	r24, r25
     a12:	09 f0       	breq	.+2      	; 0xa16 <prvCopyDataToQueue+0x1e>
     a14:	42 c0       	rjmp	.+132    	; 0xa9a <prvCopyDataToQueue+0xa2>
     a16:	8a 81       	ldd	r24, Y+2	; 0x02
     a18:	9b 81       	ldd	r25, Y+3	; 0x03
     a1a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <xTaskPriorityDisinherit>
     a1e:	1b 82       	std	Y+3, r1	; 0x03
     a20:	1a 82       	std	Y+2, r1	; 0x02
     a22:	42 c0       	rjmp	.+132    	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a24:	01 11       	cpse	r16, r1
     a26:	17 c0       	rjmp	.+46     	; 0xa56 <prvCopyDataToQueue+0x5e>
     a28:	50 e0       	ldi	r21, 0x00	; 0
     a2a:	8c 81       	ldd	r24, Y+4	; 0x04
     a2c:	9d 81       	ldd	r25, Y+5	; 0x05
     a2e:	0e 94 a6 11 	call	0x234c	; 0x234c <memcpy>
     a32:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a34:	8c 81       	ldd	r24, Y+4	; 0x04
     a36:	9d 81       	ldd	r25, Y+5	; 0x05
     a38:	82 0f       	add	r24, r18
     a3a:	91 1d       	adc	r25, r1
     a3c:	9d 83       	std	Y+5, r25	; 0x05
     a3e:	8c 83       	std	Y+4, r24	; 0x04
     a40:	2a 81       	ldd	r18, Y+2	; 0x02
     a42:	3b 81       	ldd	r19, Y+3	; 0x03
     a44:	82 17       	cp	r24, r18
     a46:	93 07       	cpc	r25, r19
     a48:	50 f1       	brcs	.+84     	; 0xa9e <prvCopyDataToQueue+0xa6>
     a4a:	88 81       	ld	r24, Y
     a4c:	99 81       	ldd	r25, Y+1	; 0x01
     a4e:	9d 83       	std	Y+5, r25	; 0x05
     a50:	8c 83       	std	Y+4, r24	; 0x04
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	29 c0       	rjmp	.+82     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	8e 81       	ldd	r24, Y+6	; 0x06
     a5a:	9f 81       	ldd	r25, Y+7	; 0x07
     a5c:	0e 94 a6 11 	call	0x234c	; 0x234c <memcpy>
     a60:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	91 95       	neg	r25
     a66:	81 95       	neg	r24
     a68:	91 09       	sbc	r25, r1
     a6a:	2e 81       	ldd	r18, Y+6	; 0x06
     a6c:	3f 81       	ldd	r19, Y+7	; 0x07
     a6e:	28 0f       	add	r18, r24
     a70:	39 1f       	adc	r19, r25
     a72:	3f 83       	std	Y+7, r19	; 0x07
     a74:	2e 83       	std	Y+6, r18	; 0x06
     a76:	48 81       	ld	r20, Y
     a78:	59 81       	ldd	r21, Y+1	; 0x01
     a7a:	24 17       	cp	r18, r20
     a7c:	35 07       	cpc	r19, r21
     a7e:	30 f4       	brcc	.+12     	; 0xa8c <prvCopyDataToQueue+0x94>
     a80:	2a 81       	ldd	r18, Y+2	; 0x02
     a82:	3b 81       	ldd	r19, Y+3	; 0x03
     a84:	82 0f       	add	r24, r18
     a86:	93 1f       	adc	r25, r19
     a88:	9f 83       	std	Y+7, r25	; 0x07
     a8a:	8e 83       	std	Y+6, r24	; 0x06
     a8c:	02 30       	cpi	r16, 0x02	; 2
     a8e:	49 f4       	brne	.+18     	; 0xaa2 <prvCopyDataToQueue+0xaa>
     a90:	11 23       	and	r17, r17
     a92:	49 f0       	breq	.+18     	; 0xaa6 <prvCopyDataToQueue+0xae>
     a94:	11 50       	subi	r17, 0x01	; 1
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	07 c0       	rjmp	.+14     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	05 c0       	rjmp	.+10     	; 0xaa8 <prvCopyDataToQueue+0xb0>
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	03 c0       	rjmp	.+6      	; 0xaa8 <prvCopyDataToQueue+0xb0>
     aa2:	80 e0       	ldi	r24, 0x00	; 0
     aa4:	01 c0       	rjmp	.+2      	; 0xaa8 <prvCopyDataToQueue+0xb0>
     aa6:	80 e0       	ldi	r24, 0x00	; 0
     aa8:	1f 5f       	subi	r17, 0xFF	; 255
     aaa:	1a 8f       	std	Y+26, r17	; 0x1a
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	1f 91       	pop	r17
     ab2:	0f 91       	pop	r16
     ab4:	08 95       	ret

00000ab6 <prvCopyDataFromQueue>:
     ab6:	fc 01       	movw	r30, r24
     ab8:	44 8d       	ldd	r20, Z+28	; 0x1c
     aba:	44 23       	and	r20, r20
     abc:	a9 f0       	breq	.+42     	; 0xae8 <prvCopyDataFromQueue+0x32>
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	26 81       	ldd	r18, Z+6	; 0x06
     ac2:	37 81       	ldd	r19, Z+7	; 0x07
     ac4:	24 0f       	add	r18, r20
     ac6:	35 1f       	adc	r19, r21
     ac8:	37 83       	std	Z+7, r19	; 0x07
     aca:	26 83       	std	Z+6, r18	; 0x06
     acc:	82 81       	ldd	r24, Z+2	; 0x02
     ace:	93 81       	ldd	r25, Z+3	; 0x03
     ad0:	28 17       	cp	r18, r24
     ad2:	39 07       	cpc	r19, r25
     ad4:	20 f0       	brcs	.+8      	; 0xade <prvCopyDataFromQueue+0x28>
     ad6:	80 81       	ld	r24, Z
     ad8:	91 81       	ldd	r25, Z+1	; 0x01
     ada:	97 83       	std	Z+7, r25	; 0x07
     adc:	86 83       	std	Z+6, r24	; 0x06
     ade:	cb 01       	movw	r24, r22
     ae0:	66 81       	ldd	r22, Z+6	; 0x06
     ae2:	77 81       	ldd	r23, Z+7	; 0x07
     ae4:	0c 94 a6 11 	jmp	0x234c	; 0x234c <memcpy>
     ae8:	08 95       	ret

00000aea <prvUnlockQueue>:
     aea:	ef 92       	push	r14
     aec:	ff 92       	push	r15
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	8c 01       	movw	r16, r24
     af6:	0f b6       	in	r0, 0x3f	; 63
     af8:	f8 94       	cli
     afa:	0f 92       	push	r0
     afc:	fc 01       	movw	r30, r24
     afe:	c6 8d       	ldd	r28, Z+30	; 0x1e
     b00:	1c 16       	cp	r1, r28
     b02:	ac f4       	brge	.+42     	; 0xb2e <prvUnlockQueue+0x44>
     b04:	81 89       	ldd	r24, Z+17	; 0x11
     b06:	81 11       	cpse	r24, r1
     b08:	06 c0       	rjmp	.+12     	; 0xb16 <prvUnlockQueue+0x2c>
     b0a:	11 c0       	rjmp	.+34     	; 0xb2e <prvUnlockQueue+0x44>
     b0c:	f8 01       	movw	r30, r16
     b0e:	81 89       	ldd	r24, Z+17	; 0x11
     b10:	81 11       	cpse	r24, r1
     b12:	05 c0       	rjmp	.+10     	; 0xb1e <prvUnlockQueue+0x34>
     b14:	0c c0       	rjmp	.+24     	; 0xb2e <prvUnlockQueue+0x44>
     b16:	78 01       	movw	r14, r16
     b18:	f1 e1       	ldi	r31, 0x11	; 17
     b1a:	ef 0e       	add	r14, r31
     b1c:	f1 1c       	adc	r15, r1
     b1e:	c7 01       	movw	r24, r14
     b20:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xTaskRemoveFromEventList>
     b24:	81 11       	cpse	r24, r1
     b26:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskMissedYield>
     b2a:	c1 50       	subi	r28, 0x01	; 1
     b2c:	79 f7       	brne	.-34     	; 0xb0c <prvUnlockQueue+0x22>
     b2e:	8f ef       	ldi	r24, 0xFF	; 255
     b30:	f8 01       	movw	r30, r16
     b32:	86 8f       	std	Z+30, r24	; 0x1e
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
     b3e:	c5 8d       	ldd	r28, Z+29	; 0x1d
     b40:	1c 16       	cp	r1, r28
     b42:	ac f4       	brge	.+42     	; 0xb6e <prvUnlockQueue+0x84>
     b44:	80 85       	ldd	r24, Z+8	; 0x08
     b46:	81 11       	cpse	r24, r1
     b48:	06 c0       	rjmp	.+12     	; 0xb56 <prvUnlockQueue+0x6c>
     b4a:	11 c0       	rjmp	.+34     	; 0xb6e <prvUnlockQueue+0x84>
     b4c:	f8 01       	movw	r30, r16
     b4e:	80 85       	ldd	r24, Z+8	; 0x08
     b50:	81 11       	cpse	r24, r1
     b52:	05 c0       	rjmp	.+10     	; 0xb5e <prvUnlockQueue+0x74>
     b54:	0c c0       	rjmp	.+24     	; 0xb6e <prvUnlockQueue+0x84>
     b56:	78 01       	movw	r14, r16
     b58:	f8 e0       	ldi	r31, 0x08	; 8
     b5a:	ef 0e       	add	r14, r31
     b5c:	f1 1c       	adc	r15, r1
     b5e:	c7 01       	movw	r24, r14
     b60:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xTaskRemoveFromEventList>
     b64:	81 11       	cpse	r24, r1
     b66:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <vTaskMissedYield>
     b6a:	c1 50       	subi	r28, 0x01	; 1
     b6c:	79 f7       	brne	.-34     	; 0xb4c <prvUnlockQueue+0x62>
     b6e:	8f ef       	ldi	r24, 0xFF	; 255
     b70:	f8 01       	movw	r30, r16
     b72:	85 8f       	std	Z+29, r24	; 0x1d
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
     b78:	cf 91       	pop	r28
     b7a:	1f 91       	pop	r17
     b7c:	0f 91       	pop	r16
     b7e:	ff 90       	pop	r15
     b80:	ef 90       	pop	r14
     b82:	08 95       	ret

00000b84 <xQueueGenericReset>:
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
     b88:	ec 01       	movw	r28, r24
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
     b90:	48 81       	ld	r20, Y
     b92:	59 81       	ldd	r21, Y+1	; 0x01
     b94:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b96:	30 e0       	ldi	r19, 0x00	; 0
     b98:	7b 8d       	ldd	r23, Y+27	; 0x1b
     b9a:	72 9f       	mul	r23, r18
     b9c:	c0 01       	movw	r24, r0
     b9e:	73 9f       	mul	r23, r19
     ba0:	90 0d       	add	r25, r0
     ba2:	11 24       	eor	r1, r1
     ba4:	fa 01       	movw	r30, r20
     ba6:	e8 0f       	add	r30, r24
     ba8:	f9 1f       	adc	r31, r25
     baa:	fb 83       	std	Y+3, r31	; 0x03
     bac:	ea 83       	std	Y+2, r30	; 0x02
     bae:	1a 8e       	std	Y+26, r1	; 0x1a
     bb0:	5d 83       	std	Y+5, r21	; 0x05
     bb2:	4c 83       	std	Y+4, r20	; 0x04
     bb4:	82 1b       	sub	r24, r18
     bb6:	93 0b       	sbc	r25, r19
     bb8:	84 0f       	add	r24, r20
     bba:	95 1f       	adc	r25, r21
     bbc:	9f 83       	std	Y+7, r25	; 0x07
     bbe:	8e 83       	std	Y+6, r24	; 0x06
     bc0:	8f ef       	ldi	r24, 0xFF	; 255
     bc2:	8d 8f       	std	Y+29, r24	; 0x1d
     bc4:	8e 8f       	std	Y+30, r24	; 0x1e
     bc6:	61 11       	cpse	r22, r1
     bc8:	0b c0       	rjmp	.+22     	; 0xbe0 <xQueueGenericReset+0x5c>
     bca:	88 85       	ldd	r24, Y+8	; 0x08
     bcc:	88 23       	and	r24, r24
     bce:	71 f0       	breq	.+28     	; 0xbec <xQueueGenericReset+0x68>
     bd0:	ce 01       	movw	r24, r28
     bd2:	08 96       	adiw	r24, 0x08	; 8
     bd4:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <xTaskRemoveFromEventList>
     bd8:	88 23       	and	r24, r24
     bda:	41 f0       	breq	.+16     	; 0xbec <xQueueGenericReset+0x68>
     bdc:	27 de       	rcall	.-946    	; 0x82c <vPortYield>
     bde:	06 c0       	rjmp	.+12     	; 0xbec <xQueueGenericReset+0x68>
     be0:	ce 01       	movw	r24, r28
     be2:	08 96       	adiw	r24, 0x08	; 8
     be4:	e1 dc       	rcall	.-1598   	; 0x5a8 <vListInitialise>
     be6:	ce 01       	movw	r24, r28
     be8:	41 96       	adiw	r24, 0x11	; 17
     bea:	de dc       	rcall	.-1604   	; 0x5a8 <vListInitialise>
     bec:	0f 90       	pop	r0
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <xQueueGenericCreate>:
     bf8:	0f 93       	push	r16
     bfa:	1f 93       	push	r17
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	08 2f       	mov	r16, r24
     c02:	16 2f       	mov	r17, r22
     c04:	66 23       	and	r22, r22
     c06:	b1 f0       	breq	.+44     	; 0xc34 <xQueueGenericCreate+0x3c>
     c08:	86 9f       	mul	r24, r22
     c0a:	c0 01       	movw	r24, r0
     c0c:	11 24       	eor	r1, r1
     c0e:	4f 96       	adiw	r24, 0x1f	; 31
     c10:	a3 db       	rcall	.-2234   	; 0x358 <pvPortMalloc>
     c12:	ec 01       	movw	r28, r24
     c14:	00 97       	sbiw	r24, 0x00	; 0
     c16:	39 f4       	brne	.+14     	; 0xc26 <xQueueGenericCreate+0x2e>
     c18:	13 c0       	rjmp	.+38     	; 0xc40 <xQueueGenericCreate+0x48>
     c1a:	0b 8f       	std	Y+27, r16	; 0x1b
     c1c:	1c 8f       	std	Y+28, r17	; 0x1c
     c1e:	61 e0       	ldi	r22, 0x01	; 1
     c20:	ce 01       	movw	r24, r28
     c22:	b0 df       	rcall	.-160    	; 0xb84 <xQueueGenericReset>
     c24:	0d c0       	rjmp	.+26     	; 0xc40 <xQueueGenericCreate+0x48>
     c26:	4f 96       	adiw	r24, 0x1f	; 31
     c28:	99 83       	std	Y+1, r25	; 0x01
     c2a:	88 83       	st	Y, r24
     c2c:	f6 cf       	rjmp	.-20     	; 0xc1a <xQueueGenericCreate+0x22>
     c2e:	d9 83       	std	Y+1, r29	; 0x01
     c30:	c8 83       	st	Y, r28
     c32:	f3 cf       	rjmp	.-26     	; 0xc1a <xQueueGenericCreate+0x22>
     c34:	8f e1       	ldi	r24, 0x1F	; 31
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	8f db       	rcall	.-2274   	; 0x358 <pvPortMalloc>
     c3a:	ec 01       	movw	r28, r24
     c3c:	89 2b       	or	r24, r25
     c3e:	b9 f7       	brne	.-18     	; 0xc2e <xQueueGenericCreate+0x36>
     c40:	ce 01       	movw	r24, r28
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	08 95       	ret

00000c4c <xQueueGenericSend>:
     c4c:	9f 92       	push	r9
     c4e:	af 92       	push	r10
     c50:	bf 92       	push	r11
     c52:	cf 92       	push	r12
     c54:	df 92       	push	r13
     c56:	ef 92       	push	r14
     c58:	ff 92       	push	r15
     c5a:	0f 93       	push	r16
     c5c:	1f 93       	push	r17
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
     c62:	00 d0       	rcall	.+0      	; 0xc64 <xQueueGenericSend+0x18>
     c64:	1f 92       	push	r1
     c66:	1f 92       	push	r1
     c68:	cd b7       	in	r28, 0x3d	; 61
     c6a:	de b7       	in	r29, 0x3e	; 62
     c6c:	8c 01       	movw	r16, r24
     c6e:	6b 01       	movw	r12, r22
     c70:	5d 83       	std	Y+5, r21	; 0x05
     c72:	4c 83       	std	Y+4, r20	; 0x04
     c74:	a2 2e       	mov	r10, r18
     c76:	b1 2c       	mov	r11, r1
     c78:	99 24       	eor	r9, r9
     c7a:	93 94       	inc	r9
     c7c:	7c 01       	movw	r14, r24
     c7e:	88 e0       	ldi	r24, 0x08	; 8
     c80:	e8 0e       	add	r14, r24
     c82:	f1 1c       	adc	r15, r1
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	0f 92       	push	r0
     c8a:	f8 01       	movw	r30, r16
     c8c:	92 8d       	ldd	r25, Z+26	; 0x1a
     c8e:	83 8d       	ldd	r24, Z+27	; 0x1b
     c90:	98 17       	cp	r25, r24
     c92:	18 f0       	brcs	.+6      	; 0xc9a <xQueueGenericSend+0x4e>
     c94:	f2 e0       	ldi	r31, 0x02	; 2
     c96:	af 12       	cpse	r10, r31
     c98:	15 c0       	rjmp	.+42     	; 0xcc4 <xQueueGenericSend+0x78>
     c9a:	4a 2d       	mov	r20, r10
     c9c:	b6 01       	movw	r22, r12
     c9e:	c8 01       	movw	r24, r16
     ca0:	ab de       	rcall	.-682    	; 0x9f8 <prvCopyDataToQueue>
     ca2:	f8 01       	movw	r30, r16
     ca4:	91 89       	ldd	r25, Z+17	; 0x11
     ca6:	99 23       	and	r25, r25
     ca8:	39 f0       	breq	.+14     	; 0xcb8 <xQueueGenericSend+0x6c>
     caa:	c8 01       	movw	r24, r16
     cac:	41 96       	adiw	r24, 0x11	; 17
     cae:	cb d7       	rcall	.+3990   	; 0x1c46 <xTaskRemoveFromEventList>
     cb0:	88 23       	and	r24, r24
     cb2:	21 f0       	breq	.+8      	; 0xcbc <xQueueGenericSend+0x70>
     cb4:	bb dd       	rcall	.-1162   	; 0x82c <vPortYield>
     cb6:	02 c0       	rjmp	.+4      	; 0xcbc <xQueueGenericSend+0x70>
     cb8:	81 11       	cpse	r24, r1
     cba:	b8 dd       	rcall	.-1168   	; 0x82c <vPortYield>
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63
     cc0:	81 e0       	ldi	r24, 0x01	; 1
     cc2:	45 c0       	rjmp	.+138    	; 0xd4e <xQueueGenericSend+0x102>
     cc4:	8c 81       	ldd	r24, Y+4	; 0x04
     cc6:	9d 81       	ldd	r25, Y+5	; 0x05
     cc8:	89 2b       	or	r24, r25
     cca:	21 f4       	brne	.+8      	; 0xcd4 <xQueueGenericSend+0x88>
     ccc:	0f 90       	pop	r0
     cce:	0f be       	out	0x3f, r0	; 63
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	3d c0       	rjmp	.+122    	; 0xd4e <xQueueGenericSend+0x102>
     cd4:	b1 10       	cpse	r11, r1
     cd6:	04 c0       	rjmp	.+8      	; 0xce0 <xQueueGenericSend+0x94>
     cd8:	ce 01       	movw	r24, r28
     cda:	01 96       	adiw	r24, 0x01	; 1
     cdc:	fc d7       	rcall	.+4088   	; 0x1cd6 <vTaskSetTimeOutState>
     cde:	b9 2c       	mov	r11, r9
     ce0:	0f 90       	pop	r0
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	95 d5       	rcall	.+2858   	; 0x1810 <vTaskSuspendAll>
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	f8 94       	cli
     cea:	0f 92       	push	r0
     cec:	f8 01       	movw	r30, r16
     cee:	85 8d       	ldd	r24, Z+29	; 0x1d
     cf0:	8f 3f       	cpi	r24, 0xFF	; 255
     cf2:	09 f4       	brne	.+2      	; 0xcf6 <xQueueGenericSend+0xaa>
     cf4:	15 8e       	std	Z+29, r1	; 0x1d
     cf6:	f8 01       	movw	r30, r16
     cf8:	86 8d       	ldd	r24, Z+30	; 0x1e
     cfa:	8f 3f       	cpi	r24, 0xFF	; 255
     cfc:	09 f4       	brne	.+2      	; 0xd00 <xQueueGenericSend+0xb4>
     cfe:	16 8e       	std	Z+30, r1	; 0x1e
     d00:	0f 90       	pop	r0
     d02:	0f be       	out	0x3f, r0	; 63
     d04:	be 01       	movw	r22, r28
     d06:	6c 5f       	subi	r22, 0xFC	; 252
     d08:	7f 4f       	sbci	r23, 0xFF	; 255
     d0a:	ce 01       	movw	r24, r28
     d0c:	01 96       	adiw	r24, 0x01	; 1
     d0e:	ee d7       	rcall	.+4060   	; 0x1cec <xTaskCheckForTimeOut>
     d10:	81 11       	cpse	r24, r1
     d12:	19 c0       	rjmp	.+50     	; 0xd46 <xQueueGenericSend+0xfa>
     d14:	0f b6       	in	r0, 0x3f	; 63
     d16:	f8 94       	cli
     d18:	0f 92       	push	r0
     d1a:	f8 01       	movw	r30, r16
     d1c:	92 8d       	ldd	r25, Z+26	; 0x1a
     d1e:	83 8d       	ldd	r24, Z+27	; 0x1b
     d20:	0f 90       	pop	r0
     d22:	0f be       	out	0x3f, r0	; 63
     d24:	98 13       	cpse	r25, r24
     d26:	0b c0       	rjmp	.+22     	; 0xd3e <xQueueGenericSend+0xf2>
     d28:	6c 81       	ldd	r22, Y+4	; 0x04
     d2a:	7d 81       	ldd	r23, Y+5	; 0x05
     d2c:	c7 01       	movw	r24, r14
     d2e:	7a d7       	rcall	.+3828   	; 0x1c24 <vTaskPlaceOnEventList>
     d30:	c8 01       	movw	r24, r16
     d32:	db de       	rcall	.-586    	; 0xaea <prvUnlockQueue>
     d34:	2d d6       	rcall	.+3162   	; 0x1990 <xTaskResumeAll>
     d36:	81 11       	cpse	r24, r1
     d38:	a5 cf       	rjmp	.-182    	; 0xc84 <xQueueGenericSend+0x38>
     d3a:	78 dd       	rcall	.-1296   	; 0x82c <vPortYield>
     d3c:	a3 cf       	rjmp	.-186    	; 0xc84 <xQueueGenericSend+0x38>
     d3e:	c8 01       	movw	r24, r16
     d40:	d4 de       	rcall	.-600    	; 0xaea <prvUnlockQueue>
     d42:	26 d6       	rcall	.+3148   	; 0x1990 <xTaskResumeAll>
     d44:	9f cf       	rjmp	.-194    	; 0xc84 <xQueueGenericSend+0x38>
     d46:	c8 01       	movw	r24, r16
     d48:	d0 de       	rcall	.-608    	; 0xaea <prvUnlockQueue>
     d4a:	22 d6       	rcall	.+3140   	; 0x1990 <xTaskResumeAll>
     d4c:	80 e0       	ldi	r24, 0x00	; 0
     d4e:	0f 90       	pop	r0
     d50:	0f 90       	pop	r0
     d52:	0f 90       	pop	r0
     d54:	0f 90       	pop	r0
     d56:	0f 90       	pop	r0
     d58:	df 91       	pop	r29
     d5a:	cf 91       	pop	r28
     d5c:	1f 91       	pop	r17
     d5e:	0f 91       	pop	r16
     d60:	ff 90       	pop	r15
     d62:	ef 90       	pop	r14
     d64:	df 90       	pop	r13
     d66:	cf 90       	pop	r12
     d68:	bf 90       	pop	r11
     d6a:	af 90       	pop	r10
     d6c:	9f 90       	pop	r9
     d6e:	08 95       	ret

00000d70 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     d70:	8f 92       	push	r8
     d72:	9f 92       	push	r9
     d74:	af 92       	push	r10
     d76:	bf 92       	push	r11
     d78:	cf 92       	push	r12
     d7a:	df 92       	push	r13
     d7c:	ef 92       	push	r14
     d7e:	ff 92       	push	r15
     d80:	0f 93       	push	r16
     d82:	1f 93       	push	r17
     d84:	cf 93       	push	r28
     d86:	df 93       	push	r29
     d88:	00 d0       	rcall	.+0      	; 0xd8a <xQueueGenericReceive+0x1a>
     d8a:	1f 92       	push	r1
     d8c:	1f 92       	push	r1
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
     d92:	8c 01       	movw	r16, r24
     d94:	5b 01       	movw	r10, r22
     d96:	5d 83       	std	Y+5, r21	; 0x05
     d98:	4c 83       	std	Y+4, r20	; 0x04
     d9a:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     d9c:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d9e:	99 24       	eor	r9, r9
     da0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     da2:	6c 01       	movw	r12, r24
     da4:	81 e1       	ldi	r24, 0x11	; 17
     da6:	c8 0e       	add	r12, r24
     da8:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     db0:	f8 01       	movw	r30, r16
     db2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     db4:	ff 20       	and	r15, r15
     db6:	69 f1       	breq	.+90     	; 0xe12 <xQueueGenericReceive+0xa2>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     db8:	c6 80       	ldd	r12, Z+6	; 0x06
     dba:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dbc:	b5 01       	movw	r22, r10
     dbe:	c8 01       	movw	r24, r16
     dc0:	7a de       	rcall	.-780    	; 0xab6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     dc2:	81 10       	cpse	r8, r1
     dc4:	17 c0       	rjmp	.+46     	; 0xdf4 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     dc6:	fa 94       	dec	r15
     dc8:	f8 01       	movw	r30, r16
     dca:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     dcc:	80 81       	ld	r24, Z
     dce:	91 81       	ldd	r25, Z+1	; 0x01
     dd0:	89 2b       	or	r24, r25
     dd2:	29 f4       	brne	.+10     	; 0xdde <xQueueGenericReceive+0x6e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     dd4:	0e 94 54 0f 	call	0x1ea8	; 0x1ea8 <pvTaskIncrementMutexHeldCount>
     dd8:	f8 01       	movw	r30, r16
     dda:	93 83       	std	Z+3, r25	; 0x03
     ddc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dde:	f8 01       	movw	r30, r16
     de0:	80 85       	ldd	r24, Z+8	; 0x08
     de2:	88 23       	and	r24, r24
     de4:	91 f0       	breq	.+36     	; 0xe0a <xQueueGenericReceive+0x9a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     de6:	c8 01       	movw	r24, r16
     de8:	08 96       	adiw	r24, 0x08	; 8
     dea:	2d d7       	rcall	.+3674   	; 0x1c46 <xTaskRemoveFromEventList>
     dec:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
     dee:	69 f0       	breq	.+26     	; 0xe0a <xQueueGenericReceive+0x9a>
     df0:	1d dd       	rcall	.-1478   	; 0x82c <vPortYield>
     df2:	0b c0       	rjmp	.+22     	; 0xe0a <xQueueGenericReceive+0x9a>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     df4:	f8 01       	movw	r30, r16
     df6:	d7 82       	std	Z+7, r13	; 0x07
     df8:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dfa:	81 89       	ldd	r24, Z+17	; 0x11
     dfc:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dfe:	29 f0       	breq	.+10     	; 0xe0a <xQueueGenericReceive+0x9a>
     e00:	c8 01       	movw	r24, r16
     e02:	41 96       	adiw	r24, 0x11	; 17
     e04:	20 d7       	rcall	.+3648   	; 0x1c46 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e06:	81 11       	cpse	r24, r1
     e08:	11 dd       	rcall	.-1502   	; 0x82c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e0a:	0f 90       	pop	r0
     e0c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	51 c0       	rjmp	.+162    	; 0xeb4 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e12:	8c 81       	ldd	r24, Y+4	; 0x04
     e14:	9d 81       	ldd	r25, Y+5	; 0x05
     e16:	89 2b       	or	r24, r25
     e18:	21 f4       	brne	.+8      	; 0xe22 <xQueueGenericReceive+0xb2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e1a:	0f 90       	pop	r0
     e1c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e1e:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     e20:	49 c0       	rjmp	.+146    	; 0xeb4 <xQueueGenericReceive+0x144>
     e22:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e24:	04 c0       	rjmp	.+8      	; 0xe2e <xQueueGenericReceive+0xbe>
     e26:	ce 01       	movw	r24, r28
     e28:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     e2a:	55 d7       	rcall	.+3754   	; 0x1cd6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e2c:	e9 2c       	mov	r14, r9
     e2e:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e30:	0f be       	out	0x3f, r0	; 63
     e32:	ee d4       	rcall	.+2524   	; 0x1810 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e34:	0f b6       	in	r0, 0x3f	; 63
     e36:	f8 94       	cli
     e38:	0f 92       	push	r0
     e3a:	f8 01       	movw	r30, r16
     e3c:	85 8d       	ldd	r24, Z+29	; 0x1d
     e3e:	8f 3f       	cpi	r24, 0xFF	; 255
     e40:	09 f4       	brne	.+2      	; 0xe44 <xQueueGenericReceive+0xd4>
     e42:	15 8e       	std	Z+29, r1	; 0x1d
     e44:	f8 01       	movw	r30, r16
     e46:	86 8d       	ldd	r24, Z+30	; 0x1e
     e48:	8f 3f       	cpi	r24, 0xFF	; 255
     e4a:	09 f4       	brne	.+2      	; 0xe4e <xQueueGenericReceive+0xde>
     e4c:	16 8e       	std	Z+30, r1	; 0x1e
     e4e:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e50:	0f be       	out	0x3f, r0	; 63
     e52:	be 01       	movw	r22, r28
     e54:	6c 5f       	subi	r22, 0xFC	; 252
     e56:	7f 4f       	sbci	r23, 0xFF	; 255
     e58:	ce 01       	movw	r24, r28
     e5a:	01 96       	adiw	r24, 0x01	; 1
     e5c:	47 d7       	rcall	.+3726   	; 0x1cec <xTaskCheckForTimeOut>
     e5e:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e60:	20 c0       	rjmp	.+64     	; 0xea2 <xQueueGenericReceive+0x132>
     e62:	c8 01       	movw	r24, r16
     e64:	be dd       	rcall	.-1156   	; 0x9e2 <prvIsQueueEmpty>
     e66:	88 23       	and	r24, r24
     e68:	c1 f0       	breq	.+48     	; 0xe9a <xQueueGenericReceive+0x12a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e6a:	f8 01       	movw	r30, r16
     e6c:	80 81       	ld	r24, Z
     e6e:	91 81       	ldd	r25, Z+1	; 0x01
     e70:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
     e72:	41 f4       	brne	.+16     	; 0xe84 <xQueueGenericReceive+0x114>
     e74:	0f b6       	in	r0, 0x3f	; 63
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     e76:	f8 94       	cli
     e78:	0f 92       	push	r0
						}
						taskEXIT_CRITICAL();
     e7a:	82 81       	ldd	r24, Z+2	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e7c:	93 81       	ldd	r25, Z+3	; 0x03
     e7e:	72 d7       	rcall	.+3812   	; 0x1d64 <vTaskPriorityInherit>
     e80:	0f 90       	pop	r0
				prvUnlockQueue( pxQueue );
     e82:	0f be       	out	0x3f, r0	; 63
     e84:	6c 81       	ldd	r22, Y+4	; 0x04
				if( xTaskResumeAll() == pdFALSE )
     e86:	7d 81       	ldd	r23, Y+5	; 0x05
     e88:	c6 01       	movw	r24, r12
     e8a:	cc d6       	rcall	.+3480   	; 0x1c24 <vTaskPlaceOnEventList>
				{
					portYIELD_WITHIN_API();
     e8c:	c8 01       	movw	r24, r16
     e8e:	2d de       	rcall	.-934    	; 0xaea <prvUnlockQueue>
     e90:	7f d5       	rcall	.+2814   	; 0x1990 <xTaskResumeAll>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e92:	81 11       	cpse	r24, r1
     e94:	8a cf       	rjmp	.-236    	; 0xdaa <xQueueGenericReceive+0x3a>
     e96:	ca dc       	rcall	.-1644   	; 0x82c <vPortYield>
				( void ) xTaskResumeAll();
     e98:	88 cf       	rjmp	.-240    	; 0xdaa <xQueueGenericReceive+0x3a>
     e9a:	c8 01       	movw	r24, r16
     e9c:	26 de       	rcall	.-948    	; 0xaea <prvUnlockQueue>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e9e:	78 d5       	rcall	.+2800   	; 0x1990 <xTaskResumeAll>
     ea0:	84 cf       	rjmp	.-248    	; 0xdaa <xQueueGenericReceive+0x3a>
     ea2:	c8 01       	movw	r24, r16
			( void ) xTaskResumeAll();
     ea4:	22 de       	rcall	.-956    	; 0xaea <prvUnlockQueue>
     ea6:	74 d5       	rcall	.+2792   	; 0x1990 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ea8:	c8 01       	movw	r24, r16
     eaa:	9b dd       	rcall	.-1226   	; 0x9e2 <prvIsQueueEmpty>
     eac:	88 23       	and	r24, r24
     eae:	09 f4       	brne	.+2      	; 0xeb2 <xQueueGenericReceive+0x142>
     eb0:	7c cf       	rjmp	.-264    	; 0xdaa <xQueueGenericReceive+0x3a>
     eb2:	80 e0       	ldi	r24, 0x00	; 0
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     eb4:	0f 90       	pop	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     eb6:	0f 90       	pop	r0
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	1f 91       	pop	r17
     ec4:	0f 91       	pop	r16
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	8f 90       	pop	r8
     ed6:	08 95       	ret

00000ed8 <__vector_25>:
     ed8:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
     eda:	0f 92       	push	r0
     edc:	0f b6       	in	r0, 0x3f	; 63
     ede:	0f 92       	push	r0
     ee0:	11 24       	eor	r1, r1
     ee2:	0b b6       	in	r0, 0x3b	; 59
     ee4:	0f 92       	push	r0
     ee6:	2f 93       	push	r18
     ee8:	3f 93       	push	r19
     eea:	4f 93       	push	r20
     eec:	8f 93       	push	r24
     eee:	9f 93       	push	r25
     ef0:	af 93       	push	r26
     ef2:	bf 93       	push	r27
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
     ef8:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     efc:	8c 71       	andi	r24, 0x1C	; 28
     efe:	71 f0       	breq	.+28     	; 0xf1c <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
     f00:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     f04:	88 23       	and	r24, r24
     f06:	0c f0       	brlt	.+2      	; 0xf0a <__vector_25+0x32>
     f08:	36 c0       	rjmp	.+108    	; 0xf76 <__vector_25+0x9e>
     f0a:	a6 ec       	ldi	r26, 0xC6	; 198
     f0c:	b0 e0       	ldi	r27, 0x00	; 0
     f0e:	e0 ec       	ldi	r30, 0xC0	; 192
     f10:	f0 e0       	ldi	r31, 0x00	; 0
     f12:	8c 91       	ld	r24, X
     f14:	80 81       	ld	r24, Z
     f16:	88 23       	and	r24, r24
     f18:	e4 f3       	brlt	.-8      	; 0xf12 <__vector_25+0x3a>
     f1a:	2d c0       	rjmp	.+90     	; 0xf76 <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
     f1c:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     f20:	0f b6       	in	r0, 0x3f	; 63
     f22:	f8 94       	cli
     f24:	0f 92       	push	r0
	{
	    count = buffer->count;
     f26:	e2 eb       	ldi	r30, 0xB2	; 178
     f28:	f2 e0       	ldi	r31, 0x02	; 2
     f2a:	21 81       	ldd	r18, Z+1	; 0x01
     f2c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
     f2e:	0f 90       	pop	r0
     f30:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
     f32:	83 85       	ldd	r24, Z+11	; 0x0b
     f34:	94 85       	ldd	r25, Z+12	; 0x0c
     f36:	28 17       	cp	r18, r24
     f38:	39 07       	cpc	r19, r25
     f3a:	e9 f0       	breq	.+58     	; 0xf76 <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     f3c:	e3 eb       	ldi	r30, 0xB3	; 179
     f3e:	f2 e0       	ldi	r31, 0x02	; 2

	*buffer->in = data;
     f40:	a2 81       	ldd	r26, Z+2	; 0x02
     f42:	b3 81       	ldd	r27, Z+3	; 0x03
     f44:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
     f46:	82 81       	ldd	r24, Z+2	; 0x02
     f48:	93 81       	ldd	r25, Z+3	; 0x03
     f4a:	01 96       	adiw	r24, 0x01	; 1
     f4c:	93 83       	std	Z+3, r25	; 0x03
     f4e:	82 83       	std	Z+2, r24	; 0x02
     f50:	20 85       	ldd	r18, Z+8	; 0x08
     f52:	31 85       	ldd	r19, Z+9	; 0x09
     f54:	82 17       	cp	r24, r18
     f56:	93 07       	cpc	r25, r19
     f58:	21 f4       	brne	.+8      	; 0xf62 <__vector_25+0x8a>
	  buffer->in = buffer->start;
     f5a:	86 81       	ldd	r24, Z+6	; 0x06
     f5c:	97 81       	ldd	r25, Z+7	; 0x07
     f5e:	93 83       	std	Z+3, r25	; 0x03
     f60:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
     f62:	0f b6       	in	r0, 0x3f	; 63
     f64:	f8 94       	cli
     f66:	0f 92       	push	r0
	{
	    buffer->count++;
     f68:	80 81       	ld	r24, Z
     f6a:	91 81       	ldd	r25, Z+1	; 0x01
     f6c:	01 96       	adiw	r24, 0x01	; 1
     f6e:	91 83       	std	Z+1, r25	; 0x01
     f70:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
     f76:	ff 91       	pop	r31
     f78:	ef 91       	pop	r30
     f7a:	bf 91       	pop	r27
     f7c:	af 91       	pop	r26
     f7e:	9f 91       	pop	r25
     f80:	8f 91       	pop	r24
     f82:	4f 91       	pop	r20
     f84:	3f 91       	pop	r19
     f86:	2f 91       	pop	r18
     f88:	0f 90       	pop	r0
     f8a:	0b be       	out	0x3b, r0	; 59
     f8c:	0f 90       	pop	r0
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	0f 90       	pop	r0
     f92:	1f 90       	pop	r1
     f94:	18 95       	reti

00000f96 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
     f96:	1f 92       	push	r1
     f98:	0f 92       	push	r0
     f9a:	0f b6       	in	r0, 0x3f	; 63
     f9c:	0f 92       	push	r0
     f9e:	11 24       	eor	r1, r1
     fa0:	0b b6       	in	r0, 0x3b	; 59
     fa2:	0f 92       	push	r0
     fa4:	2f 93       	push	r18
     fa6:	8f 93       	push	r24
     fa8:	9f 93       	push	r25
     faa:	af 93       	push	r26
     fac:	bf 93       	push	r27
     fae:	ef 93       	push	r30
     fb0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
     fb2:	0f b6       	in	r0, 0x3f	; 63
     fb4:	f8 94       	cli
     fb6:	0f 92       	push	r0
	{
	    count = buffer->count;
     fb8:	80 91 bf 02 	lds	r24, 0x02BF	; 0x8002bf <xSerialPort+0xd>
     fbc:	90 91 c0 02 	lds	r25, 0x02C0	; 0x8002c0 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
     fc4:	89 2b       	or	r24, r25
     fc6:	31 f4       	brne	.+12     	; 0xfd4 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
     fc8:	e1 ec       	ldi	r30, 0xC1	; 193
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 81       	ld	r24, Z
     fce:	8f 7d       	andi	r24, 0xDF	; 223
     fd0:	80 83       	st	Z, r24
     fd2:	1c c0       	rjmp	.+56     	; 0x100c <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
     fd4:	ef eb       	ldi	r30, 0xBF	; 191
     fd6:	f2 e0       	ldi	r31, 0x02	; 2

	uint8_t data = *buffer->out;
     fd8:	a4 81       	ldd	r26, Z+4	; 0x04
     fda:	b5 81       	ldd	r27, Z+5	; 0x05
     fdc:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
     fde:	b5 83       	std	Z+5, r27	; 0x05
     fe0:	a4 83       	std	Z+4, r26	; 0x04
     fe2:	80 85       	ldd	r24, Z+8	; 0x08
     fe4:	91 85       	ldd	r25, Z+9	; 0x09
     fe6:	a8 17       	cp	r26, r24
     fe8:	b9 07       	cpc	r27, r25
     fea:	21 f4       	brne	.+8      	; 0xff4 <__vector_26+0x5e>
	  buffer->out = buffer->start;
     fec:	86 81       	ldd	r24, Z+6	; 0x06
     fee:	97 81       	ldd	r25, Z+7	; 0x07
     ff0:	95 83       	std	Z+5, r25	; 0x05
     ff2:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
     ff4:	0f b6       	in	r0, 0x3f	; 63
     ff6:	f8 94       	cli
     ff8:	0f 92       	push	r0
	{
	    buffer->count--;
     ffa:	80 81       	ld	r24, Z
     ffc:	91 81       	ldd	r25, Z+1	; 0x01
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	91 83       	std	Z+1, r25	; 0x01
    1002:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1008:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    100c:	ff 91       	pop	r31
    100e:	ef 91       	pop	r30
    1010:	bf 91       	pop	r27
    1012:	af 91       	pop	r26
    1014:	9f 91       	pop	r25
    1016:	8f 91       	pop	r24
    1018:	2f 91       	pop	r18
    101a:	0f 90       	pop	r0
    101c:	0b be       	out	0x3b, r0	; 59
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	0f 90       	pop	r0
    1024:	1f 90       	pop	r1
    1026:	18 95       	reti

00001028 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    1028:	1f 92       	push	r1
    102a:	0f 92       	push	r0
    102c:	0f b6       	in	r0, 0x3f	; 63
    102e:	0f 92       	push	r0
    1030:	11 24       	eor	r1, r1
    1032:	0b b6       	in	r0, 0x3b	; 59
    1034:	0f 92       	push	r0
    1036:	2f 93       	push	r18
    1038:	3f 93       	push	r19
    103a:	4f 93       	push	r20
    103c:	8f 93       	push	r24
    103e:	9f 93       	push	r25
    1040:	af 93       	push	r26
    1042:	bf 93       	push	r27
    1044:	ef 93       	push	r30
    1046:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    1048:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    104c:	8c 71       	andi	r24, 0x1C	; 28
    104e:	71 f0       	breq	.+28     	; 0x106c <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    1050:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1054:	88 23       	and	r24, r24
    1056:	0c f0       	brlt	.+2      	; 0x105a <__vector_36+0x32>
    1058:	36 c0       	rjmp	.+108    	; 0x10c6 <__vector_36+0x9e>
    105a:	ae ec       	ldi	r26, 0xCE	; 206
    105c:	b0 e0       	ldi	r27, 0x00	; 0
    105e:	e8 ec       	ldi	r30, 0xC8	; 200
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	8c 91       	ld	r24, X
    1064:	80 81       	ld	r24, Z
    1066:	88 23       	and	r24, r24
    1068:	e4 f3       	brlt	.-8      	; 0x1062 <__vector_36+0x3a>
    106a:	2d c0       	rjmp	.+90     	; 0x10c6 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    106c:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1070:	0f b6       	in	r0, 0x3f	; 63
    1072:	f8 94       	cli
    1074:	0f 92       	push	r0
	{
	    count = buffer->count;
    1076:	e8 e1       	ldi	r30, 0x18	; 24
    1078:	f3 e0       	ldi	r31, 0x03	; 3
    107a:	21 81       	ldd	r18, Z+1	; 0x01
    107c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    107e:	0f 90       	pop	r0
    1080:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    1082:	83 85       	ldd	r24, Z+11	; 0x0b
    1084:	94 85       	ldd	r25, Z+12	; 0x0c
    1086:	28 17       	cp	r18, r24
    1088:	39 07       	cpc	r19, r25
    108a:	e9 f0       	breq	.+58     	; 0x10c6 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    108c:	e9 e1       	ldi	r30, 0x19	; 25
    108e:	f3 e0       	ldi	r31, 0x03	; 3

	*buffer->in = data;
    1090:	a2 81       	ldd	r26, Z+2	; 0x02
    1092:	b3 81       	ldd	r27, Z+3	; 0x03
    1094:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1096:	82 81       	ldd	r24, Z+2	; 0x02
    1098:	93 81       	ldd	r25, Z+3	; 0x03
    109a:	01 96       	adiw	r24, 0x01	; 1
    109c:	93 83       	std	Z+3, r25	; 0x03
    109e:	82 83       	std	Z+2, r24	; 0x02
    10a0:	20 85       	ldd	r18, Z+8	; 0x08
    10a2:	31 85       	ldd	r19, Z+9	; 0x09
    10a4:	82 17       	cp	r24, r18
    10a6:	93 07       	cpc	r25, r19
    10a8:	21 f4       	brne	.+8      	; 0x10b2 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    10aa:	86 81       	ldd	r24, Z+6	; 0x06
    10ac:	97 81       	ldd	r25, Z+7	; 0x07
    10ae:	93 83       	std	Z+3, r25	; 0x03
    10b0:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	0f 92       	push	r0
	{
	    buffer->count++;
    10b8:	80 81       	ld	r24, Z
    10ba:	91 81       	ldd	r25, Z+1	; 0x01
    10bc:	01 96       	adiw	r24, 0x01	; 1
    10be:	91 83       	std	Z+1, r25	; 0x01
    10c0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    10c2:	0f 90       	pop	r0
    10c4:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    10c6:	ff 91       	pop	r31
    10c8:	ef 91       	pop	r30
    10ca:	bf 91       	pop	r27
    10cc:	af 91       	pop	r26
    10ce:	9f 91       	pop	r25
    10d0:	8f 91       	pop	r24
    10d2:	4f 91       	pop	r20
    10d4:	3f 91       	pop	r19
    10d6:	2f 91       	pop	r18
    10d8:	0f 90       	pop	r0
    10da:	0b be       	out	0x3b, r0	; 59
    10dc:	0f 90       	pop	r0
    10de:	0f be       	out	0x3f, r0	; 63
    10e0:	0f 90       	pop	r0
    10e2:	1f 90       	pop	r1
    10e4:	18 95       	reti

000010e6 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    10e6:	1f 92       	push	r1
    10e8:	0f 92       	push	r0
    10ea:	0f b6       	in	r0, 0x3f	; 63
    10ec:	0f 92       	push	r0
    10ee:	11 24       	eor	r1, r1
    10f0:	0b b6       	in	r0, 0x3b	; 59
    10f2:	0f 92       	push	r0
    10f4:	2f 93       	push	r18
    10f6:	8f 93       	push	r24
    10f8:	9f 93       	push	r25
    10fa:	af 93       	push	r26
    10fc:	bf 93       	push	r27
    10fe:	ef 93       	push	r30
    1100:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1102:	0f b6       	in	r0, 0x3f	; 63
    1104:	f8 94       	cli
    1106:	0f 92       	push	r0
	{
	    count = buffer->count;
    1108:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <xSerial1Port+0xd>
    110c:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1110:	0f 90       	pop	r0
    1112:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1114:	89 2b       	or	r24, r25
    1116:	31 f4       	brne	.+12     	; 0x1124 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1118:	e9 ec       	ldi	r30, 0xC9	; 201
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	80 81       	ld	r24, Z
    111e:	8f 7d       	andi	r24, 0xDF	; 223
    1120:	80 83       	st	Z, r24
    1122:	1c c0       	rjmp	.+56     	; 0x115c <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1124:	e5 e2       	ldi	r30, 0x25	; 37
    1126:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    1128:	a4 81       	ldd	r26, Z+4	; 0x04
    112a:	b5 81       	ldd	r27, Z+5	; 0x05
    112c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    112e:	b5 83       	std	Z+5, r27	; 0x05
    1130:	a4 83       	std	Z+4, r26	; 0x04
    1132:	80 85       	ldd	r24, Z+8	; 0x08
    1134:	91 85       	ldd	r25, Z+9	; 0x09
    1136:	a8 17       	cp	r26, r24
    1138:	b9 07       	cpc	r27, r25
    113a:	21 f4       	brne	.+8      	; 0x1144 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    113c:	86 81       	ldd	r24, Z+6	; 0x06
    113e:	97 81       	ldd	r25, Z+7	; 0x07
    1140:	95 83       	std	Z+5, r25	; 0x05
    1142:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	0f 92       	push	r0
	{
	    buffer->count--;
    114a:	80 81       	ld	r24, Z
    114c:	91 81       	ldd	r25, Z+1	; 0x01
    114e:	01 97       	sbiw	r24, 0x01	; 1
    1150:	91 83       	std	Z+1, r25	; 0x01
    1152:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1154:	0f 90       	pop	r0
    1156:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1158:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    115c:	ff 91       	pop	r31
    115e:	ef 91       	pop	r30
    1160:	bf 91       	pop	r27
    1162:	af 91       	pop	r26
    1164:	9f 91       	pop	r25
    1166:	8f 91       	pop	r24
    1168:	2f 91       	pop	r18
    116a:	0f 90       	pop	r0
    116c:	0b be       	out	0x3b, r0	; 59
    116e:	0f 90       	pop	r0
    1170:	0f be       	out	0x3f, r0	; 63
    1172:	0f 90       	pop	r0
    1174:	1f 90       	pop	r1
    1176:	18 95       	reti

00001178 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    1178:	1f 92       	push	r1
    117a:	0f 92       	push	r0
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	0f 92       	push	r0
    1180:	11 24       	eor	r1, r1
    1182:	0b b6       	in	r0, 0x3b	; 59
    1184:	0f 92       	push	r0
    1186:	2f 93       	push	r18
    1188:	3f 93       	push	r19
    118a:	4f 93       	push	r20
    118c:	8f 93       	push	r24
    118e:	9f 93       	push	r25
    1190:	af 93       	push	r26
    1192:	bf 93       	push	r27
    1194:	ef 93       	push	r30
    1196:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1198:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    119c:	8c 71       	andi	r24, 0x1C	; 28
    119e:	71 f0       	breq	.+28     	; 0x11bc <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    11a0:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    11a4:	88 23       	and	r24, r24
    11a6:	0c f0       	brlt	.+2      	; 0x11aa <__vector_51+0x32>
    11a8:	36 c0       	rjmp	.+108    	; 0x1216 <__vector_51+0x9e>
    11aa:	a6 ed       	ldi	r26, 0xD6	; 214
    11ac:	b0 e0       	ldi	r27, 0x00	; 0
    11ae:	e0 ed       	ldi	r30, 0xD0	; 208
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	8c 91       	ld	r24, X
    11b4:	80 81       	ld	r24, Z
    11b6:	88 23       	and	r24, r24
    11b8:	e4 f3       	brlt	.-8      	; 0x11b2 <__vector_51+0x3a>
    11ba:	2d c0       	rjmp	.+90     	; 0x1216 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    11bc:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    11c0:	0f b6       	in	r0, 0x3f	; 63
    11c2:	f8 94       	cli
    11c4:	0f 92       	push	r0
	{
	    count = buffer->count;
    11c6:	e4 ed       	ldi	r30, 0xD4	; 212
    11c8:	f2 e0       	ldi	r31, 0x02	; 2
    11ca:	21 81       	ldd	r18, Z+1	; 0x01
    11cc:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    11ce:	0f 90       	pop	r0
    11d0:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    11d2:	83 85       	ldd	r24, Z+11	; 0x0b
    11d4:	94 85       	ldd	r25, Z+12	; 0x0c
    11d6:	28 17       	cp	r18, r24
    11d8:	39 07       	cpc	r19, r25
    11da:	e9 f0       	breq	.+58     	; 0x1216 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    11dc:	e5 ed       	ldi	r30, 0xD5	; 213
    11de:	f2 e0       	ldi	r31, 0x02	; 2

	*buffer->in = data;
    11e0:	a2 81       	ldd	r26, Z+2	; 0x02
    11e2:	b3 81       	ldd	r27, Z+3	; 0x03
    11e4:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    11e6:	82 81       	ldd	r24, Z+2	; 0x02
    11e8:	93 81       	ldd	r25, Z+3	; 0x03
    11ea:	01 96       	adiw	r24, 0x01	; 1
    11ec:	93 83       	std	Z+3, r25	; 0x03
    11ee:	82 83       	std	Z+2, r24	; 0x02
    11f0:	20 85       	ldd	r18, Z+8	; 0x08
    11f2:	31 85       	ldd	r19, Z+9	; 0x09
    11f4:	82 17       	cp	r24, r18
    11f6:	93 07       	cpc	r25, r19
    11f8:	21 f4       	brne	.+8      	; 0x1202 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    11fa:	86 81       	ldd	r24, Z+6	; 0x06
    11fc:	97 81       	ldd	r25, Z+7	; 0x07
    11fe:	93 83       	std	Z+3, r25	; 0x03
    1200:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1202:	0f b6       	in	r0, 0x3f	; 63
    1204:	f8 94       	cli
    1206:	0f 92       	push	r0
	{
	    buffer->count++;
    1208:	80 81       	ld	r24, Z
    120a:	91 81       	ldd	r25, Z+1	; 0x01
    120c:	01 96       	adiw	r24, 0x01	; 1
    120e:	91 83       	std	Z+1, r25	; 0x01
    1210:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1212:	0f 90       	pop	r0
    1214:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1216:	ff 91       	pop	r31
    1218:	ef 91       	pop	r30
    121a:	bf 91       	pop	r27
    121c:	af 91       	pop	r26
    121e:	9f 91       	pop	r25
    1220:	8f 91       	pop	r24
    1222:	4f 91       	pop	r20
    1224:	3f 91       	pop	r19
    1226:	2f 91       	pop	r18
    1228:	0f 90       	pop	r0
    122a:	0b be       	out	0x3b, r0	; 59
    122c:	0f 90       	pop	r0
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	0f 90       	pop	r0
    1232:	1f 90       	pop	r1
    1234:	18 95       	reti

00001236 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1236:	1f 92       	push	r1
    1238:	0f 92       	push	r0
    123a:	0f b6       	in	r0, 0x3f	; 63
    123c:	0f 92       	push	r0
    123e:	11 24       	eor	r1, r1
    1240:	0b b6       	in	r0, 0x3b	; 59
    1242:	0f 92       	push	r0
    1244:	2f 93       	push	r18
    1246:	8f 93       	push	r24
    1248:	9f 93       	push	r25
    124a:	af 93       	push	r26
    124c:	bf 93       	push	r27
    124e:	ef 93       	push	r30
    1250:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1252:	0f b6       	in	r0, 0x3f	; 63
    1254:	f8 94       	cli
    1256:	0f 92       	push	r0
	{
	    count = buffer->count;
    1258:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <xSerial2Port+0xd>
    125c:	90 91 e2 02 	lds	r25, 0x02E2	; 0x8002e2 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1264:	89 2b       	or	r24, r25
    1266:	31 f4       	brne	.+12     	; 0x1274 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1268:	e1 ed       	ldi	r30, 0xD1	; 209
    126a:	f0 e0       	ldi	r31, 0x00	; 0
    126c:	80 81       	ld	r24, Z
    126e:	8f 7d       	andi	r24, 0xDF	; 223
    1270:	80 83       	st	Z, r24
    1272:	1c c0       	rjmp	.+56     	; 0x12ac <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1274:	e1 ee       	ldi	r30, 0xE1	; 225
    1276:	f2 e0       	ldi	r31, 0x02	; 2

	uint8_t data = *buffer->out;
    1278:	a4 81       	ldd	r26, Z+4	; 0x04
    127a:	b5 81       	ldd	r27, Z+5	; 0x05
    127c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    127e:	b5 83       	std	Z+5, r27	; 0x05
    1280:	a4 83       	std	Z+4, r26	; 0x04
    1282:	80 85       	ldd	r24, Z+8	; 0x08
    1284:	91 85       	ldd	r25, Z+9	; 0x09
    1286:	a8 17       	cp	r26, r24
    1288:	b9 07       	cpc	r27, r25
    128a:	21 f4       	brne	.+8      	; 0x1294 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    128c:	86 81       	ldd	r24, Z+6	; 0x06
    128e:	97 81       	ldd	r25, Z+7	; 0x07
    1290:	95 83       	std	Z+5, r25	; 0x05
    1292:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1294:	0f b6       	in	r0, 0x3f	; 63
    1296:	f8 94       	cli
    1298:	0f 92       	push	r0
	{
	    buffer->count--;
    129a:	80 81       	ld	r24, Z
    129c:	91 81       	ldd	r25, Z+1	; 0x01
    129e:	01 97       	sbiw	r24, 0x01	; 1
    12a0:	91 83       	std	Z+1, r25	; 0x01
    12a2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    12a4:	0f 90       	pop	r0
    12a6:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    12a8:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    12ac:	ff 91       	pop	r31
    12ae:	ef 91       	pop	r30
    12b0:	bf 91       	pop	r27
    12b2:	af 91       	pop	r26
    12b4:	9f 91       	pop	r25
    12b6:	8f 91       	pop	r24
    12b8:	2f 91       	pop	r18
    12ba:	0f 90       	pop	r0
    12bc:	0b be       	out	0x3b, r0	; 59
    12be:	0f 90       	pop	r0
    12c0:	0f be       	out	0x3f, r0	; 63
    12c2:	0f 90       	pop	r0
    12c4:	1f 90       	pop	r1
    12c6:	18 95       	reti

000012c8 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    12c8:	1f 92       	push	r1
    12ca:	0f 92       	push	r0
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	0f 92       	push	r0
    12d0:	11 24       	eor	r1, r1
    12d2:	0b b6       	in	r0, 0x3b	; 59
    12d4:	0f 92       	push	r0
    12d6:	2f 93       	push	r18
    12d8:	3f 93       	push	r19
    12da:	4f 93       	push	r20
    12dc:	8f 93       	push	r24
    12de:	9f 93       	push	r25
    12e0:	af 93       	push	r26
    12e2:	bf 93       	push	r27
    12e4:	ef 93       	push	r30
    12e6:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    12e8:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    12ec:	8c 71       	andi	r24, 0x1C	; 28
    12ee:	71 f0       	breq	.+28     	; 0x130c <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    12f0:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    12f4:	88 23       	and	r24, r24
    12f6:	0c f0       	brlt	.+2      	; 0x12fa <__vector_54+0x32>
    12f8:	36 c0       	rjmp	.+108    	; 0x1366 <__vector_54+0x9e>
    12fa:	a6 e3       	ldi	r26, 0x36	; 54
    12fc:	b1 e0       	ldi	r27, 0x01	; 1
    12fe:	e0 e3       	ldi	r30, 0x30	; 48
    1300:	f1 e0       	ldi	r31, 0x01	; 1
    1302:	8c 91       	ld	r24, X
    1304:	80 81       	ld	r24, Z
    1306:	88 23       	and	r24, r24
    1308:	e4 f3       	brlt	.-8      	; 0x1302 <__vector_54+0x3a>
    130a:	2d c0       	rjmp	.+90     	; 0x1366 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    130c:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	0f 92       	push	r0
	{
	    count = buffer->count;
    1316:	e6 ef       	ldi	r30, 0xF6	; 246
    1318:	f2 e0       	ldi	r31, 0x02	; 2
    131a:	21 81       	ldd	r18, Z+1	; 0x01
    131c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1322:	83 85       	ldd	r24, Z+11	; 0x0b
    1324:	94 85       	ldd	r25, Z+12	; 0x0c
    1326:	28 17       	cp	r18, r24
    1328:	39 07       	cpc	r19, r25
    132a:	e9 f0       	breq	.+58     	; 0x1366 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    132c:	e7 ef       	ldi	r30, 0xF7	; 247
    132e:	f2 e0       	ldi	r31, 0x02	; 2

	*buffer->in = data;
    1330:	a2 81       	ldd	r26, Z+2	; 0x02
    1332:	b3 81       	ldd	r27, Z+3	; 0x03
    1334:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1336:	82 81       	ldd	r24, Z+2	; 0x02
    1338:	93 81       	ldd	r25, Z+3	; 0x03
    133a:	01 96       	adiw	r24, 0x01	; 1
    133c:	93 83       	std	Z+3, r25	; 0x03
    133e:	82 83       	std	Z+2, r24	; 0x02
    1340:	20 85       	ldd	r18, Z+8	; 0x08
    1342:	31 85       	ldd	r19, Z+9	; 0x09
    1344:	82 17       	cp	r24, r18
    1346:	93 07       	cpc	r25, r19
    1348:	21 f4       	brne	.+8      	; 0x1352 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    134a:	86 81       	ldd	r24, Z+6	; 0x06
    134c:	97 81       	ldd	r25, Z+7	; 0x07
    134e:	93 83       	std	Z+3, r25	; 0x03
    1350:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	f8 94       	cli
    1356:	0f 92       	push	r0
	{
	    buffer->count++;
    1358:	80 81       	ld	r24, Z
    135a:	91 81       	ldd	r25, Z+1	; 0x01
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	91 83       	std	Z+1, r25	; 0x01
    1360:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1366:	ff 91       	pop	r31
    1368:	ef 91       	pop	r30
    136a:	bf 91       	pop	r27
    136c:	af 91       	pop	r26
    136e:	9f 91       	pop	r25
    1370:	8f 91       	pop	r24
    1372:	4f 91       	pop	r20
    1374:	3f 91       	pop	r19
    1376:	2f 91       	pop	r18
    1378:	0f 90       	pop	r0
    137a:	0b be       	out	0x3b, r0	; 59
    137c:	0f 90       	pop	r0
    137e:	0f be       	out	0x3f, r0	; 63
    1380:	0f 90       	pop	r0
    1382:	1f 90       	pop	r1
    1384:	18 95       	reti

00001386 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1386:	1f 92       	push	r1
    1388:	0f 92       	push	r0
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	0f 92       	push	r0
    138e:	11 24       	eor	r1, r1
    1390:	0b b6       	in	r0, 0x3b	; 59
    1392:	0f 92       	push	r0
    1394:	2f 93       	push	r18
    1396:	8f 93       	push	r24
    1398:	9f 93       	push	r25
    139a:	af 93       	push	r26
    139c:	bf 93       	push	r27
    139e:	ef 93       	push	r30
    13a0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	0f 92       	push	r0
	{
	    count = buffer->count;
    13a8:	80 91 03 03 	lds	r24, 0x0303	; 0x800303 <xSerial3Port+0xd>
    13ac:	90 91 04 03 	lds	r25, 0x0304	; 0x800304 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    13b0:	0f 90       	pop	r0
    13b2:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    13b4:	89 2b       	or	r24, r25
    13b6:	31 f4       	brne	.+12     	; 0x13c4 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    13b8:	e1 e3       	ldi	r30, 0x31	; 49
    13ba:	f1 e0       	ldi	r31, 0x01	; 1
    13bc:	80 81       	ld	r24, Z
    13be:	8f 7d       	andi	r24, 0xDF	; 223
    13c0:	80 83       	st	Z, r24
    13c2:	1c c0       	rjmp	.+56     	; 0x13fc <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    13c4:	e3 e0       	ldi	r30, 0x03	; 3
    13c6:	f3 e0       	ldi	r31, 0x03	; 3

	uint8_t data = *buffer->out;
    13c8:	a4 81       	ldd	r26, Z+4	; 0x04
    13ca:	b5 81       	ldd	r27, Z+5	; 0x05
    13cc:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    13ce:	b5 83       	std	Z+5, r27	; 0x05
    13d0:	a4 83       	std	Z+4, r26	; 0x04
    13d2:	80 85       	ldd	r24, Z+8	; 0x08
    13d4:	91 85       	ldd	r25, Z+9	; 0x09
    13d6:	a8 17       	cp	r26, r24
    13d8:	b9 07       	cpc	r27, r25
    13da:	21 f4       	brne	.+8      	; 0x13e4 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    13dc:	86 81       	ldd	r24, Z+6	; 0x06
    13de:	97 81       	ldd	r25, Z+7	; 0x07
    13e0:	95 83       	std	Z+5, r25	; 0x05
    13e2:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    13e4:	0f b6       	in	r0, 0x3f	; 63
    13e6:	f8 94       	cli
    13e8:	0f 92       	push	r0
	{
	    buffer->count--;
    13ea:	80 81       	ld	r24, Z
    13ec:	91 81       	ldd	r25, Z+1	; 0x01
    13ee:	01 97       	sbiw	r24, 0x01	; 1
    13f0:	91 83       	std	Z+1, r25	; 0x01
    13f2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    13f4:	0f 90       	pop	r0
    13f6:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    13f8:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    13fc:	ff 91       	pop	r31
    13fe:	ef 91       	pop	r30
    1400:	bf 91       	pop	r27
    1402:	af 91       	pop	r26
    1404:	9f 91       	pop	r25
    1406:	8f 91       	pop	r24
    1408:	2f 91       	pop	r18
    140a:	0f 90       	pop	r0
    140c:	0b be       	out	0x3b, r0	; 59
    140e:	0f 90       	pop	r0
    1410:	0f be       	out	0x3f, r0	; 63
    1412:	0f 90       	pop	r0
    1414:	1f 90       	pop	r1
    1416:	18 95       	reti

00001418 <prvResetNextTaskUnblockTime>:
    1418:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    141c:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    1420:	80 81       	ld	r24, Z
    1422:	81 11       	cpse	r24, r1
    1424:	07 c0       	rjmp	.+14     	; 0x1434 <prvResetNextTaskUnblockTime+0x1c>
    1426:	8f ef       	ldi	r24, 0xFF	; 255
    1428:	9f ef       	ldi	r25, 0xFF	; 255
    142a:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    142e:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    1432:	08 95       	ret
    1434:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    1438:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    143c:	05 80       	ldd	r0, Z+5	; 0x05
    143e:	f6 81       	ldd	r31, Z+6	; 0x06
    1440:	e0 2d       	mov	r30, r0
    1442:	06 80       	ldd	r0, Z+6	; 0x06
    1444:	f7 81       	ldd	r31, Z+7	; 0x07
    1446:	e0 2d       	mov	r30, r0
    1448:	82 81       	ldd	r24, Z+2	; 0x02
    144a:	93 81       	ldd	r25, Z+3	; 0x03
    144c:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    1450:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    1454:	08 95       	ret

00001456 <prvAddCurrentTaskToDelayedList>:
    1456:	ff 92       	push	r15
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	ec 01       	movw	r28, r24
    1462:	f6 2e       	mov	r15, r22
    1464:	00 91 47 02 	lds	r16, 0x0247	; 0x800247 <xTickCount>
    1468:	10 91 48 02 	lds	r17, 0x0248	; 0x800248 <xTickCount+0x1>
    146c:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1470:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1474:	02 96       	adiw	r24, 0x02	; 2
    1476:	fc d8       	rcall	.-3592   	; 0x670 <uxListRemove>
    1478:	cf 3f       	cpi	r28, 0xFF	; 255
    147a:	8f ef       	ldi	r24, 0xFF	; 255
    147c:	d8 07       	cpc	r29, r24
    147e:	61 f4       	brne	.+24     	; 0x1498 <prvAddCurrentTaskToDelayedList+0x42>
    1480:	ff 20       	and	r15, r15
    1482:	51 f0       	breq	.+20     	; 0x1498 <prvAddCurrentTaskToDelayedList+0x42>
    1484:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1488:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    148c:	6e 5f       	subi	r22, 0xFE	; 254
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	8a e4       	ldi	r24, 0x4A	; 74
    1492:	92 e0       	ldi	r25, 0x02	; 2
    1494:	9b d8       	rcall	.-3786   	; 0x5cc <vListInsertEnd>
    1496:	2d c0       	rjmp	.+90     	; 0x14f2 <prvAddCurrentTaskToDelayedList+0x9c>
    1498:	c0 0f       	add	r28, r16
    149a:	d1 1f       	adc	r29, r17
    149c:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14a0:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    14a4:	d3 83       	std	Z+3, r29	; 0x03
    14a6:	c2 83       	std	Z+2, r28	; 0x02
    14a8:	c0 17       	cp	r28, r16
    14aa:	d1 07       	cpc	r29, r17
    14ac:	60 f4       	brcc	.+24     	; 0x14c6 <prvAddCurrentTaskToDelayedList+0x70>
    14ae:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14b2:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    14b6:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <pxOverflowDelayedTaskList>
    14ba:	90 91 67 02 	lds	r25, 0x0267	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    14be:	6e 5f       	subi	r22, 0xFE	; 254
    14c0:	7f 4f       	sbci	r23, 0xFF	; 255
    14c2:	a5 d8       	rcall	.-3766   	; 0x60e <vListInsert>
    14c4:	16 c0       	rjmp	.+44     	; 0x14f2 <prvAddCurrentTaskToDelayedList+0x9c>
    14c6:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    14ca:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    14ce:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <pxDelayedTaskList>
    14d2:	90 91 69 02 	lds	r25, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    14d6:	6e 5f       	subi	r22, 0xFE	; 254
    14d8:	7f 4f       	sbci	r23, 0xFF	; 255
    14da:	99 d8       	rcall	.-3790   	; 0x60e <vListInsert>
    14dc:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <xNextTaskUnblockTime>
    14e0:	90 91 40 02 	lds	r25, 0x0240	; 0x800240 <xNextTaskUnblockTime+0x1>
    14e4:	c8 17       	cp	r28, r24
    14e6:	d9 07       	cpc	r29, r25
    14e8:	20 f4       	brcc	.+8      	; 0x14f2 <prvAddCurrentTaskToDelayedList+0x9c>
    14ea:	d0 93 40 02 	sts	0x0240, r29	; 0x800240 <xNextTaskUnblockTime+0x1>
    14ee:	c0 93 3f 02 	sts	0x023F, r28	; 0x80023f <xNextTaskUnblockTime>
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	ff 90       	pop	r15
    14fc:	08 95       	ret

000014fe <xTaskCreate>:
    14fe:	4f 92       	push	r4
    1500:	5f 92       	push	r5
    1502:	6f 92       	push	r6
    1504:	7f 92       	push	r7
    1506:	8f 92       	push	r8
    1508:	9f 92       	push	r9
    150a:	af 92       	push	r10
    150c:	bf 92       	push	r11
    150e:	cf 92       	push	r12
    1510:	df 92       	push	r13
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	0f 93       	push	r16
    1518:	cf 93       	push	r28
    151a:	df 93       	push	r29
    151c:	4c 01       	movw	r8, r24
    151e:	6b 01       	movw	r12, r22
    1520:	5a 01       	movw	r10, r20
    1522:	29 01       	movw	r4, r18
    1524:	ca 01       	movw	r24, r20
    1526:	0e 94 ac 01 	call	0x358	; 0x358 <pvPortMalloc>
    152a:	3c 01       	movw	r6, r24
    152c:	89 2b       	or	r24, r25
    152e:	09 f4       	brne	.+2      	; 0x1532 <xTaskCreate+0x34>
    1530:	e7 c0       	rjmp	.+462    	; 0x1700 <xTaskCreate+0x202>
    1532:	88 e2       	ldi	r24, 0x28	; 40
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	0e 94 ac 01 	call	0x358	; 0x358 <pvPortMalloc>
    153a:	ec 01       	movw	r28, r24
    153c:	89 2b       	or	r24, r25
    153e:	a9 f0       	breq	.+42     	; 0x156a <xTaskCreate+0x6c>
    1540:	78 8e       	std	Y+24, r7	; 0x18
    1542:	6f 8a       	std	Y+23, r6	; 0x17
    1544:	a5 01       	movw	r20, r10
    1546:	65 ea       	ldi	r22, 0xA5	; 165
    1548:	70 e0       	ldi	r23, 0x00	; 0
    154a:	c3 01       	movw	r24, r6
    154c:	08 d7       	rcall	.+3600   	; 0x235e <memset>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	a8 1a       	sub	r10, r24
    1552:	b1 08       	sbc	r11, r1
    1554:	8f 89       	ldd	r24, Y+23	; 0x17
    1556:	98 8d       	ldd	r25, Y+24	; 0x18
    1558:	a8 0e       	add	r10, r24
    155a:	b9 1e       	adc	r11, r25
    155c:	d6 01       	movw	r26, r12
    155e:	8c 91       	ld	r24, X
    1560:	89 8f       	std	Y+25, r24	; 0x19
    1562:	8c 91       	ld	r24, X
    1564:	81 11       	cpse	r24, r1
    1566:	05 c0       	rjmp	.+10     	; 0x1572 <xTaskCreate+0x74>
    1568:	18 c0       	rjmp	.+48     	; 0x159a <xTaskCreate+0x9c>
    156a:	c3 01       	movw	r24, r6
    156c:	0e 94 be 01 	call	0x37c	; 0x37c <vPortFree>
    1570:	c7 c0       	rjmp	.+398    	; 0x1700 <xTaskCreate+0x202>
    1572:	ae 01       	movw	r20, r28
    1574:	46 5e       	subi	r20, 0xE6	; 230
    1576:	5f 4f       	sbci	r21, 0xFF	; 255
    1578:	f6 01       	movw	r30, r12
    157a:	31 96       	adiw	r30, 0x01	; 1
    157c:	b8 e0       	ldi	r27, 0x08	; 8
    157e:	cb 0e       	add	r12, r27
    1580:	d1 1c       	adc	r13, r1
    1582:	cf 01       	movw	r24, r30
    1584:	21 91       	ld	r18, Z+
    1586:	da 01       	movw	r26, r20
    1588:	2d 93       	st	X+, r18
    158a:	ad 01       	movw	r20, r26
    158c:	dc 01       	movw	r26, r24
    158e:	8c 91       	ld	r24, X
    1590:	88 23       	and	r24, r24
    1592:	19 f0       	breq	.+6      	; 0x159a <xTaskCreate+0x9c>
    1594:	ec 15       	cp	r30, r12
    1596:	fd 05       	cpc	r31, r13
    1598:	a1 f7       	brne	.-24     	; 0x1582 <xTaskCreate+0x84>
    159a:	18 a2       	std	Y+32, r1	; 0x20
    159c:	04 30       	cpi	r16, 0x04	; 4
    159e:	08 f0       	brcs	.+2      	; 0x15a2 <xTaskCreate+0xa4>
    15a0:	03 e0       	ldi	r16, 0x03	; 3
    15a2:	0e 8b       	std	Y+22, r16	; 0x16
    15a4:	09 a3       	std	Y+33, r16	; 0x21
    15a6:	1a a2       	std	Y+34, r1	; 0x22
    15a8:	6e 01       	movw	r12, r28
    15aa:	b2 e0       	ldi	r27, 0x02	; 2
    15ac:	cb 0e       	add	r12, r27
    15ae:	d1 1c       	adc	r13, r1
    15b0:	c6 01       	movw	r24, r12
    15b2:	08 d8       	rcall	.-4080   	; 0x5c4 <vListInitialiseItem>
    15b4:	ce 01       	movw	r24, r28
    15b6:	0c 96       	adiw	r24, 0x0c	; 12
    15b8:	05 d8       	rcall	.-4086   	; 0x5c4 <vListInitialiseItem>
    15ba:	d9 87       	std	Y+9, r29	; 0x09
    15bc:	c8 87       	std	Y+8, r28	; 0x08
    15be:	84 e0       	ldi	r24, 0x04	; 4
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	80 1b       	sub	r24, r16
    15c4:	91 09       	sbc	r25, r1
    15c6:	9d 87       	std	Y+13, r25	; 0x0d
    15c8:	8c 87       	std	Y+12, r24	; 0x0c
    15ca:	db 8b       	std	Y+19, r29	; 0x13
    15cc:	ca 8b       	std	Y+18, r28	; 0x12
    15ce:	1b a2       	std	Y+35, r1	; 0x23
    15d0:	1c a2       	std	Y+36, r1	; 0x24
    15d2:	1d a2       	std	Y+37, r1	; 0x25
    15d4:	1e a2       	std	Y+38, r1	; 0x26
    15d6:	1f a2       	std	Y+39, r1	; 0x27
    15d8:	a2 01       	movw	r20, r4
    15da:	b4 01       	movw	r22, r8
    15dc:	c5 01       	movw	r24, r10
    15de:	6e d8       	rcall	.-3876   	; 0x6bc <pxPortInitialiseStack>
    15e0:	99 83       	std	Y+1, r25	; 0x01
    15e2:	88 83       	st	Y, r24
    15e4:	e1 14       	cp	r14, r1
    15e6:	f1 04       	cpc	r15, r1
    15e8:	19 f0       	breq	.+6      	; 0x15f0 <xTaskCreate+0xf2>
    15ea:	f7 01       	movw	r30, r14
    15ec:	d1 83       	std	Z+1, r29	; 0x01
    15ee:	c0 83       	st	Z, r28
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
    15f6:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <uxCurrentNumberOfTasks>
    1600:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1604:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1608:	89 2b       	or	r24, r25
    160a:	d1 f5       	brne	.+116    	; 0x1680 <xTaskCreate+0x182>
    160c:	d0 93 a1 02 	sts	0x02A1, r29	; 0x8002a1 <pxCurrentTCB+0x1>
    1610:	c0 93 a0 02 	sts	0x02A0, r28	; 0x8002a0 <pxCurrentTCB>
    1614:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
    1618:	81 30       	cpi	r24, 0x01	; 1
    161a:	09 f0       	breq	.+2      	; 0x161e <xTaskCreate+0x120>
    161c:	41 c0       	rjmp	.+130    	; 0x16a0 <xTaskCreate+0x1a2>
    161e:	8c e7       	ldi	r24, 0x7C	; 124
    1620:	92 e0       	ldi	r25, 0x02	; 2
    1622:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1626:	85 e8       	ldi	r24, 0x85	; 133
    1628:	92 e0       	ldi	r25, 0x02	; 2
    162a:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    162e:	8e e8       	ldi	r24, 0x8E	; 142
    1630:	92 e0       	ldi	r25, 0x02	; 2
    1632:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1636:	87 e9       	ldi	r24, 0x97	; 151
    1638:	92 e0       	ldi	r25, 0x02	; 2
    163a:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    163e:	83 e7       	ldi	r24, 0x73	; 115
    1640:	92 e0       	ldi	r25, 0x02	; 2
    1642:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1646:	8a e6       	ldi	r24, 0x6A	; 106
    1648:	92 e0       	ldi	r25, 0x02	; 2
    164a:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    164e:	8d e5       	ldi	r24, 0x5D	; 93
    1650:	92 e0       	ldi	r25, 0x02	; 2
    1652:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1656:	84 e5       	ldi	r24, 0x54	; 84
    1658:	92 e0       	ldi	r25, 0x02	; 2
    165a:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    165e:	8a e4       	ldi	r24, 0x4A	; 74
    1660:	92 e0       	ldi	r25, 0x02	; 2
    1662:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <vListInitialise>
    1666:	83 e7       	ldi	r24, 0x73	; 115
    1668:	92 e0       	ldi	r25, 0x02	; 2
    166a:	90 93 69 02 	sts	0x0269, r25	; 0x800269 <pxDelayedTaskList+0x1>
    166e:	80 93 68 02 	sts	0x0268, r24	; 0x800268 <pxDelayedTaskList>
    1672:	8a e6       	ldi	r24, 0x6A	; 106
    1674:	92 e0       	ldi	r25, 0x02	; 2
    1676:	90 93 67 02 	sts	0x0267, r25	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    167a:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <pxOverflowDelayedTaskList>
    167e:	10 c0       	rjmp	.+32     	; 0x16a0 <xTaskCreate+0x1a2>
    1680:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    1684:	81 11       	cpse	r24, r1
    1686:	0c c0       	rjmp	.+24     	; 0x16a0 <xTaskCreate+0x1a2>
    1688:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    168c:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1690:	96 89       	ldd	r25, Z+22	; 0x16
    1692:	8e 89       	ldd	r24, Y+22	; 0x16
    1694:	89 17       	cp	r24, r25
    1696:	20 f0       	brcs	.+8      	; 0x16a0 <xTaskCreate+0x1a2>
    1698:	d0 93 a1 02 	sts	0x02A1, r29	; 0x8002a1 <pxCurrentTCB+0x1>
    169c:	c0 93 a0 02 	sts	0x02A0, r28	; 0x8002a0 <pxCurrentTCB>
    16a0:	80 91 41 02 	lds	r24, 0x0241	; 0x800241 <uxTaskNumber>
    16a4:	8f 5f       	subi	r24, 0xFF	; 255
    16a6:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <uxTaskNumber>
    16aa:	8e 89       	ldd	r24, Y+22	; 0x16
    16ac:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    16b0:	98 17       	cp	r25, r24
    16b2:	10 f4       	brcc	.+4      	; 0x16b8 <xTaskCreate+0x1ba>
    16b4:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	9c 01       	movw	r18, r24
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	22 0f       	add	r18, r18
    16c2:	33 1f       	adc	r19, r19
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	b6 01       	movw	r22, r12
    16ce:	84 58       	subi	r24, 0x84	; 132
    16d0:	9d 4f       	sbci	r25, 0xFD	; 253
    16d2:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    16d6:	0f 90       	pop	r0
    16d8:	0f be       	out	0x3f, r0	; 63
    16da:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    16de:	88 23       	and	r24, r24
    16e0:	59 f0       	breq	.+22     	; 0x16f8 <xTaskCreate+0x1fa>
    16e2:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    16e6:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    16ea:	96 89       	ldd	r25, Z+22	; 0x16
    16ec:	8e 89       	ldd	r24, Y+22	; 0x16
    16ee:	98 17       	cp	r25, r24
    16f0:	28 f4       	brcc	.+10     	; 0x16fc <xTaskCreate+0x1fe>
    16f2:	9c d8       	rcall	.-3784   	; 0x82c <vPortYield>
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	05 c0       	rjmp	.+10     	; 0x1702 <xTaskCreate+0x204>
    16f8:	81 e0       	ldi	r24, 0x01	; 1
    16fa:	03 c0       	rjmp	.+6      	; 0x1702 <xTaskCreate+0x204>
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	01 c0       	rjmp	.+2      	; 0x1702 <xTaskCreate+0x204>
    1700:	8f ef       	ldi	r24, 0xFF	; 255
    1702:	df 91       	pop	r29
    1704:	cf 91       	pop	r28
    1706:	0f 91       	pop	r16
    1708:	ff 90       	pop	r15
    170a:	ef 90       	pop	r14
    170c:	df 90       	pop	r13
    170e:	cf 90       	pop	r12
    1710:	bf 90       	pop	r11
    1712:	af 90       	pop	r10
    1714:	9f 90       	pop	r9
    1716:	8f 90       	pop	r8
    1718:	7f 90       	pop	r7
    171a:	6f 90       	pop	r6
    171c:	5f 90       	pop	r5
    171e:	4f 90       	pop	r4
    1720:	08 95       	ret

00001722 <vTaskResume>:
    1722:	0f 93       	push	r16
    1724:	1f 93       	push	r17
    1726:	cf 93       	push	r28
    1728:	df 93       	push	r29
    172a:	00 97       	sbiw	r24, 0x00	; 0
    172c:	09 f4       	brne	.+2      	; 0x1730 <vTaskResume+0xe>
    172e:	42 c0       	rjmp	.+132    	; 0x17b4 <vTaskResume+0x92>
    1730:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1734:	30 91 a1 02 	lds	r19, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1738:	82 17       	cp	r24, r18
    173a:	93 07       	cpc	r25, r19
    173c:	09 f4       	brne	.+2      	; 0x1740 <vTaskResume+0x1e>
    173e:	3a c0       	rjmp	.+116    	; 0x17b4 <vTaskResume+0x92>
    1740:	0f b6       	in	r0, 0x3f	; 63
    1742:	f8 94       	cli
    1744:	0f 92       	push	r0
    1746:	fc 01       	movw	r30, r24
    1748:	22 85       	ldd	r18, Z+10	; 0x0a
    174a:	33 85       	ldd	r19, Z+11	; 0x0b
    174c:	2a 54       	subi	r18, 0x4A	; 74
    174e:	32 40       	sbci	r19, 0x02	; 2
    1750:	79 f5       	brne	.+94     	; 0x17b0 <vTaskResume+0x8e>
    1752:	fc 01       	movw	r30, r24
    1754:	24 89       	ldd	r18, Z+20	; 0x14
    1756:	35 89       	ldd	r19, Z+21	; 0x15
    1758:	f2 e0       	ldi	r31, 0x02	; 2
    175a:	2d 35       	cpi	r18, 0x5D	; 93
    175c:	3f 07       	cpc	r19, r31
    175e:	41 f1       	breq	.+80     	; 0x17b0 <vTaskResume+0x8e>
    1760:	23 2b       	or	r18, r19
    1762:	31 f5       	brne	.+76     	; 0x17b0 <vTaskResume+0x8e>
    1764:	ec 01       	movw	r28, r24
    1766:	8c 01       	movw	r16, r24
    1768:	0e 5f       	subi	r16, 0xFE	; 254
    176a:	1f 4f       	sbci	r17, 0xFF	; 255
    176c:	c8 01       	movw	r24, r16
    176e:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1772:	8e 89       	ldd	r24, Y+22	; 0x16
    1774:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1778:	98 17       	cp	r25, r24
    177a:	10 f4       	brcc	.+4      	; 0x1780 <vTaskResume+0x5e>
    177c:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1780:	90 e0       	ldi	r25, 0x00	; 0
    1782:	9c 01       	movw	r18, r24
    1784:	22 0f       	add	r18, r18
    1786:	33 1f       	adc	r19, r19
    1788:	22 0f       	add	r18, r18
    178a:	33 1f       	adc	r19, r19
    178c:	22 0f       	add	r18, r18
    178e:	33 1f       	adc	r19, r19
    1790:	82 0f       	add	r24, r18
    1792:	93 1f       	adc	r25, r19
    1794:	b8 01       	movw	r22, r16
    1796:	84 58       	subi	r24, 0x84	; 132
    1798:	9d 4f       	sbci	r25, 0xFD	; 253
    179a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    179e:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    17a2:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    17a6:	9e 89       	ldd	r25, Y+22	; 0x16
    17a8:	86 89       	ldd	r24, Z+22	; 0x16
    17aa:	98 17       	cp	r25, r24
    17ac:	08 f0       	brcs	.+2      	; 0x17b0 <vTaskResume+0x8e>
    17ae:	3e d8       	rcall	.-3972   	; 0x82c <vPortYield>
    17b0:	0f 90       	pop	r0
    17b2:	0f be       	out	0x3f, r0	; 63
    17b4:	df 91       	pop	r29
    17b6:	cf 91       	pop	r28
    17b8:	1f 91       	pop	r17
    17ba:	0f 91       	pop	r16
    17bc:	08 95       	ret

000017be <vTaskStartScheduler>:
    17be:	ef 92       	push	r14
    17c0:	ff 92       	push	r15
    17c2:	0f 93       	push	r16
    17c4:	0f 2e       	mov	r0, r31
    17c6:	fd e3       	ldi	r31, 0x3D	; 61
    17c8:	ef 2e       	mov	r14, r31
    17ca:	f2 e0       	ldi	r31, 0x02	; 2
    17cc:	ff 2e       	mov	r15, r31
    17ce:	f0 2d       	mov	r31, r0
    17d0:	00 e0       	ldi	r16, 0x00	; 0
    17d2:	20 e0       	ldi	r18, 0x00	; 0
    17d4:	30 e0       	ldi	r19, 0x00	; 0
    17d6:	45 e5       	ldi	r20, 0x55	; 85
    17d8:	50 e0       	ldi	r21, 0x00	; 0
    17da:	67 e0       	ldi	r22, 0x07	; 7
    17dc:	72 e0       	ldi	r23, 0x02	; 2
    17de:	83 e3       	ldi	r24, 0x33	; 51
    17e0:	91 e0       	ldi	r25, 0x01	; 1
    17e2:	8d de       	rcall	.-742    	; 0x14fe <xTaskCreate>
    17e4:	81 30       	cpi	r24, 0x01	; 1
    17e6:	81 f4       	brne	.+32     	; 0x1808 <vTaskStartScheduler+0x4a>
    17e8:	f8 94       	cli
    17ea:	8f ef       	ldi	r24, 0xFF	; 255
    17ec:	9f ef       	ldi	r25, 0xFF	; 255
    17ee:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    17f2:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    17f6:	81 e0       	ldi	r24, 0x01	; 1
    17f8:	80 93 45 02 	sts	0x0245, r24	; 0x800245 <xSchedulerRunning>
    17fc:	10 92 48 02 	sts	0x0248, r1	; 0x800248 <xTickCount+0x1>
    1800:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <xTickCount>
    1804:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <xPortStartScheduler>
    1808:	0f 91       	pop	r16
    180a:	ff 90       	pop	r15
    180c:	ef 90       	pop	r14
    180e:	08 95       	ret

00001810 <vTaskSuspendAll>:
    1810:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    1814:	8f 5f       	subi	r24, 0xFF	; 255
    1816:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <uxSchedulerSuspended>
    181a:	08 95       	ret

0000181c <xTaskIncrementTick>:
    181c:	cf 92       	push	r12
    181e:	df 92       	push	r13
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    1830:	81 11       	cpse	r24, r1
    1832:	98 c0       	rjmp	.+304    	; 0x1964 <xTaskIncrementTick+0x148>
    1834:	e0 90 47 02 	lds	r14, 0x0247	; 0x800247 <xTickCount>
    1838:	f0 90 48 02 	lds	r15, 0x0248	; 0x800248 <xTickCount+0x1>
    183c:	8f ef       	ldi	r24, 0xFF	; 255
    183e:	e8 1a       	sub	r14, r24
    1840:	f8 0a       	sbc	r15, r24
    1842:	f0 92 48 02 	sts	0x0248, r15	; 0x800248 <xTickCount+0x1>
    1846:	e0 92 47 02 	sts	0x0247, r14	; 0x800247 <xTickCount>
    184a:	e1 14       	cp	r14, r1
    184c:	f1 04       	cpc	r15, r1
    184e:	b1 f4       	brne	.+44     	; 0x187c <xTaskIncrementTick+0x60>
    1850:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <pxDelayedTaskList>
    1854:	90 91 69 02 	lds	r25, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    1858:	20 91 66 02 	lds	r18, 0x0266	; 0x800266 <pxOverflowDelayedTaskList>
    185c:	30 91 67 02 	lds	r19, 0x0267	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    1860:	30 93 69 02 	sts	0x0269, r19	; 0x800269 <pxDelayedTaskList+0x1>
    1864:	20 93 68 02 	sts	0x0268, r18	; 0x800268 <pxDelayedTaskList>
    1868:	90 93 67 02 	sts	0x0267, r25	; 0x800267 <pxOverflowDelayedTaskList+0x1>
    186c:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <pxOverflowDelayedTaskList>
    1870:	80 91 42 02 	lds	r24, 0x0242	; 0x800242 <xNumOfOverflows>
    1874:	8f 5f       	subi	r24, 0xFF	; 255
    1876:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <xNumOfOverflows>
    187a:	ce dd       	rcall	.-1124   	; 0x1418 <prvResetNextTaskUnblockTime>
    187c:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <xNextTaskUnblockTime>
    1880:	90 91 40 02 	lds	r25, 0x0240	; 0x800240 <xNextTaskUnblockTime+0x1>
    1884:	e8 16       	cp	r14, r24
    1886:	f9 06       	cpc	r15, r25
    1888:	10 f4       	brcc	.+4      	; 0x188e <xTaskIncrementTick+0x72>
    188a:	d1 2c       	mov	r13, r1
    188c:	53 c0       	rjmp	.+166    	; 0x1934 <xTaskIncrementTick+0x118>
    188e:	d1 2c       	mov	r13, r1
    1890:	cc 24       	eor	r12, r12
    1892:	c3 94       	inc	r12
    1894:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    1898:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    189c:	80 81       	ld	r24, Z
    189e:	81 11       	cpse	r24, r1
    18a0:	07 c0       	rjmp	.+14     	; 0x18b0 <xTaskIncrementTick+0x94>
    18a2:	8f ef       	ldi	r24, 0xFF	; 255
    18a4:	9f ef       	ldi	r25, 0xFF	; 255
    18a6:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    18aa:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    18ae:	42 c0       	rjmp	.+132    	; 0x1934 <xTaskIncrementTick+0x118>
    18b0:	e0 91 68 02 	lds	r30, 0x0268	; 0x800268 <pxDelayedTaskList>
    18b4:	f0 91 69 02 	lds	r31, 0x0269	; 0x800269 <pxDelayedTaskList+0x1>
    18b8:	05 80       	ldd	r0, Z+5	; 0x05
    18ba:	f6 81       	ldd	r31, Z+6	; 0x06
    18bc:	e0 2d       	mov	r30, r0
    18be:	c6 81       	ldd	r28, Z+6	; 0x06
    18c0:	d7 81       	ldd	r29, Z+7	; 0x07
    18c2:	8a 81       	ldd	r24, Y+2	; 0x02
    18c4:	9b 81       	ldd	r25, Y+3	; 0x03
    18c6:	e8 16       	cp	r14, r24
    18c8:	f9 06       	cpc	r15, r25
    18ca:	28 f4       	brcc	.+10     	; 0x18d6 <xTaskIncrementTick+0xba>
    18cc:	90 93 40 02 	sts	0x0240, r25	; 0x800240 <xNextTaskUnblockTime+0x1>
    18d0:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <xNextTaskUnblockTime>
    18d4:	2f c0       	rjmp	.+94     	; 0x1934 <xTaskIncrementTick+0x118>
    18d6:	8e 01       	movw	r16, r28
    18d8:	0e 5f       	subi	r16, 0xFE	; 254
    18da:	1f 4f       	sbci	r17, 0xFF	; 255
    18dc:	c8 01       	movw	r24, r16
    18de:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    18e2:	8c 89       	ldd	r24, Y+20	; 0x14
    18e4:	9d 89       	ldd	r25, Y+21	; 0x15
    18e6:	89 2b       	or	r24, r25
    18e8:	21 f0       	breq	.+8      	; 0x18f2 <xTaskIncrementTick+0xd6>
    18ea:	ce 01       	movw	r24, r28
    18ec:	0c 96       	adiw	r24, 0x0c	; 12
    18ee:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    18f2:	8e 89       	ldd	r24, Y+22	; 0x16
    18f4:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    18f8:	98 17       	cp	r25, r24
    18fa:	10 f4       	brcc	.+4      	; 0x1900 <xTaskIncrementTick+0xe4>
    18fc:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1900:	90 e0       	ldi	r25, 0x00	; 0
    1902:	9c 01       	movw	r18, r24
    1904:	22 0f       	add	r18, r18
    1906:	33 1f       	adc	r19, r19
    1908:	22 0f       	add	r18, r18
    190a:	33 1f       	adc	r19, r19
    190c:	22 0f       	add	r18, r18
    190e:	33 1f       	adc	r19, r19
    1910:	82 0f       	add	r24, r18
    1912:	93 1f       	adc	r25, r19
    1914:	b8 01       	movw	r22, r16
    1916:	84 58       	subi	r24, 0x84	; 132
    1918:	9d 4f       	sbci	r25, 0xFD	; 253
    191a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    191e:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1922:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1926:	9e 89       	ldd	r25, Y+22	; 0x16
    1928:	86 89       	ldd	r24, Z+22	; 0x16
    192a:	98 17       	cp	r25, r24
    192c:	08 f4       	brcc	.+2      	; 0x1930 <xTaskIncrementTick+0x114>
    192e:	b2 cf       	rjmp	.-156    	; 0x1894 <xTaskIncrementTick+0x78>
    1930:	dc 2c       	mov	r13, r12
    1932:	b0 cf       	rjmp	.-160    	; 0x1894 <xTaskIncrementTick+0x78>
    1934:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1938:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    193c:	86 89       	ldd	r24, Z+22	; 0x16
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	fc 01       	movw	r30, r24
    1942:	ee 0f       	add	r30, r30
    1944:	ff 1f       	adc	r31, r31
    1946:	ee 0f       	add	r30, r30
    1948:	ff 1f       	adc	r31, r31
    194a:	ee 0f       	add	r30, r30
    194c:	ff 1f       	adc	r31, r31
    194e:	8e 0f       	add	r24, r30
    1950:	9f 1f       	adc	r25, r31
    1952:	fc 01       	movw	r30, r24
    1954:	e4 58       	subi	r30, 0x84	; 132
    1956:	fd 4f       	sbci	r31, 0xFD	; 253
    1958:	80 81       	ld	r24, Z
    195a:	82 30       	cpi	r24, 0x02	; 2
    195c:	48 f0       	brcs	.+18     	; 0x1970 <xTaskIncrementTick+0x154>
    195e:	dd 24       	eor	r13, r13
    1960:	d3 94       	inc	r13
    1962:	06 c0       	rjmp	.+12     	; 0x1970 <xTaskIncrementTick+0x154>
    1964:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <uxPendedTicks>
    1968:	8f 5f       	subi	r24, 0xFF	; 255
    196a:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxPendedTicks>
    196e:	d1 2c       	mov	r13, r1
    1970:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xYieldPending>
    1974:	88 23       	and	r24, r24
    1976:	11 f0       	breq	.+4      	; 0x197c <xTaskIncrementTick+0x160>
    1978:	dd 24       	eor	r13, r13
    197a:	d3 94       	inc	r13
    197c:	8d 2d       	mov	r24, r13
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	1f 91       	pop	r17
    1984:	0f 91       	pop	r16
    1986:	ff 90       	pop	r15
    1988:	ef 90       	pop	r14
    198a:	df 90       	pop	r13
    198c:	cf 90       	pop	r12
    198e:	08 95       	ret

00001990 <xTaskResumeAll>:
    1990:	df 92       	push	r13
    1992:	ef 92       	push	r14
    1994:	ff 92       	push	r15
    1996:	0f 93       	push	r16
    1998:	1f 93       	push	r17
    199a:	cf 93       	push	r28
    199c:	df 93       	push	r29
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	0f 92       	push	r0
    19a4:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    19a8:	81 50       	subi	r24, 0x01	; 1
    19aa:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <uxSchedulerSuspended>
    19ae:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    19b2:	81 11       	cpse	r24, r1
    19b4:	5d c0       	rjmp	.+186    	; 0x1a70 <xTaskResumeAll+0xe0>
    19b6:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
    19ba:	81 11       	cpse	r24, r1
    19bc:	33 c0       	rjmp	.+102    	; 0x1a24 <xTaskResumeAll+0x94>
    19be:	5b c0       	rjmp	.+182    	; 0x1a76 <xTaskResumeAll+0xe6>
    19c0:	d7 01       	movw	r26, r14
    19c2:	15 96       	adiw	r26, 0x05	; 5
    19c4:	ed 91       	ld	r30, X+
    19c6:	fc 91       	ld	r31, X
    19c8:	16 97       	sbiw	r26, 0x06	; 6
    19ca:	c6 81       	ldd	r28, Z+6	; 0x06
    19cc:	d7 81       	ldd	r29, Z+7	; 0x07
    19ce:	ce 01       	movw	r24, r28
    19d0:	0c 96       	adiw	r24, 0x0c	; 12
    19d2:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    19d6:	8e 01       	movw	r16, r28
    19d8:	0e 5f       	subi	r16, 0xFE	; 254
    19da:	1f 4f       	sbci	r17, 0xFF	; 255
    19dc:	c8 01       	movw	r24, r16
    19de:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    19e2:	8e 89       	ldd	r24, Y+22	; 0x16
    19e4:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    19e8:	98 17       	cp	r25, r24
    19ea:	10 f4       	brcc	.+4      	; 0x19f0 <xTaskResumeAll+0x60>
    19ec:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	9c 01       	movw	r18, r24
    19f4:	22 0f       	add	r18, r18
    19f6:	33 1f       	adc	r19, r19
    19f8:	22 0f       	add	r18, r18
    19fa:	33 1f       	adc	r19, r19
    19fc:	22 0f       	add	r18, r18
    19fe:	33 1f       	adc	r19, r19
    1a00:	82 0f       	add	r24, r18
    1a02:	93 1f       	adc	r25, r19
    1a04:	b8 01       	movw	r22, r16
    1a06:	84 58       	subi	r24, 0x84	; 132
    1a08:	9d 4f       	sbci	r25, 0xFD	; 253
    1a0a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1a0e:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1a12:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1a16:	9e 89       	ldd	r25, Y+22	; 0x16
    1a18:	86 89       	ldd	r24, Z+22	; 0x16
    1a1a:	98 17       	cp	r25, r24
    1a1c:	68 f0       	brcs	.+26     	; 0x1a38 <xTaskResumeAll+0xa8>
    1a1e:	d0 92 43 02 	sts	0x0243, r13	; 0x800243 <xYieldPending>
    1a22:	0a c0       	rjmp	.+20     	; 0x1a38 <xTaskResumeAll+0xa8>
    1a24:	c0 e0       	ldi	r28, 0x00	; 0
    1a26:	d0 e0       	ldi	r29, 0x00	; 0
    1a28:	0f 2e       	mov	r0, r31
    1a2a:	fd e5       	ldi	r31, 0x5D	; 93
    1a2c:	ef 2e       	mov	r14, r31
    1a2e:	f2 e0       	ldi	r31, 0x02	; 2
    1a30:	ff 2e       	mov	r15, r31
    1a32:	f0 2d       	mov	r31, r0
    1a34:	dd 24       	eor	r13, r13
    1a36:	d3 94       	inc	r13
    1a38:	f7 01       	movw	r30, r14
    1a3a:	80 81       	ld	r24, Z
    1a3c:	81 11       	cpse	r24, r1
    1a3e:	c0 cf       	rjmp	.-128    	; 0x19c0 <xTaskResumeAll+0x30>
    1a40:	cd 2b       	or	r28, r29
    1a42:	09 f0       	breq	.+2      	; 0x1a46 <xTaskResumeAll+0xb6>
    1a44:	e9 dc       	rcall	.-1582   	; 0x1418 <prvResetNextTaskUnblockTime>
    1a46:	c0 91 44 02 	lds	r28, 0x0244	; 0x800244 <uxPendedTicks>
    1a4a:	cc 23       	and	r28, r28
    1a4c:	49 f0       	breq	.+18     	; 0x1a60 <xTaskResumeAll+0xd0>
    1a4e:	d1 e0       	ldi	r29, 0x01	; 1
    1a50:	e5 de       	rcall	.-566    	; 0x181c <xTaskIncrementTick>
    1a52:	81 11       	cpse	r24, r1
    1a54:	d0 93 43 02 	sts	0x0243, r29	; 0x800243 <xYieldPending>
    1a58:	c1 50       	subi	r28, 0x01	; 1
    1a5a:	d1 f7       	brne	.-12     	; 0x1a50 <xTaskResumeAll+0xc0>
    1a5c:	10 92 44 02 	sts	0x0244, r1	; 0x800244 <uxPendedTicks>
    1a60:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xYieldPending>
    1a64:	88 23       	and	r24, r24
    1a66:	31 f0       	breq	.+12     	; 0x1a74 <xTaskResumeAll+0xe4>
    1a68:	0e 94 16 04 	call	0x82c	; 0x82c <vPortYield>
    1a6c:	81 e0       	ldi	r24, 0x01	; 1
    1a6e:	03 c0       	rjmp	.+6      	; 0x1a76 <xTaskResumeAll+0xe6>
    1a70:	80 e0       	ldi	r24, 0x00	; 0
    1a72:	01 c0       	rjmp	.+2      	; 0x1a76 <xTaskResumeAll+0xe6>
    1a74:	80 e0       	ldi	r24, 0x00	; 0
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63
    1a7a:	df 91       	pop	r29
    1a7c:	cf 91       	pop	r28
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	ef 90       	pop	r14
    1a86:	df 90       	pop	r13
    1a88:	08 95       	ret

00001a8a <vTaskSwitchContext>:
    1a8a:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    1a8e:	88 23       	and	r24, r24
    1a90:	21 f0       	breq	.+8      	; 0x1a9a <vTaskSwitchContext+0x10>
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    1a98:	08 95       	ret
    1a9a:	10 92 43 02 	sts	0x0243, r1	; 0x800243 <xYieldPending>
    1a9e:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1aa2:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1aa6:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1aaa:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1aae:	2d 91       	ld	r18, X+
    1ab0:	3c 91       	ld	r19, X
    1ab2:	87 89       	ldd	r24, Z+23	; 0x17
    1ab4:	90 8d       	ldd	r25, Z+24	; 0x18
    1ab6:	82 17       	cp	r24, r18
    1ab8:	93 07       	cpc	r25, r19
    1aba:	60 f0       	brcs	.+24     	; 0x1ad4 <vTaskSwitchContext+0x4a>
    1abc:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1ac0:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1ac4:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1ac8:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1acc:	67 5e       	subi	r22, 0xE7	; 231
    1ace:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad0:	0e 94 d7 01 	call	0x3ae	; 0x3ae <vApplicationStackOverflowHook>
    1ad4:	20 91 46 02 	lds	r18, 0x0246	; 0x800246 <uxTopReadyPriority>
    1ad8:	82 2f       	mov	r24, r18
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	fc 01       	movw	r30, r24
    1ade:	ee 0f       	add	r30, r30
    1ae0:	ff 1f       	adc	r31, r31
    1ae2:	ee 0f       	add	r30, r30
    1ae4:	ff 1f       	adc	r31, r31
    1ae6:	ee 0f       	add	r30, r30
    1ae8:	ff 1f       	adc	r31, r31
    1aea:	e8 0f       	add	r30, r24
    1aec:	f9 1f       	adc	r31, r25
    1aee:	e4 58       	subi	r30, 0x84	; 132
    1af0:	fd 4f       	sbci	r31, 0xFD	; 253
    1af2:	30 81       	ld	r19, Z
    1af4:	31 11       	cpse	r19, r1
    1af6:	11 c0       	rjmp	.+34     	; 0x1b1a <vTaskSwitchContext+0x90>
    1af8:	21 50       	subi	r18, 0x01	; 1
    1afa:	82 2f       	mov	r24, r18
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	fc 01       	movw	r30, r24
    1b00:	ee 0f       	add	r30, r30
    1b02:	ff 1f       	adc	r31, r31
    1b04:	ee 0f       	add	r30, r30
    1b06:	ff 1f       	adc	r31, r31
    1b08:	ee 0f       	add	r30, r30
    1b0a:	ff 1f       	adc	r31, r31
    1b0c:	e8 0f       	add	r30, r24
    1b0e:	f9 1f       	adc	r31, r25
    1b10:	e4 58       	subi	r30, 0x84	; 132
    1b12:	fd 4f       	sbci	r31, 0xFD	; 253
    1b14:	30 81       	ld	r19, Z
    1b16:	33 23       	and	r19, r19
    1b18:	79 f3       	breq	.-34     	; 0x1af8 <vTaskSwitchContext+0x6e>
    1b1a:	ac 01       	movw	r20, r24
    1b1c:	44 0f       	add	r20, r20
    1b1e:	55 1f       	adc	r21, r21
    1b20:	44 0f       	add	r20, r20
    1b22:	55 1f       	adc	r21, r21
    1b24:	44 0f       	add	r20, r20
    1b26:	55 1f       	adc	r21, r21
    1b28:	48 0f       	add	r20, r24
    1b2a:	59 1f       	adc	r21, r25
    1b2c:	da 01       	movw	r26, r20
    1b2e:	a4 58       	subi	r26, 0x84	; 132
    1b30:	bd 4f       	sbci	r27, 0xFD	; 253
    1b32:	11 96       	adiw	r26, 0x01	; 1
    1b34:	ed 91       	ld	r30, X+
    1b36:	fc 91       	ld	r31, X
    1b38:	12 97       	sbiw	r26, 0x02	; 2
    1b3a:	02 80       	ldd	r0, Z+2	; 0x02
    1b3c:	f3 81       	ldd	r31, Z+3	; 0x03
    1b3e:	e0 2d       	mov	r30, r0
    1b40:	12 96       	adiw	r26, 0x02	; 2
    1b42:	fc 93       	st	X, r31
    1b44:	ee 93       	st	-X, r30
    1b46:	11 97       	sbiw	r26, 0x01	; 1
    1b48:	41 58       	subi	r20, 0x81	; 129
    1b4a:	5d 4f       	sbci	r21, 0xFD	; 253
    1b4c:	e4 17       	cp	r30, r20
    1b4e:	f5 07       	cpc	r31, r21
    1b50:	29 f4       	brne	.+10     	; 0x1b5c <vTaskSwitchContext+0xd2>
    1b52:	42 81       	ldd	r20, Z+2	; 0x02
    1b54:	53 81       	ldd	r21, Z+3	; 0x03
    1b56:	fd 01       	movw	r30, r26
    1b58:	52 83       	std	Z+2, r21	; 0x02
    1b5a:	41 83       	std	Z+1, r20	; 0x01
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	ee 0f       	add	r30, r30
    1b60:	ff 1f       	adc	r31, r31
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ee 0f       	add	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	8e 0f       	add	r24, r30
    1b6c:	9f 1f       	adc	r25, r31
    1b6e:	fc 01       	movw	r30, r24
    1b70:	e4 58       	subi	r30, 0x84	; 132
    1b72:	fd 4f       	sbci	r31, 0xFD	; 253
    1b74:	01 80       	ldd	r0, Z+1	; 0x01
    1b76:	f2 81       	ldd	r31, Z+2	; 0x02
    1b78:	e0 2d       	mov	r30, r0
    1b7a:	86 81       	ldd	r24, Z+6	; 0x06
    1b7c:	97 81       	ldd	r25, Z+7	; 0x07
    1b7e:	90 93 a1 02 	sts	0x02A1, r25	; 0x8002a1 <pxCurrentTCB+0x1>
    1b82:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <pxCurrentTCB>
    1b86:	20 93 46 02 	sts	0x0246, r18	; 0x800246 <uxTopReadyPriority>
    1b8a:	08 95       	ret

00001b8c <vTaskSuspend>:
    1b8c:	0f 93       	push	r16
    1b8e:	1f 93       	push	r17
    1b90:	cf 93       	push	r28
    1b92:	df 93       	push	r29
    1b94:	ec 01       	movw	r28, r24
    1b96:	0f b6       	in	r0, 0x3f	; 63
    1b98:	f8 94       	cli
    1b9a:	0f 92       	push	r0
    1b9c:	89 2b       	or	r24, r25
    1b9e:	21 f4       	brne	.+8      	; 0x1ba8 <vTaskSuspend+0x1c>
    1ba0:	c0 91 a0 02 	lds	r28, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1ba4:	d0 91 a1 02 	lds	r29, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1ba8:	8e 01       	movw	r16, r28
    1baa:	0e 5f       	subi	r16, 0xFE	; 254
    1bac:	1f 4f       	sbci	r17, 0xFF	; 255
    1bae:	c8 01       	movw	r24, r16
    1bb0:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1bb4:	8c 89       	ldd	r24, Y+20	; 0x14
    1bb6:	9d 89       	ldd	r25, Y+21	; 0x15
    1bb8:	89 2b       	or	r24, r25
    1bba:	21 f0       	breq	.+8      	; 0x1bc4 <vTaskSuspend+0x38>
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	0c 96       	adiw	r24, 0x0c	; 12
    1bc0:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1bc4:	b8 01       	movw	r22, r16
    1bc6:	8a e4       	ldi	r24, 0x4A	; 74
    1bc8:	92 e0       	ldi	r25, 0x02	; 2
    1bca:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1bce:	0f 90       	pop	r0
    1bd0:	0f be       	out	0x3f, r0	; 63
    1bd2:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    1bd6:	88 23       	and	r24, r24
    1bd8:	31 f0       	breq	.+12     	; 0x1be6 <vTaskSuspend+0x5a>
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	1b dc       	rcall	.-1994   	; 0x1418 <prvResetNextTaskUnblockTime>
    1be2:	0f 90       	pop	r0
    1be4:	0f be       	out	0x3f, r0	; 63
    1be6:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1bea:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1bee:	c8 17       	cp	r28, r24
    1bf0:	d9 07       	cpc	r29, r25
    1bf2:	99 f4       	brne	.+38     	; 0x1c1a <vTaskSuspend+0x8e>
    1bf4:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xSchedulerRunning>
    1bf8:	88 23       	and	r24, r24
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <vTaskSuspend+0x76>
    1bfc:	0e 94 16 04 	call	0x82c	; 0x82c <vPortYield>
    1c00:	0c c0       	rjmp	.+24     	; 0x1c1a <vTaskSuspend+0x8e>
    1c02:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <uxCurrentNumberOfTasks>
    1c06:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <xSuspendedTaskList>
    1c0a:	98 13       	cpse	r25, r24
    1c0c:	05 c0       	rjmp	.+10     	; 0x1c18 <vTaskSuspend+0x8c>
    1c0e:	10 92 a1 02 	sts	0x02A1, r1	; 0x8002a1 <pxCurrentTCB+0x1>
    1c12:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <pxCurrentTCB>
    1c16:	01 c0       	rjmp	.+2      	; 0x1c1a <vTaskSuspend+0x8e>
    1c18:	38 df       	rcall	.-400    	; 0x1a8a <vTaskSwitchContext>
    1c1a:	df 91       	pop	r29
    1c1c:	cf 91       	pop	r28
    1c1e:	1f 91       	pop	r17
    1c20:	0f 91       	pop	r16
    1c22:	08 95       	ret

00001c24 <vTaskPlaceOnEventList>:
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	eb 01       	movw	r28, r22
    1c2a:	60 91 a0 02 	lds	r22, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1c2e:	70 91 a1 02 	lds	r23, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1c32:	64 5f       	subi	r22, 0xF4	; 244
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsert>
    1c3a:	61 e0       	ldi	r22, 0x01	; 1
    1c3c:	ce 01       	movw	r24, r28
    1c3e:	0b dc       	rcall	.-2026   	; 0x1456 <prvAddCurrentTaskToDelayedList>
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	08 95       	ret

00001c46 <xTaskRemoveFromEventList>:
    1c46:	0f 93       	push	r16
    1c48:	1f 93       	push	r17
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	dc 01       	movw	r26, r24
    1c50:	15 96       	adiw	r26, 0x05	; 5
    1c52:	ed 91       	ld	r30, X+
    1c54:	fc 91       	ld	r31, X
    1c56:	16 97       	sbiw	r26, 0x06	; 6
    1c58:	c6 81       	ldd	r28, Z+6	; 0x06
    1c5a:	d7 81       	ldd	r29, Z+7	; 0x07
    1c5c:	8e 01       	movw	r16, r28
    1c5e:	04 5f       	subi	r16, 0xF4	; 244
    1c60:	1f 4f       	sbci	r17, 0xFF	; 255
    1c62:	c8 01       	movw	r24, r16
    1c64:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1c68:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <uxSchedulerSuspended>
    1c6c:	81 11       	cpse	r24, r1
    1c6e:	1c c0       	rjmp	.+56     	; 0x1ca8 <xTaskRemoveFromEventList+0x62>
    1c70:	0a 50       	subi	r16, 0x0A	; 10
    1c72:	11 09       	sbc	r17, r1
    1c74:	c8 01       	movw	r24, r16
    1c76:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1c7a:	8e 89       	ldd	r24, Y+22	; 0x16
    1c7c:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1c80:	98 17       	cp	r25, r24
    1c82:	10 f4       	brcc	.+4      	; 0x1c88 <xTaskRemoveFromEventList+0x42>
    1c84:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	9c 01       	movw	r18, r24
    1c8c:	22 0f       	add	r18, r18
    1c8e:	33 1f       	adc	r19, r19
    1c90:	22 0f       	add	r18, r18
    1c92:	33 1f       	adc	r19, r19
    1c94:	22 0f       	add	r18, r18
    1c96:	33 1f       	adc	r19, r19
    1c98:	82 0f       	add	r24, r18
    1c9a:	93 1f       	adc	r25, r19
    1c9c:	b8 01       	movw	r22, r16
    1c9e:	84 58       	subi	r24, 0x84	; 132
    1ca0:	9d 4f       	sbci	r25, 0xFD	; 253
    1ca2:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1ca6:	05 c0       	rjmp	.+10     	; 0x1cb2 <xTaskRemoveFromEventList+0x6c>
    1ca8:	b8 01       	movw	r22, r16
    1caa:	8d e5       	ldi	r24, 0x5D	; 93
    1cac:	92 e0       	ldi	r25, 0x02	; 2
    1cae:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1cb2:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1cb6:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1cba:	9e 89       	ldd	r25, Y+22	; 0x16
    1cbc:	86 89       	ldd	r24, Z+22	; 0x16
    1cbe:	89 17       	cp	r24, r25
    1cc0:	20 f4       	brcc	.+8      	; 0x1cca <xTaskRemoveFromEventList+0x84>
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    1cc8:	01 c0       	rjmp	.+2      	; 0x1ccc <xTaskRemoveFromEventList+0x86>
    1cca:	80 e0       	ldi	r24, 0x00	; 0
    1ccc:	df 91       	pop	r29
    1cce:	cf 91       	pop	r28
    1cd0:	1f 91       	pop	r17
    1cd2:	0f 91       	pop	r16
    1cd4:	08 95       	ret

00001cd6 <vTaskSetTimeOutState>:
    1cd6:	20 91 42 02 	lds	r18, 0x0242	; 0x800242 <xNumOfOverflows>
    1cda:	fc 01       	movw	r30, r24
    1cdc:	20 83       	st	Z, r18
    1cde:	20 91 47 02 	lds	r18, 0x0247	; 0x800247 <xTickCount>
    1ce2:	30 91 48 02 	lds	r19, 0x0248	; 0x800248 <xTickCount+0x1>
    1ce6:	32 83       	std	Z+2, r19	; 0x02
    1ce8:	21 83       	std	Z+1, r18	; 0x01
    1cea:	08 95       	ret

00001cec <xTaskCheckForTimeOut>:
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	0f 92       	push	r0
    1cf2:	40 91 47 02 	lds	r20, 0x0247	; 0x800247 <xTickCount>
    1cf6:	50 91 48 02 	lds	r21, 0x0248	; 0x800248 <xTickCount+0x1>
    1cfa:	db 01       	movw	r26, r22
    1cfc:	2d 91       	ld	r18, X+
    1cfe:	3c 91       	ld	r19, X
    1d00:	2f 3f       	cpi	r18, 0xFF	; 255
    1d02:	bf ef       	ldi	r27, 0xFF	; 255
    1d04:	3b 07       	cpc	r19, r27
    1d06:	11 f1       	breq	.+68     	; 0x1d4c <xTaskCheckForTimeOut+0x60>
    1d08:	e0 91 42 02 	lds	r30, 0x0242	; 0x800242 <xNumOfOverflows>
    1d0c:	dc 01       	movw	r26, r24
    1d0e:	fc 91       	ld	r31, X
    1d10:	fe 17       	cp	r31, r30
    1d12:	39 f0       	breq	.+14     	; 0x1d22 <xTaskCheckForTimeOut+0x36>
    1d14:	11 96       	adiw	r26, 0x01	; 1
    1d16:	ed 91       	ld	r30, X+
    1d18:	fc 91       	ld	r31, X
    1d1a:	12 97       	sbiw	r26, 0x02	; 2
    1d1c:	4e 17       	cp	r20, r30
    1d1e:	5f 07       	cpc	r21, r31
    1d20:	b8 f4       	brcc	.+46     	; 0x1d50 <xTaskCheckForTimeOut+0x64>
    1d22:	dc 01       	movw	r26, r24
    1d24:	11 96       	adiw	r26, 0x01	; 1
    1d26:	ed 91       	ld	r30, X+
    1d28:	fc 91       	ld	r31, X
    1d2a:	12 97       	sbiw	r26, 0x02	; 2
    1d2c:	da 01       	movw	r26, r20
    1d2e:	ae 1b       	sub	r26, r30
    1d30:	bf 0b       	sbc	r27, r31
    1d32:	a2 17       	cp	r26, r18
    1d34:	b3 07       	cpc	r27, r19
    1d36:	70 f4       	brcc	.+28     	; 0x1d54 <xTaskCheckForTimeOut+0x68>
    1d38:	db 01       	movw	r26, r22
    1d3a:	e4 1b       	sub	r30, r20
    1d3c:	f5 0b       	sbc	r31, r21
    1d3e:	2e 0f       	add	r18, r30
    1d40:	3f 1f       	adc	r19, r31
    1d42:	2d 93       	st	X+, r18
    1d44:	3c 93       	st	X, r19
    1d46:	c7 df       	rcall	.-114    	; 0x1cd6 <vTaskSetTimeOutState>
    1d48:	80 e0       	ldi	r24, 0x00	; 0
    1d4a:	05 c0       	rjmp	.+10     	; 0x1d56 <xTaskCheckForTimeOut+0x6a>
    1d4c:	80 e0       	ldi	r24, 0x00	; 0
    1d4e:	03 c0       	rjmp	.+6      	; 0x1d56 <xTaskCheckForTimeOut+0x6a>
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	01 c0       	rjmp	.+2      	; 0x1d56 <xTaskCheckForTimeOut+0x6a>
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	0f 90       	pop	r0
    1d58:	0f be       	out	0x3f, r0	; 63
    1d5a:	08 95       	ret

00001d5c <vTaskMissedYield>:
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xYieldPending>
    1d62:	08 95       	ret

00001d64 <vTaskPriorityInherit>:
    1d64:	0f 93       	push	r16
    1d66:	1f 93       	push	r17
    1d68:	cf 93       	push	r28
    1d6a:	df 93       	push	r29
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	89 2b       	or	r24, r25
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <vTaskPriorityInherit+0x10>
    1d72:	55 c0       	rjmp	.+170    	; 0x1e1e <vTaskPriorityInherit+0xba>
    1d74:	26 89       	ldd	r18, Z+22	; 0x16
    1d76:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1d7a:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1d7e:	56 96       	adiw	r26, 0x16	; 22
    1d80:	8c 91       	ld	r24, X
    1d82:	28 17       	cp	r18, r24
    1d84:	08 f0       	brcs	.+2      	; 0x1d88 <vTaskPriorityInherit+0x24>
    1d86:	4b c0       	rjmp	.+150    	; 0x1e1e <vTaskPriorityInherit+0xba>
    1d88:	84 85       	ldd	r24, Z+12	; 0x0c
    1d8a:	95 85       	ldd	r25, Z+13	; 0x0d
    1d8c:	99 23       	and	r25, r25
    1d8e:	64 f0       	brlt	.+24     	; 0x1da8 <vTaskPriorityInherit+0x44>
    1d90:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1d94:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1d98:	56 96       	adiw	r26, 0x16	; 22
    1d9a:	3c 91       	ld	r19, X
    1d9c:	84 e0       	ldi	r24, 0x04	; 4
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	83 1b       	sub	r24, r19
    1da2:	91 09       	sbc	r25, r1
    1da4:	95 87       	std	Z+13, r25	; 0x0d
    1da6:	84 87       	std	Z+12, r24	; 0x0c
    1da8:	30 e0       	ldi	r19, 0x00	; 0
    1daa:	c9 01       	movw	r24, r18
    1dac:	88 0f       	add	r24, r24
    1dae:	99 1f       	adc	r25, r25
    1db0:	88 0f       	add	r24, r24
    1db2:	99 1f       	adc	r25, r25
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	28 0f       	add	r18, r24
    1dba:	39 1f       	adc	r19, r25
    1dbc:	24 58       	subi	r18, 0x84	; 132
    1dbe:	3d 4f       	sbci	r19, 0xFD	; 253
    1dc0:	82 85       	ldd	r24, Z+10	; 0x0a
    1dc2:	93 85       	ldd	r25, Z+11	; 0x0b
    1dc4:	82 17       	cp	r24, r18
    1dc6:	93 07       	cpc	r25, r19
    1dc8:	19 f5       	brne	.+70     	; 0x1e10 <vTaskPriorityInherit+0xac>
    1dca:	8f 01       	movw	r16, r30
    1dcc:	ef 01       	movw	r28, r30
    1dce:	22 96       	adiw	r28, 0x02	; 2
    1dd0:	ce 01       	movw	r24, r28
    1dd2:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1dd6:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1dda:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1dde:	86 89       	ldd	r24, Z+22	; 0x16
    1de0:	f8 01       	movw	r30, r16
    1de2:	86 8b       	std	Z+22, r24	; 0x16
    1de4:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1de8:	98 17       	cp	r25, r24
    1dea:	10 f4       	brcc	.+4      	; 0x1df0 <vTaskPriorityInherit+0x8c>
    1dec:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	9c 01       	movw	r18, r24
    1df4:	22 0f       	add	r18, r18
    1df6:	33 1f       	adc	r19, r19
    1df8:	22 0f       	add	r18, r18
    1dfa:	33 1f       	adc	r19, r19
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	82 0f       	add	r24, r18
    1e02:	93 1f       	adc	r25, r19
    1e04:	be 01       	movw	r22, r28
    1e06:	84 58       	subi	r24, 0x84	; 132
    1e08:	9d 4f       	sbci	r25, 0xFD	; 253
    1e0a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1e0e:	07 c0       	rjmp	.+14     	; 0x1e1e <vTaskPriorityInherit+0xba>
    1e10:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1e14:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1e18:	56 96       	adiw	r26, 0x16	; 22
    1e1a:	8c 91       	ld	r24, X
    1e1c:	86 8b       	std	Z+22, r24	; 0x16
    1e1e:	df 91       	pop	r29
    1e20:	cf 91       	pop	r28
    1e22:	1f 91       	pop	r17
    1e24:	0f 91       	pop	r16
    1e26:	08 95       	ret

00001e28 <xTaskPriorityDisinherit>:
    1e28:	0f 93       	push	r16
    1e2a:	1f 93       	push	r17
    1e2c:	cf 93       	push	r28
    1e2e:	df 93       	push	r29
    1e30:	fc 01       	movw	r30, r24
    1e32:	89 2b       	or	r24, r25
    1e34:	79 f1       	breq	.+94     	; 0x1e94 <xTaskPriorityDisinherit+0x6c>
    1e36:	82 a1       	ldd	r24, Z+34	; 0x22
    1e38:	81 50       	subi	r24, 0x01	; 1
    1e3a:	82 a3       	std	Z+34, r24	; 0x22
    1e3c:	26 89       	ldd	r18, Z+22	; 0x16
    1e3e:	91 a1       	ldd	r25, Z+33	; 0x21
    1e40:	29 17       	cp	r18, r25
    1e42:	51 f1       	breq	.+84     	; 0x1e98 <xTaskPriorityDisinherit+0x70>
    1e44:	81 11       	cpse	r24, r1
    1e46:	2a c0       	rjmp	.+84     	; 0x1e9c <xTaskPriorityDisinherit+0x74>
    1e48:	ef 01       	movw	r28, r30
    1e4a:	8f 01       	movw	r16, r30
    1e4c:	0e 5f       	subi	r16, 0xFE	; 254
    1e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e50:	c8 01       	movw	r24, r16
    1e52:	0e 94 38 03 	call	0x670	; 0x670 <uxListRemove>
    1e56:	89 a1       	ldd	r24, Y+33	; 0x21
    1e58:	8e 8b       	std	Y+22, r24	; 0x16
    1e5a:	24 e0       	ldi	r18, 0x04	; 4
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	28 1b       	sub	r18, r24
    1e60:	31 09       	sbc	r19, r1
    1e62:	3d 87       	std	Y+13, r19	; 0x0d
    1e64:	2c 87       	std	Y+12, r18	; 0x0c
    1e66:	90 91 46 02 	lds	r25, 0x0246	; 0x800246 <uxTopReadyPriority>
    1e6a:	98 17       	cp	r25, r24
    1e6c:	10 f4       	brcc	.+4      	; 0x1e72 <xTaskPriorityDisinherit+0x4a>
    1e6e:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <uxTopReadyPriority>
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	9c 01       	movw	r18, r24
    1e76:	22 0f       	add	r18, r18
    1e78:	33 1f       	adc	r19, r19
    1e7a:	22 0f       	add	r18, r18
    1e7c:	33 1f       	adc	r19, r19
    1e7e:	22 0f       	add	r18, r18
    1e80:	33 1f       	adc	r19, r19
    1e82:	82 0f       	add	r24, r18
    1e84:	93 1f       	adc	r25, r19
    1e86:	b8 01       	movw	r22, r16
    1e88:	84 58       	subi	r24, 0x84	; 132
    1e8a:	9d 4f       	sbci	r25, 0xFD	; 253
    1e8c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInsertEnd>
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	05 c0       	rjmp	.+10     	; 0x1e9e <xTaskPriorityDisinherit+0x76>
    1e94:	80 e0       	ldi	r24, 0x00	; 0
    1e96:	03 c0       	rjmp	.+6      	; 0x1e9e <xTaskPriorityDisinherit+0x76>
    1e98:	80 e0       	ldi	r24, 0x00	; 0
    1e9a:	01 c0       	rjmp	.+2      	; 0x1e9e <xTaskPriorityDisinherit+0x76>
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	1f 91       	pop	r17
    1ea4:	0f 91       	pop	r16
    1ea6:	08 95       	ret

00001ea8 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1ea8:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1eac:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1eb0:	89 2b       	or	r24, r25
    1eb2:	39 f0       	breq	.+14     	; 0x1ec2 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1eb4:	e0 91 a0 02 	lds	r30, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1eb8:	f0 91 a1 02 	lds	r31, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
    1ebc:	82 a1       	ldd	r24, Z+34	; 0x22
    1ebe:	8f 5f       	subi	r24, 0xFF	; 255
    1ec0:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1ec2:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pxCurrentTCB>
    1ec6:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pxCurrentTCB+0x1>
	}
    1eca:	08 95       	ret

00001ecc <TaakVerlaag>:
void writeInt(int16_t nr)
{
	char buffer[8];
	itoa(nr,buffer,10);
	writeString(buffer);
}
    1ecc:	c2 ea       	ldi	r28, 0xA2	; 162
    1ece:	d2 e0       	ldi	r29, 0x02	; 2
    1ed0:	0f 2e       	mov	r0, r31
    1ed2:	f0 ea       	ldi	r31, 0xA0	; 160
    1ed4:	cf 2e       	mov	r12, r31
    1ed6:	f6 e8       	ldi	r31, 0x86	; 134
    1ed8:	df 2e       	mov	r13, r31
    1eda:	ee 24       	eor	r14, r14
    1edc:	e3 94       	inc	r14
    1ede:	f1 2c       	mov	r15, r1
    1ee0:	f0 2d       	mov	r31, r0
    1ee2:	20 e0       	ldi	r18, 0x00	; 0
    1ee4:	4f ef       	ldi	r20, 0xFF	; 255
    1ee6:	5f ef       	ldi	r21, 0xFF	; 255
    1ee8:	60 e0       	ldi	r22, 0x00	; 0
    1eea:	70 e0       	ldi	r23, 0x00	; 0
    1eec:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <sem>
    1ef0:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <sem+0x1>
    1ef4:	0e 94 b8 06 	call	0xd70	; 0xd70 <xQueueGenericReceive>
    1ef8:	88 81       	ld	r24, Y
    1efa:	99 81       	ldd	r25, Y+1	; 0x01
    1efc:	01 97       	sbiw	r24, 0x01	; 1
    1efe:	09 2e       	mov	r0, r25
    1f00:	00 0c       	add	r0, r0
    1f02:	aa 0b       	sbc	r26, r26
    1f04:	bb 0b       	sbc	r27, r27
    1f06:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <waarde>
    1f0a:	90 93 a3 02 	sts	0x02A3, r25	; 0x8002a3 <waarde+0x1>
    1f0e:	a0 93 a4 02 	sts	0x02A4, r26	; 0x8002a4 <waarde+0x2>
    1f12:	b0 93 a5 02 	sts	0x02A5, r27	; 0x8002a5 <waarde+0x3>
    1f16:	20 e0       	ldi	r18, 0x00	; 0
    1f18:	40 e0       	ldi	r20, 0x00	; 0
    1f1a:	50 e0       	ldi	r21, 0x00	; 0
    1f1c:	60 e0       	ldi	r22, 0x00	; 0
    1f1e:	70 e0       	ldi	r23, 0x00	; 0
    1f20:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <sem>
    1f24:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <sem+0x1>
    1f28:	0e 94 26 06 	call	0xc4c	; 0xc4c <xQueueGenericSend>
    1f2c:	81 e0       	ldi	r24, 0x01	; 1
    1f2e:	c8 1a       	sub	r12, r24
    1f30:	d1 08       	sbc	r13, r1
    1f32:	e1 08       	sbc	r14, r1
    1f34:	f1 08       	sbc	r15, r1
    1f36:	a9 f6       	brne	.-86     	; 0x1ee2 <TaakVerlaag+0x16>
    1f38:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <verlaagHandle>
    1f3c:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <verlaagHandle+0x1>
    1f40:	25 de       	rcall	.-950    	; 0x1b8c <vTaskSuspend>
    1f42:	c6 cf       	rjmp	.-116    	; 0x1ed0 <TaakVerlaag+0x4>

00001f44 <TaakVerhoog>:
    1f44:	c2 ea       	ldi	r28, 0xA2	; 162
    1f46:	d2 e0       	ldi	r29, 0x02	; 2
    1f48:	0f 2e       	mov	r0, r31
    1f4a:	f0 ea       	ldi	r31, 0xA0	; 160
    1f4c:	cf 2e       	mov	r12, r31
    1f4e:	f6 e8       	ldi	r31, 0x86	; 134
    1f50:	df 2e       	mov	r13, r31
    1f52:	ee 24       	eor	r14, r14
    1f54:	e3 94       	inc	r14
    1f56:	f1 2c       	mov	r15, r1
    1f58:	f0 2d       	mov	r31, r0
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	4f ef       	ldi	r20, 0xFF	; 255
    1f5e:	5f ef       	ldi	r21, 0xFF	; 255
    1f60:	60 e0       	ldi	r22, 0x00	; 0
    1f62:	70 e0       	ldi	r23, 0x00	; 0
    1f64:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <sem>
    1f68:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <sem+0x1>
    1f6c:	0e 94 b8 06 	call	0xd70	; 0xd70 <xQueueGenericReceive>
    1f70:	88 81       	ld	r24, Y
    1f72:	99 81       	ldd	r25, Y+1	; 0x01
    1f74:	01 96       	adiw	r24, 0x01	; 1
    1f76:	09 2e       	mov	r0, r25
    1f78:	00 0c       	add	r0, r0
    1f7a:	aa 0b       	sbc	r26, r26
    1f7c:	bb 0b       	sbc	r27, r27
    1f7e:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <waarde>
    1f82:	90 93 a3 02 	sts	0x02A3, r25	; 0x8002a3 <waarde+0x1>
    1f86:	a0 93 a4 02 	sts	0x02A4, r26	; 0x8002a4 <waarde+0x2>
    1f8a:	b0 93 a5 02 	sts	0x02A5, r27	; 0x8002a5 <waarde+0x3>
    1f8e:	20 e0       	ldi	r18, 0x00	; 0
    1f90:	40 e0       	ldi	r20, 0x00	; 0
    1f92:	50 e0       	ldi	r21, 0x00	; 0
    1f94:	60 e0       	ldi	r22, 0x00	; 0
    1f96:	70 e0       	ldi	r23, 0x00	; 0
    1f98:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <sem>
    1f9c:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <sem+0x1>
    1fa0:	0e 94 26 06 	call	0xc4c	; 0xc4c <xQueueGenericSend>
    1fa4:	81 e0       	ldi	r24, 0x01	; 1
    1fa6:	c8 1a       	sub	r12, r24
    1fa8:	d1 08       	sbc	r13, r1
    1faa:	e1 08       	sbc	r14, r1
    1fac:	f1 08       	sbc	r15, r1
    1fae:	a9 f6       	brne	.-86     	; 0x1f5a <TaakVerhoog+0x16>
    1fb0:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <verhoogHandle>
    1fb4:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <verhoogHandle+0x1>
    1fb8:	e9 dd       	rcall	.-1070   	; 0x1b8c <vTaskSuspend>
    1fba:	c6 cf       	rjmp	.-116    	; 0x1f48 <TaakVerhoog+0x4>

00001fbc <initUsart0>:
    1fbc:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1fc0:	88 e1       	ldi	r24, 0x18	; 24
    1fc2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1fc6:	86 e0       	ldi	r24, 0x06	; 6
    1fc8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1fcc:	87 e6       	ldi	r24, 0x67	; 103
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1fd4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1fd8:	08 95       	ret

00001fda <main>:
    1fda:	ef 92       	push	r14
    1fdc:	ff 92       	push	r15
    1fde:	0f 93       	push	r16
    1fe0:	ed df       	rcall	.-38     	; 0x1fbc <initUsart0>
    1fe2:	43 e0       	ldi	r20, 0x03	; 3
    1fe4:	60 e0       	ldi	r22, 0x00	; 0
    1fe6:	81 e0       	ldi	r24, 0x01	; 1
    1fe8:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xQueueGenericCreate>
    1fec:	90 93 3b 03 	sts	0x033B, r25	; 0x80033b <sem+0x1>
    1ff0:	80 93 3a 03 	sts	0x033A, r24	; 0x80033a <sem>
    1ff4:	0f 2e       	mov	r0, r31
    1ff6:	f8 ea       	ldi	r31, 0xA8	; 168
    1ff8:	ef 2e       	mov	r14, r31
    1ffa:	f2 e0       	ldi	r31, 0x02	; 2
    1ffc:	ff 2e       	mov	r15, r31
    1ffe:	f0 2d       	mov	r31, r0
    2000:	03 e0       	ldi	r16, 0x03	; 3
    2002:	20 e0       	ldi	r18, 0x00	; 0
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	40 e0       	ldi	r20, 0x00	; 0
    2008:	51 e0       	ldi	r21, 0x01	; 1
    200a:	6c e0       	ldi	r22, 0x0C	; 12
    200c:	72 e0       	ldi	r23, 0x02	; 2
    200e:	82 ea       	ldi	r24, 0xA2	; 162
    2010:	9f e0       	ldi	r25, 0x0F	; 15
    2012:	75 da       	rcall	.-2838   	; 0x14fe <xTaskCreate>
    2014:	e0 90 a6 02 	lds	r14, 0x02A6	; 0x8002a6 <verlaagHandle>
    2018:	f0 90 a7 02 	lds	r15, 0x02A7	; 0x8002a7 <verlaagHandle+0x1>
    201c:	20 e0       	ldi	r18, 0x00	; 0
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	40 e0       	ldi	r20, 0x00	; 0
    2022:	51 e0       	ldi	r21, 0x01	; 1
    2024:	64 e1       	ldi	r22, 0x14	; 20
    2026:	72 e0       	ldi	r23, 0x02	; 2
    2028:	86 e6       	ldi	r24, 0x66	; 102
    202a:	9f e0       	ldi	r25, 0x0F	; 15
    202c:	68 da       	rcall	.-2864   	; 0x14fe <xTaskCreate>
    202e:	c7 db       	rcall	.-2162   	; 0x17be <vTaskStartScheduler>
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	0f 91       	pop	r16
    2036:	ff 90       	pop	r15
    2038:	ef 90       	pop	r14
    203a:	08 95       	ret

0000203c <writeChar>:
    203c:	e0 ec       	ldi	r30, 0xC0	; 192
    203e:	f0 e0       	ldi	r31, 0x00	; 0
    2040:	90 81       	ld	r25, Z
    2042:	95 ff       	sbrs	r25, 5
    2044:	fd cf       	rjmp	.-6      	; 0x2040 <writeChar+0x4>
    2046:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    204a:	08 95       	ret

0000204c <writeString>:
    204c:	cf 93       	push	r28
    204e:	df 93       	push	r29
    2050:	ec 01       	movw	r28, r24
    2052:	88 81       	ld	r24, Y
    2054:	88 23       	and	r24, r24
    2056:	29 f0       	breq	.+10     	; 0x2062 <writeString+0x16>
    2058:	21 96       	adiw	r28, 0x01	; 1
    205a:	f0 df       	rcall	.-32     	; 0x203c <writeChar>
    205c:	89 91       	ld	r24, Y+
    205e:	81 11       	cpse	r24, r1
    2060:	fc cf       	rjmp	.-8      	; 0x205a <writeString+0xe>
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	08 95       	ret

00002068 <writeULong>:

void writeULong(unsigned long nr)
{
    2068:	cf 93       	push	r28
    206a:	df 93       	push	r29
    206c:	cd b7       	in	r28, 0x3d	; 61
    206e:	de b7       	in	r29, 0x3e	; 62
    2070:	68 97       	sbiw	r28, 0x18	; 24
    2072:	0f b6       	in	r0, 0x3f	; 63
    2074:	f8 94       	cli
    2076:	de bf       	out	0x3e, r29	; 62
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__ultoa_ncheck (unsigned long, char *, unsigned char);
	return __ultoa_ncheck (__val, __s, __radix);
    207c:	2a e0       	ldi	r18, 0x0A	; 10
    207e:	ae 01       	movw	r20, r28
    2080:	4f 5f       	subi	r20, 0xFF	; 255
    2082:	5f 4f       	sbci	r21, 0xFF	; 255
    2084:	73 d1       	rcall	.+742    	; 0x236c <__ultoa_ncheck>
	char buffer[24];
	ultoa(nr,buffer,10);
	writeString(buffer);
    2086:	ce 01       	movw	r24, r28
    2088:	01 96       	adiw	r24, 0x01	; 1
    208a:	e0 df       	rcall	.-64     	; 0x204c <writeString>
}
    208c:	68 96       	adiw	r28, 0x18	; 24
    208e:	0f b6       	in	r0, 0x3f	; 63
    2090:	f8 94       	cli
    2092:	de bf       	out	0x3e, r29	; 62
    2094:	0f be       	out	0x3f, r0	; 63
    2096:	cd bf       	out	0x3d, r28	; 61
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	08 95       	ret

0000209e <vApplicationIdleHook>:
TaskHandle_t verlaagHandle = NULL;
unsigned long waarde=0;
SemaphoreHandle_t sem; 

void vApplicationIdleHook( void ) {
	DDRL = 1 << PL2;
    209e:	84 e0       	ldi	r24, 0x04	; 4
    20a0:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <__TEXT_REGION_LENGTH__+0x70010a>
	
	while(1) {
		writeULong(waarde);
		writeString("\n\r");
		for(int x=0;x<20;x++) {
		     PORTL ^= (1 << PL2);
    20a4:	cb e0       	ldi	r28, 0x0B	; 11
    20a6:	d1 e0       	ldi	r29, 0x01	; 1
    20a8:	14 e0       	ldi	r17, 0x04	; 4

void vApplicationIdleHook( void ) {
	DDRL = 1 << PL2;
	
	while(1) {
		writeULong(waarde);
    20aa:	60 91 a2 02 	lds	r22, 0x02A2	; 0x8002a2 <waarde>
    20ae:	70 91 a3 02 	lds	r23, 0x02A3	; 0x8002a3 <waarde+0x1>
    20b2:	80 91 a4 02 	lds	r24, 0x02A4	; 0x8002a4 <waarde+0x2>
    20b6:	90 91 a5 02 	lds	r25, 0x02A5	; 0x8002a5 <waarde+0x3>
    20ba:	d6 df       	rcall	.-84     	; 0x2068 <writeULong>
		writeString("\n\r");
    20bc:	8c e1       	ldi	r24, 0x1C	; 28
    20be:	92 e0       	ldi	r25, 0x02	; 2
    20c0:	c5 df       	rcall	.-118    	; 0x204c <writeString>
    20c2:	24 e1       	ldi	r18, 0x14	; 20
    20c4:	30 e0       	ldi	r19, 0x00	; 0
		for(int x=0;x<20;x++) {
		     PORTL ^= (1 << PL2);
    20c6:	88 81       	ld	r24, Y
    20c8:	81 27       	eor	r24, r17
    20ca:	88 83       	st	Y, r24
    20cc:	4f ef       	ldi	r20, 0xFF	; 255
    20ce:	83 ed       	ldi	r24, 0xD3	; 211
    20d0:	90 e3       	ldi	r25, 0x30	; 48
    20d2:	41 50       	subi	r20, 0x01	; 1
    20d4:	80 40       	sbci	r24, 0x00	; 0
    20d6:	90 40       	sbci	r25, 0x00	; 0
    20d8:	e1 f7       	brne	.-8      	; 0x20d2 <vApplicationIdleHook+0x34>
    20da:	00 c0       	rjmp	.+0      	; 0x20dc <vApplicationIdleHook+0x3e>
    20dc:	00 00       	nop
    20de:	21 50       	subi	r18, 0x01	; 1
    20e0:	31 09       	sbc	r19, r1
	DDRL = 1 << PL2;
	
	while(1) {
		writeULong(waarde);
		writeString("\n\r");
		for(int x=0;x<20;x++) {
    20e2:	89 f7       	brne	.-30     	; 0x20c6 <vApplicationIdleHook+0x28>
		     PORTL ^= (1 << PL2);
	         _delay_ms(1000);
		}
		vTaskResume(verlaagHandle);
    20e4:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <verlaagHandle>
    20e8:	90 91 a7 02 	lds	r25, 0x02A7	; 0x8002a7 <verlaagHandle+0x1>
    20ec:	1a db       	rcall	.-2508   	; 0x1722 <vTaskResume>
		vTaskResume(verhoogHandle);		
    20ee:	80 91 a8 02 	lds	r24, 0x02A8	; 0x8002a8 <verhoogHandle>
    20f2:	90 91 a9 02 	lds	r25, 0x02A9	; 0x8002a9 <verhoogHandle+0x1>
    20f6:	15 db       	rcall	.-2518   	; 0x1722 <vTaskResume>
	}	
    20f8:	d8 cf       	rjmp	.-80     	; 0x20aa <vApplicationIdleHook+0xc>

000020fa <__tablejump2__>:
    20fa:	ee 0f       	add	r30, r30
    20fc:	ff 1f       	adc	r31, r31
    20fe:	88 1f       	adc	r24, r24
    2100:	8b bf       	out	0x3b, r24	; 59
    2102:	07 90       	elpm	r0, Z+
    2104:	f6 91       	elpm	r31, Z
    2106:	e0 2d       	mov	r30, r0
    2108:	19 94       	eijmp

0000210a <malloc>:
    210a:	0f 93       	push	r16
    210c:	1f 93       	push	r17
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	82 30       	cpi	r24, 0x02	; 2
    2114:	91 05       	cpc	r25, r1
    2116:	10 f4       	brcc	.+4      	; 0x211c <malloc+0x12>
    2118:	82 e0       	ldi	r24, 0x02	; 2
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	e0 91 3e 03 	lds	r30, 0x033E	; 0x80033e <__flp>
    2120:	f0 91 3f 03 	lds	r31, 0x033F	; 0x80033f <__flp+0x1>
    2124:	20 e0       	ldi	r18, 0x00	; 0
    2126:	30 e0       	ldi	r19, 0x00	; 0
    2128:	a0 e0       	ldi	r26, 0x00	; 0
    212a:	b0 e0       	ldi	r27, 0x00	; 0
    212c:	30 97       	sbiw	r30, 0x00	; 0
    212e:	19 f1       	breq	.+70     	; 0x2176 <malloc+0x6c>
    2130:	40 81       	ld	r20, Z
    2132:	51 81       	ldd	r21, Z+1	; 0x01
    2134:	02 81       	ldd	r16, Z+2	; 0x02
    2136:	13 81       	ldd	r17, Z+3	; 0x03
    2138:	48 17       	cp	r20, r24
    213a:	59 07       	cpc	r21, r25
    213c:	c8 f0       	brcs	.+50     	; 0x2170 <malloc+0x66>
    213e:	84 17       	cp	r24, r20
    2140:	95 07       	cpc	r25, r21
    2142:	69 f4       	brne	.+26     	; 0x215e <malloc+0x54>
    2144:	10 97       	sbiw	r26, 0x00	; 0
    2146:	31 f0       	breq	.+12     	; 0x2154 <malloc+0x4a>
    2148:	12 96       	adiw	r26, 0x02	; 2
    214a:	0c 93       	st	X, r16
    214c:	12 97       	sbiw	r26, 0x02	; 2
    214e:	13 96       	adiw	r26, 0x03	; 3
    2150:	1c 93       	st	X, r17
    2152:	27 c0       	rjmp	.+78     	; 0x21a2 <malloc+0x98>
    2154:	00 93 3e 03 	sts	0x033E, r16	; 0x80033e <__flp>
    2158:	10 93 3f 03 	sts	0x033F, r17	; 0x80033f <__flp+0x1>
    215c:	22 c0       	rjmp	.+68     	; 0x21a2 <malloc+0x98>
    215e:	21 15       	cp	r18, r1
    2160:	31 05       	cpc	r19, r1
    2162:	19 f0       	breq	.+6      	; 0x216a <malloc+0x60>
    2164:	42 17       	cp	r20, r18
    2166:	53 07       	cpc	r21, r19
    2168:	18 f4       	brcc	.+6      	; 0x2170 <malloc+0x66>
    216a:	9a 01       	movw	r18, r20
    216c:	bd 01       	movw	r22, r26
    216e:	ef 01       	movw	r28, r30
    2170:	df 01       	movw	r26, r30
    2172:	f8 01       	movw	r30, r16
    2174:	db cf       	rjmp	.-74     	; 0x212c <malloc+0x22>
    2176:	21 15       	cp	r18, r1
    2178:	31 05       	cpc	r19, r1
    217a:	f9 f0       	breq	.+62     	; 0x21ba <malloc+0xb0>
    217c:	28 1b       	sub	r18, r24
    217e:	39 0b       	sbc	r19, r25
    2180:	24 30       	cpi	r18, 0x04	; 4
    2182:	31 05       	cpc	r19, r1
    2184:	80 f4       	brcc	.+32     	; 0x21a6 <malloc+0x9c>
    2186:	8a 81       	ldd	r24, Y+2	; 0x02
    2188:	9b 81       	ldd	r25, Y+3	; 0x03
    218a:	61 15       	cp	r22, r1
    218c:	71 05       	cpc	r23, r1
    218e:	21 f0       	breq	.+8      	; 0x2198 <malloc+0x8e>
    2190:	fb 01       	movw	r30, r22
    2192:	93 83       	std	Z+3, r25	; 0x03
    2194:	82 83       	std	Z+2, r24	; 0x02
    2196:	04 c0       	rjmp	.+8      	; 0x21a0 <malloc+0x96>
    2198:	90 93 3f 03 	sts	0x033F, r25	; 0x80033f <__flp+0x1>
    219c:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <__flp>
    21a0:	fe 01       	movw	r30, r28
    21a2:	32 96       	adiw	r30, 0x02	; 2
    21a4:	44 c0       	rjmp	.+136    	; 0x222e <__stack+0x2f>
    21a6:	fe 01       	movw	r30, r28
    21a8:	e2 0f       	add	r30, r18
    21aa:	f3 1f       	adc	r31, r19
    21ac:	81 93       	st	Z+, r24
    21ae:	91 93       	st	Z+, r25
    21b0:	22 50       	subi	r18, 0x02	; 2
    21b2:	31 09       	sbc	r19, r1
    21b4:	39 83       	std	Y+1, r19	; 0x01
    21b6:	28 83       	st	Y, r18
    21b8:	3a c0       	rjmp	.+116    	; 0x222e <__stack+0x2f>
    21ba:	20 91 3c 03 	lds	r18, 0x033C	; 0x80033c <__brkval>
    21be:	30 91 3d 03 	lds	r19, 0x033D	; 0x80033d <__brkval+0x1>
    21c2:	23 2b       	or	r18, r19
    21c4:	41 f4       	brne	.+16     	; 0x21d6 <malloc+0xcc>
    21c6:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    21ca:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    21ce:	30 93 3d 03 	sts	0x033D, r19	; 0x80033d <__brkval+0x1>
    21d2:	20 93 3c 03 	sts	0x033C, r18	; 0x80033c <__brkval>
    21d6:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    21da:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    21de:	21 15       	cp	r18, r1
    21e0:	31 05       	cpc	r19, r1
    21e2:	41 f4       	brne	.+16     	; 0x21f4 <malloc+0xea>
    21e4:	2d b7       	in	r18, 0x3d	; 61
    21e6:	3e b7       	in	r19, 0x3e	; 62
    21e8:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    21ec:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    21f0:	24 1b       	sub	r18, r20
    21f2:	35 0b       	sbc	r19, r21
    21f4:	e0 91 3c 03 	lds	r30, 0x033C	; 0x80033c <__brkval>
    21f8:	f0 91 3d 03 	lds	r31, 0x033D	; 0x80033d <__brkval+0x1>
    21fc:	e2 17       	cp	r30, r18
    21fe:	f3 07       	cpc	r31, r19
    2200:	a0 f4       	brcc	.+40     	; 0x222a <__stack+0x2b>
    2202:	2e 1b       	sub	r18, r30
    2204:	3f 0b       	sbc	r19, r31
    2206:	28 17       	cp	r18, r24
    2208:	39 07       	cpc	r19, r25
    220a:	78 f0       	brcs	.+30     	; 0x222a <__stack+0x2b>
    220c:	ac 01       	movw	r20, r24
    220e:	4e 5f       	subi	r20, 0xFE	; 254
    2210:	5f 4f       	sbci	r21, 0xFF	; 255
    2212:	24 17       	cp	r18, r20
    2214:	35 07       	cpc	r19, r21
    2216:	48 f0       	brcs	.+18     	; 0x222a <__stack+0x2b>
    2218:	4e 0f       	add	r20, r30
    221a:	5f 1f       	adc	r21, r31
    221c:	50 93 3d 03 	sts	0x033D, r21	; 0x80033d <__brkval+0x1>
    2220:	40 93 3c 03 	sts	0x033C, r20	; 0x80033c <__brkval>
    2224:	81 93       	st	Z+, r24
    2226:	91 93       	st	Z+, r25
    2228:	02 c0       	rjmp	.+4      	; 0x222e <__stack+0x2f>
    222a:	e0 e0       	ldi	r30, 0x00	; 0
    222c:	f0 e0       	ldi	r31, 0x00	; 0
    222e:	cf 01       	movw	r24, r30
    2230:	df 91       	pop	r29
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	0f 91       	pop	r16
    2238:	08 95       	ret

0000223a <free>:
    223a:	cf 93       	push	r28
    223c:	df 93       	push	r29
    223e:	00 97       	sbiw	r24, 0x00	; 0
    2240:	09 f4       	brne	.+2      	; 0x2244 <free+0xa>
    2242:	81 c0       	rjmp	.+258    	; 0x2346 <free+0x10c>
    2244:	fc 01       	movw	r30, r24
    2246:	32 97       	sbiw	r30, 0x02	; 2
    2248:	13 82       	std	Z+3, r1	; 0x03
    224a:	12 82       	std	Z+2, r1	; 0x02
    224c:	a0 91 3e 03 	lds	r26, 0x033E	; 0x80033e <__flp>
    2250:	b0 91 3f 03 	lds	r27, 0x033F	; 0x80033f <__flp+0x1>
    2254:	10 97       	sbiw	r26, 0x00	; 0
    2256:	81 f4       	brne	.+32     	; 0x2278 <free+0x3e>
    2258:	20 81       	ld	r18, Z
    225a:	31 81       	ldd	r19, Z+1	; 0x01
    225c:	82 0f       	add	r24, r18
    225e:	93 1f       	adc	r25, r19
    2260:	20 91 3c 03 	lds	r18, 0x033C	; 0x80033c <__brkval>
    2264:	30 91 3d 03 	lds	r19, 0x033D	; 0x80033d <__brkval+0x1>
    2268:	28 17       	cp	r18, r24
    226a:	39 07       	cpc	r19, r25
    226c:	51 f5       	brne	.+84     	; 0x22c2 <free+0x88>
    226e:	f0 93 3d 03 	sts	0x033D, r31	; 0x80033d <__brkval+0x1>
    2272:	e0 93 3c 03 	sts	0x033C, r30	; 0x80033c <__brkval>
    2276:	67 c0       	rjmp	.+206    	; 0x2346 <free+0x10c>
    2278:	ed 01       	movw	r28, r26
    227a:	20 e0       	ldi	r18, 0x00	; 0
    227c:	30 e0       	ldi	r19, 0x00	; 0
    227e:	ce 17       	cp	r28, r30
    2280:	df 07       	cpc	r29, r31
    2282:	40 f4       	brcc	.+16     	; 0x2294 <free+0x5a>
    2284:	4a 81       	ldd	r20, Y+2	; 0x02
    2286:	5b 81       	ldd	r21, Y+3	; 0x03
    2288:	9e 01       	movw	r18, r28
    228a:	41 15       	cp	r20, r1
    228c:	51 05       	cpc	r21, r1
    228e:	f1 f0       	breq	.+60     	; 0x22cc <free+0x92>
    2290:	ea 01       	movw	r28, r20
    2292:	f5 cf       	rjmp	.-22     	; 0x227e <free+0x44>
    2294:	d3 83       	std	Z+3, r29	; 0x03
    2296:	c2 83       	std	Z+2, r28	; 0x02
    2298:	40 81       	ld	r20, Z
    229a:	51 81       	ldd	r21, Z+1	; 0x01
    229c:	84 0f       	add	r24, r20
    229e:	95 1f       	adc	r25, r21
    22a0:	c8 17       	cp	r28, r24
    22a2:	d9 07       	cpc	r29, r25
    22a4:	59 f4       	brne	.+22     	; 0x22bc <free+0x82>
    22a6:	88 81       	ld	r24, Y
    22a8:	99 81       	ldd	r25, Y+1	; 0x01
    22aa:	84 0f       	add	r24, r20
    22ac:	95 1f       	adc	r25, r21
    22ae:	02 96       	adiw	r24, 0x02	; 2
    22b0:	91 83       	std	Z+1, r25	; 0x01
    22b2:	80 83       	st	Z, r24
    22b4:	8a 81       	ldd	r24, Y+2	; 0x02
    22b6:	9b 81       	ldd	r25, Y+3	; 0x03
    22b8:	93 83       	std	Z+3, r25	; 0x03
    22ba:	82 83       	std	Z+2, r24	; 0x02
    22bc:	21 15       	cp	r18, r1
    22be:	31 05       	cpc	r19, r1
    22c0:	29 f4       	brne	.+10     	; 0x22cc <free+0x92>
    22c2:	f0 93 3f 03 	sts	0x033F, r31	; 0x80033f <__flp+0x1>
    22c6:	e0 93 3e 03 	sts	0x033E, r30	; 0x80033e <__flp>
    22ca:	3d c0       	rjmp	.+122    	; 0x2346 <free+0x10c>
    22cc:	e9 01       	movw	r28, r18
    22ce:	fb 83       	std	Y+3, r31	; 0x03
    22d0:	ea 83       	std	Y+2, r30	; 0x02
    22d2:	49 91       	ld	r20, Y+
    22d4:	59 91       	ld	r21, Y+
    22d6:	c4 0f       	add	r28, r20
    22d8:	d5 1f       	adc	r29, r21
    22da:	ec 17       	cp	r30, r28
    22dc:	fd 07       	cpc	r31, r29
    22de:	61 f4       	brne	.+24     	; 0x22f8 <free+0xbe>
    22e0:	80 81       	ld	r24, Z
    22e2:	91 81       	ldd	r25, Z+1	; 0x01
    22e4:	84 0f       	add	r24, r20
    22e6:	95 1f       	adc	r25, r21
    22e8:	02 96       	adiw	r24, 0x02	; 2
    22ea:	e9 01       	movw	r28, r18
    22ec:	99 83       	std	Y+1, r25	; 0x01
    22ee:	88 83       	st	Y, r24
    22f0:	82 81       	ldd	r24, Z+2	; 0x02
    22f2:	93 81       	ldd	r25, Z+3	; 0x03
    22f4:	9b 83       	std	Y+3, r25	; 0x03
    22f6:	8a 83       	std	Y+2, r24	; 0x02
    22f8:	e0 e0       	ldi	r30, 0x00	; 0
    22fa:	f0 e0       	ldi	r31, 0x00	; 0
    22fc:	12 96       	adiw	r26, 0x02	; 2
    22fe:	8d 91       	ld	r24, X+
    2300:	9c 91       	ld	r25, X
    2302:	13 97       	sbiw	r26, 0x03	; 3
    2304:	00 97       	sbiw	r24, 0x00	; 0
    2306:	19 f0       	breq	.+6      	; 0x230e <free+0xd4>
    2308:	fd 01       	movw	r30, r26
    230a:	dc 01       	movw	r26, r24
    230c:	f7 cf       	rjmp	.-18     	; 0x22fc <free+0xc2>
    230e:	8d 91       	ld	r24, X+
    2310:	9c 91       	ld	r25, X
    2312:	11 97       	sbiw	r26, 0x01	; 1
    2314:	9d 01       	movw	r18, r26
    2316:	2e 5f       	subi	r18, 0xFE	; 254
    2318:	3f 4f       	sbci	r19, 0xFF	; 255
    231a:	82 0f       	add	r24, r18
    231c:	93 1f       	adc	r25, r19
    231e:	20 91 3c 03 	lds	r18, 0x033C	; 0x80033c <__brkval>
    2322:	30 91 3d 03 	lds	r19, 0x033D	; 0x80033d <__brkval+0x1>
    2326:	28 17       	cp	r18, r24
    2328:	39 07       	cpc	r19, r25
    232a:	69 f4       	brne	.+26     	; 0x2346 <free+0x10c>
    232c:	30 97       	sbiw	r30, 0x00	; 0
    232e:	29 f4       	brne	.+10     	; 0x233a <free+0x100>
    2330:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <__flp+0x1>
    2334:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <__flp>
    2338:	02 c0       	rjmp	.+4      	; 0x233e <free+0x104>
    233a:	13 82       	std	Z+3, r1	; 0x03
    233c:	12 82       	std	Z+2, r1	; 0x02
    233e:	b0 93 3d 03 	sts	0x033D, r27	; 0x80033d <__brkval+0x1>
    2342:	a0 93 3c 03 	sts	0x033C, r26	; 0x80033c <__brkval>
    2346:	df 91       	pop	r29
    2348:	cf 91       	pop	r28
    234a:	08 95       	ret

0000234c <memcpy>:
    234c:	fb 01       	movw	r30, r22
    234e:	dc 01       	movw	r26, r24
    2350:	02 c0       	rjmp	.+4      	; 0x2356 <memcpy+0xa>
    2352:	01 90       	ld	r0, Z+
    2354:	0d 92       	st	X+, r0
    2356:	41 50       	subi	r20, 0x01	; 1
    2358:	50 40       	sbci	r21, 0x00	; 0
    235a:	d8 f7       	brcc	.-10     	; 0x2352 <memcpy+0x6>
    235c:	08 95       	ret

0000235e <memset>:
    235e:	dc 01       	movw	r26, r24
    2360:	01 c0       	rjmp	.+2      	; 0x2364 <memset+0x6>
    2362:	6d 93       	st	X+, r22
    2364:	41 50       	subi	r20, 0x01	; 1
    2366:	50 40       	sbci	r21, 0x00	; 0
    2368:	e0 f7       	brcc	.-8      	; 0x2362 <memset+0x4>
    236a:	08 95       	ret

0000236c <__ultoa_ncheck>:
    236c:	bb 27       	eor	r27, r27

0000236e <__ultoa_common>:
    236e:	fa 01       	movw	r30, r20
    2370:	a6 2f       	mov	r26, r22
    2372:	62 17       	cp	r22, r18
    2374:	71 05       	cpc	r23, r1
    2376:	81 05       	cpc	r24, r1
    2378:	91 05       	cpc	r25, r1
    237a:	33 0b       	sbc	r19, r19
    237c:	30 fb       	bst	r19, 0
    237e:	66 f0       	brts	.+24     	; 0x2398 <__ultoa_common+0x2a>
    2380:	aa 27       	eor	r26, r26
    2382:	66 0f       	add	r22, r22
    2384:	77 1f       	adc	r23, r23
    2386:	88 1f       	adc	r24, r24
    2388:	99 1f       	adc	r25, r25
    238a:	aa 1f       	adc	r26, r26
    238c:	a2 17       	cp	r26, r18
    238e:	10 f0       	brcs	.+4      	; 0x2394 <__ultoa_common+0x26>
    2390:	a2 1b       	sub	r26, r18
    2392:	63 95       	inc	r22
    2394:	38 50       	subi	r19, 0x08	; 8
    2396:	a9 f7       	brne	.-22     	; 0x2382 <__ultoa_common+0x14>
    2398:	a0 5d       	subi	r26, 0xD0	; 208
    239a:	aa 33       	cpi	r26, 0x3A	; 58
    239c:	08 f0       	brcs	.+2      	; 0x23a0 <__ultoa_common+0x32>
    239e:	a9 5d       	subi	r26, 0xD9	; 217
    23a0:	a1 93       	st	Z+, r26
    23a2:	36 f7       	brtc	.-52     	; 0x2370 <__ultoa_common+0x2>
    23a4:	b1 11       	cpse	r27, r1
    23a6:	b1 93       	st	Z+, r27
    23a8:	10 82       	st	Z, r1
    23aa:	ca 01       	movw	r24, r20
    23ac:	00 c0       	rjmp	.+0      	; 0x23ae <strrev>

000023ae <strrev>:
    23ae:	dc 01       	movw	r26, r24
    23b0:	fc 01       	movw	r30, r24
    23b2:	67 2f       	mov	r22, r23
    23b4:	71 91       	ld	r23, Z+
    23b6:	77 23       	and	r23, r23
    23b8:	e1 f7       	brne	.-8      	; 0x23b2 <strrev+0x4>
    23ba:	32 97       	sbiw	r30, 0x02	; 2
    23bc:	04 c0       	rjmp	.+8      	; 0x23c6 <strrev+0x18>
    23be:	7c 91       	ld	r23, X
    23c0:	6d 93       	st	X+, r22
    23c2:	70 83       	st	Z, r23
    23c4:	62 91       	ld	r22, -Z
    23c6:	ae 17       	cp	r26, r30
    23c8:	bf 07       	cpc	r27, r31
    23ca:	c8 f3       	brcs	.-14     	; 0x23be <strrev+0x10>
    23cc:	08 95       	ret

000023ce <_exit>:
    23ce:	f8 94       	cli

000023d0 <__stop_program>:
    23d0:	ff cf       	rjmp	.-2      	; 0x23d0 <__stop_program>
