
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000092  00800200  00002816  000028aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002816  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000237  00800292  00800292  0000293c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000293c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000296c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  000029ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007902  00000000  00000000  00002f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f4d  00000000  00000000  0000a85e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000047d7  00000000  00000000  0000c7ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001528  00000000  00000000  00010f84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001fb8  00000000  00000000  000124ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000074f0  00000000  00000000  00014464  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000888  00000000  00000000  0001b954  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8a c1       	rjmp	.+788    	; 0x31a <__bad_interrupt>
       6:	00 00       	nop
       8:	88 c1       	rjmp	.+784    	; 0x31a <__bad_interrupt>
       a:	00 00       	nop
       c:	86 c1       	rjmp	.+780    	; 0x31a <__bad_interrupt>
       e:	00 00       	nop
      10:	84 c1       	rjmp	.+776    	; 0x31a <__bad_interrupt>
      12:	00 00       	nop
      14:	82 c1       	rjmp	.+772    	; 0x31a <__bad_interrupt>
      16:	00 00       	nop
      18:	80 c1       	rjmp	.+768    	; 0x31a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7e c1       	rjmp	.+764    	; 0x31a <__bad_interrupt>
      1e:	00 00       	nop
      20:	7c c1       	rjmp	.+760    	; 0x31a <__bad_interrupt>
      22:	00 00       	nop
      24:	90 c4       	rjmp	.+2336   	; 0x946 <__vector_9>
      26:	00 00       	nop
      28:	78 c1       	rjmp	.+752    	; 0x31a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	76 c1       	rjmp	.+748    	; 0x31a <__bad_interrupt>
      2e:	00 00       	nop
      30:	74 c1       	rjmp	.+744    	; 0x31a <__bad_interrupt>
      32:	00 00       	nop
      34:	72 c1       	rjmp	.+740    	; 0x31a <__bad_interrupt>
      36:	00 00       	nop
      38:	70 c1       	rjmp	.+736    	; 0x31a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6e c1       	rjmp	.+732    	; 0x31a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6c c1       	rjmp	.+728    	; 0x31a <__bad_interrupt>
      42:	00 00       	nop
      44:	e7 c6       	rjmp	.+3534   	; 0xe14 <__vector_17>
      46:	00 00       	nop
      48:	68 c1       	rjmp	.+720    	; 0x31a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	66 c1       	rjmp	.+716    	; 0x31a <__bad_interrupt>
      4e:	00 00       	nop
      50:	64 c1       	rjmp	.+712    	; 0x31a <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 ab 08 	jmp	0x1156	; 0x1156 <__vector_21>
      58:	60 c1       	rjmp	.+704    	; 0x31a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5e c1       	rjmp	.+700    	; 0x31a <__bad_interrupt>
      5e:	00 00       	nop
      60:	5c c1       	rjmp	.+696    	; 0x31a <__bad_interrupt>
      62:	00 00       	nop
      64:	34 c4       	rjmp	.+2152   	; 0x8ce <__vector_25>
      66:	00 00       	nop
      68:	0c 94 4a 0a 	jmp	0x1494	; 0x1494 <__vector_26>
      6c:	56 c1       	rjmp	.+684    	; 0x31a <__bad_interrupt>
      6e:	00 00       	nop
      70:	54 c1       	rjmp	.+680    	; 0x31a <__bad_interrupt>
      72:	00 00       	nop
      74:	52 c1       	rjmp	.+676    	; 0x31a <__bad_interrupt>
      76:	00 00       	nop
      78:	50 c1       	rjmp	.+672    	; 0x31a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4e c1       	rjmp	.+668    	; 0x31a <__bad_interrupt>
      7e:	00 00       	nop
      80:	4c c1       	rjmp	.+664    	; 0x31a <__bad_interrupt>
      82:	00 00       	nop
      84:	4a c1       	rjmp	.+660    	; 0x31a <__bad_interrupt>
      86:	00 00       	nop
      88:	48 c1       	rjmp	.+656    	; 0x31a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	ff c4       	rjmp	.+2558   	; 0xa8c <__vector_35>
      8e:	00 00       	nop
      90:	0c 94 93 0a 	jmp	0x1526	; 0x1526 <__vector_36>
      94:	0c 94 f2 0a 	jmp	0x15e4	; 0x15e4 <__vector_37>
      98:	40 c1       	rjmp	.+640    	; 0x31a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ac c1       	rjmp	.+856    	; 0x3f6 <__vector_39>
      9e:	00 00       	nop
      a0:	3c c1       	rjmp	.+632    	; 0x31a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	38 c1       	rjmp	.+624    	; 0x31a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	36 c1       	rjmp	.+620    	; 0x31a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	34 c1       	rjmp	.+616    	; 0x31a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	32 c1       	rjmp	.+612    	; 0x31a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	30 c1       	rjmp	.+608    	; 0x31a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2e c1       	rjmp	.+604    	; 0x31a <__bad_interrupt>
      be:	00 00       	nop
      c0:	2c c1       	rjmp	.+600    	; 0x31a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2a c1       	rjmp	.+596    	; 0x31a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	28 c1       	rjmp	.+592    	; 0x31a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 3b 0b 	jmp	0x1676	; 0x1676 <__vector_51>
      d0:	0c 94 9a 0b 	jmp	0x1734	; 0x1734 <__vector_52>
      d4:	22 c1       	rjmp	.+580    	; 0x31a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 e3 0b 	jmp	0x17c6	; 0x17c6 <__vector_54>
      dc:	0c 94 42 0c 	jmp	0x1884	; 0x1884 <__vector_55>
      e0:	1c c1       	rjmp	.+568    	; 0x31a <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1a 02       	muls	r17, r26
      e6:	d5 02       	muls	r29, r21
      e8:	d5 02       	muls	r29, r21
      ea:	d5 02       	muls	r29, r21
      ec:	d5 02       	muls	r29, r21
      ee:	d5 02       	muls	r29, r21
      f0:	d5 02       	muls	r29, r21
      f2:	d5 02       	muls	r29, r21
      f4:	1a 02       	muls	r17, r26
      f6:	d5 02       	muls	r29, r21
      f8:	d5 02       	muls	r29, r21
      fa:	d5 02       	muls	r29, r21
      fc:	d5 02       	muls	r29, r21
      fe:	d5 02       	muls	r29, r21
     100:	d5 02       	muls	r29, r21
     102:	d5 02       	muls	r29, r21
     104:	1c 02       	muls	r17, r28
     106:	d5 02       	muls	r29, r21
     108:	d5 02       	muls	r29, r21
     10a:	d5 02       	muls	r29, r21
     10c:	d5 02       	muls	r29, r21
     10e:	d5 02       	muls	r29, r21
     110:	d5 02       	muls	r29, r21
     112:	d5 02       	muls	r29, r21
     114:	39 02       	muls	r19, r25
     116:	d5 02       	muls	r29, r21
     118:	d5 02       	muls	r29, r21
     11a:	d5 02       	muls	r29, r21
     11c:	d5 02       	muls	r29, r21
     11e:	d5 02       	muls	r29, r21
     120:	d5 02       	muls	r29, r21
     122:	d5 02       	muls	r29, r21
     124:	1c 02       	muls	r17, r28
     126:	d5 02       	muls	r29, r21
     128:	d5 02       	muls	r29, r21
     12a:	d5 02       	muls	r29, r21
     12c:	d5 02       	muls	r29, r21
     12e:	d5 02       	muls	r29, r21
     130:	d5 02       	muls	r29, r21
     132:	d5 02       	muls	r29, r21
     134:	39 02       	muls	r19, r25
     136:	d5 02       	muls	r29, r21
     138:	d5 02       	muls	r29, r21
     13a:	d5 02       	muls	r29, r21
     13c:	d5 02       	muls	r29, r21
     13e:	d5 02       	muls	r29, r21
     140:	d5 02       	muls	r29, r21
     142:	d5 02       	muls	r29, r21
     144:	d1 02       	muls	r29, r17
     146:	d5 02       	muls	r29, r21
     148:	d5 02       	muls	r29, r21
     14a:	d5 02       	muls	r29, r21
     14c:	d5 02       	muls	r29, r21
     14e:	d5 02       	muls	r29, r21
     150:	d5 02       	muls	r29, r21
     152:	d5 02       	muls	r29, r21
     154:	4d 02       	muls	r20, r29
     156:	d5 02       	muls	r29, r21
     158:	d5 02       	muls	r29, r21
     15a:	d5 02       	muls	r29, r21
     15c:	d5 02       	muls	r29, r21
     15e:	d5 02       	muls	r29, r21
     160:	d5 02       	muls	r29, r21
     162:	d5 02       	muls	r29, r21
     164:	70 02       	muls	r23, r16
     166:	d5 02       	muls	r29, r21
     168:	d5 02       	muls	r29, r21
     16a:	d5 02       	muls	r29, r21
     16c:	d5 02       	muls	r29, r21
     16e:	d5 02       	muls	r29, r21
     170:	d5 02       	muls	r29, r21
     172:	d5 02       	muls	r29, r21
     174:	41 02       	muls	r20, r17
     176:	d5 02       	muls	r29, r21
     178:	d5 02       	muls	r29, r21
     17a:	d5 02       	muls	r29, r21
     17c:	d5 02       	muls	r29, r21
     17e:	d5 02       	muls	r29, r21
     180:	d5 02       	muls	r29, r21
     182:	d5 02       	muls	r29, r21
     184:	5f 02       	muls	r21, r31
     186:	d5 02       	muls	r29, r21
     188:	d5 02       	muls	r29, r21
     18a:	d5 02       	muls	r29, r21
     18c:	d5 02       	muls	r29, r21
     18e:	d5 02       	muls	r29, r21
     190:	d5 02       	muls	r29, r21
     192:	d5 02       	muls	r29, r21
     194:	a7 02       	muls	r26, r23
     196:	d5 02       	muls	r29, r21
     198:	d5 02       	muls	r29, r21
     19a:	d5 02       	muls	r29, r21
     19c:	d5 02       	muls	r29, r21
     19e:	d5 02       	muls	r29, r21
     1a0:	d5 02       	muls	r29, r21
     1a2:	d5 02       	muls	r29, r21
     1a4:	a7 02       	muls	r26, r23
     1a6:	d5 02       	muls	r29, r21
     1a8:	d5 02       	muls	r29, r21
     1aa:	d5 02       	muls	r29, r21
     1ac:	d5 02       	muls	r29, r21
     1ae:	d5 02       	muls	r29, r21
     1b0:	d5 02       	muls	r29, r21
     1b2:	d5 02       	muls	r29, r21
     1b4:	a2 02       	muls	r26, r18
     1b6:	d5 02       	muls	r29, r21
     1b8:	d5 02       	muls	r29, r21
     1ba:	d5 02       	muls	r29, r21
     1bc:	d5 02       	muls	r29, r21
     1be:	d5 02       	muls	r29, r21
     1c0:	d5 02       	muls	r29, r21
     1c2:	d5 02       	muls	r29, r21
     1c4:	a2 02       	muls	r26, r18
     1c6:	d5 02       	muls	r29, r21
     1c8:	d5 02       	muls	r29, r21
     1ca:	d5 02       	muls	r29, r21
     1cc:	d5 02       	muls	r29, r21
     1ce:	d5 02       	muls	r29, r21
     1d0:	d5 02       	muls	r29, r21
     1d2:	d5 02       	muls	r29, r21
     1d4:	b2 02       	muls	r27, r18
     1d6:	d5 02       	muls	r29, r21
     1d8:	d5 02       	muls	r29, r21
     1da:	d5 02       	muls	r29, r21
     1dc:	d5 02       	muls	r29, r21
     1de:	d5 02       	muls	r29, r21
     1e0:	d5 02       	muls	r29, r21
     1e2:	d5 02       	muls	r29, r21
     1e4:	c7 02       	muls	r28, r23
     1e6:	d5 02       	muls	r29, r21
     1e8:	d5 02       	muls	r29, r21
     1ea:	d5 02       	muls	r29, r21
     1ec:	d5 02       	muls	r29, r21
     1ee:	d5 02       	muls	r29, r21
     1f0:	d5 02       	muls	r29, r21
     1f2:	d5 02       	muls	r29, r21
     1f4:	b2 02       	muls	r27, r18
     1f6:	d5 02       	muls	r29, r21
     1f8:	d5 02       	muls	r29, r21
     1fa:	d5 02       	muls	r29, r21
     1fc:	d5 02       	muls	r29, r21
     1fe:	d5 02       	muls	r29, r21
     200:	d5 02       	muls	r29, r21
     202:	d5 02       	muls	r29, r21
     204:	c7 02       	muls	r28, r23
     206:	d5 02       	muls	r29, r21
     208:	d5 02       	muls	r29, r21
     20a:	d5 02       	muls	r29, r21
     20c:	d5 02       	muls	r29, r21
     20e:	d5 02       	muls	r29, r21
     210:	d5 02       	muls	r29, r21
     212:	d5 02       	muls	r29, r21
     214:	cb 02       	muls	r28, r27
     216:	d5 02       	muls	r29, r21
     218:	d5 02       	muls	r29, r21
     21a:	d5 02       	muls	r29, r21
     21c:	d5 02       	muls	r29, r21
     21e:	d5 02       	muls	r29, r21
     220:	d5 02       	muls	r29, r21
     222:	d5 02       	muls	r29, r21
     224:	78 02       	muls	r23, r24
     226:	d5 02       	muls	r29, r21
     228:	d5 02       	muls	r29, r21
     22a:	d5 02       	muls	r29, r21
     22c:	d5 02       	muls	r29, r21
     22e:	d5 02       	muls	r29, r21
     230:	d5 02       	muls	r29, r21
     232:	d5 02       	muls	r29, r21
     234:	78 02       	muls	r23, r24
     236:	d5 02       	muls	r29, r21
     238:	d5 02       	muls	r29, r21
     23a:	d5 02       	muls	r29, r21
     23c:	d5 02       	muls	r29, r21
     23e:	d5 02       	muls	r29, r21
     240:	d5 02       	muls	r29, r21
     242:	d5 02       	muls	r29, r21
     244:	7a 02       	muls	r23, r26
     246:	d5 02       	muls	r29, r21
     248:	d5 02       	muls	r29, r21
     24a:	d5 02       	muls	r29, r21
     24c:	d5 02       	muls	r29, r21
     24e:	d5 02       	muls	r29, r21
     250:	d5 02       	muls	r29, r21
     252:	d5 02       	muls	r29, r21
     254:	8a 02       	muls	r24, r26
     256:	d5 02       	muls	r29, r21
     258:	d5 02       	muls	r29, r21
     25a:	d5 02       	muls	r29, r21
     25c:	d5 02       	muls	r29, r21
     25e:	d5 02       	muls	r29, r21
     260:	d5 02       	muls	r29, r21
     262:	d5 02       	muls	r29, r21
     264:	9e 02       	muls	r25, r30

00000266 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     266:	02 ed       	ldi	r16, 0xD2	; 210
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	fa ef       	ldi	r31, 0xFA	; 250
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	fe d1       	rcall	.+1020   	; 0x69e <uxListRemove>
     2a2:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <uxCurrentNumberOfTasks>
     2ac:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5c d0       	rcall	.+184    	; 0x378 <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5a d0       	rcall	.+180    	; 0x378 <vPortFree>
     2c4:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	69 d6       	rcall	.+3282   	; 0xfa8 <vPortYield>
     2d6:	5f d0       	rcall	.+190    	; 0x396 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	e6 e1       	ldi	r30, 0x16	; 22
     2f2:	f8 e2       	ldi	r31, 0x28	; 40
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	a2 39       	cpi	r26, 0x92	; 146
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	24 e0       	ldi	r18, 0x04	; 4
     306:	a2 e9       	ldi	r26, 0x92	; 146
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a9 3c       	cpi	r26, 0xC9	; 201
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	48 d4       	rcall	.+2192   	; 0xba6 <main>
     316:	0c 94 09 14 	jmp	0x2812	; 0x2812 <_exit>

0000031a <__bad_interrupt>:
     31a:	72 ce       	rjmp	.-796    	; 0x0 <__vectors>

0000031c <system_tick>:
     31c:	8f 93       	push	r24
     31e:	8f b7       	in	r24, 0x3f	; 63
     320:	8f 93       	push	r24
     322:	f8 94       	cli
     324:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <__system_time>
     328:	8f 5f       	subi	r24, 0xFF	; 255
     32a:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <__system_time>
     32e:	80 91 c6 04 	lds	r24, 0x04C6	; 0x8004c6 <__system_time+0x1>
     332:	8f 4f       	sbci	r24, 0xFF	; 255
     334:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <__system_time+0x1>
     338:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <__system_time+0x2>
     33c:	8f 4f       	sbci	r24, 0xFF	; 255
     33e:	80 93 c7 04 	sts	0x04C7, r24	; 0x8004c7 <__system_time+0x2>
     342:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <__system_time+0x3>
     346:	8f 4f       	sbci	r24, 0xFF	; 255
     348:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <__system_time+0x3>
     34c:	8f 91       	pop	r24
     34e:	8f bf       	out	0x3f, r24	; 63
     350:	8f 91       	pop	r24
     352:	08 95       	ret

00000354 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35a:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     35e:	ce 01       	movw	r24, r28
     360:	0e 94 a5 12 	call	0x254a	; 0x254a <malloc>
     364:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     366:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36a:	20 97       	sbiw	r28, 0x00	; 0
     36c:	09 f4       	brne	.+2      	; 0x370 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     36e:	2c d0       	rcall	.+88     	; 0x3c8 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     370:	ce 01       	movw	r24, r28
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
	if( pv )
     37c:	00 97       	sbiw	r24, 0x00	; 0
     37e:	41 f0       	breq	.+16     	; 0x390 <vPortFree+0x18>
     380:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     382:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <vTaskSuspendAll>
		{
			free( pv );
     386:	ce 01       	movw	r24, r28
     388:	0e 94 3d 13 	call	0x267a	; 0x267a <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xTaskResumeAll>
	}
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39c:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a0:	80 b7       	in	r24, 0x30	; 48
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a6:	80 b7       	in	r24, 0x30	; 48
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ac:	83 b7       	in	r24, 0x33	; 51
     3ae:	81 7f       	andi	r24, 0xF1	; 241
     3b0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0

	sleep_enable();
     3b8:	83 b7       	in	r24, 0x33	; 51
     3ba:	81 60       	ori	r24, 0x01	; 1
     3bc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3be:	0f 90       	pop	r0
     3c0:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c2:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c4:	13 be       	out	0x33, r1	; 51
     3c6:	08 95       	ret

000003c8 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3ca:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3cc:	83 ed       	ldi	r24, 0xD3	; 211
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <vApplicationMallocFailedHook+0x8>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <vApplicationMallocFailedHook+0xe>
     3d6:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3d8:	1f 9a       	sbi	0x03, 7	; 3
     3da:	f8 cf       	rjmp	.-16     	; 0x3cc <vApplicationMallocFailedHook+0x4>

000003dc <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3dc:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3de:	2f 9a       	sbi	0x05, 7	; 5
     3e0:	2f e7       	ldi	r18, 0x7F	; 127
     3e2:	8a e1       	ldi	r24, 0x1A	; 26
     3e4:	96 e0       	ldi	r25, 0x06	; 6
     3e6:	21 50       	subi	r18, 0x01	; 1
     3e8:	80 40       	sbci	r24, 0x00	; 0
     3ea:	90 40       	sbci	r25, 0x00	; 0
     3ec:	e1 f7       	brne	.-8      	; 0x3e6 <vApplicationStackOverflowHook+0xa>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <vApplicationStackOverflowHook+0x14>
     3f0:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f2:	1f 9a       	sbi	0x03, 7	; 3
     3f4:	f5 cf       	rjmp	.-22     	; 0x3e0 <vApplicationStackOverflowHook+0x4>

000003f6 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f6:	1f 92       	push	r1
     3f8:	0f 92       	push	r0
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	0b b6       	in	r0, 0x3b	; 59
     402:	0f 92       	push	r0
     404:	2f 93       	push	r18
     406:	3f 93       	push	r19
     408:	8f 93       	push	r24
     40a:	9f 93       	push	r25
     40c:	af 93       	push	r26
     40e:	bf 93       	push	r27
     410:	ef 93       	push	r30
     412:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     414:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     418:	8e 2f       	mov	r24, r30
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	38 97       	sbiw	r30, 0x08	; 8
     420:	e1 3c       	cpi	r30, 0xC1	; 193
     422:	f1 05       	cpc	r31, r1
     424:	08 f0       	brcs	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	c1 c0       	rjmp	.+386    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     428:	88 27       	eor	r24, r24
     42a:	ee 58       	subi	r30, 0x8E	; 142
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	8f 4f       	sbci	r24, 0xFF	; 255
     430:	0c 94 84 12 	jmp	0x2508	; 0x2508 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     434:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     438:	e0 91 92 02 	lds	r30, 0x0292	; 0x800292 <__data_end>
     43c:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <I2C_msgSize>
     440:	e8 17       	cp	r30, r24
     442:	70 f4       	brcc	.+28     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	8e 0f       	add	r24, r30
     448:	80 93 92 02 	sts	0x0292, r24	; 0x800292 <__data_end>
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	ea 56       	subi	r30, 0x6A	; 106
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     458:	85 e8       	ldi	r24, 0x85	; 133
     45a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     45e:	ac c0       	rjmp	.+344    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     460:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     464:	81 60       	ori	r24, 0x01	; 1
     466:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46a:	84 e9       	ldi	r24, 0x94	; 148
     46c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     470:	a3 c0       	rjmp	.+326    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     476:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47a:	85 ee       	ldi	r24, 0xE5	; 229
     47c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     480:	9b c0       	rjmp	.+310    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     482:	e0 91 92 02 	lds	r30, 0x0292	; 0x800292 <__data_end>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e 0f       	add	r24, r30
     48a:	80 93 92 02 	sts	0x0292, r24	; 0x800292 <__data_end>
     48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     492:	f0 e0       	ldi	r31, 0x00	; 0
     494:	ea 56       	subi	r30, 0x6A	; 106
     496:	fd 4f       	sbci	r31, 0xFD	; 253
     498:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49a:	20 91 92 02 	lds	r18, 0x0292	; 0x800292 <__data_end>
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <I2C_msgSize>
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	28 17       	cp	r18, r24
     4aa:	39 07       	cpc	r19, r25
     4ac:	24 f4       	brge	.+8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4ae:	85 ec       	ldi	r24, 0xC5	; 197
     4b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b4:	81 c0       	rjmp	.+258    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b6:	85 e8       	ldi	r24, 0x85	; 133
     4b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4bc:	7d c0       	rjmp	.+250    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4be:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c2:	e0 91 92 02 	lds	r30, 0x0292	; 0x800292 <__data_end>
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	ea 56       	subi	r30, 0x6A	; 106
     4ca:	fd 4f       	sbci	r31, 0xFD	; 253
     4cc:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4ce:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     4d2:	81 60       	ori	r24, 0x01	; 1
     4d4:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4de:	6c c0       	rjmp	.+216    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e4:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4e8:	85 ed       	ldi	r24, 0xD5	; 213
     4ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4ee:	64 c0       	rjmp	.+200    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f0:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f4:	e0 91 92 02 	lds	r30, 0x0292	; 0x800292 <__data_end>
     4f8:	81 e0       	ldi	r24, 0x01	; 1
     4fa:	8e 0f       	add	r24, r30
     4fc:	80 93 92 02 	sts	0x0292, r24	; 0x800292 <__data_end>
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	ea 56       	subi	r30, 0x6A	; 106
     504:	fd 4f       	sbci	r31, 0xFD	; 253
     506:	80 81       	ld	r24, Z
     508:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50c:	85 ec       	ldi	r24, 0xC5	; 197
     50e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     512:	52 c0       	rjmp	.+164    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     514:	90 91 92 02 	lds	r25, 0x0292	; 0x800292 <__data_end>
     518:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <I2C_msgSize>
     51c:	98 13       	cpse	r25, r24
     51e:	06 c0       	rjmp	.+12     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     520:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     524:	81 60       	ori	r24, 0x01	; 1
     526:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     530:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53a:	3e c0       	rjmp	.+124    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53c:	85 ec       	ldi	r24, 0xC5	; 197
     53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     544:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     548:	84 60       	ori	r24, 0x04	; 4
     54a:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     54e:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     558:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55c:	85 ec       	ldi	r24, 0xC5	; 197
     55e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     564:	e0 91 92 02 	lds	r30, 0x0292	; 0x800292 <__data_end>
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e 0f       	add	r24, r30
     56c:	80 93 92 02 	sts	0x0292, r24	; 0x800292 <__data_end>
     570:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	ea 56       	subi	r30, 0x6A	; 106
     578:	fd 4f       	sbci	r31, 0xFD	; 253
     57a:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57c:	80 91 93 02 	lds	r24, 0x0293	; 0x800293 <I2C_statusReg>
     580:	81 60       	ori	r24, 0x01	; 1
     582:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     586:	85 ec       	ldi	r24, 0xC5	; 197
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58c:	15 c0       	rjmp	.+42     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     58e:	85 e8       	ldi	r24, 0x85	; 133
     590:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     594:	11 c0       	rjmp	.+34     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     596:	84 e0       	ldi	r24, 0x04	; 4
     598:	80 93 94 02 	sts	0x0294, r24	; 0x800294 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a2:	85 ee       	ldi	r24, 0xE5	; 229
     5a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5a8:	07 c0       	rjmp	.+14     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5aa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ae:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b2:	85 ed       	ldi	r24, 0xD5	; 213
     5b4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	3f 91       	pop	r19
     5c6:	2f 91       	pop	r18
     5c8:	0f 90       	pop	r0
     5ca:	0b be       	out	0x3b, r0	; 59
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	03 96       	adiw	r24, 0x03	; 3
     5da:	92 83       	std	Z+2, r25	; 0x02
     5dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5de:	2f ef       	ldi	r18, 0xFF	; 255
     5e0:	3f ef       	ldi	r19, 0xFF	; 255
     5e2:	34 83       	std	Z+4, r19	; 0x04
     5e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e6:	96 83       	std	Z+6, r25	; 0x06
     5e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ea:	90 87       	std	Z+8, r25	; 0x08
     5ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5ee:	10 82       	st	Z, r1
     5f0:	08 95       	ret

000005f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f2:	fc 01       	movw	r30, r24
     5f4:	11 86       	std	Z+9, r1	; 0x09
     5f6:	10 86       	std	Z+8, r1	; 0x08
     5f8:	08 95       	ret

000005fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	9c 01       	movw	r18, r24
     600:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     602:	dc 01       	movw	r26, r24
     604:	11 96       	adiw	r26, 0x01	; 1
     606:	cd 91       	ld	r28, X+
     608:	dc 91       	ld	r29, X
     60a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60c:	d3 83       	std	Z+3, r29	; 0x03
     60e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     610:	8c 81       	ldd	r24, Y+4	; 0x04
     612:	9d 81       	ldd	r25, Y+5	; 0x05
     614:	95 83       	std	Z+5, r25	; 0x05
     616:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	dc 01       	movw	r26, r24
     61e:	13 96       	adiw	r26, 0x03	; 3
     620:	7c 93       	st	X, r23
     622:	6e 93       	st	-X, r22
     624:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     626:	7d 83       	std	Y+5, r23	; 0x05
     628:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	31 87       	std	Z+9, r19	; 0x09
     62c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	f9 01       	movw	r30, r18
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     642:	48 81       	ld	r20, Y
     644:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     646:	4f 3f       	cpi	r20, 0xFF	; 255
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	52 07       	cpc	r21, r18
     64c:	21 f4       	brne	.+8      	; 0x656 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     64e:	fc 01       	movw	r30, r24
     650:	a7 81       	ldd	r26, Z+7	; 0x07
     652:	b0 85       	ldd	r27, Z+8	; 0x08
     654:	0d c0       	rjmp	.+26     	; 0x670 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     656:	dc 01       	movw	r26, r24
     658:	13 96       	adiw	r26, 0x03	; 3
     65a:	01 c0       	rjmp	.+2      	; 0x65e <vListInsert+0x22>
     65c:	df 01       	movw	r26, r30
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	ed 91       	ld	r30, X+
     662:	fc 91       	ld	r31, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	20 81       	ld	r18, Z
     668:	31 81       	ldd	r19, Z+1	; 0x01
     66a:	42 17       	cp	r20, r18
     66c:	53 07       	cpc	r21, r19
     66e:	b0 f7       	brcc	.-20     	; 0x65c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     670:	12 96       	adiw	r26, 0x02	; 2
     672:	ed 91       	ld	r30, X+
     674:	fc 91       	ld	r31, X
     676:	13 97       	sbiw	r26, 0x03	; 3
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67c:	d5 83       	std	Z+5, r29	; 0x05
     67e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     680:	bd 83       	std	Y+5, r27	; 0x05
     682:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     684:	13 96       	adiw	r26, 0x03	; 3
     686:	dc 93       	st	X, r29
     688:	ce 93       	st	-X, r28
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68c:	99 87       	std	Y+9, r25	; 0x09
     68e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     690:	fc 01       	movw	r30, r24
     692:	20 81       	ld	r18, Z
     694:	2f 5f       	subi	r18, 0xFF	; 255
     696:	20 83       	st	Z, r18
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a4:	a0 85       	ldd	r26, Z+8	; 0x08
     6a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6a8:	c2 81       	ldd	r28, Z+2	; 0x02
     6aa:	d3 81       	ldd	r29, Z+3	; 0x03
     6ac:	84 81       	ldd	r24, Z+4	; 0x04
     6ae:	95 81       	ldd	r25, Z+5	; 0x05
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b4:	c4 81       	ldd	r28, Z+4	; 0x04
     6b6:	d5 81       	ldd	r29, Z+5	; 0x05
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	9b 83       	std	Y+3, r25	; 0x03
     6be:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2
     6c8:	e8 17       	cp	r30, r24
     6ca:	f9 07       	cpc	r31, r25
     6cc:	31 f4       	brne	.+12     	; 0x6da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6ce:	84 81       	ldd	r24, Z+4	; 0x04
     6d0:	95 81       	ldd	r25, Z+5	; 0x05
     6d2:	12 96       	adiw	r26, 0x02	; 2
     6d4:	9c 93       	st	X, r25
     6d6:	8e 93       	st	-X, r24
     6d8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6da:	11 86       	std	Z+9, r1	; 0x09
     6dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6de:	8c 91       	ld	r24, X
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <initQ>:
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     6ea:	40 e0       	ldi	r20, 0x00	; 0
     6ec:	62 e0       	ldi	r22, 0x02	; 2
     6ee:	8a e0       	ldi	r24, 0x0A	; 10
     6f0:	14 d6       	rcall	.+3112   	; 0x131a <xQueueGenericCreate>
     6f2:	90 93 2f 04 	sts	0x042F, r25	; 0x80042f <sonarAfstand+0x1>
     6f6:	80 93 2e 04 	sts	0x042E, r24	; 0x80042e <sonarAfstand>
     6fa:	89 2b       	or	r24, r25
     6fc:	41 f4       	brne	.+16     	; 0x70e <initQ+0x24>
     6fe:	40 e0       	ldi	r20, 0x00	; 0
     700:	62 e0       	ldi	r22, 0x02	; 2
     702:	8a e0       	ldi	r24, 0x0A	; 10
     704:	0a d6       	rcall	.+3092   	; 0x131a <xQueueGenericCreate>
     706:	90 93 2f 04 	sts	0x042F, r25	; 0x80042f <sonarAfstand+0x1>
     70a:	80 93 2e 04 	sts	0x042E, r24	; 0x80042e <sonarAfstand>
     70e:	40 e0       	ldi	r20, 0x00	; 0
     710:	62 e0       	ldi	r22, 0x02	; 2
     712:	8a e0       	ldi	r24, 0x0A	; 10
     714:	02 d6       	rcall	.+3076   	; 0x131a <xQueueGenericCreate>
     716:	90 93 2d 04 	sts	0x042D, r25	; 0x80042d <servoHoek+0x1>
     71a:	80 93 2c 04 	sts	0x042C, r24	; 0x80042c <servoHoek>
     71e:	89 2b       	or	r24, r25
     720:	41 f4       	brne	.+16     	; 0x732 <initQ+0x48>
     722:	40 e0       	ldi	r20, 0x00	; 0
     724:	62 e0       	ldi	r22, 0x02	; 2
     726:	8a e0       	ldi	r24, 0x0A	; 10
     728:	f8 d5       	rcall	.+3056   	; 0x131a <xQueueGenericCreate>
     72a:	90 93 2d 04 	sts	0x042D, r25	; 0x80042d <servoHoek+0x1>
     72e:	80 93 2c 04 	sts	0x042C, r24	; 0x80042c <servoHoek>
     732:	08 95       	ret

00000734 <UART_Init>:
     734:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     738:	87 e6       	ldi	r24, 0x67	; 103
     73a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     73e:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     742:	86 e0       	ldi	r24, 0x06	; 6
     744:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     748:	88 e1       	ldi	r24, 0x18	; 24
     74a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     74e:	08 95       	ret

00000750 <UART_Transmit>:
     750:	e0 ec       	ldi	r30, 0xC0	; 192
     752:	f0 e0       	ldi	r31, 0x00	; 0
     754:	90 81       	ld	r25, Z
     756:	95 ff       	sbrs	r25, 5
     758:	fd cf       	rjmp	.-6      	; 0x754 <UART_Transmit+0x4>
     75a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     75e:	08 95       	ret

00000760 <UART_Transmit_String>:
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	ec 01       	movw	r28, r24
     766:	88 81       	ld	r24, Y
     768:	88 23       	and	r24, r24
     76a:	29 f0       	breq	.+10     	; 0x776 <UART_Transmit_String+0x16>
     76c:	21 96       	adiw	r28, 0x01	; 1
     76e:	f0 df       	rcall	.-32     	; 0x750 <UART_Transmit>
     770:	89 91       	ld	r24, Y+
     772:	81 11       	cpse	r24, r1
     774:	fc cf       	rjmp	.-8      	; 0x76e <UART_Transmit_String+0xe>
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	08 95       	ret

0000077c <watchdogTaak>:
     77c:	8f e9       	ldi	r24, 0x9F	; 159
     77e:	9f e0       	ldi	r25, 0x0F	; 15
     780:	01 97       	sbiw	r24, 0x01	; 1
     782:	f1 f7       	brne	.-4      	; 0x780 <watchdogTaak+0x4>
     784:	00 c0       	rjmp	.+0      	; 0x786 <watchdogTaak+0xa>
     786:	00 00       	nop
     788:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <watchdogSonar>
     78c:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <watchdogSonar+0x1>
     790:	89 2b       	or	r24, r25
     792:	a1 f3       	breq	.-24     	; 0x77c <watchdogTaak>
     794:	80 91 30 04 	lds	r24, 0x0430	; 0x800430 <watchdogServo>
     798:	90 91 31 04 	lds	r25, 0x0431	; 0x800431 <watchdogServo+0x1>
     79c:	89 2b       	or	r24, r25
     79e:	71 f3       	breq	.-36     	; 0x77c <watchdogTaak>
     7a0:	80 91 24 04 	lds	r24, 0x0424	; 0x800424 <watchdogTemp>
     7a4:	90 91 25 04 	lds	r25, 0x0425	; 0x800425 <watchdogTemp+0x1>
     7a8:	89 2b       	or	r24, r25
     7aa:	41 f3       	breq	.-48     	; 0x77c <watchdogTaak>
     7ac:	87 e0       	ldi	r24, 0x07	; 7
     7ae:	92 e0       	ldi	r25, 0x02	; 2
     7b0:	d7 df       	rcall	.-82     	; 0x760 <UART_Transmit_String>
     7b2:	a8 95       	wdr
     7b4:	10 92 23 03 	sts	0x0323, r1	; 0x800323 <watchdogSonar+0x1>
     7b8:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <watchdogSonar>
     7bc:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <watchdogServo+0x1>
     7c0:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <watchdogServo>
     7c4:	10 92 25 04 	sts	0x0425, r1	; 0x800425 <watchdogTemp+0x1>
     7c8:	10 92 24 04 	sts	0x0424, r1	; 0x800424 <watchdogTemp>
     7cc:	d7 cf       	rjmp	.-82     	; 0x77c <watchdogTaak>

000007ce <UART_Transmit_Integer>:
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
     7d2:	cd b7       	in	r28, 0x3d	; 61
     7d4:	de b7       	in	r29, 0x3e	; 62
     7d6:	61 97       	sbiw	r28, 0x11	; 17
     7d8:	0f b6       	in	r0, 0x3f	; 63
     7da:	f8 94       	cli
     7dc:	de bf       	out	0x3e, r29	; 62
     7de:	0f be       	out	0x3f, r0	; 63
     7e0:	cd bf       	out	0x3d, r28	; 61
     7e2:	dc 01       	movw	r26, r24
     7e4:	cb 01       	movw	r24, r22
     7e6:	4a e0       	ldi	r20, 0x0A	; 10
     7e8:	be 01       	movw	r22, r28
     7ea:	6f 5f       	subi	r22, 0xFF	; 255
     7ec:	7f 4f       	sbci	r23, 0xFF	; 255
     7ee:	0e 94 d6 13 	call	0x27ac	; 0x27ac <__itoa_ncheck>
     7f2:	ce 01       	movw	r24, r28
     7f4:	01 96       	adiw	r24, 0x01	; 1
     7f6:	b4 df       	rcall	.-152    	; 0x760 <UART_Transmit_String>
     7f8:	61 96       	adiw	r28, 0x11	; 17
     7fa:	0f b6       	in	r0, 0x3f	; 63
     7fc:	f8 94       	cli
     7fe:	de bf       	out	0x3e, r29	; 62
     800:	0f be       	out	0x3f, r0	; 63
     802:	cd bf       	out	0x3d, r28	; 61
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	08 95       	ret

0000080a <servoTaak>:
     80a:	0a e8       	ldi	r16, 0x8A	; 138
     80c:	10 e0       	ldi	r17, 0x00	; 0
     80e:	c1 e0       	ldi	r28, 0x01	; 1
     810:	d0 e0       	ldi	r29, 0x00	; 0
     812:	e1 2c       	mov	r14, r1
     814:	f1 2c       	mov	r15, r1
     816:	f0 92 2b 04 	sts	0x042B, r15	; 0x80042b <hoek+0x1>
     81a:	e0 92 2a 04 	sts	0x042A, r14	; 0x80042a <hoek>
     81e:	c7 01       	movw	r24, r14
     820:	99 27       	eor	r25, r25
     822:	9c 01       	movw	r18, r24
     824:	22 0f       	add	r18, r18
     826:	33 1f       	adc	r19, r19
     828:	22 0f       	add	r18, r18
     82a:	33 1f       	adc	r19, r19
     82c:	22 0f       	add	r18, r18
     82e:	33 1f       	adc	r19, r19
     830:	82 1b       	sub	r24, r18
     832:	93 0b       	sbc	r25, r19
     834:	95 5b       	subi	r25, 0xB5	; 181
     836:	f8 01       	movw	r30, r16
     838:	91 83       	std	Z+1, r25	; 0x01
     83a:	80 83       	st	Z, r24
     83c:	ff ef       	ldi	r31, 0xFF	; 255
     83e:	24 e3       	ldi	r18, 0x34	; 52
     840:	8c e0       	ldi	r24, 0x0C	; 12
     842:	f1 50       	subi	r31, 0x01	; 1
     844:	20 40       	sbci	r18, 0x00	; 0
     846:	80 40       	sbci	r24, 0x00	; 0
     848:	e1 f7       	brne	.-8      	; 0x842 <servoTaak+0x38>
     84a:	00 c0       	rjmp	.+0      	; 0x84c <servoTaak+0x42>
     84c:	00 00       	nop
     84e:	88 e1       	ldi	r24, 0x18	; 24
     850:	92 e0       	ldi	r25, 0x02	; 2
     852:	86 df       	rcall	.-244    	; 0x760 <UART_Transmit_String>
     854:	60 91 2a 04 	lds	r22, 0x042A	; 0x80042a <hoek>
     858:	70 91 2b 04 	lds	r23, 0x042B	; 0x80042b <hoek+0x1>
     85c:	07 2e       	mov	r0, r23
     85e:	00 0c       	add	r0, r0
     860:	88 0b       	sbc	r24, r24
     862:	99 0b       	sbc	r25, r25
     864:	b4 df       	rcall	.-152    	; 0x7ce <UART_Transmit_Integer>
     866:	8f e1       	ldi	r24, 0x1F	; 31
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	7a df       	rcall	.-268    	; 0x760 <UART_Transmit_String>
     86c:	60 91 33 04 	lds	r22, 0x0433	; 0x800433 <afstand>
     870:	70 91 34 04 	lds	r23, 0x0434	; 0x800434 <afstand+0x1>
     874:	07 2e       	mov	r0, r23
     876:	00 0c       	add	r0, r0
     878:	88 0b       	sbc	r24, r24
     87a:	99 0b       	sbc	r25, r25
     87c:	a8 df       	rcall	.-176    	; 0x7ce <UART_Transmit_Integer>
     87e:	8a e2       	ldi	r24, 0x2A	; 42
     880:	92 e0       	ldi	r25, 0x02	; 2
     882:	6e df       	rcall	.-292    	; 0x760 <UART_Transmit_String>
     884:	60 91 26 04 	lds	r22, 0x0426	; 0x800426 <temperatuur>
     888:	70 91 27 04 	lds	r23, 0x0427	; 0x800427 <temperatuur+0x1>
     88c:	07 2e       	mov	r0, r23
     88e:	00 0c       	add	r0, r0
     890:	88 0b       	sbc	r24, r24
     892:	99 0b       	sbc	r25, r25
     894:	9c df       	rcall	.-200    	; 0x7ce <UART_Transmit_Integer>
     896:	89 e3       	ldi	r24, 0x39	; 57
     898:	92 e0       	ldi	r25, 0x02	; 2
     89a:	62 df       	rcall	.-316    	; 0x760 <UART_Transmit_String>
     89c:	60 91 28 04 	lds	r22, 0x0428	; 0x800428 <humidity>
     8a0:	70 91 29 04 	lds	r23, 0x0429	; 0x800429 <humidity+0x1>
     8a4:	07 2e       	mov	r0, r23
     8a6:	00 0c       	add	r0, r0
     8a8:	88 0b       	sbc	r24, r24
     8aa:	99 0b       	sbc	r25, r25
     8ac:	90 df       	rcall	.-224    	; 0x7ce <UART_Transmit_Integer>
     8ae:	85 e1       	ldi	r24, 0x15	; 21
     8b0:	92 e0       	ldi	r25, 0x02	; 2
     8b2:	56 df       	rcall	.-340    	; 0x760 <UART_Transmit_String>
     8b4:	d0 93 31 04 	sts	0x0431, r29	; 0x800431 <watchdogServo+0x1>
     8b8:	c0 93 30 04 	sts	0x0430, r28	; 0x800430 <watchdogServo>
     8bc:	9b e1       	ldi	r25, 0x1B	; 27
     8be:	e9 0e       	add	r14, r25
     8c0:	f1 1c       	adc	r15, r1
     8c2:	e3 ef       	ldi	r30, 0xF3	; 243
     8c4:	ee 16       	cp	r14, r30
     8c6:	f1 04       	cpc	r15, r1
     8c8:	09 f0       	breq	.+2      	; 0x8cc <servoTaak+0xc2>
     8ca:	a5 cf       	rjmp	.-182    	; 0x816 <servoTaak+0xc>
     8cc:	a2 cf       	rjmp	.-188    	; 0x812 <servoTaak+0x8>

000008ce <__vector_25>:
     8ce:	1f 92       	push	r1
     8d0:	0f 92       	push	r0
     8d2:	0f b6       	in	r0, 0x3f	; 63
     8d4:	0f 92       	push	r0
     8d6:	11 24       	eor	r1, r1
     8d8:	0b b6       	in	r0, 0x3b	; 59
     8da:	0f 92       	push	r0
     8dc:	2f 93       	push	r18
     8de:	3f 93       	push	r19
     8e0:	4f 93       	push	r20
     8e2:	5f 93       	push	r21
     8e4:	6f 93       	push	r22
     8e6:	7f 93       	push	r23
     8e8:	8f 93       	push	r24
     8ea:	9f 93       	push	r25
     8ec:	af 93       	push	r26
     8ee:	bf 93       	push	r27
     8f0:	ef 93       	push	r30
     8f2:	ff 93       	push	r31
     8f4:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     8f8:	80 93 32 04 	sts	0x0432, r24	; 0x800432 <ontvang>
     8fc:	29 df       	rcall	.-430    	; 0x750 <UART_Transmit>
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	90 93 b9 02 	sts	0x02B9, r25	; 0x8002b9 <state+0x1>
     906:	80 93 b8 02 	sts	0x02B8, r24	; 0x8002b8 <state>
     90a:	ff 91       	pop	r31
     90c:	ef 91       	pop	r30
     90e:	bf 91       	pop	r27
     910:	af 91       	pop	r26
     912:	9f 91       	pop	r25
     914:	8f 91       	pop	r24
     916:	7f 91       	pop	r23
     918:	6f 91       	pop	r22
     91a:	5f 91       	pop	r21
     91c:	4f 91       	pop	r20
     91e:	3f 91       	pop	r19
     920:	2f 91       	pop	r18
     922:	0f 90       	pop	r0
     924:	0b be       	out	0x3b, r0	; 59
     926:	0f 90       	pop	r0
     928:	0f be       	out	0x3f, r0	; 63
     92a:	0f 90       	pop	r0
     92c:	1f 90       	pop	r1
     92e:	18 95       	reti

00000930 <INT1_init>:
     930:	e8 e6       	ldi	r30, 0x68	; 104
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	80 81       	ld	r24, Z
     936:	81 60       	ori	r24, 0x01	; 1
     938:	80 83       	st	Z, r24
     93a:	eb e6       	ldi	r30, 0x6B	; 107
     93c:	f0 e0       	ldi	r31, 0x00	; 0
     93e:	80 81       	ld	r24, Z
     940:	82 60       	ori	r24, 0x02	; 2
     942:	80 83       	st	Z, r24
     944:	08 95       	ret

00000946 <__vector_9>:
     946:	1f 92       	push	r1
     948:	0f 92       	push	r0
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	0f 92       	push	r0
     94e:	11 24       	eor	r1, r1
     950:	0b b6       	in	r0, 0x3b	; 59
     952:	0f 92       	push	r0
     954:	2f 93       	push	r18
     956:	3f 93       	push	r19
     958:	4f 93       	push	r20
     95a:	5f 93       	push	r21
     95c:	6f 93       	push	r22
     95e:	7f 93       	push	r23
     960:	8f 93       	push	r24
     962:	9f 93       	push	r25
     964:	af 93       	push	r26
     966:	bf 93       	push	r27
     968:	ef 93       	push	r30
     96a:	ff 93       	push	r31
     96c:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <running>
     970:	88 23       	and	r24, r24
     972:	d1 f1       	breq	.+116    	; 0x9e8 <__vector_9+0xa2>
     974:	80 91 b6 02 	lds	r24, 0x02B6	; 0x8002b6 <up>
     978:	81 11       	cpse	r24, r1
     97a:	10 c0       	rjmp	.+32     	; 0x99c <__vector_9+0x56>
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	80 93 b6 02 	sts	0x02B6, r24	; 0x8002b6 <up>
     982:	10 92 b2 02 	sts	0x02B2, r1	; 0x8002b2 <timerCounter>
     986:	10 92 b3 02 	sts	0x02B3, r1	; 0x8002b3 <timerCounter+0x1>
     98a:	10 92 b4 02 	sts	0x02B4, r1	; 0x8002b4 <timerCounter+0x2>
     98e:	10 92 b5 02 	sts	0x02B5, r1	; 0x8002b5 <timerCounter+0x3>
     992:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     996:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     99a:	26 c0       	rjmp	.+76     	; 0x9e8 <__vector_9+0xa2>
     99c:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <up>
     9a0:	20 91 b2 02 	lds	r18, 0x02B2	; 0x8002b2 <timerCounter>
     9a4:	30 91 b3 02 	lds	r19, 0x02B3	; 0x8002b3 <timerCounter+0x1>
     9a8:	40 91 b4 02 	lds	r20, 0x02B4	; 0x8002b4 <timerCounter+0x2>
     9ac:	50 91 b5 02 	lds	r21, 0x02B5	; 0x8002b5 <timerCounter+0x3>
     9b0:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     9b4:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     9b8:	af ef       	ldi	r26, 0xFF	; 255
     9ba:	bf ef       	ldi	r27, 0xFF	; 255
     9bc:	0e 94 9b 12 	call	0x2536	; 0x2536 <__muluhisi3>
     9c0:	6e 0f       	add	r22, r30
     9c2:	7f 1f       	adc	r23, r31
     9c4:	81 1d       	adc	r24, r1
     9c6:	91 1d       	adc	r25, r1
     9c8:	24 e7       	ldi	r18, 0x74	; 116
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	40 e0       	ldi	r20, 0x00	; 0
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	0e 94 62 12 	call	0x24c4	; 0x24c4 <__udivmodsi4>
     9d4:	20 93 ae 02 	sts	0x02AE, r18	; 0x8002ae <result>
     9d8:	30 93 af 02 	sts	0x02AF, r19	; 0x8002af <result+0x1>
     9dc:	40 93 b0 02 	sts	0x02B0, r20	; 0x8002b0 <result+0x2>
     9e0:	50 93 b1 02 	sts	0x02B1, r21	; 0x8002b1 <result+0x3>
     9e4:	10 92 b7 02 	sts	0x02B7, r1	; 0x8002b7 <running>
     9e8:	ff 91       	pop	r31
     9ea:	ef 91       	pop	r30
     9ec:	bf 91       	pop	r27
     9ee:	af 91       	pop	r26
     9f0:	9f 91       	pop	r25
     9f2:	8f 91       	pop	r24
     9f4:	7f 91       	pop	r23
     9f6:	6f 91       	pop	r22
     9f8:	5f 91       	pop	r21
     9fa:	4f 91       	pop	r20
     9fc:	3f 91       	pop	r19
     9fe:	2f 91       	pop	r18
     a00:	0f 90       	pop	r0
     a02:	0b be       	out	0x3b, r0	; 59
     a04:	0f 90       	pop	r0
     a06:	0f be       	out	0x3f, r0	; 63
     a08:	0f 90       	pop	r0
     a0a:	1f 90       	pop	r1
     a0c:	18 95       	reti

00000a0e <pulse>:
     a0e:	28 98       	cbi	0x05, 0	; 5
     a10:	85 e0       	ldi	r24, 0x05	; 5
     a12:	8a 95       	dec	r24
     a14:	f1 f7       	brne	.-4      	; 0xa12 <pulse+0x4>
     a16:	00 00       	nop
     a18:	28 9a       	sbi	0x05, 0	; 5
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <running>
     a20:	85 e3       	ldi	r24, 0x35	; 53
     a22:	8a 95       	dec	r24
     a24:	f1 f7       	brne	.-4      	; 0xa22 <pulse+0x14>
     a26:	00 00       	nop
     a28:	28 98       	cbi	0x05, 0	; 5
     a2a:	08 95       	ret

00000a2c <sonarTaak>:
     a2c:	c1 e0       	ldi	r28, 0x01	; 1
     a2e:	d0 e0       	ldi	r29, 0x00	; 0
     a30:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <running>
     a34:	81 11       	cpse	r24, r1
     a36:	16 c0       	rjmp	.+44     	; 0xa64 <sonarTaak+0x38>
     a38:	2f ef       	ldi	r18, 0xFF	; 255
     a3a:	80 e7       	ldi	r24, 0x70	; 112
     a3c:	92 e0       	ldi	r25, 0x02	; 2
     a3e:	21 50       	subi	r18, 0x01	; 1
     a40:	80 40       	sbci	r24, 0x00	; 0
     a42:	90 40       	sbci	r25, 0x00	; 0
     a44:	e1 f7       	brne	.-8      	; 0xa3e <sonarTaak+0x12>
     a46:	00 c0       	rjmp	.+0      	; 0xa48 <sonarTaak+0x1c>
     a48:	00 00       	nop
     a4a:	e1 df       	rcall	.-62     	; 0xa0e <pulse>
     a4c:	80 91 ae 02 	lds	r24, 0x02AE	; 0x8002ae <result>
     a50:	90 91 af 02 	lds	r25, 0x02AF	; 0x8002af <result+0x1>
     a54:	a0 91 b0 02 	lds	r26, 0x02B0	; 0x8002b0 <result+0x2>
     a58:	b0 91 b1 02 	lds	r27, 0x02B1	; 0x8002b1 <result+0x3>
     a5c:	90 93 34 04 	sts	0x0434, r25	; 0x800434 <afstand+0x1>
     a60:	80 93 33 04 	sts	0x0433, r24	; 0x800433 <afstand>
     a64:	d0 93 23 03 	sts	0x0323, r29	; 0x800323 <watchdogSonar+0x1>
     a68:	c0 93 22 03 	sts	0x0322, r28	; 0x800322 <watchdogSonar>
     a6c:	e1 cf       	rjmp	.-62     	; 0xa30 <sonarTaak+0x4>

00000a6e <timer3_init>:
     a6e:	e1 e9       	ldi	r30, 0x91	; 145
     a70:	f0 e0       	ldi	r31, 0x00	; 0
     a72:	80 81       	ld	r24, Z
     a74:	82 60       	ori	r24, 0x02	; 2
     a76:	80 83       	st	Z, r24
     a78:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a7c:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a80:	e1 e7       	ldi	r30, 0x71	; 113
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	80 81       	ld	r24, Z
     a86:	81 60       	ori	r24, 0x01	; 1
     a88:	80 83       	st	Z, r24
     a8a:	08 95       	ret

00000a8c <__vector_35>:
     a8c:	1f 92       	push	r1
     a8e:	0f 92       	push	r0
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	0f 92       	push	r0
     a94:	11 24       	eor	r1, r1
     a96:	0b b6       	in	r0, 0x3b	; 59
     a98:	0f 92       	push	r0
     a9a:	2f 93       	push	r18
     a9c:	3f 93       	push	r19
     a9e:	4f 93       	push	r20
     aa0:	5f 93       	push	r21
     aa2:	6f 93       	push	r22
     aa4:	7f 93       	push	r23
     aa6:	8f 93       	push	r24
     aa8:	9f 93       	push	r25
     aaa:	af 93       	push	r26
     aac:	bf 93       	push	r27
     aae:	ef 93       	push	r30
     ab0:	ff 93       	push	r31
     ab2:	80 91 b6 02 	lds	r24, 0x02B6	; 0x8002b6 <up>
     ab6:	88 23       	and	r24, r24
     ab8:	e9 f1       	breq	.+122    	; 0xb34 <__vector_35+0xa8>
     aba:	80 91 b2 02 	lds	r24, 0x02B2	; 0x8002b2 <timerCounter>
     abe:	90 91 b3 02 	lds	r25, 0x02B3	; 0x8002b3 <timerCounter+0x1>
     ac2:	a0 91 b4 02 	lds	r26, 0x02B4	; 0x8002b4 <timerCounter+0x2>
     ac6:	b0 91 b5 02 	lds	r27, 0x02B5	; 0x8002b5 <timerCounter+0x3>
     aca:	01 96       	adiw	r24, 0x01	; 1
     acc:	a1 1d       	adc	r26, r1
     ace:	b1 1d       	adc	r27, r1
     ad0:	80 93 b2 02 	sts	0x02B2, r24	; 0x8002b2 <timerCounter>
     ad4:	90 93 b3 02 	sts	0x02B3, r25	; 0x8002b3 <timerCounter+0x1>
     ad8:	a0 93 b4 02 	sts	0x02B4, r26	; 0x8002b4 <timerCounter+0x2>
     adc:	b0 93 b5 02 	sts	0x02B5, r27	; 0x8002b5 <timerCounter+0x3>
     ae0:	20 91 b2 02 	lds	r18, 0x02B2	; 0x8002b2 <timerCounter>
     ae4:	30 91 b3 02 	lds	r19, 0x02B3	; 0x8002b3 <timerCounter+0x1>
     ae8:	40 91 b4 02 	lds	r20, 0x02B4	; 0x8002b4 <timerCounter+0x2>
     aec:	50 91 b5 02 	lds	r21, 0x02B5	; 0x8002b5 <timerCounter+0x3>
     af0:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     af4:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     af8:	af ef       	ldi	r26, 0xFF	; 255
     afa:	bf ef       	ldi	r27, 0xFF	; 255
     afc:	0e 94 9b 12 	call	0x2536	; 0x2536 <__muluhisi3>
     b00:	dc 01       	movw	r26, r24
     b02:	cb 01       	movw	r24, r22
     b04:	8e 0f       	add	r24, r30
     b06:	9f 1f       	adc	r25, r31
     b08:	a1 1d       	adc	r26, r1
     b0a:	b1 1d       	adc	r27, r1
     b0c:	81 30       	cpi	r24, 0x01	; 1
     b0e:	94 4d       	sbci	r25, 0xD4	; 212
     b10:	a0 43       	sbci	r26, 0x30	; 48
     b12:	b1 05       	cpc	r27, r1
     b14:	78 f0       	brcs	.+30     	; 0xb34 <__vector_35+0xa8>
     b16:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <up>
     b1a:	10 92 b7 02 	sts	0x02B7, r1	; 0x8002b7 <running>
     b1e:	8f ef       	ldi	r24, 0xFF	; 255
     b20:	9f ef       	ldi	r25, 0xFF	; 255
     b22:	dc 01       	movw	r26, r24
     b24:	80 93 ae 02 	sts	0x02AE, r24	; 0x8002ae <result>
     b28:	90 93 af 02 	sts	0x02AF, r25	; 0x8002af <result+0x1>
     b2c:	a0 93 b0 02 	sts	0x02B0, r26	; 0x8002b0 <result+0x2>
     b30:	b0 93 b1 02 	sts	0x02B1, r27	; 0x8002b1 <result+0x3>
     b34:	ff 91       	pop	r31
     b36:	ef 91       	pop	r30
     b38:	bf 91       	pop	r27
     b3a:	af 91       	pop	r26
     b3c:	9f 91       	pop	r25
     b3e:	8f 91       	pop	r24
     b40:	7f 91       	pop	r23
     b42:	6f 91       	pop	r22
     b44:	5f 91       	pop	r21
     b46:	4f 91       	pop	r20
     b48:	3f 91       	pop	r19
     b4a:	2f 91       	pop	r18
     b4c:	0f 90       	pop	r0
     b4e:	0b be       	out	0x3b, r0	; 59
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <initServo>:
}

void initServo()
{
	DDRB |= (1 << PB6);
     b5a:	26 9a       	sbi	0x04, 6	; 4
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
     b5c:	82 e3       	ldi	r24, 0x32	; 50
     b5e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = (1 << WGM13) | (1 << CS11);
     b62:	82 e1       	ldi	r24, 0x12	; 18
     b64:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	ICR1 = 20000;
     b68:	80 e2       	ldi	r24, 0x20	; 32
     b6a:	9e e4       	ldi	r25, 0x4E	; 78
     b6c:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     b70:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	TCNT1 = 0;
     b74:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     b78:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	9b e4       	ldi	r25, 0x4B	; 75
     b80:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     b84:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
	TCCR1B = (1 << WGM13) | (1 << CS11);
	ICR1 = 20000;
	TCNT1 = 0;
	turnServo(0);
	TIMSK1 |= (1 << 1);
     b88:	ef e6       	ldi	r30, 0x6F	; 111
     b8a:	f0 e0       	ldi	r31, 0x00	; 0
     b8c:	80 81       	ld	r24, Z
     b8e:	82 60       	ori	r24, 0x02	; 2
     b90:	80 83       	st	Z, r24
     b92:	08 95       	ret

00000b94 <init_master>:
}



void init_master() {
	TWSR = 0;
     b94:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
     b98:	88 e4       	ldi	r24, 0x48	; 72
     b9a:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
	TWCR = (1<<TWEN);
     b9e:	84 e0       	ldi	r24, 0x04	; 4
     ba0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     ba4:	08 95       	ret

00000ba6 <main>:
//echo = digital pin 52
//servo = digital pin 12


int main() 
{
     ba6:	ef 92       	push	r14
     ba8:	ff 92       	push	r15
     baa:	0f 93       	push	r16
	sem = xSemaphoreCreateBinary();
     bac:	43 e0       	ldi	r20, 0x03	; 3
     bae:	60 e0       	ldi	r22, 0x00	; 0
     bb0:	81 e0       	ldi	r24, 0x01	; 1
     bb2:	b3 d3       	rcall	.+1894   	; 0x131a <xQueueGenericCreate>
     bb4:	90 93 21 03 	sts	0x0321, r25	; 0x800321 <sem+0x1>
     bb8:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <sem>
	xSemaphoreGive(sem);
     bbc:	20 e0       	ldi	r18, 0x00	; 0
     bbe:	40 e0       	ldi	r20, 0x00	; 0
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	60 e0       	ldi	r22, 0x00	; 0
     bc4:	70 e0       	ldi	r23, 0x00	; 0
     bc6:	d4 d3       	rcall	.+1960   	; 0x1370 <xQueueGenericSend>
	DDRD|= 0x03;
     bc8:	8a b1       	in	r24, 0x0a	; 10
     bca:	83 60       	ori	r24, 0x03	; 3
	DDRB |= (1 << TRIGGER);											// Trigger pin
	UART_Init();
     bcc:	8a b9       	out	0x0a, r24	; 10
	INT1_init();
     bce:	20 9a       	sbi	0x04, 0	; 4
	timer3_init();
     bd0:	b1 dd       	rcall	.-1182   	; 0x734 <UART_Init>
	initServo();
     bd2:	ae de       	rcall	.-676    	; 0x930 <INT1_init>
     bd4:	4c df       	rcall	.-360    	; 0xa6e <timer3_init>
	sei();
     bd6:	c1 df       	rcall	.-126    	; 0xb5a <initServo>
	initQ();
     bd8:	78 94       	sei
     bda:	87 dd       	rcall	.-1266   	; 0x6ea <initQ>
	init_master();
     bdc:	db df       	rcall	.-74     	; 0xb94 <init_master>
     bde:	10 92 23 03 	sts	0x0323, r1	; 0x800323 <watchdogSonar+0x1>
	watchdogSonar=0;
     be2:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <watchdogSonar>
     be6:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <watchdogServo+0x1>
	watchdogServo=0;
     bea:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <watchdogServo>
     bee:	10 92 25 04 	sts	0x0425, r1	; 0x800425 <watchdogTemp+0x1>
	watchdogTemp=0;
     bf2:	10 92 24 04 	sts	0x0424, r1	; 0x800424 <watchdogTemp>
     bf6:	98 e2       	ldi	r25, 0x28	; 40
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
     bf8:	88 e1       	ldi	r24, 0x18	; 24
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	a8 95       	wdr
     c00:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     c04:	0f be       	out	0x3f, r0	; 63
     c06:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	wdt_enable(WDTO_4S);
	// Replace with your application code
	UART_Transmit_String("setup done\n\r");
     c0a:	85 e4       	ldi	r24, 0x45	; 69
     c0c:	92 e0       	ldi	r25, 0x02	; 2
     c0e:	a8 dd       	rcall	.-1200   	; 0x760 <UART_Transmit_String>
     c10:	e1 2c       	mov	r14, r1
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,3,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
     c12:	f1 2c       	mov	r15, r1
     c14:	03 e0       	ldi	r16, 0x03	; 3
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	30 e0       	ldi	r19, 0x00	; 0
     c1a:	40 e0       	ldi	r20, 0x00	; 0
     c1c:	51 e0       	ldi	r21, 0x01	; 1
     c1e:	62 e5       	ldi	r22, 0x52	; 82
     c20:	72 e0       	ldi	r23, 0x02	; 2
     c22:	86 e1       	ldi	r24, 0x16	; 22
     c24:	95 e0       	ldi	r25, 0x05	; 5
     c26:	ee d6       	rcall	.+3548   	; 0x1a04 <xTaskCreate>
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,3,NULL);			//code van Joris & Benjamin
     c28:	20 e0       	ldi	r18, 0x00	; 0
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	40 e0       	ldi	r20, 0x00	; 0
     c2e:	51 e0       	ldi	r21, 0x01	; 1
     c30:	6f e5       	ldi	r22, 0x5F	; 95
     c32:	72 e0       	ldi	r23, 0x02	; 2
     c34:	85 e0       	ldi	r24, 0x05	; 5
     c36:	94 e0       	ldi	r25, 0x04	; 4
     c38:	e5 d6       	rcall	.+3530   	; 0x1a04 <xTaskCreate>
	xTaskCreate(temperatuurTaak,"temperatuur Sensor",256,NULL,3,NULL);
     c3a:	20 e0       	ldi	r18, 0x00	; 0
     c3c:	30 e0       	ldi	r19, 0x00	; 0
     c3e:	40 e0       	ldi	r20, 0x00	; 0
     c40:	51 e0       	ldi	r21, 0x01	; 1
     c42:	6b e6       	ldi	r22, 0x6B	; 107
     c44:	72 e0       	ldi	r23, 0x02	; 2
     c46:	8b ea       	ldi	r24, 0xAB	; 171
     c48:	96 e0       	ldi	r25, 0x06	; 6
	xTaskCreate(watchdogTaak,"watchdog reset",256,NULL,4,NULL);
     c4a:	dc d6       	rcall	.+3512   	; 0x1a04 <xTaskCreate>
     c4c:	04 e0       	ldi	r16, 0x04	; 4
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	30 e0       	ldi	r19, 0x00	; 0
     c52:	40 e0       	ldi	r20, 0x00	; 0
     c54:	51 e0       	ldi	r21, 0x01	; 1
     c56:	6e e7       	ldi	r22, 0x7E	; 126
     c58:	72 e0       	ldi	r23, 0x02	; 2
     c5a:	8e eb       	ldi	r24, 0xBE	; 190
     c5c:	93 e0       	ldi	r25, 0x03	; 3
     c5e:	d2 d6       	rcall	.+3492   	; 0x1a04 <xTaskCreate>

	vTaskStartScheduler();
     c60:	e5 d7       	rcall	.+4042   	; 0x1c2c <vTaskStartScheduler>
     c62:	80 e0       	ldi	r24, 0x00	; 0
}
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	08 95       	ret

00000c6e <ontvangen>:
     c6e:	ef 92       	push	r14
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
	TWCR = (1<<TWEN);
}

void ontvangen(uint8_t ad,uint8_t b[],uint8_t max) {
     c70:	ff 92       	push	r15
     c72:	0f 93       	push	r16
     c74:	1f 93       	push	r17
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
	uint8_t op[15];
	
	//	UART_Transmit('a');

	TWCR |= (1<<TWSTA);
     c7a:	ec eb       	ldi	r30, 0xBC	; 188
     c7c:	f0 e0       	ldi	r31, 0x00	; 0
     c7e:	90 81       	ld	r25, Z
     c80:	90 62       	ori	r25, 0x20	; 32
     c82:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     c84:	90 81       	ld	r25, Z
     c86:	99 23       	and	r25, r25
     c88:	ec f7       	brge	.-6      	; 0xc84 <ontvangen+0x16>
	op[0] = TWSR;
     c8a:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>

	
	//UART_Transmit('b');

	TWDR=(ad<<1)+1;
     c8e:	88 0f       	add	r24, r24
     c90:	8f 5f       	subi	r24, 0xFF	; 255
     c92:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     c96:	84 e8       	ldi	r24, 0x84	; 132
     c98:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     c9c:	ec eb       	ldi	r30, 0xBC	; 188
     c9e:	f0 e0       	ldi	r31, 0x00	; 0
     ca0:	80 81       	ld	r24, Z
     ca2:	88 23       	and	r24, r24
     ca4:	ec f7       	brge	.-6      	; 0xca0 <ontvangen+0x32>

	op[1] = TWSR;
     ca6:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	b[0]=TWDR;
     caa:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     cae:	db 01       	movw	r26, r22
     cb0:	8c 93       	st	X, r24
	
	uint8_t tel=0;
     cb2:	90 e0       	ldi	r25, 0x00	; 0
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     cb4:	50 e0       	ldi	r21, 0x00	; 0
     cb6:	41 50       	subi	r20, 0x01	; 1
     cb8:	51 09       	sbc	r21, r1
			TWCR=(1<<TWINT)|(1<<TWEN);
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     cba:	ec eb       	ldi	r30, 0xBC	; 188
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	0f 2e       	mov	r0, r31
     cc0:	f4 ec       	ldi	r31, 0xC4	; 196
     cc2:	ff 2e       	mov	r15, r31
     cc4:	f0 2d       	mov	r31, r0
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
			TWCR=(1<<TWINT)|(1<<TWEN);
     cc6:	0f 2e       	mov	r0, r31
     cc8:	f4 e8       	ldi	r31, 0x84	; 132
     cca:	ef 2e       	mov	r14, r31
     ccc:	f0 2d       	mov	r31, r0
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
		//UART_Transmit('c3');
		op[tel] = TWSR;
     cce:	09 eb       	ldi	r16, 0xB9	; 185
     cd0:	10 e0       	ldi	r17, 0x00	; 0
		b[tel]=TWDR;
     cd2:	cb eb       	ldi	r28, 0xBB	; 187
     cd4:	d0 e0       	ldi	r29, 0x00	; 0
	
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     cd6:	29 2f       	mov	r18, r25
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	24 17       	cp	r18, r20
     cdc:	35 07       	cpc	r19, r21
     cde:	11 f4       	brne	.+4      	; 0xce4 <ontvangen+0x76>
			TWCR=(1<<TWINT)|(1<<TWEN);
     ce0:	e0 82       	st	Z, r14
     ce2:	01 c0       	rjmp	.+2      	; 0xce6 <ontvangen+0x78>
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     ce4:	f0 82       	st	Z, r15
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
     ce6:	80 81       	ld	r24, Z
     ce8:	88 23       	and	r24, r24
     cea:	ec f7       	brge	.-6      	; 0xce6 <ontvangen+0x78>
		//UART_Transmit('c3');
		op[tel] = TWSR;
     cec:	d8 01       	movw	r26, r16
     cee:	8c 91       	ld	r24, X
		b[tel]=TWDR;
     cf0:	28 81       	ld	r18, Y
     cf2:	db 01       	movw	r26, r22
     cf4:	a9 0f       	add	r26, r25
     cf6:	b1 1d       	adc	r27, r1
     cf8:	2c 93       	st	X, r18
	}while(op[tel++] == 0x50);
     cfa:	9f 5f       	subi	r25, 0xFF	; 255
     cfc:	80 35       	cpi	r24, 0x50	; 80
     cfe:	59 f3       	breq	.-42     	; 0xcd6 <ontvangen+0x68>

	
	//UART_Transmit('d');

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d00:	84 e9       	ldi	r24, 0x94	; 148
     d02:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>

	//   for(uint8_t i=0;i<tel;++i) {
	//	 writeString("\n\r");writeInteger(op[i],16);
	//	 writeString(" data ");writeInteger(b[i],10);
	//   }
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	0f 91       	pop	r16
     d0e:	ff 90       	pop	r15
     d10:	ef 90       	pop	r14
     d12:	08 95       	ret

00000d14 <verzenden>:

void verzenden(uint8_t ad,uint8_t b) {
	//  uint8_t op[5];

	TWCR |= (1<<TWSTA);
     d14:	ec eb       	ldi	r30, 0xBC	; 188
     d16:	f0 e0       	ldi	r31, 0x00	; 0
     d18:	90 81       	ld	r25, Z
     d1a:	90 62       	ori	r25, 0x20	; 32
     d1c:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     d1e:	90 81       	ld	r25, Z
     d20:	99 23       	and	r25, r25
     d22:	ec f7       	brge	.-6      	; 0xd1e <verzenden+0xa>
	//   op[0] = TWSR;
	TWDR=(ad<<1);
     d24:	88 0f       	add	r24, r24
     d26:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     d2a:	84 e8       	ldi	r24, 0x84	; 132
     d2c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     d30:	ec eb       	ldi	r30, 0xBC	; 188
     d32:	f0 e0       	ldi	r31, 0x00	; 0
     d34:	80 81       	ld	r24, Z
     d36:	88 23       	and	r24, r24
     d38:	ec f7       	brge	.-6      	; 0xd34 <verzenden+0x20>
	//    op[1] = TWSR;

	TWDR=b;
     d3a:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     d3e:	84 e8       	ldi	r24, 0x84	; 132
     d40:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     d44:	ec eb       	ldi	r30, 0xBC	; 188
     d46:	f0 e0       	ldi	r31, 0x00	; 0
     d48:	80 81       	ld	r24, Z
     d4a:	88 23       	and	r24, r24
     d4c:	ec f7       	brge	.-6      	; 0xd48 <verzenden+0x34>
	//  op[2] = TWSR;

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d4e:	84 e9       	ldi	r24, 0x94	; 148
     d50:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     d54:	08 95       	ret

00000d56 <temperatuurTaak>:

	vTaskStartScheduler();
}


void temperatuurTaak(){
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	1f 92       	push	r1
     d5c:	1f 92       	push	r1
     d5e:	cd b7       	in	r28, 0x3d	; 61
     d60:	de b7       	in	r29, 0x3e	; 62
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		humidity=((125*waarde)/65536.0) -6;

		watchdogTemp = 1;
     d62:	01 e0       	ldi	r16, 0x01	; 1
     d64:	10 e0       	ldi	r17, 0x00	; 0

	uint8_t data[2];
	uint32_t waarde =0;

	while(1){
		verzenden(0x40, 0xE3);
     d66:	63 ee       	ldi	r22, 0xE3	; 227
     d68:	80 e4       	ldi	r24, 0x40	; 64
     d6a:	d4 df       	rcall	.-88     	; 0xd14 <verzenden>
		ontvangen(0x40, data, 2);
     d6c:	42 e0       	ldi	r20, 0x02	; 2
     d6e:	be 01       	movw	r22, r28
     d70:	6f 5f       	subi	r22, 0xFF	; 255
     d72:	7f 4f       	sbci	r23, 0xFF	; 255
     d74:	80 e4       	ldi	r24, 0x40	; 64
     d76:	7b df       	rcall	.-266    	; 0xc6e <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		temperatuur=((175.72*waarde)/65536.0) -46.85;
     d78:	69 81       	ldd	r22, Y+1	; 0x01
     d7a:	70 e0       	ldi	r23, 0x00	; 0
     d7c:	76 2f       	mov	r23, r22
     d7e:	66 27       	eor	r22, r22
     d80:	8a 81       	ldd	r24, Y+2	; 0x02
     d82:	68 2b       	or	r22, r24
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	0e 94 71 11 	call	0x22e2	; 0x22e2 <__floatunsisf>
     d8c:	22 e5       	ldi	r18, 0x52	; 82
     d8e:	38 eb       	ldi	r19, 0xB8	; 184
     d90:	4f e2       	ldi	r20, 0x2F	; 47
     d92:	53 e4       	ldi	r21, 0x43	; 67
     d94:	0e 94 ff 11 	call	0x23fe	; 0x23fe <__mulsf3>
     d98:	20 e0       	ldi	r18, 0x00	; 0
     d9a:	30 e0       	ldi	r19, 0x00	; 0
     d9c:	40 e8       	ldi	r20, 0x80	; 128
     d9e:	57 e3       	ldi	r21, 0x37	; 55
     da0:	0e 94 ff 11 	call	0x23fe	; 0x23fe <__mulsf3>
     da4:	26 e6       	ldi	r18, 0x66	; 102
     da6:	36 e6       	ldi	r19, 0x66	; 102
     da8:	4b e3       	ldi	r20, 0x3B	; 59
     daa:	52 e4       	ldi	r21, 0x42	; 66
     dac:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__subsf3>
     db0:	0e 94 40 11 	call	0x2280	; 0x2280 <__fixsfsi>
     db4:	70 93 27 04 	sts	0x0427, r23	; 0x800427 <temperatuur+0x1>
     db8:	60 93 26 04 	sts	0x0426, r22	; 0x800426 <temperatuur>

		verzenden(0x40, 0xE5);
     dbc:	65 ee       	ldi	r22, 0xE5	; 229
     dbe:	80 e4       	ldi	r24, 0x40	; 64
     dc0:	a9 df       	rcall	.-174    	; 0xd14 <verzenden>
		ontvangen(0x40, data, 2);
     dc2:	42 e0       	ldi	r20, 0x02	; 2
     dc4:	be 01       	movw	r22, r28
     dc6:	6f 5f       	subi	r22, 0xFF	; 255
     dc8:	7f 4f       	sbci	r23, 0xFF	; 255
     dca:	80 e4       	ldi	r24, 0x40	; 64
     dcc:	50 df       	rcall	.-352    	; 0xc6e <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		humidity=((125*waarde)/65536.0) -6;
     dce:	29 81       	ldd	r18, Y+1	; 0x01
     dd0:	30 e0       	ldi	r19, 0x00	; 0
     dd2:	32 2f       	mov	r19, r18
     dd4:	22 27       	eor	r18, r18
     dd6:	8a 81       	ldd	r24, Y+2	; 0x02
     dd8:	28 2b       	or	r18, r24
     dda:	ad e7       	ldi	r26, 0x7D	; 125
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	0e 94 8c 12 	call	0x2518	; 0x2518 <__umulhisi3>
     de2:	0e 94 71 11 	call	0x22e2	; 0x22e2 <__floatunsisf>
     de6:	20 e0       	ldi	r18, 0x00	; 0
     de8:	30 e0       	ldi	r19, 0x00	; 0
     dea:	40 e8       	ldi	r20, 0x80	; 128
     dec:	57 e3       	ldi	r21, 0x37	; 55
     dee:	0e 94 ff 11 	call	0x23fe	; 0x23fe <__mulsf3>
     df2:	20 e0       	ldi	r18, 0x00	; 0
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	40 ec       	ldi	r20, 0xC0	; 192
     df8:	50 e4       	ldi	r21, 0x40	; 64
     dfa:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__subsf3>
     dfe:	0e 94 40 11 	call	0x2280	; 0x2280 <__fixsfsi>
     e02:	70 93 29 04 	sts	0x0429, r23	; 0x800429 <humidity+0x1>
     e06:	60 93 28 04 	sts	0x0428, r22	; 0x800428 <humidity>

		watchdogTemp = 1;
     e0a:	10 93 25 04 	sts	0x0425, r17	; 0x800425 <watchdogTemp+0x1>
     e0e:	00 93 24 04 	sts	0x0424, r16	; 0x800424 <watchdogTemp>
     e12:	a9 cf       	rjmp	.-174    	; 0xd66 <temperatuurTaak+0x10>

00000e14 <__vector_17>:
	// writeString(" ");writeInteger(op[1],16);
	// writeString(" ");writeInteger(op[2],16);
}

ISR(TIMER1_COMPA_vect)
{
     e14:	1f 92       	push	r1
     e16:	0f 92       	push	r0
     e18:	0f b6       	in	r0, 0x3f	; 63
     e1a:	0f 92       	push	r0
     e1c:	11 24       	eor	r1, r1
     e1e:	8f 93       	push	r24
     e20:	9f 93       	push	r25
	PORTB ^= (1 << PB6);
     e22:	95 b1       	in	r25, 0x05	; 5
     e24:	80 e4       	ldi	r24, 0x40	; 64
     e26:	89 27       	eor	r24, r25
     e28:	85 b9       	out	0x05, r24	; 5
}
     e2a:	9f 91       	pop	r25
     e2c:	8f 91       	pop	r24
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63
     e32:	0f 90       	pop	r0
     e34:	1f 90       	pop	r1
     e36:	18 95       	reti

00000e38 <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     e38:	31 e1       	ldi	r19, 0x11	; 17
     e3a:	fc 01       	movw	r30, r24
     e3c:	30 83       	st	Z, r19
     e3e:	31 97       	sbiw	r30, 0x01	; 1
     e40:	22 e2       	ldi	r18, 0x22	; 34
     e42:	20 83       	st	Z, r18
     e44:	31 97       	sbiw	r30, 0x01	; 1
     e46:	a3 e3       	ldi	r26, 0x33	; 51
     e48:	a0 83       	st	Z, r26
     e4a:	31 97       	sbiw	r30, 0x01	; 1
     e4c:	60 83       	st	Z, r22
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	70 83       	st	Z, r23
     e52:	31 97       	sbiw	r30, 0x01	; 1
     e54:	10 82       	st	Z, r1
     e56:	31 97       	sbiw	r30, 0x01	; 1
     e58:	10 82       	st	Z, r1
     e5a:	31 97       	sbiw	r30, 0x01	; 1
     e5c:	60 e8       	ldi	r22, 0x80	; 128
     e5e:	60 83       	st	Z, r22
     e60:	31 97       	sbiw	r30, 0x01	; 1
     e62:	10 82       	st	Z, r1
     e64:	31 97       	sbiw	r30, 0x01	; 1
     e66:	10 82       	st	Z, r1
     e68:	31 97       	sbiw	r30, 0x01	; 1
     e6a:	10 82       	st	Z, r1
     e6c:	31 97       	sbiw	r30, 0x01	; 1
     e6e:	62 e0       	ldi	r22, 0x02	; 2
     e70:	60 83       	st	Z, r22
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	63 e0       	ldi	r22, 0x03	; 3
     e76:	60 83       	st	Z, r22
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	64 e0       	ldi	r22, 0x04	; 4
     e7c:	60 83       	st	Z, r22
     e7e:	31 97       	sbiw	r30, 0x01	; 1
     e80:	65 e0       	ldi	r22, 0x05	; 5
     e82:	60 83       	st	Z, r22
     e84:	31 97       	sbiw	r30, 0x01	; 1
     e86:	66 e0       	ldi	r22, 0x06	; 6
     e88:	60 83       	st	Z, r22
     e8a:	31 97       	sbiw	r30, 0x01	; 1
     e8c:	67 e0       	ldi	r22, 0x07	; 7
     e8e:	60 83       	st	Z, r22
     e90:	31 97       	sbiw	r30, 0x01	; 1
     e92:	68 e0       	ldi	r22, 0x08	; 8
     e94:	60 83       	st	Z, r22
     e96:	31 97       	sbiw	r30, 0x01	; 1
     e98:	69 e0       	ldi	r22, 0x09	; 9
     e9a:	60 83       	st	Z, r22
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	60 e1       	ldi	r22, 0x10	; 16
     ea0:	60 83       	st	Z, r22
     ea2:	31 97       	sbiw	r30, 0x01	; 1
     ea4:	30 83       	st	Z, r19
     ea6:	31 97       	sbiw	r30, 0x01	; 1
     ea8:	32 e1       	ldi	r19, 0x12	; 18
     eaa:	30 83       	st	Z, r19
     eac:	31 97       	sbiw	r30, 0x01	; 1
     eae:	33 e1       	ldi	r19, 0x13	; 19
     eb0:	30 83       	st	Z, r19
     eb2:	31 97       	sbiw	r30, 0x01	; 1
     eb4:	34 e1       	ldi	r19, 0x14	; 20
     eb6:	30 83       	st	Z, r19
     eb8:	31 97       	sbiw	r30, 0x01	; 1
     eba:	35 e1       	ldi	r19, 0x15	; 21
     ebc:	30 83       	st	Z, r19
     ebe:	31 97       	sbiw	r30, 0x01	; 1
     ec0:	36 e1       	ldi	r19, 0x16	; 22
     ec2:	30 83       	st	Z, r19
     ec4:	31 97       	sbiw	r30, 0x01	; 1
     ec6:	37 e1       	ldi	r19, 0x17	; 23
     ec8:	30 83       	st	Z, r19
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	38 e1       	ldi	r19, 0x18	; 24
     ece:	30 83       	st	Z, r19
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	39 e1       	ldi	r19, 0x19	; 25
     ed4:	30 83       	st	Z, r19
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	30 e2       	ldi	r19, 0x20	; 32
     eda:	30 83       	st	Z, r19
     edc:	31 97       	sbiw	r30, 0x01	; 1
     ede:	31 e2       	ldi	r19, 0x21	; 33
     ee0:	30 83       	st	Z, r19
     ee2:	31 97       	sbiw	r30, 0x01	; 1
     ee4:	20 83       	st	Z, r18
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	23 e2       	ldi	r18, 0x23	; 35
     eea:	20 83       	st	Z, r18
     eec:	31 97       	sbiw	r30, 0x01	; 1
     eee:	40 83       	st	Z, r20
     ef0:	31 97       	sbiw	r30, 0x01	; 1
     ef2:	50 83       	st	Z, r21
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	26 e2       	ldi	r18, 0x26	; 38
     ef8:	20 83       	st	Z, r18
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	27 e2       	ldi	r18, 0x27	; 39
     efe:	20 83       	st	Z, r18
     f00:	31 97       	sbiw	r30, 0x01	; 1
     f02:	28 e2       	ldi	r18, 0x28	; 40
     f04:	20 83       	st	Z, r18
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	29 e2       	ldi	r18, 0x29	; 41
     f0a:	20 83       	st	Z, r18
     f0c:	31 97       	sbiw	r30, 0x01	; 1
     f0e:	20 e3       	ldi	r18, 0x30	; 48
     f10:	20 83       	st	Z, r18
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	21 e3       	ldi	r18, 0x31	; 49
     f16:	20 83       	st	Z, r18
     f18:	89 97       	sbiw	r24, 0x29	; 41
     f1a:	08 95       	ret

00000f1c <xPortStartScheduler>:
     f1c:	88 ec       	ldi	r24, 0xC8	; 200
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	90 93 36 04 	sts	0x0436, r25	; 0x800436 <portTickRateHz+0x1>
     f24:	80 93 35 04 	sts	0x0435, r24	; 0x800435 <portTickRateHz>
     f28:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <ticksRemainingInSec+0x1>
     f2c:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <ticksRemainingInSec>
     f30:	8d e4       	ldi	r24, 0x4D	; 77
     f32:	87 bd       	out	0x27, r24	; 39
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	84 bd       	out	0x24, r24	; 36
     f38:	85 e0       	ldi	r24, 0x05	; 5
     f3a:	85 bd       	out	0x25, r24	; 37
     f3c:	ee e6       	ldi	r30, 0x6E	; 110
     f3e:	f0 e0       	ldi	r31, 0x00	; 0
     f40:	80 81       	ld	r24, Z
     f42:	82 60       	ori	r24, 0x02	; 2
     f44:	80 83       	st	Z, r24
     f46:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
     f4a:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
     f4e:	cd 91       	ld	r28, X+
     f50:	cd bf       	out	0x3d, r28	; 61
     f52:	dd 91       	ld	r29, X+
     f54:	de bf       	out	0x3e, r29	; 62
     f56:	ff 91       	pop	r31
     f58:	ef 91       	pop	r30
     f5a:	df 91       	pop	r29
     f5c:	cf 91       	pop	r28
     f5e:	bf 91       	pop	r27
     f60:	af 91       	pop	r26
     f62:	9f 91       	pop	r25
     f64:	8f 91       	pop	r24
     f66:	7f 91       	pop	r23
     f68:	6f 91       	pop	r22
     f6a:	5f 91       	pop	r21
     f6c:	4f 91       	pop	r20
     f6e:	3f 91       	pop	r19
     f70:	2f 91       	pop	r18
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	ff 90       	pop	r15
     f78:	ef 90       	pop	r14
     f7a:	df 90       	pop	r13
     f7c:	cf 90       	pop	r12
     f7e:	bf 90       	pop	r11
     f80:	af 90       	pop	r10
     f82:	9f 90       	pop	r9
     f84:	8f 90       	pop	r8
     f86:	7f 90       	pop	r7
     f88:	6f 90       	pop	r6
     f8a:	5f 90       	pop	r5
     f8c:	4f 90       	pop	r4
     f8e:	3f 90       	pop	r3
     f90:	2f 90       	pop	r2
     f92:	1f 90       	pop	r1
     f94:	0f 90       	pop	r0
     f96:	0c be       	out	0x3c, r0	; 60
     f98:	0f 90       	pop	r0
     f9a:	0b be       	out	0x3b, r0	; 59
     f9c:	0f 90       	pop	r0
     f9e:	0f be       	out	0x3f, r0	; 63
     fa0:	0f 90       	pop	r0
     fa2:	08 95       	ret
     fa4:	81 e0       	ldi	r24, 0x01	; 1
     fa6:	08 95       	ret

00000fa8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fa8:	0f 92       	push	r0
     faa:	0f b6       	in	r0, 0x3f	; 63
     fac:	f8 94       	cli
     fae:	0f 92       	push	r0
     fb0:	0b b6       	in	r0, 0x3b	; 59
     fb2:	0f 92       	push	r0
     fb4:	0c b6       	in	r0, 0x3c	; 60
     fb6:	0f 92       	push	r0
     fb8:	1f 92       	push	r1
     fba:	11 24       	eor	r1, r1
     fbc:	2f 92       	push	r2
     fbe:	3f 92       	push	r3
     fc0:	4f 92       	push	r4
     fc2:	5f 92       	push	r5
     fc4:	6f 92       	push	r6
     fc6:	7f 92       	push	r7
     fc8:	8f 92       	push	r8
     fca:	9f 92       	push	r9
     fcc:	af 92       	push	r10
     fce:	bf 92       	push	r11
     fd0:	cf 92       	push	r12
     fd2:	df 92       	push	r13
     fd4:	ef 92       	push	r14
     fd6:	ff 92       	push	r15
     fd8:	0f 93       	push	r16
     fda:	1f 93       	push	r17
     fdc:	2f 93       	push	r18
     fde:	3f 93       	push	r19
     fe0:	4f 93       	push	r20
     fe2:	5f 93       	push	r21
     fe4:	6f 93       	push	r22
     fe6:	7f 93       	push	r23
     fe8:	8f 93       	push	r24
     fea:	9f 93       	push	r25
     fec:	af 93       	push	r26
     fee:	bf 93       	push	r27
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	ef 93       	push	r30
     ff6:	ff 93       	push	r31
     ff8:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
     ffc:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1000:	0d b6       	in	r0, 0x3d	; 61
    1002:	0d 92       	st	X+, r0
    1004:	0e b6       	in	r0, 0x3e	; 62
    1006:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1008:	75 d7       	rcall	.+3818   	; 0x1ef4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    100a:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
    100e:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1012:	cd 91       	ld	r28, X+
    1014:	cd bf       	out	0x3d, r28	; 61
    1016:	dd 91       	ld	r29, X+
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	ff 91       	pop	r31
    101c:	ef 91       	pop	r30
    101e:	df 91       	pop	r29
    1020:	cf 91       	pop	r28
    1022:	bf 91       	pop	r27
    1024:	af 91       	pop	r26
    1026:	9f 91       	pop	r25
    1028:	8f 91       	pop	r24
    102a:	7f 91       	pop	r23
    102c:	6f 91       	pop	r22
    102e:	5f 91       	pop	r21
    1030:	4f 91       	pop	r20
    1032:	3f 91       	pop	r19
    1034:	2f 91       	pop	r18
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	ff 90       	pop	r15
    103c:	ef 90       	pop	r14
    103e:	df 90       	pop	r13
    1040:	cf 90       	pop	r12
    1042:	bf 90       	pop	r11
    1044:	af 90       	pop	r10
    1046:	9f 90       	pop	r9
    1048:	8f 90       	pop	r8
    104a:	7f 90       	pop	r7
    104c:	6f 90       	pop	r6
    104e:	5f 90       	pop	r5
    1050:	4f 90       	pop	r4
    1052:	3f 90       	pop	r3
    1054:	2f 90       	pop	r2
    1056:	1f 90       	pop	r1
    1058:	0f 90       	pop	r0
    105a:	0c be       	out	0x3c, r0	; 60
    105c:	0f 90       	pop	r0
    105e:	0b be       	out	0x3b, r0	; 59
    1060:	0f 90       	pop	r0
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1066:	08 95       	ret

00001068 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1068:	0f 92       	push	r0
    106a:	0f b6       	in	r0, 0x3f	; 63
    106c:	f8 94       	cli
    106e:	0f 92       	push	r0
    1070:	0b b6       	in	r0, 0x3b	; 59
    1072:	0f 92       	push	r0
    1074:	0c b6       	in	r0, 0x3c	; 60
    1076:	0f 92       	push	r0
    1078:	1f 92       	push	r1
    107a:	11 24       	eor	r1, r1
    107c:	2f 92       	push	r2
    107e:	3f 92       	push	r3
    1080:	4f 92       	push	r4
    1082:	5f 92       	push	r5
    1084:	6f 92       	push	r6
    1086:	7f 92       	push	r7
    1088:	8f 92       	push	r8
    108a:	9f 92       	push	r9
    108c:	af 92       	push	r10
    108e:	bf 92       	push	r11
    1090:	cf 92       	push	r12
    1092:	df 92       	push	r13
    1094:	ef 92       	push	r14
    1096:	ff 92       	push	r15
    1098:	0f 93       	push	r16
    109a:	1f 93       	push	r17
    109c:	2f 93       	push	r18
    109e:	3f 93       	push	r19
    10a0:	4f 93       	push	r20
    10a2:	5f 93       	push	r21
    10a4:	6f 93       	push	r22
    10a6:	7f 93       	push	r23
    10a8:	8f 93       	push	r24
    10aa:	9f 93       	push	r25
    10ac:	af 93       	push	r26
    10ae:	bf 93       	push	r27
    10b0:	cf 93       	push	r28
    10b2:	df 93       	push	r29
    10b4:	ef 93       	push	r30
    10b6:	ff 93       	push	r31
    10b8:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
    10bc:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    10c0:	0d b6       	in	r0, 0x3d	; 61
    10c2:	0d 92       	st	X+, r0
    10c4:	0e b6       	in	r0, 0x3e	; 62
    10c6:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    10c8:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    10ca:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <ticksRemainingInSec>
    10ce:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <ticksRemainingInSec+0x1>
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <ticksRemainingInSec+0x1>
    10d8:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <ticksRemainingInSec>
    10dc:	89 2b       	or	r24, r25
    10de:	49 f4       	brne	.+18     	; 0x10f2 <vPortYieldFromTick+0x8a>
	{
		system_tick();
    10e0:	1d d9       	rcall	.-3526   	; 0x31c <system_tick>
		ticksRemainingInSec = portTickRateHz;
    10e2:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <portTickRateHz>
    10e6:	90 91 36 04 	lds	r25, 0x0436	; 0x800436 <portTickRateHz+0x1>
    10ea:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <ticksRemainingInSec+0x1>
    10ee:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    10f2:	ca d5       	rcall	.+2964   	; 0x1c88 <xTaskIncrementTick>
	{
		vTaskSwitchContext();
    10f4:	81 11       	cpse	r24, r1
    10f6:	fe d6       	rcall	.+3580   	; 0x1ef4 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    10f8:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
    10fc:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1100:	cd 91       	ld	r28, X+
    1102:	cd bf       	out	0x3d, r28	; 61
    1104:	dd 91       	ld	r29, X+
    1106:	de bf       	out	0x3e, r29	; 62
    1108:	ff 91       	pop	r31
    110a:	ef 91       	pop	r30
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	bf 91       	pop	r27
    1112:	af 91       	pop	r26
    1114:	9f 91       	pop	r25
    1116:	8f 91       	pop	r24
    1118:	7f 91       	pop	r23
    111a:	6f 91       	pop	r22
    111c:	5f 91       	pop	r21
    111e:	4f 91       	pop	r20
    1120:	3f 91       	pop	r19
    1122:	2f 91       	pop	r18
    1124:	1f 91       	pop	r17
    1126:	0f 91       	pop	r16
    1128:	ff 90       	pop	r15
    112a:	ef 90       	pop	r14
    112c:	df 90       	pop	r13
    112e:	cf 90       	pop	r12
    1130:	bf 90       	pop	r11
    1132:	af 90       	pop	r10
    1134:	9f 90       	pop	r9
    1136:	8f 90       	pop	r8
    1138:	7f 90       	pop	r7
    113a:	6f 90       	pop	r6
    113c:	5f 90       	pop	r5
    113e:	4f 90       	pop	r4
    1140:	3f 90       	pop	r3
    1142:	2f 90       	pop	r2
    1144:	1f 90       	pop	r1
    1146:	0f 90       	pop	r0
    1148:	0c be       	out	0x3c, r0	; 60
    114a:	0f 90       	pop	r0
    114c:	0b be       	out	0x3b, r0	; 59
    114e:	0f 90       	pop	r0
    1150:	0f be       	out	0x3f, r0	; 63
    1152:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1154:	08 95       	ret

00001156 <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1156:	88 df       	rcall	.-240    	; 0x1068 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1158:	18 95       	reti

0000115a <prvCopyDataToQueue>:
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ec 01       	movw	r28, r24
    1164:	04 2f       	mov	r16, r20
    1166:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1168:	4c 8d       	ldd	r20, Y+28	; 0x1c
    116a:	41 11       	cpse	r20, r1
    116c:	0b c0       	rjmp	.+22     	; 0x1184 <prvCopyDataToQueue+0x2a>
    116e:	88 81       	ld	r24, Y
    1170:	99 81       	ldd	r25, Y+1	; 0x01
    1172:	89 2b       	or	r24, r25
    1174:	09 f0       	breq	.+2      	; 0x1178 <prvCopyDataToQueue+0x1e>
    1176:	41 c0       	rjmp	.+130    	; 0x11fa <prvCopyDataToQueue+0xa0>
    1178:	8a 81       	ldd	r24, Y+2	; 0x02
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	dc d7       	rcall	.+4024   	; 0x2136 <xTaskPriorityDisinherit>
    117e:	1b 82       	std	Y+3, r1	; 0x03
    1180:	1a 82       	std	Y+2, r1	; 0x02
    1182:	42 c0       	rjmp	.+132    	; 0x1208 <prvCopyDataToQueue+0xae>
    1184:	01 11       	cpse	r16, r1
    1186:	17 c0       	rjmp	.+46     	; 0x11b6 <prvCopyDataToQueue+0x5c>
    1188:	50 e0       	ldi	r21, 0x00	; 0
    118a:	8c 81       	ldd	r24, Y+4	; 0x04
    118c:	9d 81       	ldd	r25, Y+5	; 0x05
    118e:	0e 94 c6 13 	call	0x278c	; 0x278c <memcpy>
    1192:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1194:	8c 81       	ldd	r24, Y+4	; 0x04
    1196:	9d 81       	ldd	r25, Y+5	; 0x05
    1198:	82 0f       	add	r24, r18
    119a:	91 1d       	adc	r25, r1
    119c:	9d 83       	std	Y+5, r25	; 0x05
    119e:	8c 83       	std	Y+4, r24	; 0x04
    11a0:	2a 81       	ldd	r18, Y+2	; 0x02
    11a2:	3b 81       	ldd	r19, Y+3	; 0x03
    11a4:	82 17       	cp	r24, r18
    11a6:	93 07       	cpc	r25, r19
    11a8:	50 f1       	brcs	.+84     	; 0x11fe <prvCopyDataToQueue+0xa4>
    11aa:	88 81       	ld	r24, Y
    11ac:	99 81       	ldd	r25, Y+1	; 0x01
    11ae:	9d 83       	std	Y+5, r25	; 0x05
    11b0:	8c 83       	std	Y+4, r24	; 0x04
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	29 c0       	rjmp	.+82     	; 0x1208 <prvCopyDataToQueue+0xae>
    11b6:	50 e0       	ldi	r21, 0x00	; 0
    11b8:	8e 81       	ldd	r24, Y+6	; 0x06
    11ba:	9f 81       	ldd	r25, Y+7	; 0x07
    11bc:	0e 94 c6 13 	call	0x278c	; 0x278c <memcpy>
    11c0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	91 95       	neg	r25
    11c6:	81 95       	neg	r24
    11c8:	91 09       	sbc	r25, r1
    11ca:	2e 81       	ldd	r18, Y+6	; 0x06
    11cc:	3f 81       	ldd	r19, Y+7	; 0x07
    11ce:	28 0f       	add	r18, r24
    11d0:	39 1f       	adc	r19, r25
    11d2:	3f 83       	std	Y+7, r19	; 0x07
    11d4:	2e 83       	std	Y+6, r18	; 0x06
    11d6:	48 81       	ld	r20, Y
    11d8:	59 81       	ldd	r21, Y+1	; 0x01
    11da:	24 17       	cp	r18, r20
    11dc:	35 07       	cpc	r19, r21
    11de:	30 f4       	brcc	.+12     	; 0x11ec <prvCopyDataToQueue+0x92>
    11e0:	2a 81       	ldd	r18, Y+2	; 0x02
    11e2:	3b 81       	ldd	r19, Y+3	; 0x03
    11e4:	82 0f       	add	r24, r18
    11e6:	93 1f       	adc	r25, r19
    11e8:	9f 83       	std	Y+7, r25	; 0x07
    11ea:	8e 83       	std	Y+6, r24	; 0x06
    11ec:	02 30       	cpi	r16, 0x02	; 2
    11ee:	49 f4       	brne	.+18     	; 0x1202 <prvCopyDataToQueue+0xa8>
    11f0:	11 23       	and	r17, r17
    11f2:	49 f0       	breq	.+18     	; 0x1206 <prvCopyDataToQueue+0xac>
    11f4:	11 50       	subi	r17, 0x01	; 1
    11f6:	80 e0       	ldi	r24, 0x00	; 0
    11f8:	07 c0       	rjmp	.+14     	; 0x1208 <prvCopyDataToQueue+0xae>
    11fa:	80 e0       	ldi	r24, 0x00	; 0
    11fc:	05 c0       	rjmp	.+10     	; 0x1208 <prvCopyDataToQueue+0xae>
    11fe:	80 e0       	ldi	r24, 0x00	; 0
    1200:	03 c0       	rjmp	.+6      	; 0x1208 <prvCopyDataToQueue+0xae>
    1202:	80 e0       	ldi	r24, 0x00	; 0
    1204:	01 c0       	rjmp	.+2      	; 0x1208 <prvCopyDataToQueue+0xae>
    1206:	80 e0       	ldi	r24, 0x00	; 0
    1208:	1f 5f       	subi	r17, 0xFF	; 255
    120a:	1a 8f       	std	Y+26, r17	; 0x1a
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	1f 91       	pop	r17
    1212:	0f 91       	pop	r16
    1214:	08 95       	ret

00001216 <prvUnlockQueue>:
    1216:	ef 92       	push	r14
    1218:	ff 92       	push	r15
    121a:	0f 93       	push	r16
    121c:	1f 93       	push	r17
    121e:	cf 93       	push	r28
    1220:	8c 01       	movw	r16, r24
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	0f 92       	push	r0
    1228:	fc 01       	movw	r30, r24
    122a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    122c:	1c 16       	cp	r1, r28
    122e:	9c f4       	brge	.+38     	; 0x1256 <prvUnlockQueue+0x40>
    1230:	81 89       	ldd	r24, Z+17	; 0x11
    1232:	81 11       	cpse	r24, r1
    1234:	06 c0       	rjmp	.+12     	; 0x1242 <prvUnlockQueue+0x2c>
    1236:	0f c0       	rjmp	.+30     	; 0x1256 <prvUnlockQueue+0x40>
    1238:	f8 01       	movw	r30, r16
    123a:	81 89       	ldd	r24, Z+17	; 0x11
    123c:	81 11       	cpse	r24, r1
    123e:	05 c0       	rjmp	.+10     	; 0x124a <prvUnlockQueue+0x34>
    1240:	0a c0       	rjmp	.+20     	; 0x1256 <prvUnlockQueue+0x40>
    1242:	78 01       	movw	r14, r16
    1244:	f1 e1       	ldi	r31, 0x11	; 17
    1246:	ef 0e       	add	r14, r31
    1248:	f1 1c       	adc	r15, r1
    124a:	c7 01       	movw	r24, r14
    124c:	e5 d6       	rcall	.+3530   	; 0x2018 <xTaskRemoveFromEventList>
    124e:	81 11       	cpse	r24, r1
    1250:	6e d7       	rcall	.+3804   	; 0x212e <vTaskMissedYield>
    1252:	c1 50       	subi	r28, 0x01	; 1
    1254:	89 f7       	brne	.-30     	; 0x1238 <prvUnlockQueue+0x22>
    1256:	8f ef       	ldi	r24, 0xFF	; 255
    1258:	f8 01       	movw	r30, r16
    125a:	86 8f       	std	Z+30, r24	; 0x1e
    125c:	0f 90       	pop	r0
    125e:	0f be       	out	0x3f, r0	; 63
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	0f 92       	push	r0
    1266:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1268:	1c 16       	cp	r1, r28
    126a:	9c f4       	brge	.+38     	; 0x1292 <prvUnlockQueue+0x7c>
    126c:	80 85       	ldd	r24, Z+8	; 0x08
    126e:	81 11       	cpse	r24, r1
    1270:	06 c0       	rjmp	.+12     	; 0x127e <prvUnlockQueue+0x68>
    1272:	0f c0       	rjmp	.+30     	; 0x1292 <prvUnlockQueue+0x7c>
    1274:	f8 01       	movw	r30, r16
    1276:	80 85       	ldd	r24, Z+8	; 0x08
    1278:	81 11       	cpse	r24, r1
    127a:	05 c0       	rjmp	.+10     	; 0x1286 <prvUnlockQueue+0x70>
    127c:	0a c0       	rjmp	.+20     	; 0x1292 <prvUnlockQueue+0x7c>
    127e:	78 01       	movw	r14, r16
    1280:	f8 e0       	ldi	r31, 0x08	; 8
    1282:	ef 0e       	add	r14, r31
    1284:	f1 1c       	adc	r15, r1
    1286:	c7 01       	movw	r24, r14
    1288:	c7 d6       	rcall	.+3470   	; 0x2018 <xTaskRemoveFromEventList>
    128a:	81 11       	cpse	r24, r1
    128c:	50 d7       	rcall	.+3744   	; 0x212e <vTaskMissedYield>
    128e:	c1 50       	subi	r28, 0x01	; 1
    1290:	89 f7       	brne	.-30     	; 0x1274 <prvUnlockQueue+0x5e>
    1292:	8f ef       	ldi	r24, 0xFF	; 255
    1294:	f8 01       	movw	r30, r16
    1296:	85 8f       	std	Z+29, r24	; 0x1d
    1298:	0f 90       	pop	r0
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	ff 90       	pop	r15
    12a4:	ef 90       	pop	r14
    12a6:	08 95       	ret

000012a8 <xQueueGenericReset>:
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	ec 01       	movw	r28, r24
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	0f 92       	push	r0
    12b4:	48 81       	ld	r20, Y
    12b6:	59 81       	ldd	r21, Y+1	; 0x01
    12b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12ba:	30 e0       	ldi	r19, 0x00	; 0
    12bc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    12be:	72 9f       	mul	r23, r18
    12c0:	c0 01       	movw	r24, r0
    12c2:	73 9f       	mul	r23, r19
    12c4:	90 0d       	add	r25, r0
    12c6:	11 24       	eor	r1, r1
    12c8:	fa 01       	movw	r30, r20
    12ca:	e8 0f       	add	r30, r24
    12cc:	f9 1f       	adc	r31, r25
    12ce:	fb 83       	std	Y+3, r31	; 0x03
    12d0:	ea 83       	std	Y+2, r30	; 0x02
    12d2:	1a 8e       	std	Y+26, r1	; 0x1a
    12d4:	5d 83       	std	Y+5, r21	; 0x05
    12d6:	4c 83       	std	Y+4, r20	; 0x04
    12d8:	82 1b       	sub	r24, r18
    12da:	93 0b       	sbc	r25, r19
    12dc:	84 0f       	add	r24, r20
    12de:	95 1f       	adc	r25, r21
    12e0:	9f 83       	std	Y+7, r25	; 0x07
    12e2:	8e 83       	std	Y+6, r24	; 0x06
    12e4:	8f ef       	ldi	r24, 0xFF	; 255
    12e6:	8d 8f       	std	Y+29, r24	; 0x1d
    12e8:	8e 8f       	std	Y+30, r24	; 0x1e
    12ea:	61 11       	cpse	r22, r1
    12ec:	0a c0       	rjmp	.+20     	; 0x1302 <xQueueGenericReset+0x5a>
    12ee:	88 85       	ldd	r24, Y+8	; 0x08
    12f0:	88 23       	and	r24, r24
    12f2:	69 f0       	breq	.+26     	; 0x130e <xQueueGenericReset+0x66>
    12f4:	ce 01       	movw	r24, r28
    12f6:	08 96       	adiw	r24, 0x08	; 8
    12f8:	8f d6       	rcall	.+3358   	; 0x2018 <xTaskRemoveFromEventList>
    12fa:	88 23       	and	r24, r24
    12fc:	41 f0       	breq	.+16     	; 0x130e <xQueueGenericReset+0x66>
    12fe:	54 de       	rcall	.-856    	; 0xfa8 <vPortYield>
    1300:	06 c0       	rjmp	.+12     	; 0x130e <xQueueGenericReset+0x66>
    1302:	ce 01       	movw	r24, r28
    1304:	08 96       	adiw	r24, 0x08	; 8
    1306:	67 d9       	rcall	.-3378   	; 0x5d6 <vListInitialise>
    1308:	ce 01       	movw	r24, r28
    130a:	41 96       	adiw	r24, 0x11	; 17
    130c:	64 d9       	rcall	.-3384   	; 0x5d6 <vListInitialise>
    130e:	0f 90       	pop	r0
    1310:	0f be       	out	0x3f, r0	; 63
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	df 91       	pop	r29
    1316:	cf 91       	pop	r28
    1318:	08 95       	ret

0000131a <xQueueGenericCreate>:
    131a:	0f 93       	push	r16
    131c:	1f 93       	push	r17
    131e:	cf 93       	push	r28
    1320:	df 93       	push	r29
    1322:	08 2f       	mov	r16, r24
    1324:	16 2f       	mov	r17, r22
    1326:	66 23       	and	r22, r22
    1328:	b1 f0       	breq	.+44     	; 0x1356 <xQueueGenericCreate+0x3c>
    132a:	86 9f       	mul	r24, r22
    132c:	c0 01       	movw	r24, r0
    132e:	11 24       	eor	r1, r1
    1330:	4f 96       	adiw	r24, 0x1f	; 31
    1332:	10 d8       	rcall	.-4064   	; 0x354 <pvPortMalloc>
    1334:	ec 01       	movw	r28, r24
    1336:	00 97       	sbiw	r24, 0x00	; 0
    1338:	39 f4       	brne	.+14     	; 0x1348 <xQueueGenericCreate+0x2e>
    133a:	14 c0       	rjmp	.+40     	; 0x1364 <xQueueGenericCreate+0x4a>
    133c:	0b 8f       	std	Y+27, r16	; 0x1b
    133e:	1c 8f       	std	Y+28, r17	; 0x1c
    1340:	61 e0       	ldi	r22, 0x01	; 1
    1342:	ce 01       	movw	r24, r28
    1344:	b1 df       	rcall	.-158    	; 0x12a8 <xQueueGenericReset>
    1346:	0e c0       	rjmp	.+28     	; 0x1364 <xQueueGenericCreate+0x4a>
    1348:	4f 96       	adiw	r24, 0x1f	; 31
    134a:	99 83       	std	Y+1, r25	; 0x01
    134c:	88 83       	st	Y, r24
    134e:	f6 cf       	rjmp	.-20     	; 0x133c <xQueueGenericCreate+0x22>
    1350:	d9 83       	std	Y+1, r29	; 0x01
    1352:	c8 83       	st	Y, r28
    1354:	f3 cf       	rjmp	.-26     	; 0x133c <xQueueGenericCreate+0x22>
    1356:	8f e1       	ldi	r24, 0x1F	; 31
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    135e:	ec 01       	movw	r28, r24
    1360:	89 2b       	or	r24, r25
    1362:	b1 f7       	brne	.-20     	; 0x1350 <xQueueGenericCreate+0x36>
    1364:	ce 01       	movw	r24, r28
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	1f 91       	pop	r17
    136c:	0f 91       	pop	r16
    136e:	08 95       	ret

00001370 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1370:	9f 92       	push	r9
    1372:	af 92       	push	r10
    1374:	bf 92       	push	r11
    1376:	cf 92       	push	r12
    1378:	df 92       	push	r13
    137a:	ef 92       	push	r14
    137c:	ff 92       	push	r15
    137e:	0f 93       	push	r16
    1380:	1f 93       	push	r17
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
    1386:	00 d0       	rcall	.+0      	; 0x1388 <xQueueGenericSend+0x18>
    1388:	1f 92       	push	r1
    138a:	1f 92       	push	r1
    138c:	cd b7       	in	r28, 0x3d	; 61
    138e:	de b7       	in	r29, 0x3e	; 62
    1390:	8c 01       	movw	r16, r24
    1392:	6b 01       	movw	r12, r22
    1394:	5d 83       	std	Y+5, r21	; 0x05
    1396:	4c 83       	std	Y+4, r20	; 0x04
    1398:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    139a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    139c:	99 24       	eor	r9, r9
    139e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13a0:	7c 01       	movw	r14, r24
    13a2:	88 e0       	ldi	r24, 0x08	; 8
    13a4:	e8 0e       	add	r14, r24
    13a6:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13ae:	f8 01       	movw	r30, r16
    13b0:	92 8d       	ldd	r25, Z+26	; 0x1a
    13b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    13b4:	98 17       	cp	r25, r24
    13b6:	18 f0       	brcs	.+6      	; 0x13be <xQueueGenericSend+0x4e>
    13b8:	f2 e0       	ldi	r31, 0x02	; 2
    13ba:	af 12       	cpse	r10, r31
    13bc:	15 c0       	rjmp	.+42     	; 0x13e8 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13be:	4a 2d       	mov	r20, r10
    13c0:	b6 01       	movw	r22, r12
    13c2:	c8 01       	movw	r24, r16
    13c4:	ca de       	rcall	.-620    	; 0x115a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13c6:	f8 01       	movw	r30, r16
    13c8:	91 89       	ldd	r25, Z+17	; 0x11
    13ca:	99 23       	and	r25, r25
    13cc:	39 f0       	breq	.+14     	; 0x13dc <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13ce:	c8 01       	movw	r24, r16
    13d0:	41 96       	adiw	r24, 0x11	; 17
    13d2:	22 d6       	rcall	.+3140   	; 0x2018 <xTaskRemoveFromEventList>
    13d4:	88 23       	and	r24, r24
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    13d6:	21 f0       	breq	.+8      	; 0x13e0 <xQueueGenericSend+0x70>
    13d8:	e7 dd       	rcall	.-1074   	; 0xfa8 <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    13da:	02 c0       	rjmp	.+4      	; 0x13e0 <xQueueGenericSend+0x70>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    13dc:	81 11       	cpse	r24, r1
    13de:	e4 dd       	rcall	.-1080   	; 0xfa8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	45 c0       	rjmp	.+138    	; 0x1472 <xQueueGenericSend+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13e8:	8c 81       	ldd	r24, Y+4	; 0x04
    13ea:	9d 81       	ldd	r25, Y+5	; 0x05
    13ec:	89 2b       	or	r24, r25
    13ee:	21 f4       	brne	.+8      	; 0x13f8 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13f0:	0f 90       	pop	r0
    13f2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	3d c0       	rjmp	.+122    	; 0x1472 <xQueueGenericSend+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    13f8:	b1 10       	cpse	r11, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13fa:	04 c0       	rjmp	.+8      	; 0x1404 <xQueueGenericSend+0x94>
    13fc:	ce 01       	movw	r24, r28
    13fe:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    1400:	53 d6       	rcall	.+3238   	; 0x20a8 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1402:	b9 2c       	mov	r11, r9
    1404:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1406:	0f be       	out	0x3f, r0	; 63
    1408:	39 d4       	rcall	.+2162   	; 0x1c7c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
    1410:	f8 01       	movw	r30, r16
    1412:	85 8d       	ldd	r24, Z+29	; 0x1d
    1414:	8f 3f       	cpi	r24, 0xFF	; 255
    1416:	09 f4       	brne	.+2      	; 0x141a <xQueueGenericSend+0xaa>
    1418:	15 8e       	std	Z+29, r1	; 0x1d
    141a:	f8 01       	movw	r30, r16
    141c:	86 8d       	ldd	r24, Z+30	; 0x1e
    141e:	8f 3f       	cpi	r24, 0xFF	; 255
    1420:	09 f4       	brne	.+2      	; 0x1424 <xQueueGenericSend+0xb4>
    1422:	16 8e       	std	Z+30, r1	; 0x1e
    1424:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	be 01       	movw	r22, r28
    142a:	6c 5f       	subi	r22, 0xFC	; 252
    142c:	7f 4f       	sbci	r23, 0xFF	; 255
    142e:	ce 01       	movw	r24, r28
    1430:	01 96       	adiw	r24, 0x01	; 1
    1432:	45 d6       	rcall	.+3210   	; 0x20be <xTaskCheckForTimeOut>
    1434:	81 11       	cpse	r24, r1
    1436:	19 c0       	rjmp	.+50     	; 0x146a <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    143e:	f8 01       	movw	r30, r16
    1440:	92 8d       	ldd	r25, Z+26	; 0x1a
    1442:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1444:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1446:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1448:	98 13       	cpse	r25, r24
    144a:	0b c0       	rjmp	.+22     	; 0x1462 <xQueueGenericSend+0xf2>
    144c:	6c 81       	ldd	r22, Y+4	; 0x04
    144e:	7d 81       	ldd	r23, Y+5	; 0x05
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1450:	c7 01       	movw	r24, r14
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1452:	d1 d5       	rcall	.+2978   	; 0x1ff6 <vTaskPlaceOnEventList>
    1454:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    1456:	df de       	rcall	.-578    	; 0x1216 <prvUnlockQueue>
    1458:	d1 d4       	rcall	.+2466   	; 0x1dfc <xTaskResumeAll>
    145a:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    145c:	a5 cf       	rjmp	.-182    	; 0x13a8 <xQueueGenericSend+0x38>
    145e:	a4 dd       	rcall	.-1208   	; 0xfa8 <vPortYield>
    1460:	a3 cf       	rjmp	.-186    	; 0x13a8 <xQueueGenericSend+0x38>
				( void ) xTaskResumeAll();
    1462:	c8 01       	movw	r24, r16
    1464:	d8 de       	rcall	.-592    	; 0x1216 <prvUnlockQueue>
    1466:	ca d4       	rcall	.+2452   	; 0x1dfc <xTaskResumeAll>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1468:	9f cf       	rjmp	.-194    	; 0x13a8 <xQueueGenericSend+0x38>
    146a:	c8 01       	movw	r24, r16
    146c:	d4 de       	rcall	.-600    	; 0x1216 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    146e:	c6 d4       	rcall	.+2444   	; 0x1dfc <xTaskResumeAll>
    1470:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1472:	0f 90       	pop	r0
		}
	}
}
    1474:	0f 90       	pop	r0
    1476:	0f 90       	pop	r0
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	1f 91       	pop	r17
    1482:	0f 91       	pop	r16
    1484:	ff 90       	pop	r15
    1486:	ef 90       	pop	r14
    1488:	df 90       	pop	r13
    148a:	cf 90       	pop	r12
    148c:	bf 90       	pop	r11
    148e:	af 90       	pop	r10
    1490:	9f 90       	pop	r9
    1492:	08 95       	ret

00001494 <__vector_26>:
    1494:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    1496:	0f 92       	push	r0
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	0f 92       	push	r0
    149c:	11 24       	eor	r1, r1
    149e:	0b b6       	in	r0, 0x3b	; 59
    14a0:	0f 92       	push	r0
    14a2:	2f 93       	push	r18
    14a4:	8f 93       	push	r24
    14a6:	9f 93       	push	r25
    14a8:	af 93       	push	r26
    14aa:	bf 93       	push	r27
    14ac:	ef 93       	push	r30
    14ae:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	0f 92       	push	r0
	{
	    count = buffer->count;
    14b6:	80 91 46 04 	lds	r24, 0x0446	; 0x800446 <xSerialPort+0xd>
    14ba:	90 91 47 04 	lds	r25, 0x0447	; 0x800447 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    14c2:	89 2b       	or	r24, r25
    14c4:	31 f4       	brne	.+12     	; 0x14d2 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    14c6:	e1 ec       	ldi	r30, 0xC1	; 193
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	80 81       	ld	r24, Z
    14cc:	8f 7d       	andi	r24, 0xDF	; 223
    14ce:	80 83       	st	Z, r24
    14d0:	1c c0       	rjmp	.+56     	; 0x150a <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    14d2:	e6 e4       	ldi	r30, 0x46	; 70
    14d4:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    14d6:	a4 81       	ldd	r26, Z+4	; 0x04
    14d8:	b5 81       	ldd	r27, Z+5	; 0x05
    14da:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    14dc:	b5 83       	std	Z+5, r27	; 0x05
    14de:	a4 83       	std	Z+4, r26	; 0x04
    14e0:	80 85       	ldd	r24, Z+8	; 0x08
    14e2:	91 85       	ldd	r25, Z+9	; 0x09
    14e4:	a8 17       	cp	r26, r24
    14e6:	b9 07       	cpc	r27, r25
    14e8:	21 f4       	brne	.+8      	; 0x14f2 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    14ea:	86 81       	ldd	r24, Z+6	; 0x06
    14ec:	97 81       	ldd	r25, Z+7	; 0x07
    14ee:	95 83       	std	Z+5, r25	; 0x05
    14f0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	0f 92       	push	r0
	{
	    buffer->count--;
    14f8:	80 81       	ld	r24, Z
    14fa:	91 81       	ldd	r25, Z+1	; 0x01
    14fc:	01 97       	sbiw	r24, 0x01	; 1
    14fe:	91 83       	std	Z+1, r25	; 0x01
    1500:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1506:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    150a:	ff 91       	pop	r31
    150c:	ef 91       	pop	r30
    150e:	bf 91       	pop	r27
    1510:	af 91       	pop	r26
    1512:	9f 91       	pop	r25
    1514:	8f 91       	pop	r24
    1516:	2f 91       	pop	r18
    1518:	0f 90       	pop	r0
    151a:	0b be       	out	0x3b, r0	; 59
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	0f 90       	pop	r0
    1522:	1f 90       	pop	r1
    1524:	18 95       	reti

00001526 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    1526:	1f 92       	push	r1
    1528:	0f 92       	push	r0
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	0f 92       	push	r0
    152e:	11 24       	eor	r1, r1
    1530:	0b b6       	in	r0, 0x3b	; 59
    1532:	0f 92       	push	r0
    1534:	2f 93       	push	r18
    1536:	3f 93       	push	r19
    1538:	4f 93       	push	r20
    153a:	8f 93       	push	r24
    153c:	9f 93       	push	r25
    153e:	af 93       	push	r26
    1540:	bf 93       	push	r27
    1542:	ef 93       	push	r30
    1544:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    1546:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    154a:	8c 71       	andi	r24, 0x1C	; 28
    154c:	71 f0       	breq	.+28     	; 0x156a <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    154e:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1552:	88 23       	and	r24, r24
    1554:	0c f0       	brlt	.+2      	; 0x1558 <__vector_36+0x32>
    1556:	36 c0       	rjmp	.+108    	; 0x15c4 <__vector_36+0x9e>
    1558:	ae ec       	ldi	r26, 0xCE	; 206
    155a:	b0 e0       	ldi	r27, 0x00	; 0
    155c:	e8 ec       	ldi	r30, 0xC8	; 200
    155e:	f0 e0       	ldi	r31, 0x00	; 0
    1560:	8c 91       	ld	r24, X
    1562:	80 81       	ld	r24, Z
    1564:	88 23       	and	r24, r24
    1566:	e4 f3       	brlt	.-8      	; 0x1560 <__vector_36+0x3a>
    1568:	2d c0       	rjmp	.+90     	; 0x15c4 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    156a:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
	{
	    count = buffer->count;
    1574:	ef e9       	ldi	r30, 0x9F	; 159
    1576:	f4 e0       	ldi	r31, 0x04	; 4
    1578:	21 81       	ldd	r18, Z+1	; 0x01
    157a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    1580:	83 85       	ldd	r24, Z+11	; 0x0b
    1582:	94 85       	ldd	r25, Z+12	; 0x0c
    1584:	28 17       	cp	r18, r24
    1586:	39 07       	cpc	r19, r25
    1588:	e9 f0       	breq	.+58     	; 0x15c4 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    158a:	e0 ea       	ldi	r30, 0xA0	; 160
    158c:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    158e:	a2 81       	ldd	r26, Z+2	; 0x02
    1590:	b3 81       	ldd	r27, Z+3	; 0x03
    1592:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1594:	82 81       	ldd	r24, Z+2	; 0x02
    1596:	93 81       	ldd	r25, Z+3	; 0x03
    1598:	01 96       	adiw	r24, 0x01	; 1
    159a:	93 83       	std	Z+3, r25	; 0x03
    159c:	82 83       	std	Z+2, r24	; 0x02
    159e:	20 85       	ldd	r18, Z+8	; 0x08
    15a0:	31 85       	ldd	r19, Z+9	; 0x09
    15a2:	82 17       	cp	r24, r18
    15a4:	93 07       	cpc	r25, r19
    15a6:	21 f4       	brne	.+8      	; 0x15b0 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    15a8:	86 81       	ldd	r24, Z+6	; 0x06
    15aa:	97 81       	ldd	r25, Z+7	; 0x07
    15ac:	93 83       	std	Z+3, r25	; 0x03
    15ae:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	0f 92       	push	r0
	{
	    buffer->count++;
    15b6:	80 81       	ld	r24, Z
    15b8:	91 81       	ldd	r25, Z+1	; 0x01
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	91 83       	std	Z+1, r25	; 0x01
    15be:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    15c0:	0f 90       	pop	r0
    15c2:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    15c4:	ff 91       	pop	r31
    15c6:	ef 91       	pop	r30
    15c8:	bf 91       	pop	r27
    15ca:	af 91       	pop	r26
    15cc:	9f 91       	pop	r25
    15ce:	8f 91       	pop	r24
    15d0:	4f 91       	pop	r20
    15d2:	3f 91       	pop	r19
    15d4:	2f 91       	pop	r18
    15d6:	0f 90       	pop	r0
    15d8:	0b be       	out	0x3b, r0	; 59
    15da:	0f 90       	pop	r0
    15dc:	0f be       	out	0x3f, r0	; 63
    15de:	0f 90       	pop	r0
    15e0:	1f 90       	pop	r1
    15e2:	18 95       	reti

000015e4 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    15e4:	1f 92       	push	r1
    15e6:	0f 92       	push	r0
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	0f 92       	push	r0
    15ec:	11 24       	eor	r1, r1
    15ee:	0b b6       	in	r0, 0x3b	; 59
    15f0:	0f 92       	push	r0
    15f2:	2f 93       	push	r18
    15f4:	8f 93       	push	r24
    15f6:	9f 93       	push	r25
    15f8:	af 93       	push	r26
    15fa:	bf 93       	push	r27
    15fc:	ef 93       	push	r30
    15fe:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	0f 92       	push	r0
	{
	    count = buffer->count;
    1606:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <xSerial1Port+0xd>
    160a:	90 91 ad 04 	lds	r25, 0x04AD	; 0x8004ad <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    160e:	0f 90       	pop	r0
    1610:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1612:	89 2b       	or	r24, r25
    1614:	31 f4       	brne	.+12     	; 0x1622 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1616:	e9 ec       	ldi	r30, 0xC9	; 201
    1618:	f0 e0       	ldi	r31, 0x00	; 0
    161a:	80 81       	ld	r24, Z
    161c:	8f 7d       	andi	r24, 0xDF	; 223
    161e:	80 83       	st	Z, r24
    1620:	1c c0       	rjmp	.+56     	; 0x165a <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1622:	ec ea       	ldi	r30, 0xAC	; 172
    1624:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1626:	a4 81       	ldd	r26, Z+4	; 0x04
    1628:	b5 81       	ldd	r27, Z+5	; 0x05
    162a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    162c:	b5 83       	std	Z+5, r27	; 0x05
    162e:	a4 83       	std	Z+4, r26	; 0x04
    1630:	80 85       	ldd	r24, Z+8	; 0x08
    1632:	91 85       	ldd	r25, Z+9	; 0x09
    1634:	a8 17       	cp	r26, r24
    1636:	b9 07       	cpc	r27, r25
    1638:	21 f4       	brne	.+8      	; 0x1642 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    163a:	86 81       	ldd	r24, Z+6	; 0x06
    163c:	97 81       	ldd	r25, Z+7	; 0x07
    163e:	95 83       	std	Z+5, r25	; 0x05
    1640:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	0f 92       	push	r0
	{
	    buffer->count--;
    1648:	80 81       	ld	r24, Z
    164a:	91 81       	ldd	r25, Z+1	; 0x01
    164c:	01 97       	sbiw	r24, 0x01	; 1
    164e:	91 83       	std	Z+1, r25	; 0x01
    1650:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1656:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    165a:	ff 91       	pop	r31
    165c:	ef 91       	pop	r30
    165e:	bf 91       	pop	r27
    1660:	af 91       	pop	r26
    1662:	9f 91       	pop	r25
    1664:	8f 91       	pop	r24
    1666:	2f 91       	pop	r18
    1668:	0f 90       	pop	r0
    166a:	0b be       	out	0x3b, r0	; 59
    166c:	0f 90       	pop	r0
    166e:	0f be       	out	0x3f, r0	; 63
    1670:	0f 90       	pop	r0
    1672:	1f 90       	pop	r1
    1674:	18 95       	reti

00001676 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    1676:	1f 92       	push	r1
    1678:	0f 92       	push	r0
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	0f 92       	push	r0
    167e:	11 24       	eor	r1, r1
    1680:	0b b6       	in	r0, 0x3b	; 59
    1682:	0f 92       	push	r0
    1684:	2f 93       	push	r18
    1686:	3f 93       	push	r19
    1688:	4f 93       	push	r20
    168a:	8f 93       	push	r24
    168c:	9f 93       	push	r25
    168e:	af 93       	push	r26
    1690:	bf 93       	push	r27
    1692:	ef 93       	push	r30
    1694:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1696:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    169a:	8c 71       	andi	r24, 0x1C	; 28
    169c:	71 f0       	breq	.+28     	; 0x16ba <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    169e:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    16a2:	88 23       	and	r24, r24
    16a4:	0c f0       	brlt	.+2      	; 0x16a8 <__vector_51+0x32>
    16a6:	36 c0       	rjmp	.+108    	; 0x1714 <__vector_51+0x9e>
    16a8:	a6 ed       	ldi	r26, 0xD6	; 214
    16aa:	b0 e0       	ldi	r27, 0x00	; 0
    16ac:	e0 ed       	ldi	r30, 0xD0	; 208
    16ae:	f0 e0       	ldi	r31, 0x00	; 0
    16b0:	8c 91       	ld	r24, X
    16b2:	80 81       	ld	r24, Z
    16b4:	88 23       	and	r24, r24
    16b6:	e4 f3       	brlt	.-8      	; 0x16b0 <__vector_51+0x3a>
    16b8:	2d c0       	rjmp	.+90     	; 0x1714 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    16ba:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    16be:	0f b6       	in	r0, 0x3f	; 63
    16c0:	f8 94       	cli
    16c2:	0f 92       	push	r0
	{
	    count = buffer->count;
    16c4:	eb e5       	ldi	r30, 0x5B	; 91
    16c6:	f4 e0       	ldi	r31, 0x04	; 4
    16c8:	21 81       	ldd	r18, Z+1	; 0x01
    16ca:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    16cc:	0f 90       	pop	r0
    16ce:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    16d0:	83 85       	ldd	r24, Z+11	; 0x0b
    16d2:	94 85       	ldd	r25, Z+12	; 0x0c
    16d4:	28 17       	cp	r18, r24
    16d6:	39 07       	cpc	r19, r25
    16d8:	e9 f0       	breq	.+58     	; 0x1714 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    16da:	ec e5       	ldi	r30, 0x5C	; 92
    16dc:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    16de:	a2 81       	ldd	r26, Z+2	; 0x02
    16e0:	b3 81       	ldd	r27, Z+3	; 0x03
    16e2:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    16e4:	82 81       	ldd	r24, Z+2	; 0x02
    16e6:	93 81       	ldd	r25, Z+3	; 0x03
    16e8:	01 96       	adiw	r24, 0x01	; 1
    16ea:	93 83       	std	Z+3, r25	; 0x03
    16ec:	82 83       	std	Z+2, r24	; 0x02
    16ee:	20 85       	ldd	r18, Z+8	; 0x08
    16f0:	31 85       	ldd	r19, Z+9	; 0x09
    16f2:	82 17       	cp	r24, r18
    16f4:	93 07       	cpc	r25, r19
    16f6:	21 f4       	brne	.+8      	; 0x1700 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    16f8:	86 81       	ldd	r24, Z+6	; 0x06
    16fa:	97 81       	ldd	r25, Z+7	; 0x07
    16fc:	93 83       	std	Z+3, r25	; 0x03
    16fe:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1700:	0f b6       	in	r0, 0x3f	; 63
    1702:	f8 94       	cli
    1704:	0f 92       	push	r0
	{
	    buffer->count++;
    1706:	80 81       	ld	r24, Z
    1708:	91 81       	ldd	r25, Z+1	; 0x01
    170a:	01 96       	adiw	r24, 0x01	; 1
    170c:	91 83       	std	Z+1, r25	; 0x01
    170e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1710:	0f 90       	pop	r0
    1712:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1714:	ff 91       	pop	r31
    1716:	ef 91       	pop	r30
    1718:	bf 91       	pop	r27
    171a:	af 91       	pop	r26
    171c:	9f 91       	pop	r25
    171e:	8f 91       	pop	r24
    1720:	4f 91       	pop	r20
    1722:	3f 91       	pop	r19
    1724:	2f 91       	pop	r18
    1726:	0f 90       	pop	r0
    1728:	0b be       	out	0x3b, r0	; 59
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	0f 90       	pop	r0
    1730:	1f 90       	pop	r1
    1732:	18 95       	reti

00001734 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1734:	1f 92       	push	r1
    1736:	0f 92       	push	r0
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	0f 92       	push	r0
    173c:	11 24       	eor	r1, r1
    173e:	0b b6       	in	r0, 0x3b	; 59
    1740:	0f 92       	push	r0
    1742:	2f 93       	push	r18
    1744:	8f 93       	push	r24
    1746:	9f 93       	push	r25
    1748:	af 93       	push	r26
    174a:	bf 93       	push	r27
    174c:	ef 93       	push	r30
    174e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1750:	0f b6       	in	r0, 0x3f	; 63
    1752:	f8 94       	cli
    1754:	0f 92       	push	r0
	{
	    count = buffer->count;
    1756:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <xSerial2Port+0xd>
    175a:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    175e:	0f 90       	pop	r0
    1760:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1762:	89 2b       	or	r24, r25
    1764:	31 f4       	brne	.+12     	; 0x1772 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1766:	e1 ed       	ldi	r30, 0xD1	; 209
    1768:	f0 e0       	ldi	r31, 0x00	; 0
    176a:	80 81       	ld	r24, Z
    176c:	8f 7d       	andi	r24, 0xDF	; 223
    176e:	80 83       	st	Z, r24
    1770:	1c c0       	rjmp	.+56     	; 0x17aa <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1772:	e8 e6       	ldi	r30, 0x68	; 104
    1774:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1776:	a4 81       	ldd	r26, Z+4	; 0x04
    1778:	b5 81       	ldd	r27, Z+5	; 0x05
    177a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    177c:	b5 83       	std	Z+5, r27	; 0x05
    177e:	a4 83       	std	Z+4, r26	; 0x04
    1780:	80 85       	ldd	r24, Z+8	; 0x08
    1782:	91 85       	ldd	r25, Z+9	; 0x09
    1784:	a8 17       	cp	r26, r24
    1786:	b9 07       	cpc	r27, r25
    1788:	21 f4       	brne	.+8      	; 0x1792 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    178a:	86 81       	ldd	r24, Z+6	; 0x06
    178c:	97 81       	ldd	r25, Z+7	; 0x07
    178e:	95 83       	std	Z+5, r25	; 0x05
    1790:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1792:	0f b6       	in	r0, 0x3f	; 63
    1794:	f8 94       	cli
    1796:	0f 92       	push	r0
	{
	    buffer->count--;
    1798:	80 81       	ld	r24, Z
    179a:	91 81       	ldd	r25, Z+1	; 0x01
    179c:	01 97       	sbiw	r24, 0x01	; 1
    179e:	91 83       	std	Z+1, r25	; 0x01
    17a0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    17a2:	0f 90       	pop	r0
    17a4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    17a6:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    17aa:	ff 91       	pop	r31
    17ac:	ef 91       	pop	r30
    17ae:	bf 91       	pop	r27
    17b0:	af 91       	pop	r26
    17b2:	9f 91       	pop	r25
    17b4:	8f 91       	pop	r24
    17b6:	2f 91       	pop	r18
    17b8:	0f 90       	pop	r0
    17ba:	0b be       	out	0x3b, r0	; 59
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	0f 90       	pop	r0
    17c2:	1f 90       	pop	r1
    17c4:	18 95       	reti

000017c6 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    17c6:	1f 92       	push	r1
    17c8:	0f 92       	push	r0
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	0f 92       	push	r0
    17ce:	11 24       	eor	r1, r1
    17d0:	0b b6       	in	r0, 0x3b	; 59
    17d2:	0f 92       	push	r0
    17d4:	2f 93       	push	r18
    17d6:	3f 93       	push	r19
    17d8:	4f 93       	push	r20
    17da:	8f 93       	push	r24
    17dc:	9f 93       	push	r25
    17de:	af 93       	push	r26
    17e0:	bf 93       	push	r27
    17e2:	ef 93       	push	r30
    17e4:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    17e6:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    17ea:	8c 71       	andi	r24, 0x1C	; 28
    17ec:	71 f0       	breq	.+28     	; 0x180a <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    17ee:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    17f2:	88 23       	and	r24, r24
    17f4:	0c f0       	brlt	.+2      	; 0x17f8 <__vector_54+0x32>
    17f6:	36 c0       	rjmp	.+108    	; 0x1864 <__vector_54+0x9e>
    17f8:	a6 e3       	ldi	r26, 0x36	; 54
    17fa:	b1 e0       	ldi	r27, 0x01	; 1
    17fc:	e0 e3       	ldi	r30, 0x30	; 48
    17fe:	f1 e0       	ldi	r31, 0x01	; 1
    1800:	8c 91       	ld	r24, X
    1802:	80 81       	ld	r24, Z
    1804:	88 23       	and	r24, r24
    1806:	e4 f3       	brlt	.-8      	; 0x1800 <__vector_54+0x3a>
    1808:	2d c0       	rjmp	.+90     	; 0x1864 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    180a:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	0f 92       	push	r0
	{
	    count = buffer->count;
    1814:	ed e7       	ldi	r30, 0x7D	; 125
    1816:	f4 e0       	ldi	r31, 0x04	; 4
    1818:	21 81       	ldd	r18, Z+1	; 0x01
    181a:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    181c:	0f 90       	pop	r0
    181e:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1820:	83 85       	ldd	r24, Z+11	; 0x0b
    1822:	94 85       	ldd	r25, Z+12	; 0x0c
    1824:	28 17       	cp	r18, r24
    1826:	39 07       	cpc	r19, r25
    1828:	e9 f0       	breq	.+58     	; 0x1864 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    182a:	ee e7       	ldi	r30, 0x7E	; 126
    182c:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    182e:	a2 81       	ldd	r26, Z+2	; 0x02
    1830:	b3 81       	ldd	r27, Z+3	; 0x03
    1832:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1834:	82 81       	ldd	r24, Z+2	; 0x02
    1836:	93 81       	ldd	r25, Z+3	; 0x03
    1838:	01 96       	adiw	r24, 0x01	; 1
    183a:	93 83       	std	Z+3, r25	; 0x03
    183c:	82 83       	std	Z+2, r24	; 0x02
    183e:	20 85       	ldd	r18, Z+8	; 0x08
    1840:	31 85       	ldd	r19, Z+9	; 0x09
    1842:	82 17       	cp	r24, r18
    1844:	93 07       	cpc	r25, r19
    1846:	21 f4       	brne	.+8      	; 0x1850 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1848:	86 81       	ldd	r24, Z+6	; 0x06
    184a:	97 81       	ldd	r25, Z+7	; 0x07
    184c:	93 83       	std	Z+3, r25	; 0x03
    184e:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	0f 92       	push	r0
	{
	    buffer->count++;
    1856:	80 81       	ld	r24, Z
    1858:	91 81       	ldd	r25, Z+1	; 0x01
    185a:	01 96       	adiw	r24, 0x01	; 1
    185c:	91 83       	std	Z+1, r25	; 0x01
    185e:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1860:	0f 90       	pop	r0
    1862:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1864:	ff 91       	pop	r31
    1866:	ef 91       	pop	r30
    1868:	bf 91       	pop	r27
    186a:	af 91       	pop	r26
    186c:	9f 91       	pop	r25
    186e:	8f 91       	pop	r24
    1870:	4f 91       	pop	r20
    1872:	3f 91       	pop	r19
    1874:	2f 91       	pop	r18
    1876:	0f 90       	pop	r0
    1878:	0b be       	out	0x3b, r0	; 59
    187a:	0f 90       	pop	r0
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	0f 90       	pop	r0
    1880:	1f 90       	pop	r1
    1882:	18 95       	reti

00001884 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1884:	1f 92       	push	r1
    1886:	0f 92       	push	r0
    1888:	0f b6       	in	r0, 0x3f	; 63
    188a:	0f 92       	push	r0
    188c:	11 24       	eor	r1, r1
    188e:	0b b6       	in	r0, 0x3b	; 59
    1890:	0f 92       	push	r0
    1892:	2f 93       	push	r18
    1894:	8f 93       	push	r24
    1896:	9f 93       	push	r25
    1898:	af 93       	push	r26
    189a:	bf 93       	push	r27
    189c:	ef 93       	push	r30
    189e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18a0:	0f b6       	in	r0, 0x3f	; 63
    18a2:	f8 94       	cli
    18a4:	0f 92       	push	r0
	{
	    count = buffer->count;
    18a6:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <xSerial3Port+0xd>
    18aa:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    18b2:	89 2b       	or	r24, r25
    18b4:	31 f4       	brne	.+12     	; 0x18c2 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    18b6:	e1 e3       	ldi	r30, 0x31	; 49
    18b8:	f1 e0       	ldi	r31, 0x01	; 1
    18ba:	80 81       	ld	r24, Z
    18bc:	8f 7d       	andi	r24, 0xDF	; 223
    18be:	80 83       	st	Z, r24
    18c0:	1c c0       	rjmp	.+56     	; 0x18fa <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    18c2:	ea e8       	ldi	r30, 0x8A	; 138
    18c4:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    18c6:	a4 81       	ldd	r26, Z+4	; 0x04
    18c8:	b5 81       	ldd	r27, Z+5	; 0x05
    18ca:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    18cc:	b5 83       	std	Z+5, r27	; 0x05
    18ce:	a4 83       	std	Z+4, r26	; 0x04
    18d0:	80 85       	ldd	r24, Z+8	; 0x08
    18d2:	91 85       	ldd	r25, Z+9	; 0x09
    18d4:	a8 17       	cp	r26, r24
    18d6:	b9 07       	cpc	r27, r25
    18d8:	21 f4       	brne	.+8      	; 0x18e2 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    18da:	86 81       	ldd	r24, Z+6	; 0x06
    18dc:	97 81       	ldd	r25, Z+7	; 0x07
    18de:	95 83       	std	Z+5, r25	; 0x05
    18e0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    18e2:	0f b6       	in	r0, 0x3f	; 63
    18e4:	f8 94       	cli
    18e6:	0f 92       	push	r0
	{
	    buffer->count--;
    18e8:	80 81       	ld	r24, Z
    18ea:	91 81       	ldd	r25, Z+1	; 0x01
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	91 83       	std	Z+1, r25	; 0x01
    18f0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    18f6:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    18fa:	ff 91       	pop	r31
    18fc:	ef 91       	pop	r30
    18fe:	bf 91       	pop	r27
    1900:	af 91       	pop	r26
    1902:	9f 91       	pop	r25
    1904:	8f 91       	pop	r24
    1906:	2f 91       	pop	r18
    1908:	0f 90       	pop	r0
    190a:	0b be       	out	0x3b, r0	; 59
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	0f 90       	pop	r0
    1912:	1f 90       	pop	r1
    1914:	18 95       	reti

00001916 <prvResetNextTaskUnblockTime>:
    1916:	e0 91 e6 02 	lds	r30, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    191a:	f0 91 e7 02 	lds	r31, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    191e:	80 81       	ld	r24, Z
    1920:	81 11       	cpse	r24, r1
    1922:	07 c0       	rjmp	.+14     	; 0x1932 <prvResetNextTaskUnblockTime+0x1c>
    1924:	8f ef       	ldi	r24, 0xFF	; 255
    1926:	9f ef       	ldi	r25, 0xFF	; 255
    1928:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <xNextTaskUnblockTime+0x1>
    192c:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xNextTaskUnblockTime>
    1930:	08 95       	ret
    1932:	e0 91 e6 02 	lds	r30, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    1936:	f0 91 e7 02 	lds	r31, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    193a:	05 80       	ldd	r0, Z+5	; 0x05
    193c:	f6 81       	ldd	r31, Z+6	; 0x06
    193e:	e0 2d       	mov	r30, r0
    1940:	06 80       	ldd	r0, Z+6	; 0x06
    1942:	f7 81       	ldd	r31, Z+7	; 0x07
    1944:	e0 2d       	mov	r30, r0
    1946:	82 81       	ldd	r24, Z+2	; 0x02
    1948:	93 81       	ldd	r25, Z+3	; 0x03
    194a:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <xNextTaskUnblockTime+0x1>
    194e:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xNextTaskUnblockTime>
    1952:	08 95       	ret

00001954 <prvAddCurrentTaskToDelayedList>:
    1954:	ff 92       	push	r15
    1956:	0f 93       	push	r16
    1958:	1f 93       	push	r17
    195a:	cf 93       	push	r28
    195c:	df 93       	push	r29
    195e:	ec 01       	movw	r28, r24
    1960:	f6 2e       	mov	r15, r22
    1962:	00 91 c5 02 	lds	r16, 0x02C5	; 0x8002c5 <xTickCount>
    1966:	10 91 c6 02 	lds	r17, 0x02C6	; 0x8002c6 <xTickCount+0x1>
    196a:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <pxCurrentTCB>
    196e:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1972:	02 96       	adiw	r24, 0x02	; 2
    1974:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1978:	cf 3f       	cpi	r28, 0xFF	; 255
    197a:	8f ef       	ldi	r24, 0xFF	; 255
    197c:	d8 07       	cpc	r29, r24
    197e:	69 f4       	brne	.+26     	; 0x199a <prvAddCurrentTaskToDelayedList+0x46>
    1980:	ff 20       	and	r15, r15
    1982:	59 f0       	breq	.+22     	; 0x199a <prvAddCurrentTaskToDelayedList+0x46>
    1984:	60 91 1e 03 	lds	r22, 0x031E	; 0x80031e <pxCurrentTCB>
    1988:	70 91 1f 03 	lds	r23, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    198c:	6e 5f       	subi	r22, 0xFE	; 254
    198e:	7f 4f       	sbci	r23, 0xFF	; 255
    1990:	88 ec       	ldi	r24, 0xC8	; 200
    1992:	92 e0       	ldi	r25, 0x02	; 2
    1994:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1998:	2f c0       	rjmp	.+94     	; 0x19f8 <prvAddCurrentTaskToDelayedList+0xa4>
    199a:	c0 0f       	add	r28, r16
    199c:	d1 1f       	adc	r29, r17
    199e:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    19a2:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    19a6:	d3 83       	std	Z+3, r29	; 0x03
    19a8:	c2 83       	std	Z+2, r28	; 0x02
    19aa:	c0 17       	cp	r28, r16
    19ac:	d1 07       	cpc	r29, r17
    19ae:	68 f4       	brcc	.+26     	; 0x19ca <prvAddCurrentTaskToDelayedList+0x76>
    19b0:	60 91 1e 03 	lds	r22, 0x031E	; 0x80031e <pxCurrentTCB>
    19b4:	70 91 1f 03 	lds	r23, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    19b8:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <pxOverflowDelayedTaskList>
    19bc:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <pxOverflowDelayedTaskList+0x1>
    19c0:	6e 5f       	subi	r22, 0xFE	; 254
    19c2:	7f 4f       	sbci	r23, 0xFF	; 255
    19c4:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    19c8:	17 c0       	rjmp	.+46     	; 0x19f8 <prvAddCurrentTaskToDelayedList+0xa4>
    19ca:	60 91 1e 03 	lds	r22, 0x031E	; 0x80031e <pxCurrentTCB>
    19ce:	70 91 1f 03 	lds	r23, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    19d2:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    19d6:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    19da:	6e 5f       	subi	r22, 0xFE	; 254
    19dc:	7f 4f       	sbci	r23, 0xFF	; 255
    19de:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    19e2:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <xNextTaskUnblockTime>
    19e6:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <xNextTaskUnblockTime+0x1>
    19ea:	c8 17       	cp	r28, r24
    19ec:	d9 07       	cpc	r29, r25
    19ee:	20 f4       	brcc	.+8      	; 0x19f8 <prvAddCurrentTaskToDelayedList+0xa4>
    19f0:	d0 93 be 02 	sts	0x02BE, r29	; 0x8002be <xNextTaskUnblockTime+0x1>
    19f4:	c0 93 bd 02 	sts	0x02BD, r28	; 0x8002bd <xNextTaskUnblockTime>
    19f8:	df 91       	pop	r29
    19fa:	cf 91       	pop	r28
    19fc:	1f 91       	pop	r17
    19fe:	0f 91       	pop	r16
    1a00:	ff 90       	pop	r15
    1a02:	08 95       	ret

00001a04 <xTaskCreate>:
    1a04:	4f 92       	push	r4
    1a06:	5f 92       	push	r5
    1a08:	6f 92       	push	r6
    1a0a:	7f 92       	push	r7
    1a0c:	8f 92       	push	r8
    1a0e:	9f 92       	push	r9
    1a10:	af 92       	push	r10
    1a12:	bf 92       	push	r11
    1a14:	cf 92       	push	r12
    1a16:	df 92       	push	r13
    1a18:	ef 92       	push	r14
    1a1a:	ff 92       	push	r15
    1a1c:	0f 93       	push	r16
    1a1e:	cf 93       	push	r28
    1a20:	df 93       	push	r29
    1a22:	4c 01       	movw	r8, r24
    1a24:	6b 01       	movw	r12, r22
    1a26:	5a 01       	movw	r10, r20
    1a28:	29 01       	movw	r4, r18
    1a2a:	ca 01       	movw	r24, r20
    1a2c:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1a30:	3c 01       	movw	r6, r24
    1a32:	89 2b       	or	r24, r25
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <xTaskCreate+0x34>
    1a36:	e9 c0       	rjmp	.+466    	; 0x1c0a <xTaskCreate+0x206>
    1a38:	88 e2       	ldi	r24, 0x28	; 40
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1a40:	ec 01       	movw	r28, r24
    1a42:	89 2b       	or	r24, r25
    1a44:	a9 f0       	breq	.+42     	; 0x1a70 <xTaskCreate+0x6c>
    1a46:	78 8e       	std	Y+24, r7	; 0x18
    1a48:	6f 8a       	std	Y+23, r6	; 0x17
    1a4a:	a5 01       	movw	r20, r10
    1a4c:	65 ea       	ldi	r22, 0xA5	; 165
    1a4e:	70 e0       	ldi	r23, 0x00	; 0
    1a50:	c3 01       	movw	r24, r6
    1a52:	a5 d6       	rcall	.+3402   	; 0x279e <memset>
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	a8 1a       	sub	r10, r24
    1a58:	b1 08       	sbc	r11, r1
    1a5a:	8f 89       	ldd	r24, Y+23	; 0x17
    1a5c:	98 8d       	ldd	r25, Y+24	; 0x18
    1a5e:	a8 0e       	add	r10, r24
    1a60:	b9 1e       	adc	r11, r25
    1a62:	d6 01       	movw	r26, r12
    1a64:	8c 91       	ld	r24, X
    1a66:	89 8f       	std	Y+25, r24	; 0x19
    1a68:	8c 91       	ld	r24, X
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	05 c0       	rjmp	.+10     	; 0x1a78 <xTaskCreate+0x74>
    1a6e:	18 c0       	rjmp	.+48     	; 0x1aa0 <xTaskCreate+0x9c>
    1a70:	c3 01       	movw	r24, r6
    1a72:	0e 94 bc 01 	call	0x378	; 0x378 <vPortFree>
    1a76:	c9 c0       	rjmp	.+402    	; 0x1c0a <xTaskCreate+0x206>
    1a78:	ae 01       	movw	r20, r28
    1a7a:	46 5e       	subi	r20, 0xE6	; 230
    1a7c:	5f 4f       	sbci	r21, 0xFF	; 255
    1a7e:	f6 01       	movw	r30, r12
    1a80:	31 96       	adiw	r30, 0x01	; 1
    1a82:	b8 e0       	ldi	r27, 0x08	; 8
    1a84:	cb 0e       	add	r12, r27
    1a86:	d1 1c       	adc	r13, r1
    1a88:	cf 01       	movw	r24, r30
    1a8a:	21 91       	ld	r18, Z+
    1a8c:	da 01       	movw	r26, r20
    1a8e:	2d 93       	st	X+, r18
    1a90:	ad 01       	movw	r20, r26
    1a92:	dc 01       	movw	r26, r24
    1a94:	8c 91       	ld	r24, X
    1a96:	88 23       	and	r24, r24
    1a98:	19 f0       	breq	.+6      	; 0x1aa0 <xTaskCreate+0x9c>
    1a9a:	ec 15       	cp	r30, r12
    1a9c:	fd 05       	cpc	r31, r13
    1a9e:	a1 f7       	brne	.-24     	; 0x1a88 <xTaskCreate+0x84>
    1aa0:	18 a2       	std	Y+32, r1	; 0x20
    1aa2:	04 30       	cpi	r16, 0x04	; 4
    1aa4:	08 f0       	brcs	.+2      	; 0x1aa8 <xTaskCreate+0xa4>
    1aa6:	03 e0       	ldi	r16, 0x03	; 3
    1aa8:	0e 8b       	std	Y+22, r16	; 0x16
    1aaa:	09 a3       	std	Y+33, r16	; 0x21
    1aac:	1a a2       	std	Y+34, r1	; 0x22
    1aae:	6e 01       	movw	r12, r28
    1ab0:	b2 e0       	ldi	r27, 0x02	; 2
    1ab2:	cb 0e       	add	r12, r27
    1ab4:	d1 1c       	adc	r13, r1
    1ab6:	c6 01       	movw	r24, r12
    1ab8:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1abc:	ce 01       	movw	r24, r28
    1abe:	0c 96       	adiw	r24, 0x0c	; 12
    1ac0:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1ac4:	d9 87       	std	Y+9, r29	; 0x09
    1ac6:	c8 87       	std	Y+8, r28	; 0x08
    1ac8:	84 e0       	ldi	r24, 0x04	; 4
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	80 1b       	sub	r24, r16
    1ace:	91 09       	sbc	r25, r1
    1ad0:	9d 87       	std	Y+13, r25	; 0x0d
    1ad2:	8c 87       	std	Y+12, r24	; 0x0c
    1ad4:	db 8b       	std	Y+19, r29	; 0x13
    1ad6:	ca 8b       	std	Y+18, r28	; 0x12
    1ad8:	1b a2       	std	Y+35, r1	; 0x23
    1ada:	1c a2       	std	Y+36, r1	; 0x24
    1adc:	1d a2       	std	Y+37, r1	; 0x25
    1ade:	1e a2       	std	Y+38, r1	; 0x26
    1ae0:	1f a2       	std	Y+39, r1	; 0x27
    1ae2:	a2 01       	movw	r20, r4
    1ae4:	b4 01       	movw	r22, r8
    1ae6:	c5 01       	movw	r24, r10
    1ae8:	a7 d9       	rcall	.-3250   	; 0xe38 <pxPortInitialiseStack>
    1aea:	99 83       	std	Y+1, r25	; 0x01
    1aec:	88 83       	st	Y, r24
    1aee:	e1 14       	cp	r14, r1
    1af0:	f1 04       	cpc	r15, r1
    1af2:	19 f0       	breq	.+6      	; 0x1afa <xTaskCreate+0xf6>
    1af4:	f7 01       	movw	r30, r14
    1af6:	d1 83       	std	Z+1, r29	; 0x01
    1af8:	c0 83       	st	Z, r28
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	0f 92       	push	r0
    1b00:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxCurrentNumberOfTasks>
    1b04:	8f 5f       	subi	r24, 0xFF	; 255
    1b06:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <uxCurrentNumberOfTasks>
    1b0a:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <pxCurrentTCB>
    1b0e:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1b12:	89 2b       	or	r24, r25
    1b14:	d1 f5       	brne	.+116    	; 0x1b8a <xTaskCreate+0x186>
    1b16:	d0 93 1f 03 	sts	0x031F, r29	; 0x80031f <pxCurrentTCB+0x1>
    1b1a:	c0 93 1e 03 	sts	0x031E, r28	; 0x80031e <pxCurrentTCB>
    1b1e:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxCurrentNumberOfTasks>
    1b22:	81 30       	cpi	r24, 0x01	; 1
    1b24:	09 f0       	breq	.+2      	; 0x1b28 <xTaskCreate+0x124>
    1b26:	41 c0       	rjmp	.+130    	; 0x1baa <xTaskCreate+0x1a6>
    1b28:	8a ef       	ldi	r24, 0xFA	; 250
    1b2a:	92 e0       	ldi	r25, 0x02	; 2
    1b2c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b30:	83 e0       	ldi	r24, 0x03	; 3
    1b32:	93 e0       	ldi	r25, 0x03	; 3
    1b34:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b38:	8c e0       	ldi	r24, 0x0C	; 12
    1b3a:	93 e0       	ldi	r25, 0x03	; 3
    1b3c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b40:	85 e1       	ldi	r24, 0x15	; 21
    1b42:	93 e0       	ldi	r25, 0x03	; 3
    1b44:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b48:	81 ef       	ldi	r24, 0xF1	; 241
    1b4a:	92 e0       	ldi	r25, 0x02	; 2
    1b4c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b50:	88 ee       	ldi	r24, 0xE8	; 232
    1b52:	92 e0       	ldi	r25, 0x02	; 2
    1b54:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b58:	8b ed       	ldi	r24, 0xDB	; 219
    1b5a:	92 e0       	ldi	r25, 0x02	; 2
    1b5c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b60:	82 ed       	ldi	r24, 0xD2	; 210
    1b62:	92 e0       	ldi	r25, 0x02	; 2
    1b64:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b68:	88 ec       	ldi	r24, 0xC8	; 200
    1b6a:	92 e0       	ldi	r25, 0x02	; 2
    1b6c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1b70:	81 ef       	ldi	r24, 0xF1	; 241
    1b72:	92 e0       	ldi	r25, 0x02	; 2
    1b74:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <pxDelayedTaskList+0x1>
    1b78:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <pxDelayedTaskList>
    1b7c:	88 ee       	ldi	r24, 0xE8	; 232
    1b7e:	92 e0       	ldi	r25, 0x02	; 2
    1b80:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <pxOverflowDelayedTaskList+0x1>
    1b84:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <pxOverflowDelayedTaskList>
    1b88:	10 c0       	rjmp	.+32     	; 0x1baa <xTaskCreate+0x1a6>
    1b8a:	80 91 c3 02 	lds	r24, 0x02C3	; 0x8002c3 <xSchedulerRunning>
    1b8e:	81 11       	cpse	r24, r1
    1b90:	0c c0       	rjmp	.+24     	; 0x1baa <xTaskCreate+0x1a6>
    1b92:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1b96:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1b9a:	96 89       	ldd	r25, Z+22	; 0x16
    1b9c:	8e 89       	ldd	r24, Y+22	; 0x16
    1b9e:	89 17       	cp	r24, r25
    1ba0:	20 f0       	brcs	.+8      	; 0x1baa <xTaskCreate+0x1a6>
    1ba2:	d0 93 1f 03 	sts	0x031F, r29	; 0x80031f <pxCurrentTCB+0x1>
    1ba6:	c0 93 1e 03 	sts	0x031E, r28	; 0x80031e <pxCurrentTCB>
    1baa:	80 91 bf 02 	lds	r24, 0x02BF	; 0x8002bf <uxTaskNumber>
    1bae:	8f 5f       	subi	r24, 0xFF	; 255
    1bb0:	80 93 bf 02 	sts	0x02BF, r24	; 0x8002bf <uxTaskNumber>
    1bb4:	8e 89       	ldd	r24, Y+22	; 0x16
    1bb6:	90 91 c4 02 	lds	r25, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    1bba:	98 17       	cp	r25, r24
    1bbc:	10 f4       	brcc	.+4      	; 0x1bc2 <xTaskCreate+0x1be>
    1bbe:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <uxTopReadyPriority>
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	9c 01       	movw	r18, r24
    1bc6:	22 0f       	add	r18, r18
    1bc8:	33 1f       	adc	r19, r19
    1bca:	22 0f       	add	r18, r18
    1bcc:	33 1f       	adc	r19, r19
    1bce:	22 0f       	add	r18, r18
    1bd0:	33 1f       	adc	r19, r19
    1bd2:	82 0f       	add	r24, r18
    1bd4:	93 1f       	adc	r25, r19
    1bd6:	b6 01       	movw	r22, r12
    1bd8:	86 50       	subi	r24, 0x06	; 6
    1bda:	9d 4f       	sbci	r25, 0xFD	; 253
    1bdc:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	80 91 c3 02 	lds	r24, 0x02C3	; 0x8002c3 <xSchedulerRunning>
    1be8:	88 23       	and	r24, r24
    1bea:	59 f0       	breq	.+22     	; 0x1c02 <xTaskCreate+0x1fe>
    1bec:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1bf0:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1bf4:	96 89       	ldd	r25, Z+22	; 0x16
    1bf6:	8e 89       	ldd	r24, Y+22	; 0x16
    1bf8:	98 17       	cp	r25, r24
    1bfa:	28 f4       	brcc	.+10     	; 0x1c06 <xTaskCreate+0x202>
    1bfc:	d5 d9       	rcall	.-3158   	; 0xfa8 <vPortYield>
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	05 c0       	rjmp	.+10     	; 0x1c0c <xTaskCreate+0x208>
    1c02:	81 e0       	ldi	r24, 0x01	; 1
    1c04:	03 c0       	rjmp	.+6      	; 0x1c0c <xTaskCreate+0x208>
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	01 c0       	rjmp	.+2      	; 0x1c0c <xTaskCreate+0x208>
    1c0a:	8f ef       	ldi	r24, 0xFF	; 255
    1c0c:	df 91       	pop	r29
    1c0e:	cf 91       	pop	r28
    1c10:	0f 91       	pop	r16
    1c12:	ff 90       	pop	r15
    1c14:	ef 90       	pop	r14
    1c16:	df 90       	pop	r13
    1c18:	cf 90       	pop	r12
    1c1a:	bf 90       	pop	r11
    1c1c:	af 90       	pop	r10
    1c1e:	9f 90       	pop	r9
    1c20:	8f 90       	pop	r8
    1c22:	7f 90       	pop	r7
    1c24:	6f 90       	pop	r6
    1c26:	5f 90       	pop	r5
    1c28:	4f 90       	pop	r4
    1c2a:	08 95       	ret

00001c2c <vTaskStartScheduler>:
    1c2c:	ef 92       	push	r14
    1c2e:	ff 92       	push	r15
    1c30:	0f 93       	push	r16
    1c32:	0f 2e       	mov	r0, r31
    1c34:	fb eb       	ldi	r31, 0xBB	; 187
    1c36:	ef 2e       	mov	r14, r31
    1c38:	f2 e0       	ldi	r31, 0x02	; 2
    1c3a:	ff 2e       	mov	r15, r31
    1c3c:	f0 2d       	mov	r31, r0
    1c3e:	00 e0       	ldi	r16, 0x00	; 0
    1c40:	20 e0       	ldi	r18, 0x00	; 0
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	45 e5       	ldi	r20, 0x55	; 85
    1c46:	50 e0       	ldi	r21, 0x00	; 0
    1c48:	6d e8       	ldi	r22, 0x8D	; 141
    1c4a:	72 e0       	ldi	r23, 0x02	; 2
    1c4c:	83 e3       	ldi	r24, 0x33	; 51
    1c4e:	91 e0       	ldi	r25, 0x01	; 1
    1c50:	d9 de       	rcall	.-590    	; 0x1a04 <xTaskCreate>
    1c52:	81 30       	cpi	r24, 0x01	; 1
    1c54:	79 f4       	brne	.+30     	; 0x1c74 <vTaskStartScheduler+0x48>
    1c56:	f8 94       	cli
    1c58:	8f ef       	ldi	r24, 0xFF	; 255
    1c5a:	9f ef       	ldi	r25, 0xFF	; 255
    1c5c:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <xNextTaskUnblockTime+0x1>
    1c60:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xNextTaskUnblockTime>
    1c64:	81 e0       	ldi	r24, 0x01	; 1
    1c66:	80 93 c3 02 	sts	0x02C3, r24	; 0x8002c3 <xSchedulerRunning>
    1c6a:	10 92 c6 02 	sts	0x02C6, r1	; 0x8002c6 <xTickCount+0x1>
    1c6e:	10 92 c5 02 	sts	0x02C5, r1	; 0x8002c5 <xTickCount>
    1c72:	54 d9       	rcall	.-3416   	; 0xf1c <xPortStartScheduler>
    1c74:	0f 91       	pop	r16
    1c76:	ff 90       	pop	r15
    1c78:	ef 90       	pop	r14
    1c7a:	08 95       	ret

00001c7c <vTaskSuspendAll>:
    1c7c:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    1c80:	8f 5f       	subi	r24, 0xFF	; 255
    1c82:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <uxSchedulerSuspended>
    1c86:	08 95       	ret

00001c88 <xTaskIncrementTick>:
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	98 c0       	rjmp	.+304    	; 0x1dd0 <xTaskIncrementTick+0x148>
    1ca0:	e0 90 c5 02 	lds	r14, 0x02C5	; 0x8002c5 <xTickCount>
    1ca4:	f0 90 c6 02 	lds	r15, 0x02C6	; 0x8002c6 <xTickCount+0x1>
    1ca8:	8f ef       	ldi	r24, 0xFF	; 255
    1caa:	e8 1a       	sub	r14, r24
    1cac:	f8 0a       	sbc	r15, r24
    1cae:	f0 92 c6 02 	sts	0x02C6, r15	; 0x8002c6 <xTickCount+0x1>
    1cb2:	e0 92 c5 02 	sts	0x02C5, r14	; 0x8002c5 <xTickCount>
    1cb6:	e1 14       	cp	r14, r1
    1cb8:	f1 04       	cpc	r15, r1
    1cba:	b1 f4       	brne	.+44     	; 0x1ce8 <xTaskIncrementTick+0x60>
    1cbc:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    1cc0:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    1cc4:	20 91 e4 02 	lds	r18, 0x02E4	; 0x8002e4 <pxOverflowDelayedTaskList>
    1cc8:	30 91 e5 02 	lds	r19, 0x02E5	; 0x8002e5 <pxOverflowDelayedTaskList+0x1>
    1ccc:	30 93 e7 02 	sts	0x02E7, r19	; 0x8002e7 <pxDelayedTaskList+0x1>
    1cd0:	20 93 e6 02 	sts	0x02E6, r18	; 0x8002e6 <pxDelayedTaskList>
    1cd4:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <pxOverflowDelayedTaskList+0x1>
    1cd8:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <pxOverflowDelayedTaskList>
    1cdc:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <xNumOfOverflows>
    1ce0:	8f 5f       	subi	r24, 0xFF	; 255
    1ce2:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <xNumOfOverflows>
    1ce6:	17 de       	rcall	.-978    	; 0x1916 <prvResetNextTaskUnblockTime>
    1ce8:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <xNextTaskUnblockTime>
    1cec:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <xNextTaskUnblockTime+0x1>
    1cf0:	e8 16       	cp	r14, r24
    1cf2:	f9 06       	cpc	r15, r25
    1cf4:	10 f4       	brcc	.+4      	; 0x1cfa <xTaskIncrementTick+0x72>
    1cf6:	d1 2c       	mov	r13, r1
    1cf8:	53 c0       	rjmp	.+166    	; 0x1da0 <xTaskIncrementTick+0x118>
    1cfa:	d1 2c       	mov	r13, r1
    1cfc:	cc 24       	eor	r12, r12
    1cfe:	c3 94       	inc	r12
    1d00:	e0 91 e6 02 	lds	r30, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    1d04:	f0 91 e7 02 	lds	r31, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    1d08:	80 81       	ld	r24, Z
    1d0a:	81 11       	cpse	r24, r1
    1d0c:	07 c0       	rjmp	.+14     	; 0x1d1c <xTaskIncrementTick+0x94>
    1d0e:	8f ef       	ldi	r24, 0xFF	; 255
    1d10:	9f ef       	ldi	r25, 0xFF	; 255
    1d12:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <xNextTaskUnblockTime+0x1>
    1d16:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xNextTaskUnblockTime>
    1d1a:	42 c0       	rjmp	.+132    	; 0x1da0 <xTaskIncrementTick+0x118>
    1d1c:	e0 91 e6 02 	lds	r30, 0x02E6	; 0x8002e6 <pxDelayedTaskList>
    1d20:	f0 91 e7 02 	lds	r31, 0x02E7	; 0x8002e7 <pxDelayedTaskList+0x1>
    1d24:	05 80       	ldd	r0, Z+5	; 0x05
    1d26:	f6 81       	ldd	r31, Z+6	; 0x06
    1d28:	e0 2d       	mov	r30, r0
    1d2a:	c6 81       	ldd	r28, Z+6	; 0x06
    1d2c:	d7 81       	ldd	r29, Z+7	; 0x07
    1d2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d30:	9b 81       	ldd	r25, Y+3	; 0x03
    1d32:	e8 16       	cp	r14, r24
    1d34:	f9 06       	cpc	r15, r25
    1d36:	28 f4       	brcc	.+10     	; 0x1d42 <xTaskIncrementTick+0xba>
    1d38:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <xNextTaskUnblockTime+0x1>
    1d3c:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xNextTaskUnblockTime>
    1d40:	2f c0       	rjmp	.+94     	; 0x1da0 <xTaskIncrementTick+0x118>
    1d42:	8e 01       	movw	r16, r28
    1d44:	0e 5f       	subi	r16, 0xFE	; 254
    1d46:	1f 4f       	sbci	r17, 0xFF	; 255
    1d48:	c8 01       	movw	r24, r16
    1d4a:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1d4e:	8c 89       	ldd	r24, Y+20	; 0x14
    1d50:	9d 89       	ldd	r25, Y+21	; 0x15
    1d52:	89 2b       	or	r24, r25
    1d54:	21 f0       	breq	.+8      	; 0x1d5e <xTaskIncrementTick+0xd6>
    1d56:	ce 01       	movw	r24, r28
    1d58:	0c 96       	adiw	r24, 0x0c	; 12
    1d5a:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1d5e:	8e 89       	ldd	r24, Y+22	; 0x16
    1d60:	90 91 c4 02 	lds	r25, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    1d64:	98 17       	cp	r25, r24
    1d66:	10 f4       	brcc	.+4      	; 0x1d6c <xTaskIncrementTick+0xe4>
    1d68:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <uxTopReadyPriority>
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	9c 01       	movw	r18, r24
    1d70:	22 0f       	add	r18, r18
    1d72:	33 1f       	adc	r19, r19
    1d74:	22 0f       	add	r18, r18
    1d76:	33 1f       	adc	r19, r19
    1d78:	22 0f       	add	r18, r18
    1d7a:	33 1f       	adc	r19, r19
    1d7c:	82 0f       	add	r24, r18
    1d7e:	93 1f       	adc	r25, r19
    1d80:	b8 01       	movw	r22, r16
    1d82:	86 50       	subi	r24, 0x06	; 6
    1d84:	9d 4f       	sbci	r25, 0xFD	; 253
    1d86:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1d8a:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1d8e:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1d92:	9e 89       	ldd	r25, Y+22	; 0x16
    1d94:	86 89       	ldd	r24, Z+22	; 0x16
    1d96:	98 17       	cp	r25, r24
    1d98:	08 f4       	brcc	.+2      	; 0x1d9c <xTaskIncrementTick+0x114>
    1d9a:	b2 cf       	rjmp	.-156    	; 0x1d00 <xTaskIncrementTick+0x78>
    1d9c:	dc 2c       	mov	r13, r12
    1d9e:	b0 cf       	rjmp	.-160    	; 0x1d00 <xTaskIncrementTick+0x78>
    1da0:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1da4:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1da8:	86 89       	ldd	r24, Z+22	; 0x16
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	fc 01       	movw	r30, r24
    1dae:	ee 0f       	add	r30, r30
    1db0:	ff 1f       	adc	r31, r31
    1db2:	ee 0f       	add	r30, r30
    1db4:	ff 1f       	adc	r31, r31
    1db6:	ee 0f       	add	r30, r30
    1db8:	ff 1f       	adc	r31, r31
    1dba:	8e 0f       	add	r24, r30
    1dbc:	9f 1f       	adc	r25, r31
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	e6 50       	subi	r30, 0x06	; 6
    1dc2:	fd 4f       	sbci	r31, 0xFD	; 253
    1dc4:	80 81       	ld	r24, Z
    1dc6:	82 30       	cpi	r24, 0x02	; 2
    1dc8:	48 f0       	brcs	.+18     	; 0x1ddc <xTaskIncrementTick+0x154>
    1dca:	dd 24       	eor	r13, r13
    1dcc:	d3 94       	inc	r13
    1dce:	06 c0       	rjmp	.+12     	; 0x1ddc <xTaskIncrementTick+0x154>
    1dd0:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxPendedTicks>
    1dd4:	8f 5f       	subi	r24, 0xFF	; 255
    1dd6:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxPendedTicks>
    1dda:	d1 2c       	mov	r13, r1
    1ddc:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <xYieldPending>
    1de0:	88 23       	and	r24, r24
    1de2:	11 f0       	breq	.+4      	; 0x1de8 <xTaskIncrementTick+0x160>
    1de4:	dd 24       	eor	r13, r13
    1de6:	d3 94       	inc	r13
    1de8:	8d 2d       	mov	r24, r13
    1dea:	df 91       	pop	r29
    1dec:	cf 91       	pop	r28
    1dee:	1f 91       	pop	r17
    1df0:	0f 91       	pop	r16
    1df2:	ff 90       	pop	r15
    1df4:	ef 90       	pop	r14
    1df6:	df 90       	pop	r13
    1df8:	cf 90       	pop	r12
    1dfa:	08 95       	ret

00001dfc <xTaskResumeAll>:
    1dfc:	df 92       	push	r13
    1dfe:	ef 92       	push	r14
    1e00:	ff 92       	push	r15
    1e02:	0f 93       	push	r16
    1e04:	1f 93       	push	r17
    1e06:	cf 93       	push	r28
    1e08:	df 93       	push	r29
    1e0a:	0f b6       	in	r0, 0x3f	; 63
    1e0c:	f8 94       	cli
    1e0e:	0f 92       	push	r0
    1e10:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    1e14:	81 50       	subi	r24, 0x01	; 1
    1e16:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <uxSchedulerSuspended>
    1e1a:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    1e1e:	81 11       	cpse	r24, r1
    1e20:	5c c0       	rjmp	.+184    	; 0x1eda <xTaskResumeAll+0xde>
    1e22:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxCurrentNumberOfTasks>
    1e26:	81 11       	cpse	r24, r1
    1e28:	33 c0       	rjmp	.+102    	; 0x1e90 <xTaskResumeAll+0x94>
    1e2a:	5a c0       	rjmp	.+180    	; 0x1ee0 <xTaskResumeAll+0xe4>
    1e2c:	d7 01       	movw	r26, r14
    1e2e:	15 96       	adiw	r26, 0x05	; 5
    1e30:	ed 91       	ld	r30, X+
    1e32:	fc 91       	ld	r31, X
    1e34:	16 97       	sbiw	r26, 0x06	; 6
    1e36:	c6 81       	ldd	r28, Z+6	; 0x06
    1e38:	d7 81       	ldd	r29, Z+7	; 0x07
    1e3a:	ce 01       	movw	r24, r28
    1e3c:	0c 96       	adiw	r24, 0x0c	; 12
    1e3e:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1e42:	8e 01       	movw	r16, r28
    1e44:	0e 5f       	subi	r16, 0xFE	; 254
    1e46:	1f 4f       	sbci	r17, 0xFF	; 255
    1e48:	c8 01       	movw	r24, r16
    1e4a:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1e4e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e50:	90 91 c4 02 	lds	r25, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    1e54:	98 17       	cp	r25, r24
    1e56:	10 f4       	brcc	.+4      	; 0x1e5c <xTaskResumeAll+0x60>
    1e58:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <uxTopReadyPriority>
    1e5c:	90 e0       	ldi	r25, 0x00	; 0
    1e5e:	9c 01       	movw	r18, r24
    1e60:	22 0f       	add	r18, r18
    1e62:	33 1f       	adc	r19, r19
    1e64:	22 0f       	add	r18, r18
    1e66:	33 1f       	adc	r19, r19
    1e68:	22 0f       	add	r18, r18
    1e6a:	33 1f       	adc	r19, r19
    1e6c:	82 0f       	add	r24, r18
    1e6e:	93 1f       	adc	r25, r19
    1e70:	b8 01       	movw	r22, r16
    1e72:	86 50       	subi	r24, 0x06	; 6
    1e74:	9d 4f       	sbci	r25, 0xFD	; 253
    1e76:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1e7a:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1e7e:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1e82:	9e 89       	ldd	r25, Y+22	; 0x16
    1e84:	86 89       	ldd	r24, Z+22	; 0x16
    1e86:	98 17       	cp	r25, r24
    1e88:	68 f0       	brcs	.+26     	; 0x1ea4 <xTaskResumeAll+0xa8>
    1e8a:	d0 92 c1 02 	sts	0x02C1, r13	; 0x8002c1 <xYieldPending>
    1e8e:	0a c0       	rjmp	.+20     	; 0x1ea4 <xTaskResumeAll+0xa8>
    1e90:	c0 e0       	ldi	r28, 0x00	; 0
    1e92:	d0 e0       	ldi	r29, 0x00	; 0
    1e94:	0f 2e       	mov	r0, r31
    1e96:	fb ed       	ldi	r31, 0xDB	; 219
    1e98:	ef 2e       	mov	r14, r31
    1e9a:	f2 e0       	ldi	r31, 0x02	; 2
    1e9c:	ff 2e       	mov	r15, r31
    1e9e:	f0 2d       	mov	r31, r0
    1ea0:	dd 24       	eor	r13, r13
    1ea2:	d3 94       	inc	r13
    1ea4:	f7 01       	movw	r30, r14
    1ea6:	80 81       	ld	r24, Z
    1ea8:	81 11       	cpse	r24, r1
    1eaa:	c0 cf       	rjmp	.-128    	; 0x1e2c <xTaskResumeAll+0x30>
    1eac:	cd 2b       	or	r28, r29
    1eae:	09 f0       	breq	.+2      	; 0x1eb2 <xTaskResumeAll+0xb6>
    1eb0:	32 dd       	rcall	.-1436   	; 0x1916 <prvResetNextTaskUnblockTime>
    1eb2:	c0 91 c2 02 	lds	r28, 0x02C2	; 0x8002c2 <uxPendedTicks>
    1eb6:	cc 23       	and	r28, r28
    1eb8:	49 f0       	breq	.+18     	; 0x1ecc <xTaskResumeAll+0xd0>
    1eba:	d1 e0       	ldi	r29, 0x01	; 1
    1ebc:	e5 de       	rcall	.-566    	; 0x1c88 <xTaskIncrementTick>
    1ebe:	81 11       	cpse	r24, r1
    1ec0:	d0 93 c1 02 	sts	0x02C1, r29	; 0x8002c1 <xYieldPending>
    1ec4:	c1 50       	subi	r28, 0x01	; 1
    1ec6:	d1 f7       	brne	.-12     	; 0x1ebc <xTaskResumeAll+0xc0>
    1ec8:	10 92 c2 02 	sts	0x02C2, r1	; 0x8002c2 <uxPendedTicks>
    1ecc:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <xYieldPending>
    1ed0:	88 23       	and	r24, r24
    1ed2:	29 f0       	breq	.+10     	; 0x1ede <xTaskResumeAll+0xe2>
    1ed4:	69 d8       	rcall	.-3886   	; 0xfa8 <vPortYield>
    1ed6:	81 e0       	ldi	r24, 0x01	; 1
    1ed8:	03 c0       	rjmp	.+6      	; 0x1ee0 <xTaskResumeAll+0xe4>
    1eda:	80 e0       	ldi	r24, 0x00	; 0
    1edc:	01 c0       	rjmp	.+2      	; 0x1ee0 <xTaskResumeAll+0xe4>
    1ede:	80 e0       	ldi	r24, 0x00	; 0
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63
    1ee4:	df 91       	pop	r29
    1ee6:	cf 91       	pop	r28
    1ee8:	1f 91       	pop	r17
    1eea:	0f 91       	pop	r16
    1eec:	ff 90       	pop	r15
    1eee:	ef 90       	pop	r14
    1ef0:	df 90       	pop	r13
    1ef2:	08 95       	ret

00001ef4 <vTaskSwitchContext>:
    1ef4:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    1ef8:	88 23       	and	r24, r24
    1efa:	21 f0       	breq	.+8      	; 0x1f04 <vTaskSwitchContext+0x10>
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <xYieldPending>
    1f02:	08 95       	ret
    1f04:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <xYieldPending>
    1f08:	a0 91 1e 03 	lds	r26, 0x031E	; 0x80031e <pxCurrentTCB>
    1f0c:	b0 91 1f 03 	lds	r27, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1f10:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    1f14:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1f18:	2d 91       	ld	r18, X+
    1f1a:	3c 91       	ld	r19, X
    1f1c:	87 89       	ldd	r24, Z+23	; 0x17
    1f1e:	90 8d       	ldd	r25, Z+24	; 0x18
    1f20:	82 17       	cp	r24, r18
    1f22:	93 07       	cpc	r25, r19
    1f24:	60 f0       	brcs	.+24     	; 0x1f3e <vTaskSwitchContext+0x4a>
    1f26:	60 91 1e 03 	lds	r22, 0x031E	; 0x80031e <pxCurrentTCB>
    1f2a:	70 91 1f 03 	lds	r23, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1f2e:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <pxCurrentTCB>
    1f32:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    1f36:	67 5e       	subi	r22, 0xE7	; 231
    1f38:	7f 4f       	sbci	r23, 0xFF	; 255
    1f3a:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vApplicationStackOverflowHook>
    1f3e:	20 91 c4 02 	lds	r18, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    1f42:	82 2f       	mov	r24, r18
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	fc 01       	movw	r30, r24
    1f48:	ee 0f       	add	r30, r30
    1f4a:	ff 1f       	adc	r31, r31
    1f4c:	ee 0f       	add	r30, r30
    1f4e:	ff 1f       	adc	r31, r31
    1f50:	ee 0f       	add	r30, r30
    1f52:	ff 1f       	adc	r31, r31
    1f54:	e8 0f       	add	r30, r24
    1f56:	f9 1f       	adc	r31, r25
    1f58:	e6 50       	subi	r30, 0x06	; 6
    1f5a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f5c:	30 81       	ld	r19, Z
    1f5e:	31 11       	cpse	r19, r1
    1f60:	11 c0       	rjmp	.+34     	; 0x1f84 <vTaskSwitchContext+0x90>
    1f62:	21 50       	subi	r18, 0x01	; 1
    1f64:	82 2f       	mov	r24, r18
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	fc 01       	movw	r30, r24
    1f6a:	ee 0f       	add	r30, r30
    1f6c:	ff 1f       	adc	r31, r31
    1f6e:	ee 0f       	add	r30, r30
    1f70:	ff 1f       	adc	r31, r31
    1f72:	ee 0f       	add	r30, r30
    1f74:	ff 1f       	adc	r31, r31
    1f76:	e8 0f       	add	r30, r24
    1f78:	f9 1f       	adc	r31, r25
    1f7a:	e6 50       	subi	r30, 0x06	; 6
    1f7c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f7e:	30 81       	ld	r19, Z
    1f80:	33 23       	and	r19, r19
    1f82:	79 f3       	breq	.-34     	; 0x1f62 <vTaskSwitchContext+0x6e>
    1f84:	ac 01       	movw	r20, r24
    1f86:	44 0f       	add	r20, r20
    1f88:	55 1f       	adc	r21, r21
    1f8a:	44 0f       	add	r20, r20
    1f8c:	55 1f       	adc	r21, r21
    1f8e:	44 0f       	add	r20, r20
    1f90:	55 1f       	adc	r21, r21
    1f92:	48 0f       	add	r20, r24
    1f94:	59 1f       	adc	r21, r25
    1f96:	da 01       	movw	r26, r20
    1f98:	a6 50       	subi	r26, 0x06	; 6
    1f9a:	bd 4f       	sbci	r27, 0xFD	; 253
    1f9c:	11 96       	adiw	r26, 0x01	; 1
    1f9e:	ed 91       	ld	r30, X+
    1fa0:	fc 91       	ld	r31, X
    1fa2:	12 97       	sbiw	r26, 0x02	; 2
    1fa4:	02 80       	ldd	r0, Z+2	; 0x02
    1fa6:	f3 81       	ldd	r31, Z+3	; 0x03
    1fa8:	e0 2d       	mov	r30, r0
    1faa:	12 96       	adiw	r26, 0x02	; 2
    1fac:	fc 93       	st	X, r31
    1fae:	ee 93       	st	-X, r30
    1fb0:	11 97       	sbiw	r26, 0x01	; 1
    1fb2:	43 50       	subi	r20, 0x03	; 3
    1fb4:	5d 4f       	sbci	r21, 0xFD	; 253
    1fb6:	e4 17       	cp	r30, r20
    1fb8:	f5 07       	cpc	r31, r21
    1fba:	29 f4       	brne	.+10     	; 0x1fc6 <vTaskSwitchContext+0xd2>
    1fbc:	42 81       	ldd	r20, Z+2	; 0x02
    1fbe:	53 81       	ldd	r21, Z+3	; 0x03
    1fc0:	fd 01       	movw	r30, r26
    1fc2:	52 83       	std	Z+2, r21	; 0x02
    1fc4:	41 83       	std	Z+1, r20	; 0x01
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	ee 0f       	add	r30, r30
    1fca:	ff 1f       	adc	r31, r31
    1fcc:	ee 0f       	add	r30, r30
    1fce:	ff 1f       	adc	r31, r31
    1fd0:	ee 0f       	add	r30, r30
    1fd2:	ff 1f       	adc	r31, r31
    1fd4:	8e 0f       	add	r24, r30
    1fd6:	9f 1f       	adc	r25, r31
    1fd8:	fc 01       	movw	r30, r24
    1fda:	e6 50       	subi	r30, 0x06	; 6
    1fdc:	fd 4f       	sbci	r31, 0xFD	; 253
    1fde:	01 80       	ldd	r0, Z+1	; 0x01
    1fe0:	f2 81       	ldd	r31, Z+2	; 0x02
    1fe2:	e0 2d       	mov	r30, r0
    1fe4:	86 81       	ldd	r24, Z+6	; 0x06
    1fe6:	97 81       	ldd	r25, Z+7	; 0x07
    1fe8:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <pxCurrentTCB+0x1>
    1fec:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <pxCurrentTCB>
    1ff0:	20 93 c4 02 	sts	0x02C4, r18	; 0x8002c4 <uxTopReadyPriority>
    1ff4:	08 95       	ret

00001ff6 <vTaskPlaceOnEventList>:
    1ff6:	cf 93       	push	r28
    1ff8:	df 93       	push	r29
    1ffa:	eb 01       	movw	r28, r22
    1ffc:	60 91 1e 03 	lds	r22, 0x031E	; 0x80031e <pxCurrentTCB>
    2000:	70 91 1f 03 	lds	r23, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    2004:	64 5f       	subi	r22, 0xF4	; 244
    2006:	7f 4f       	sbci	r23, 0xFF	; 255
    2008:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    200c:	61 e0       	ldi	r22, 0x01	; 1
    200e:	ce 01       	movw	r24, r28
    2010:	a1 dc       	rcall	.-1726   	; 0x1954 <prvAddCurrentTaskToDelayedList>
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	08 95       	ret

00002018 <xTaskRemoveFromEventList>:
    2018:	0f 93       	push	r16
    201a:	1f 93       	push	r17
    201c:	cf 93       	push	r28
    201e:	df 93       	push	r29
    2020:	dc 01       	movw	r26, r24
    2022:	15 96       	adiw	r26, 0x05	; 5
    2024:	ed 91       	ld	r30, X+
    2026:	fc 91       	ld	r31, X
    2028:	16 97       	sbiw	r26, 0x06	; 6
    202a:	c6 81       	ldd	r28, Z+6	; 0x06
    202c:	d7 81       	ldd	r29, Z+7	; 0x07
    202e:	8e 01       	movw	r16, r28
    2030:	04 5f       	subi	r16, 0xF4	; 244
    2032:	1f 4f       	sbci	r17, 0xFF	; 255
    2034:	c8 01       	movw	r24, r16
    2036:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    203a:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <uxSchedulerSuspended>
    203e:	81 11       	cpse	r24, r1
    2040:	1c c0       	rjmp	.+56     	; 0x207a <xTaskRemoveFromEventList+0x62>
    2042:	0a 50       	subi	r16, 0x0A	; 10
    2044:	11 09       	sbc	r17, r1
    2046:	c8 01       	movw	r24, r16
    2048:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    204c:	8e 89       	ldd	r24, Y+22	; 0x16
    204e:	90 91 c4 02 	lds	r25, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    2052:	98 17       	cp	r25, r24
    2054:	10 f4       	brcc	.+4      	; 0x205a <xTaskRemoveFromEventList+0x42>
    2056:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <uxTopReadyPriority>
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	9c 01       	movw	r18, r24
    205e:	22 0f       	add	r18, r18
    2060:	33 1f       	adc	r19, r19
    2062:	22 0f       	add	r18, r18
    2064:	33 1f       	adc	r19, r19
    2066:	22 0f       	add	r18, r18
    2068:	33 1f       	adc	r19, r19
    206a:	82 0f       	add	r24, r18
    206c:	93 1f       	adc	r25, r19
    206e:	b8 01       	movw	r22, r16
    2070:	86 50       	subi	r24, 0x06	; 6
    2072:	9d 4f       	sbci	r25, 0xFD	; 253
    2074:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2078:	05 c0       	rjmp	.+10     	; 0x2084 <xTaskRemoveFromEventList+0x6c>
    207a:	b8 01       	movw	r22, r16
    207c:	8b ed       	ldi	r24, 0xDB	; 219
    207e:	92 e0       	ldi	r25, 0x02	; 2
    2080:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2084:	e0 91 1e 03 	lds	r30, 0x031E	; 0x80031e <pxCurrentTCB>
    2088:	f0 91 1f 03 	lds	r31, 0x031F	; 0x80031f <pxCurrentTCB+0x1>
    208c:	9e 89       	ldd	r25, Y+22	; 0x16
    208e:	86 89       	ldd	r24, Z+22	; 0x16
    2090:	89 17       	cp	r24, r25
    2092:	20 f4       	brcc	.+8      	; 0x209c <xTaskRemoveFromEventList+0x84>
    2094:	81 e0       	ldi	r24, 0x01	; 1
    2096:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <xYieldPending>
    209a:	01 c0       	rjmp	.+2      	; 0x209e <xTaskRemoveFromEventList+0x86>
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
    20a2:	1f 91       	pop	r17
    20a4:	0f 91       	pop	r16
    20a6:	08 95       	ret

000020a8 <vTaskSetTimeOutState>:
    20a8:	20 91 c0 02 	lds	r18, 0x02C0	; 0x8002c0 <xNumOfOverflows>
    20ac:	fc 01       	movw	r30, r24
    20ae:	20 83       	st	Z, r18
    20b0:	20 91 c5 02 	lds	r18, 0x02C5	; 0x8002c5 <xTickCount>
    20b4:	30 91 c6 02 	lds	r19, 0x02C6	; 0x8002c6 <xTickCount+0x1>
    20b8:	32 83       	std	Z+2, r19	; 0x02
    20ba:	21 83       	std	Z+1, r18	; 0x01
    20bc:	08 95       	ret

000020be <xTaskCheckForTimeOut>:
    20be:	0f b6       	in	r0, 0x3f	; 63
    20c0:	f8 94       	cli
    20c2:	0f 92       	push	r0
    20c4:	40 91 c5 02 	lds	r20, 0x02C5	; 0x8002c5 <xTickCount>
    20c8:	50 91 c6 02 	lds	r21, 0x02C6	; 0x8002c6 <xTickCount+0x1>
    20cc:	db 01       	movw	r26, r22
    20ce:	2d 91       	ld	r18, X+
    20d0:	3c 91       	ld	r19, X
    20d2:	2f 3f       	cpi	r18, 0xFF	; 255
    20d4:	bf ef       	ldi	r27, 0xFF	; 255
    20d6:	3b 07       	cpc	r19, r27
    20d8:	11 f1       	breq	.+68     	; 0x211e <xTaskCheckForTimeOut+0x60>
    20da:	e0 91 c0 02 	lds	r30, 0x02C0	; 0x8002c0 <xNumOfOverflows>
    20de:	dc 01       	movw	r26, r24
    20e0:	fc 91       	ld	r31, X
    20e2:	fe 17       	cp	r31, r30
    20e4:	39 f0       	breq	.+14     	; 0x20f4 <xTaskCheckForTimeOut+0x36>
    20e6:	11 96       	adiw	r26, 0x01	; 1
    20e8:	ed 91       	ld	r30, X+
    20ea:	fc 91       	ld	r31, X
    20ec:	12 97       	sbiw	r26, 0x02	; 2
    20ee:	4e 17       	cp	r20, r30
    20f0:	5f 07       	cpc	r21, r31
    20f2:	b8 f4       	brcc	.+46     	; 0x2122 <xTaskCheckForTimeOut+0x64>
    20f4:	dc 01       	movw	r26, r24
    20f6:	11 96       	adiw	r26, 0x01	; 1
    20f8:	ed 91       	ld	r30, X+
    20fa:	fc 91       	ld	r31, X
    20fc:	12 97       	sbiw	r26, 0x02	; 2
    20fe:	da 01       	movw	r26, r20
    2100:	ae 1b       	sub	r26, r30
    2102:	bf 0b       	sbc	r27, r31
    2104:	a2 17       	cp	r26, r18
    2106:	b3 07       	cpc	r27, r19
    2108:	70 f4       	brcc	.+28     	; 0x2126 <xTaskCheckForTimeOut+0x68>
    210a:	db 01       	movw	r26, r22
    210c:	e4 1b       	sub	r30, r20
    210e:	f5 0b       	sbc	r31, r21
    2110:	2e 0f       	add	r18, r30
    2112:	3f 1f       	adc	r19, r31
    2114:	2d 93       	st	X+, r18
    2116:	3c 93       	st	X, r19
    2118:	c7 df       	rcall	.-114    	; 0x20a8 <vTaskSetTimeOutState>
    211a:	80 e0       	ldi	r24, 0x00	; 0
    211c:	05 c0       	rjmp	.+10     	; 0x2128 <xTaskCheckForTimeOut+0x6a>
    211e:	80 e0       	ldi	r24, 0x00	; 0
    2120:	03 c0       	rjmp	.+6      	; 0x2128 <xTaskCheckForTimeOut+0x6a>
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	01 c0       	rjmp	.+2      	; 0x2128 <xTaskCheckForTimeOut+0x6a>
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	0f 90       	pop	r0
    212a:	0f be       	out	0x3f, r0	; 63
    212c:	08 95       	ret

0000212e <vTaskMissedYield>:
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <xYieldPending>
    2134:	08 95       	ret

00002136 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2136:	0f 93       	push	r16
    2138:	1f 93       	push	r17
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2140:	89 2b       	or	r24, r25
    2142:	79 f1       	breq	.+94     	; 0x21a2 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2144:	82 a1       	ldd	r24, Z+34	; 0x22
    2146:	81 50       	subi	r24, 0x01	; 1
    2148:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    214a:	26 89       	ldd	r18, Z+22	; 0x16
    214c:	91 a1       	ldd	r25, Z+33	; 0x21
    214e:	29 17       	cp	r18, r25
    2150:	51 f1       	breq	.+84     	; 0x21a6 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2152:	81 11       	cpse	r24, r1
    2154:	2a c0       	rjmp	.+84     	; 0x21aa <xTaskPriorityDisinherit+0x74>
    2156:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2158:	8f 01       	movw	r16, r30
    215a:	0e 5f       	subi	r16, 0xFE	; 254
    215c:	1f 4f       	sbci	r17, 0xFF	; 255
    215e:	c8 01       	movw	r24, r16
    2160:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2164:	89 a1       	ldd	r24, Y+33	; 0x21
    2166:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2168:	24 e0       	ldi	r18, 0x04	; 4
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	28 1b       	sub	r18, r24
    216e:	31 09       	sbc	r19, r1
    2170:	3d 87       	std	Y+13, r19	; 0x0d
    2172:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2174:	90 91 c4 02 	lds	r25, 0x02C4	; 0x8002c4 <uxTopReadyPriority>
    2178:	98 17       	cp	r25, r24
    217a:	10 f4       	brcc	.+4      	; 0x2180 <xTaskPriorityDisinherit+0x4a>
    217c:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <uxTopReadyPriority>
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	9c 01       	movw	r18, r24
    2184:	22 0f       	add	r18, r18
    2186:	33 1f       	adc	r19, r19
    2188:	22 0f       	add	r18, r18
    218a:	33 1f       	adc	r19, r19
    218c:	22 0f       	add	r18, r18
    218e:	33 1f       	adc	r19, r19
    2190:	82 0f       	add	r24, r18
    2192:	93 1f       	adc	r25, r19
    2194:	b8 01       	movw	r22, r16
    2196:	86 50       	subi	r24, 0x06	; 6
    2198:	9d 4f       	sbci	r25, 0xFD	; 253
    219a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    219e:	81 e0       	ldi	r24, 0x01	; 1
    21a0:	05 c0       	rjmp	.+10     	; 0x21ac <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    21a2:	80 e0       	ldi	r24, 0x00	; 0
    21a4:	03 c0       	rjmp	.+6      	; 0x21ac <xTaskPriorityDisinherit+0x76>
    21a6:	80 e0       	ldi	r24, 0x00	; 0
    21a8:	01 c0       	rjmp	.+2      	; 0x21ac <xTaskPriorityDisinherit+0x76>
    21aa:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    21ac:	df 91       	pop	r29
    21ae:	cf 91       	pop	r28
    21b0:	1f 91       	pop	r17
    21b2:	0f 91       	pop	r16
    21b4:	08 95       	ret

000021b6 <__subsf3>:
    21b6:	50 58       	subi	r21, 0x80	; 128

000021b8 <__addsf3>:
    21b8:	bb 27       	eor	r27, r27
    21ba:	aa 27       	eor	r26, r26
    21bc:	0e d0       	rcall	.+28     	; 0x21da <__addsf3x>
    21be:	e5 c0       	rjmp	.+458    	; 0x238a <__fp_round>
    21c0:	d6 d0       	rcall	.+428    	; 0x236e <__fp_pscA>
    21c2:	30 f0       	brcs	.+12     	; 0x21d0 <__addsf3+0x18>
    21c4:	db d0       	rcall	.+438    	; 0x237c <__fp_pscB>
    21c6:	20 f0       	brcs	.+8      	; 0x21d0 <__addsf3+0x18>
    21c8:	31 f4       	brne	.+12     	; 0x21d6 <__addsf3+0x1e>
    21ca:	9f 3f       	cpi	r25, 0xFF	; 255
    21cc:	11 f4       	brne	.+4      	; 0x21d2 <__addsf3+0x1a>
    21ce:	1e f4       	brtc	.+6      	; 0x21d6 <__addsf3+0x1e>
    21d0:	cb c0       	rjmp	.+406    	; 0x2368 <__fp_nan>
    21d2:	0e f4       	brtc	.+2      	; 0x21d6 <__addsf3+0x1e>
    21d4:	e0 95       	com	r30
    21d6:	e7 fb       	bst	r30, 7
    21d8:	c1 c0       	rjmp	.+386    	; 0x235c <__fp_inf>

000021da <__addsf3x>:
    21da:	e9 2f       	mov	r30, r25
    21dc:	e7 d0       	rcall	.+462    	; 0x23ac <__fp_split3>
    21de:	80 f3       	brcs	.-32     	; 0x21c0 <__addsf3+0x8>
    21e0:	ba 17       	cp	r27, r26
    21e2:	62 07       	cpc	r22, r18
    21e4:	73 07       	cpc	r23, r19
    21e6:	84 07       	cpc	r24, r20
    21e8:	95 07       	cpc	r25, r21
    21ea:	18 f0       	brcs	.+6      	; 0x21f2 <__addsf3x+0x18>
    21ec:	71 f4       	brne	.+28     	; 0x220a <__stack+0xb>
    21ee:	9e f5       	brtc	.+102    	; 0x2256 <__stack+0x57>
    21f0:	ff c0       	rjmp	.+510    	; 0x23f0 <__fp_zero>
    21f2:	0e f4       	brtc	.+2      	; 0x21f6 <__addsf3x+0x1c>
    21f4:	e0 95       	com	r30
    21f6:	0b 2e       	mov	r0, r27
    21f8:	ba 2f       	mov	r27, r26
    21fa:	a0 2d       	mov	r26, r0
    21fc:	0b 01       	movw	r0, r22
    21fe:	b9 01       	movw	r22, r18
    2200:	90 01       	movw	r18, r0
    2202:	0c 01       	movw	r0, r24
    2204:	ca 01       	movw	r24, r20
    2206:	a0 01       	movw	r20, r0
    2208:	11 24       	eor	r1, r1
    220a:	ff 27       	eor	r31, r31
    220c:	59 1b       	sub	r21, r25
    220e:	99 f0       	breq	.+38     	; 0x2236 <__stack+0x37>
    2210:	59 3f       	cpi	r21, 0xF9	; 249
    2212:	50 f4       	brcc	.+20     	; 0x2228 <__stack+0x29>
    2214:	50 3e       	cpi	r21, 0xE0	; 224
    2216:	68 f1       	brcs	.+90     	; 0x2272 <__stack+0x73>
    2218:	1a 16       	cp	r1, r26
    221a:	f0 40       	sbci	r31, 0x00	; 0
    221c:	a2 2f       	mov	r26, r18
    221e:	23 2f       	mov	r18, r19
    2220:	34 2f       	mov	r19, r20
    2222:	44 27       	eor	r20, r20
    2224:	58 5f       	subi	r21, 0xF8	; 248
    2226:	f3 cf       	rjmp	.-26     	; 0x220e <__stack+0xf>
    2228:	46 95       	lsr	r20
    222a:	37 95       	ror	r19
    222c:	27 95       	ror	r18
    222e:	a7 95       	ror	r26
    2230:	f0 40       	sbci	r31, 0x00	; 0
    2232:	53 95       	inc	r21
    2234:	c9 f7       	brne	.-14     	; 0x2228 <__stack+0x29>
    2236:	7e f4       	brtc	.+30     	; 0x2256 <__stack+0x57>
    2238:	1f 16       	cp	r1, r31
    223a:	ba 0b       	sbc	r27, r26
    223c:	62 0b       	sbc	r22, r18
    223e:	73 0b       	sbc	r23, r19
    2240:	84 0b       	sbc	r24, r20
    2242:	ba f0       	brmi	.+46     	; 0x2272 <__stack+0x73>
    2244:	91 50       	subi	r25, 0x01	; 1
    2246:	a1 f0       	breq	.+40     	; 0x2270 <__stack+0x71>
    2248:	ff 0f       	add	r31, r31
    224a:	bb 1f       	adc	r27, r27
    224c:	66 1f       	adc	r22, r22
    224e:	77 1f       	adc	r23, r23
    2250:	88 1f       	adc	r24, r24
    2252:	c2 f7       	brpl	.-16     	; 0x2244 <__stack+0x45>
    2254:	0e c0       	rjmp	.+28     	; 0x2272 <__stack+0x73>
    2256:	ba 0f       	add	r27, r26
    2258:	62 1f       	adc	r22, r18
    225a:	73 1f       	adc	r23, r19
    225c:	84 1f       	adc	r24, r20
    225e:	48 f4       	brcc	.+18     	; 0x2272 <__stack+0x73>
    2260:	87 95       	ror	r24
    2262:	77 95       	ror	r23
    2264:	67 95       	ror	r22
    2266:	b7 95       	ror	r27
    2268:	f7 95       	ror	r31
    226a:	9e 3f       	cpi	r25, 0xFE	; 254
    226c:	08 f0       	brcs	.+2      	; 0x2270 <__stack+0x71>
    226e:	b3 cf       	rjmp	.-154    	; 0x21d6 <__addsf3+0x1e>
    2270:	93 95       	inc	r25
    2272:	88 0f       	add	r24, r24
    2274:	08 f0       	brcs	.+2      	; 0x2278 <__stack+0x79>
    2276:	99 27       	eor	r25, r25
    2278:	ee 0f       	add	r30, r30
    227a:	97 95       	ror	r25
    227c:	87 95       	ror	r24
    227e:	08 95       	ret

00002280 <__fixsfsi>:
    2280:	04 d0       	rcall	.+8      	; 0x228a <__fixunssfsi>
    2282:	68 94       	set
    2284:	b1 11       	cpse	r27, r1
    2286:	b5 c0       	rjmp	.+362    	; 0x23f2 <__fp_szero>
    2288:	08 95       	ret

0000228a <__fixunssfsi>:
    228a:	98 d0       	rcall	.+304    	; 0x23bc <__fp_splitA>
    228c:	88 f0       	brcs	.+34     	; 0x22b0 <__fixunssfsi+0x26>
    228e:	9f 57       	subi	r25, 0x7F	; 127
    2290:	90 f0       	brcs	.+36     	; 0x22b6 <__fixunssfsi+0x2c>
    2292:	b9 2f       	mov	r27, r25
    2294:	99 27       	eor	r25, r25
    2296:	b7 51       	subi	r27, 0x17	; 23
    2298:	a0 f0       	brcs	.+40     	; 0x22c2 <__fixunssfsi+0x38>
    229a:	d1 f0       	breq	.+52     	; 0x22d0 <__fixunssfsi+0x46>
    229c:	66 0f       	add	r22, r22
    229e:	77 1f       	adc	r23, r23
    22a0:	88 1f       	adc	r24, r24
    22a2:	99 1f       	adc	r25, r25
    22a4:	1a f0       	brmi	.+6      	; 0x22ac <__fixunssfsi+0x22>
    22a6:	ba 95       	dec	r27
    22a8:	c9 f7       	brne	.-14     	; 0x229c <__fixunssfsi+0x12>
    22aa:	12 c0       	rjmp	.+36     	; 0x22d0 <__fixunssfsi+0x46>
    22ac:	b1 30       	cpi	r27, 0x01	; 1
    22ae:	81 f0       	breq	.+32     	; 0x22d0 <__fixunssfsi+0x46>
    22b0:	9f d0       	rcall	.+318    	; 0x23f0 <__fp_zero>
    22b2:	b1 e0       	ldi	r27, 0x01	; 1
    22b4:	08 95       	ret
    22b6:	9c c0       	rjmp	.+312    	; 0x23f0 <__fp_zero>
    22b8:	67 2f       	mov	r22, r23
    22ba:	78 2f       	mov	r23, r24
    22bc:	88 27       	eor	r24, r24
    22be:	b8 5f       	subi	r27, 0xF8	; 248
    22c0:	39 f0       	breq	.+14     	; 0x22d0 <__fixunssfsi+0x46>
    22c2:	b9 3f       	cpi	r27, 0xF9	; 249
    22c4:	cc f3       	brlt	.-14     	; 0x22b8 <__fixunssfsi+0x2e>
    22c6:	86 95       	lsr	r24
    22c8:	77 95       	ror	r23
    22ca:	67 95       	ror	r22
    22cc:	b3 95       	inc	r27
    22ce:	d9 f7       	brne	.-10     	; 0x22c6 <__fixunssfsi+0x3c>
    22d0:	3e f4       	brtc	.+14     	; 0x22e0 <__fixunssfsi+0x56>
    22d2:	90 95       	com	r25
    22d4:	80 95       	com	r24
    22d6:	70 95       	com	r23
    22d8:	61 95       	neg	r22
    22da:	7f 4f       	sbci	r23, 0xFF	; 255
    22dc:	8f 4f       	sbci	r24, 0xFF	; 255
    22de:	9f 4f       	sbci	r25, 0xFF	; 255
    22e0:	08 95       	ret

000022e2 <__floatunsisf>:
    22e2:	e8 94       	clt
    22e4:	09 c0       	rjmp	.+18     	; 0x22f8 <__floatsisf+0x12>

000022e6 <__floatsisf>:
    22e6:	97 fb       	bst	r25, 7
    22e8:	3e f4       	brtc	.+14     	; 0x22f8 <__floatsisf+0x12>
    22ea:	90 95       	com	r25
    22ec:	80 95       	com	r24
    22ee:	70 95       	com	r23
    22f0:	61 95       	neg	r22
    22f2:	7f 4f       	sbci	r23, 0xFF	; 255
    22f4:	8f 4f       	sbci	r24, 0xFF	; 255
    22f6:	9f 4f       	sbci	r25, 0xFF	; 255
    22f8:	99 23       	and	r25, r25
    22fa:	a9 f0       	breq	.+42     	; 0x2326 <__floatsisf+0x40>
    22fc:	f9 2f       	mov	r31, r25
    22fe:	96 e9       	ldi	r25, 0x96	; 150
    2300:	bb 27       	eor	r27, r27
    2302:	93 95       	inc	r25
    2304:	f6 95       	lsr	r31
    2306:	87 95       	ror	r24
    2308:	77 95       	ror	r23
    230a:	67 95       	ror	r22
    230c:	b7 95       	ror	r27
    230e:	f1 11       	cpse	r31, r1
    2310:	f8 cf       	rjmp	.-16     	; 0x2302 <__floatsisf+0x1c>
    2312:	fa f4       	brpl	.+62     	; 0x2352 <__floatsisf+0x6c>
    2314:	bb 0f       	add	r27, r27
    2316:	11 f4       	brne	.+4      	; 0x231c <__floatsisf+0x36>
    2318:	60 ff       	sbrs	r22, 0
    231a:	1b c0       	rjmp	.+54     	; 0x2352 <__floatsisf+0x6c>
    231c:	6f 5f       	subi	r22, 0xFF	; 255
    231e:	7f 4f       	sbci	r23, 0xFF	; 255
    2320:	8f 4f       	sbci	r24, 0xFF	; 255
    2322:	9f 4f       	sbci	r25, 0xFF	; 255
    2324:	16 c0       	rjmp	.+44     	; 0x2352 <__floatsisf+0x6c>
    2326:	88 23       	and	r24, r24
    2328:	11 f0       	breq	.+4      	; 0x232e <__floatsisf+0x48>
    232a:	96 e9       	ldi	r25, 0x96	; 150
    232c:	11 c0       	rjmp	.+34     	; 0x2350 <__floatsisf+0x6a>
    232e:	77 23       	and	r23, r23
    2330:	21 f0       	breq	.+8      	; 0x233a <__floatsisf+0x54>
    2332:	9e e8       	ldi	r25, 0x8E	; 142
    2334:	87 2f       	mov	r24, r23
    2336:	76 2f       	mov	r23, r22
    2338:	05 c0       	rjmp	.+10     	; 0x2344 <__floatsisf+0x5e>
    233a:	66 23       	and	r22, r22
    233c:	71 f0       	breq	.+28     	; 0x235a <__floatsisf+0x74>
    233e:	96 e8       	ldi	r25, 0x86	; 134
    2340:	86 2f       	mov	r24, r22
    2342:	70 e0       	ldi	r23, 0x00	; 0
    2344:	60 e0       	ldi	r22, 0x00	; 0
    2346:	2a f0       	brmi	.+10     	; 0x2352 <__floatsisf+0x6c>
    2348:	9a 95       	dec	r25
    234a:	66 0f       	add	r22, r22
    234c:	77 1f       	adc	r23, r23
    234e:	88 1f       	adc	r24, r24
    2350:	da f7       	brpl	.-10     	; 0x2348 <__floatsisf+0x62>
    2352:	88 0f       	add	r24, r24
    2354:	96 95       	lsr	r25
    2356:	87 95       	ror	r24
    2358:	97 f9       	bld	r25, 7
    235a:	08 95       	ret

0000235c <__fp_inf>:
    235c:	97 f9       	bld	r25, 7
    235e:	9f 67       	ori	r25, 0x7F	; 127
    2360:	80 e8       	ldi	r24, 0x80	; 128
    2362:	70 e0       	ldi	r23, 0x00	; 0
    2364:	60 e0       	ldi	r22, 0x00	; 0
    2366:	08 95       	ret

00002368 <__fp_nan>:
    2368:	9f ef       	ldi	r25, 0xFF	; 255
    236a:	80 ec       	ldi	r24, 0xC0	; 192
    236c:	08 95       	ret

0000236e <__fp_pscA>:
    236e:	00 24       	eor	r0, r0
    2370:	0a 94       	dec	r0
    2372:	16 16       	cp	r1, r22
    2374:	17 06       	cpc	r1, r23
    2376:	18 06       	cpc	r1, r24
    2378:	09 06       	cpc	r0, r25
    237a:	08 95       	ret

0000237c <__fp_pscB>:
    237c:	00 24       	eor	r0, r0
    237e:	0a 94       	dec	r0
    2380:	12 16       	cp	r1, r18
    2382:	13 06       	cpc	r1, r19
    2384:	14 06       	cpc	r1, r20
    2386:	05 06       	cpc	r0, r21
    2388:	08 95       	ret

0000238a <__fp_round>:
    238a:	09 2e       	mov	r0, r25
    238c:	03 94       	inc	r0
    238e:	00 0c       	add	r0, r0
    2390:	11 f4       	brne	.+4      	; 0x2396 <__fp_round+0xc>
    2392:	88 23       	and	r24, r24
    2394:	52 f0       	brmi	.+20     	; 0x23aa <__fp_round+0x20>
    2396:	bb 0f       	add	r27, r27
    2398:	40 f4       	brcc	.+16     	; 0x23aa <__fp_round+0x20>
    239a:	bf 2b       	or	r27, r31
    239c:	11 f4       	brne	.+4      	; 0x23a2 <__fp_round+0x18>
    239e:	60 ff       	sbrs	r22, 0
    23a0:	04 c0       	rjmp	.+8      	; 0x23aa <__fp_round+0x20>
    23a2:	6f 5f       	subi	r22, 0xFF	; 255
    23a4:	7f 4f       	sbci	r23, 0xFF	; 255
    23a6:	8f 4f       	sbci	r24, 0xFF	; 255
    23a8:	9f 4f       	sbci	r25, 0xFF	; 255
    23aa:	08 95       	ret

000023ac <__fp_split3>:
    23ac:	57 fd       	sbrc	r21, 7
    23ae:	90 58       	subi	r25, 0x80	; 128
    23b0:	44 0f       	add	r20, r20
    23b2:	55 1f       	adc	r21, r21
    23b4:	59 f0       	breq	.+22     	; 0x23cc <__fp_splitA+0x10>
    23b6:	5f 3f       	cpi	r21, 0xFF	; 255
    23b8:	71 f0       	breq	.+28     	; 0x23d6 <__fp_splitA+0x1a>
    23ba:	47 95       	ror	r20

000023bc <__fp_splitA>:
    23bc:	88 0f       	add	r24, r24
    23be:	97 fb       	bst	r25, 7
    23c0:	99 1f       	adc	r25, r25
    23c2:	61 f0       	breq	.+24     	; 0x23dc <__fp_splitA+0x20>
    23c4:	9f 3f       	cpi	r25, 0xFF	; 255
    23c6:	79 f0       	breq	.+30     	; 0x23e6 <__fp_splitA+0x2a>
    23c8:	87 95       	ror	r24
    23ca:	08 95       	ret
    23cc:	12 16       	cp	r1, r18
    23ce:	13 06       	cpc	r1, r19
    23d0:	14 06       	cpc	r1, r20
    23d2:	55 1f       	adc	r21, r21
    23d4:	f2 cf       	rjmp	.-28     	; 0x23ba <__fp_split3+0xe>
    23d6:	46 95       	lsr	r20
    23d8:	f1 df       	rcall	.-30     	; 0x23bc <__fp_splitA>
    23da:	08 c0       	rjmp	.+16     	; 0x23ec <__fp_splitA+0x30>
    23dc:	16 16       	cp	r1, r22
    23de:	17 06       	cpc	r1, r23
    23e0:	18 06       	cpc	r1, r24
    23e2:	99 1f       	adc	r25, r25
    23e4:	f1 cf       	rjmp	.-30     	; 0x23c8 <__fp_splitA+0xc>
    23e6:	86 95       	lsr	r24
    23e8:	71 05       	cpc	r23, r1
    23ea:	61 05       	cpc	r22, r1
    23ec:	08 94       	sec
    23ee:	08 95       	ret

000023f0 <__fp_zero>:
    23f0:	e8 94       	clt

000023f2 <__fp_szero>:
    23f2:	bb 27       	eor	r27, r27
    23f4:	66 27       	eor	r22, r22
    23f6:	77 27       	eor	r23, r23
    23f8:	cb 01       	movw	r24, r22
    23fa:	97 f9       	bld	r25, 7
    23fc:	08 95       	ret

000023fe <__mulsf3>:
    23fe:	0b d0       	rcall	.+22     	; 0x2416 <__mulsf3x>
    2400:	c4 cf       	rjmp	.-120    	; 0x238a <__fp_round>
    2402:	b5 df       	rcall	.-150    	; 0x236e <__fp_pscA>
    2404:	28 f0       	brcs	.+10     	; 0x2410 <__mulsf3+0x12>
    2406:	ba df       	rcall	.-140    	; 0x237c <__fp_pscB>
    2408:	18 f0       	brcs	.+6      	; 0x2410 <__mulsf3+0x12>
    240a:	95 23       	and	r25, r21
    240c:	09 f0       	breq	.+2      	; 0x2410 <__mulsf3+0x12>
    240e:	a6 cf       	rjmp	.-180    	; 0x235c <__fp_inf>
    2410:	ab cf       	rjmp	.-170    	; 0x2368 <__fp_nan>
    2412:	11 24       	eor	r1, r1
    2414:	ee cf       	rjmp	.-36     	; 0x23f2 <__fp_szero>

00002416 <__mulsf3x>:
    2416:	ca df       	rcall	.-108    	; 0x23ac <__fp_split3>
    2418:	a0 f3       	brcs	.-24     	; 0x2402 <__mulsf3+0x4>

0000241a <__mulsf3_pse>:
    241a:	95 9f       	mul	r25, r21
    241c:	d1 f3       	breq	.-12     	; 0x2412 <__mulsf3+0x14>
    241e:	95 0f       	add	r25, r21
    2420:	50 e0       	ldi	r21, 0x00	; 0
    2422:	55 1f       	adc	r21, r21
    2424:	62 9f       	mul	r22, r18
    2426:	f0 01       	movw	r30, r0
    2428:	72 9f       	mul	r23, r18
    242a:	bb 27       	eor	r27, r27
    242c:	f0 0d       	add	r31, r0
    242e:	b1 1d       	adc	r27, r1
    2430:	63 9f       	mul	r22, r19
    2432:	aa 27       	eor	r26, r26
    2434:	f0 0d       	add	r31, r0
    2436:	b1 1d       	adc	r27, r1
    2438:	aa 1f       	adc	r26, r26
    243a:	64 9f       	mul	r22, r20
    243c:	66 27       	eor	r22, r22
    243e:	b0 0d       	add	r27, r0
    2440:	a1 1d       	adc	r26, r1
    2442:	66 1f       	adc	r22, r22
    2444:	82 9f       	mul	r24, r18
    2446:	22 27       	eor	r18, r18
    2448:	b0 0d       	add	r27, r0
    244a:	a1 1d       	adc	r26, r1
    244c:	62 1f       	adc	r22, r18
    244e:	73 9f       	mul	r23, r19
    2450:	b0 0d       	add	r27, r0
    2452:	a1 1d       	adc	r26, r1
    2454:	62 1f       	adc	r22, r18
    2456:	83 9f       	mul	r24, r19
    2458:	a0 0d       	add	r26, r0
    245a:	61 1d       	adc	r22, r1
    245c:	22 1f       	adc	r18, r18
    245e:	74 9f       	mul	r23, r20
    2460:	33 27       	eor	r19, r19
    2462:	a0 0d       	add	r26, r0
    2464:	61 1d       	adc	r22, r1
    2466:	23 1f       	adc	r18, r19
    2468:	84 9f       	mul	r24, r20
    246a:	60 0d       	add	r22, r0
    246c:	21 1d       	adc	r18, r1
    246e:	82 2f       	mov	r24, r18
    2470:	76 2f       	mov	r23, r22
    2472:	6a 2f       	mov	r22, r26
    2474:	11 24       	eor	r1, r1
    2476:	9f 57       	subi	r25, 0x7F	; 127
    2478:	50 40       	sbci	r21, 0x00	; 0
    247a:	8a f0       	brmi	.+34     	; 0x249e <__mulsf3_pse+0x84>
    247c:	e1 f0       	breq	.+56     	; 0x24b6 <__mulsf3_pse+0x9c>
    247e:	88 23       	and	r24, r24
    2480:	4a f0       	brmi	.+18     	; 0x2494 <__mulsf3_pse+0x7a>
    2482:	ee 0f       	add	r30, r30
    2484:	ff 1f       	adc	r31, r31
    2486:	bb 1f       	adc	r27, r27
    2488:	66 1f       	adc	r22, r22
    248a:	77 1f       	adc	r23, r23
    248c:	88 1f       	adc	r24, r24
    248e:	91 50       	subi	r25, 0x01	; 1
    2490:	50 40       	sbci	r21, 0x00	; 0
    2492:	a9 f7       	brne	.-22     	; 0x247e <__mulsf3_pse+0x64>
    2494:	9e 3f       	cpi	r25, 0xFE	; 254
    2496:	51 05       	cpc	r21, r1
    2498:	70 f0       	brcs	.+28     	; 0x24b6 <__mulsf3_pse+0x9c>
    249a:	60 cf       	rjmp	.-320    	; 0x235c <__fp_inf>
    249c:	aa cf       	rjmp	.-172    	; 0x23f2 <__fp_szero>
    249e:	5f 3f       	cpi	r21, 0xFF	; 255
    24a0:	ec f3       	brlt	.-6      	; 0x249c <__mulsf3_pse+0x82>
    24a2:	98 3e       	cpi	r25, 0xE8	; 232
    24a4:	dc f3       	brlt	.-10     	; 0x249c <__mulsf3_pse+0x82>
    24a6:	86 95       	lsr	r24
    24a8:	77 95       	ror	r23
    24aa:	67 95       	ror	r22
    24ac:	b7 95       	ror	r27
    24ae:	f7 95       	ror	r31
    24b0:	e7 95       	ror	r30
    24b2:	9f 5f       	subi	r25, 0xFF	; 255
    24b4:	c1 f7       	brne	.-16     	; 0x24a6 <__mulsf3_pse+0x8c>
    24b6:	fe 2b       	or	r31, r30
    24b8:	88 0f       	add	r24, r24
    24ba:	91 1d       	adc	r25, r1
    24bc:	96 95       	lsr	r25
    24be:	87 95       	ror	r24
    24c0:	97 f9       	bld	r25, 7
    24c2:	08 95       	ret

000024c4 <__udivmodsi4>:
    24c4:	a1 e2       	ldi	r26, 0x21	; 33
    24c6:	1a 2e       	mov	r1, r26
    24c8:	aa 1b       	sub	r26, r26
    24ca:	bb 1b       	sub	r27, r27
    24cc:	fd 01       	movw	r30, r26
    24ce:	0d c0       	rjmp	.+26     	; 0x24ea <__udivmodsi4_ep>

000024d0 <__udivmodsi4_loop>:
    24d0:	aa 1f       	adc	r26, r26
    24d2:	bb 1f       	adc	r27, r27
    24d4:	ee 1f       	adc	r30, r30
    24d6:	ff 1f       	adc	r31, r31
    24d8:	a2 17       	cp	r26, r18
    24da:	b3 07       	cpc	r27, r19
    24dc:	e4 07       	cpc	r30, r20
    24de:	f5 07       	cpc	r31, r21
    24e0:	20 f0       	brcs	.+8      	; 0x24ea <__udivmodsi4_ep>
    24e2:	a2 1b       	sub	r26, r18
    24e4:	b3 0b       	sbc	r27, r19
    24e6:	e4 0b       	sbc	r30, r20
    24e8:	f5 0b       	sbc	r31, r21

000024ea <__udivmodsi4_ep>:
    24ea:	66 1f       	adc	r22, r22
    24ec:	77 1f       	adc	r23, r23
    24ee:	88 1f       	adc	r24, r24
    24f0:	99 1f       	adc	r25, r25
    24f2:	1a 94       	dec	r1
    24f4:	69 f7       	brne	.-38     	; 0x24d0 <__udivmodsi4_loop>
    24f6:	60 95       	com	r22
    24f8:	70 95       	com	r23
    24fa:	80 95       	com	r24
    24fc:	90 95       	com	r25
    24fe:	9b 01       	movw	r18, r22
    2500:	ac 01       	movw	r20, r24
    2502:	bd 01       	movw	r22, r26
    2504:	cf 01       	movw	r24, r30
    2506:	08 95       	ret

00002508 <__tablejump2__>:
    2508:	ee 0f       	add	r30, r30
    250a:	ff 1f       	adc	r31, r31
    250c:	88 1f       	adc	r24, r24
    250e:	8b bf       	out	0x3b, r24	; 59
    2510:	07 90       	elpm	r0, Z+
    2512:	f6 91       	elpm	r31, Z
    2514:	e0 2d       	mov	r30, r0
    2516:	19 94       	eijmp

00002518 <__umulhisi3>:
    2518:	a2 9f       	mul	r26, r18
    251a:	b0 01       	movw	r22, r0
    251c:	b3 9f       	mul	r27, r19
    251e:	c0 01       	movw	r24, r0
    2520:	a3 9f       	mul	r26, r19
    2522:	70 0d       	add	r23, r0
    2524:	81 1d       	adc	r24, r1
    2526:	11 24       	eor	r1, r1
    2528:	91 1d       	adc	r25, r1
    252a:	b2 9f       	mul	r27, r18
    252c:	70 0d       	add	r23, r0
    252e:	81 1d       	adc	r24, r1
    2530:	11 24       	eor	r1, r1
    2532:	91 1d       	adc	r25, r1
    2534:	08 95       	ret

00002536 <__muluhisi3>:
    2536:	f0 df       	rcall	.-32     	; 0x2518 <__umulhisi3>
    2538:	a5 9f       	mul	r26, r21
    253a:	90 0d       	add	r25, r0
    253c:	b4 9f       	mul	r27, r20
    253e:	90 0d       	add	r25, r0
    2540:	a4 9f       	mul	r26, r20
    2542:	80 0d       	add	r24, r0
    2544:	91 1d       	adc	r25, r1
    2546:	11 24       	eor	r1, r1
    2548:	08 95       	ret

0000254a <malloc>:
    254a:	0f 93       	push	r16
    254c:	1f 93       	push	r17
    254e:	cf 93       	push	r28
    2550:	df 93       	push	r29
    2552:	82 30       	cpi	r24, 0x02	; 2
    2554:	91 05       	cpc	r25, r1
    2556:	10 f4       	brcc	.+4      	; 0x255c <malloc+0x12>
    2558:	82 e0       	ldi	r24, 0x02	; 2
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <__flp>
    2560:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <__flp+0x1>
    2564:	20 e0       	ldi	r18, 0x00	; 0
    2566:	30 e0       	ldi	r19, 0x00	; 0
    2568:	a0 e0       	ldi	r26, 0x00	; 0
    256a:	b0 e0       	ldi	r27, 0x00	; 0
    256c:	30 97       	sbiw	r30, 0x00	; 0
    256e:	19 f1       	breq	.+70     	; 0x25b6 <malloc+0x6c>
    2570:	40 81       	ld	r20, Z
    2572:	51 81       	ldd	r21, Z+1	; 0x01
    2574:	02 81       	ldd	r16, Z+2	; 0x02
    2576:	13 81       	ldd	r17, Z+3	; 0x03
    2578:	48 17       	cp	r20, r24
    257a:	59 07       	cpc	r21, r25
    257c:	c8 f0       	brcs	.+50     	; 0x25b0 <malloc+0x66>
    257e:	84 17       	cp	r24, r20
    2580:	95 07       	cpc	r25, r21
    2582:	69 f4       	brne	.+26     	; 0x259e <malloc+0x54>
    2584:	10 97       	sbiw	r26, 0x00	; 0
    2586:	31 f0       	breq	.+12     	; 0x2594 <malloc+0x4a>
    2588:	12 96       	adiw	r26, 0x02	; 2
    258a:	0c 93       	st	X, r16
    258c:	12 97       	sbiw	r26, 0x02	; 2
    258e:	13 96       	adiw	r26, 0x03	; 3
    2590:	1c 93       	st	X, r17
    2592:	27 c0       	rjmp	.+78     	; 0x25e2 <malloc+0x98>
    2594:	00 93 c3 04 	sts	0x04C3, r16	; 0x8004c3 <__flp>
    2598:	10 93 c4 04 	sts	0x04C4, r17	; 0x8004c4 <__flp+0x1>
    259c:	22 c0       	rjmp	.+68     	; 0x25e2 <malloc+0x98>
    259e:	21 15       	cp	r18, r1
    25a0:	31 05       	cpc	r19, r1
    25a2:	19 f0       	breq	.+6      	; 0x25aa <malloc+0x60>
    25a4:	42 17       	cp	r20, r18
    25a6:	53 07       	cpc	r21, r19
    25a8:	18 f4       	brcc	.+6      	; 0x25b0 <malloc+0x66>
    25aa:	9a 01       	movw	r18, r20
    25ac:	bd 01       	movw	r22, r26
    25ae:	ef 01       	movw	r28, r30
    25b0:	df 01       	movw	r26, r30
    25b2:	f8 01       	movw	r30, r16
    25b4:	db cf       	rjmp	.-74     	; 0x256c <malloc+0x22>
    25b6:	21 15       	cp	r18, r1
    25b8:	31 05       	cpc	r19, r1
    25ba:	f9 f0       	breq	.+62     	; 0x25fa <malloc+0xb0>
    25bc:	28 1b       	sub	r18, r24
    25be:	39 0b       	sbc	r19, r25
    25c0:	24 30       	cpi	r18, 0x04	; 4
    25c2:	31 05       	cpc	r19, r1
    25c4:	80 f4       	brcc	.+32     	; 0x25e6 <malloc+0x9c>
    25c6:	8a 81       	ldd	r24, Y+2	; 0x02
    25c8:	9b 81       	ldd	r25, Y+3	; 0x03
    25ca:	61 15       	cp	r22, r1
    25cc:	71 05       	cpc	r23, r1
    25ce:	21 f0       	breq	.+8      	; 0x25d8 <malloc+0x8e>
    25d0:	fb 01       	movw	r30, r22
    25d2:	93 83       	std	Z+3, r25	; 0x03
    25d4:	82 83       	std	Z+2, r24	; 0x02
    25d6:	04 c0       	rjmp	.+8      	; 0x25e0 <malloc+0x96>
    25d8:	90 93 c4 04 	sts	0x04C4, r25	; 0x8004c4 <__flp+0x1>
    25dc:	80 93 c3 04 	sts	0x04C3, r24	; 0x8004c3 <__flp>
    25e0:	fe 01       	movw	r30, r28
    25e2:	32 96       	adiw	r30, 0x02	; 2
    25e4:	44 c0       	rjmp	.+136    	; 0x266e <malloc+0x124>
    25e6:	fe 01       	movw	r30, r28
    25e8:	e2 0f       	add	r30, r18
    25ea:	f3 1f       	adc	r31, r19
    25ec:	81 93       	st	Z+, r24
    25ee:	91 93       	st	Z+, r25
    25f0:	22 50       	subi	r18, 0x02	; 2
    25f2:	31 09       	sbc	r19, r1
    25f4:	39 83       	std	Y+1, r19	; 0x01
    25f6:	28 83       	st	Y, r18
    25f8:	3a c0       	rjmp	.+116    	; 0x266e <malloc+0x124>
    25fa:	20 91 c1 04 	lds	r18, 0x04C1	; 0x8004c1 <__brkval>
    25fe:	30 91 c2 04 	lds	r19, 0x04C2	; 0x8004c2 <__brkval+0x1>
    2602:	23 2b       	or	r18, r19
    2604:	41 f4       	brne	.+16     	; 0x2616 <malloc+0xcc>
    2606:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    260a:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    260e:	30 93 c2 04 	sts	0x04C2, r19	; 0x8004c2 <__brkval+0x1>
    2612:	20 93 c1 04 	sts	0x04C1, r18	; 0x8004c1 <__brkval>
    2616:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    261a:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    261e:	21 15       	cp	r18, r1
    2620:	31 05       	cpc	r19, r1
    2622:	41 f4       	brne	.+16     	; 0x2634 <malloc+0xea>
    2624:	2d b7       	in	r18, 0x3d	; 61
    2626:	3e b7       	in	r19, 0x3e	; 62
    2628:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    262c:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2630:	24 1b       	sub	r18, r20
    2632:	35 0b       	sbc	r19, r21
    2634:	e0 91 c1 04 	lds	r30, 0x04C1	; 0x8004c1 <__brkval>
    2638:	f0 91 c2 04 	lds	r31, 0x04C2	; 0x8004c2 <__brkval+0x1>
    263c:	e2 17       	cp	r30, r18
    263e:	f3 07       	cpc	r31, r19
    2640:	a0 f4       	brcc	.+40     	; 0x266a <malloc+0x120>
    2642:	2e 1b       	sub	r18, r30
    2644:	3f 0b       	sbc	r19, r31
    2646:	28 17       	cp	r18, r24
    2648:	39 07       	cpc	r19, r25
    264a:	78 f0       	brcs	.+30     	; 0x266a <malloc+0x120>
    264c:	ac 01       	movw	r20, r24
    264e:	4e 5f       	subi	r20, 0xFE	; 254
    2650:	5f 4f       	sbci	r21, 0xFF	; 255
    2652:	24 17       	cp	r18, r20
    2654:	35 07       	cpc	r19, r21
    2656:	48 f0       	brcs	.+18     	; 0x266a <malloc+0x120>
    2658:	4e 0f       	add	r20, r30
    265a:	5f 1f       	adc	r21, r31
    265c:	50 93 c2 04 	sts	0x04C2, r21	; 0x8004c2 <__brkval+0x1>
    2660:	40 93 c1 04 	sts	0x04C1, r20	; 0x8004c1 <__brkval>
    2664:	81 93       	st	Z+, r24
    2666:	91 93       	st	Z+, r25
    2668:	02 c0       	rjmp	.+4      	; 0x266e <malloc+0x124>
    266a:	e0 e0       	ldi	r30, 0x00	; 0
    266c:	f0 e0       	ldi	r31, 0x00	; 0
    266e:	cf 01       	movw	r24, r30
    2670:	df 91       	pop	r29
    2672:	cf 91       	pop	r28
    2674:	1f 91       	pop	r17
    2676:	0f 91       	pop	r16
    2678:	08 95       	ret

0000267a <free>:
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	00 97       	sbiw	r24, 0x00	; 0
    2680:	09 f4       	brne	.+2      	; 0x2684 <free+0xa>
    2682:	81 c0       	rjmp	.+258    	; 0x2786 <free+0x10c>
    2684:	fc 01       	movw	r30, r24
    2686:	32 97       	sbiw	r30, 0x02	; 2
    2688:	13 82       	std	Z+3, r1	; 0x03
    268a:	12 82       	std	Z+2, r1	; 0x02
    268c:	a0 91 c3 04 	lds	r26, 0x04C3	; 0x8004c3 <__flp>
    2690:	b0 91 c4 04 	lds	r27, 0x04C4	; 0x8004c4 <__flp+0x1>
    2694:	10 97       	sbiw	r26, 0x00	; 0
    2696:	81 f4       	brne	.+32     	; 0x26b8 <free+0x3e>
    2698:	20 81       	ld	r18, Z
    269a:	31 81       	ldd	r19, Z+1	; 0x01
    269c:	82 0f       	add	r24, r18
    269e:	93 1f       	adc	r25, r19
    26a0:	20 91 c1 04 	lds	r18, 0x04C1	; 0x8004c1 <__brkval>
    26a4:	30 91 c2 04 	lds	r19, 0x04C2	; 0x8004c2 <__brkval+0x1>
    26a8:	28 17       	cp	r18, r24
    26aa:	39 07       	cpc	r19, r25
    26ac:	51 f5       	brne	.+84     	; 0x2702 <free+0x88>
    26ae:	f0 93 c2 04 	sts	0x04C2, r31	; 0x8004c2 <__brkval+0x1>
    26b2:	e0 93 c1 04 	sts	0x04C1, r30	; 0x8004c1 <__brkval>
    26b6:	67 c0       	rjmp	.+206    	; 0x2786 <free+0x10c>
    26b8:	ed 01       	movw	r28, r26
    26ba:	20 e0       	ldi	r18, 0x00	; 0
    26bc:	30 e0       	ldi	r19, 0x00	; 0
    26be:	ce 17       	cp	r28, r30
    26c0:	df 07       	cpc	r29, r31
    26c2:	40 f4       	brcc	.+16     	; 0x26d4 <free+0x5a>
    26c4:	4a 81       	ldd	r20, Y+2	; 0x02
    26c6:	5b 81       	ldd	r21, Y+3	; 0x03
    26c8:	9e 01       	movw	r18, r28
    26ca:	41 15       	cp	r20, r1
    26cc:	51 05       	cpc	r21, r1
    26ce:	f1 f0       	breq	.+60     	; 0x270c <free+0x92>
    26d0:	ea 01       	movw	r28, r20
    26d2:	f5 cf       	rjmp	.-22     	; 0x26be <free+0x44>
    26d4:	d3 83       	std	Z+3, r29	; 0x03
    26d6:	c2 83       	std	Z+2, r28	; 0x02
    26d8:	40 81       	ld	r20, Z
    26da:	51 81       	ldd	r21, Z+1	; 0x01
    26dc:	84 0f       	add	r24, r20
    26de:	95 1f       	adc	r25, r21
    26e0:	c8 17       	cp	r28, r24
    26e2:	d9 07       	cpc	r29, r25
    26e4:	59 f4       	brne	.+22     	; 0x26fc <free+0x82>
    26e6:	88 81       	ld	r24, Y
    26e8:	99 81       	ldd	r25, Y+1	; 0x01
    26ea:	84 0f       	add	r24, r20
    26ec:	95 1f       	adc	r25, r21
    26ee:	02 96       	adiw	r24, 0x02	; 2
    26f0:	91 83       	std	Z+1, r25	; 0x01
    26f2:	80 83       	st	Z, r24
    26f4:	8a 81       	ldd	r24, Y+2	; 0x02
    26f6:	9b 81       	ldd	r25, Y+3	; 0x03
    26f8:	93 83       	std	Z+3, r25	; 0x03
    26fa:	82 83       	std	Z+2, r24	; 0x02
    26fc:	21 15       	cp	r18, r1
    26fe:	31 05       	cpc	r19, r1
    2700:	29 f4       	brne	.+10     	; 0x270c <free+0x92>
    2702:	f0 93 c4 04 	sts	0x04C4, r31	; 0x8004c4 <__flp+0x1>
    2706:	e0 93 c3 04 	sts	0x04C3, r30	; 0x8004c3 <__flp>
    270a:	3d c0       	rjmp	.+122    	; 0x2786 <free+0x10c>
    270c:	e9 01       	movw	r28, r18
    270e:	fb 83       	std	Y+3, r31	; 0x03
    2710:	ea 83       	std	Y+2, r30	; 0x02
    2712:	49 91       	ld	r20, Y+
    2714:	59 91       	ld	r21, Y+
    2716:	c4 0f       	add	r28, r20
    2718:	d5 1f       	adc	r29, r21
    271a:	ec 17       	cp	r30, r28
    271c:	fd 07       	cpc	r31, r29
    271e:	61 f4       	brne	.+24     	; 0x2738 <free+0xbe>
    2720:	80 81       	ld	r24, Z
    2722:	91 81       	ldd	r25, Z+1	; 0x01
    2724:	84 0f       	add	r24, r20
    2726:	95 1f       	adc	r25, r21
    2728:	02 96       	adiw	r24, 0x02	; 2
    272a:	e9 01       	movw	r28, r18
    272c:	99 83       	std	Y+1, r25	; 0x01
    272e:	88 83       	st	Y, r24
    2730:	82 81       	ldd	r24, Z+2	; 0x02
    2732:	93 81       	ldd	r25, Z+3	; 0x03
    2734:	9b 83       	std	Y+3, r25	; 0x03
    2736:	8a 83       	std	Y+2, r24	; 0x02
    2738:	e0 e0       	ldi	r30, 0x00	; 0
    273a:	f0 e0       	ldi	r31, 0x00	; 0
    273c:	12 96       	adiw	r26, 0x02	; 2
    273e:	8d 91       	ld	r24, X+
    2740:	9c 91       	ld	r25, X
    2742:	13 97       	sbiw	r26, 0x03	; 3
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	19 f0       	breq	.+6      	; 0x274e <free+0xd4>
    2748:	fd 01       	movw	r30, r26
    274a:	dc 01       	movw	r26, r24
    274c:	f7 cf       	rjmp	.-18     	; 0x273c <free+0xc2>
    274e:	8d 91       	ld	r24, X+
    2750:	9c 91       	ld	r25, X
    2752:	11 97       	sbiw	r26, 0x01	; 1
    2754:	9d 01       	movw	r18, r26
    2756:	2e 5f       	subi	r18, 0xFE	; 254
    2758:	3f 4f       	sbci	r19, 0xFF	; 255
    275a:	82 0f       	add	r24, r18
    275c:	93 1f       	adc	r25, r19
    275e:	20 91 c1 04 	lds	r18, 0x04C1	; 0x8004c1 <__brkval>
    2762:	30 91 c2 04 	lds	r19, 0x04C2	; 0x8004c2 <__brkval+0x1>
    2766:	28 17       	cp	r18, r24
    2768:	39 07       	cpc	r19, r25
    276a:	69 f4       	brne	.+26     	; 0x2786 <free+0x10c>
    276c:	30 97       	sbiw	r30, 0x00	; 0
    276e:	29 f4       	brne	.+10     	; 0x277a <free+0x100>
    2770:	10 92 c4 04 	sts	0x04C4, r1	; 0x8004c4 <__flp+0x1>
    2774:	10 92 c3 04 	sts	0x04C3, r1	; 0x8004c3 <__flp>
    2778:	02 c0       	rjmp	.+4      	; 0x277e <free+0x104>
    277a:	13 82       	std	Z+3, r1	; 0x03
    277c:	12 82       	std	Z+2, r1	; 0x02
    277e:	b0 93 c2 04 	sts	0x04C2, r27	; 0x8004c2 <__brkval+0x1>
    2782:	a0 93 c1 04 	sts	0x04C1, r26	; 0x8004c1 <__brkval>
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	08 95       	ret

0000278c <memcpy>:
    278c:	fb 01       	movw	r30, r22
    278e:	dc 01       	movw	r26, r24
    2790:	02 c0       	rjmp	.+4      	; 0x2796 <memcpy+0xa>
    2792:	01 90       	ld	r0, Z+
    2794:	0d 92       	st	X+, r0
    2796:	41 50       	subi	r20, 0x01	; 1
    2798:	50 40       	sbci	r21, 0x00	; 0
    279a:	d8 f7       	brcc	.-10     	; 0x2792 <memcpy+0x6>
    279c:	08 95       	ret

0000279e <memset>:
    279e:	dc 01       	movw	r26, r24
    27a0:	01 c0       	rjmp	.+2      	; 0x27a4 <memset+0x6>
    27a2:	6d 93       	st	X+, r22
    27a4:	41 50       	subi	r20, 0x01	; 1
    27a6:	50 40       	sbci	r21, 0x00	; 0
    27a8:	e0 f7       	brcc	.-8      	; 0x27a2 <memset+0x4>
    27aa:	08 95       	ret

000027ac <__itoa_ncheck>:
    27ac:	bb 27       	eor	r27, r27
    27ae:	4a 30       	cpi	r20, 0x0A	; 10
    27b0:	31 f4       	brne	.+12     	; 0x27be <__itoa_ncheck+0x12>
    27b2:	99 23       	and	r25, r25
    27b4:	22 f4       	brpl	.+8      	; 0x27be <__itoa_ncheck+0x12>
    27b6:	bd e2       	ldi	r27, 0x2D	; 45
    27b8:	90 95       	com	r25
    27ba:	81 95       	neg	r24
    27bc:	9f 4f       	sbci	r25, 0xFF	; 255
    27be:	01 c0       	rjmp	.+2      	; 0x27c2 <__utoa_common>

000027c0 <__utoa_ncheck>:
    27c0:	bb 27       	eor	r27, r27

000027c2 <__utoa_common>:
    27c2:	fb 01       	movw	r30, r22
    27c4:	55 27       	eor	r21, r21
    27c6:	aa 27       	eor	r26, r26
    27c8:	88 0f       	add	r24, r24
    27ca:	99 1f       	adc	r25, r25
    27cc:	aa 1f       	adc	r26, r26
    27ce:	a4 17       	cp	r26, r20
    27d0:	10 f0       	brcs	.+4      	; 0x27d6 <__utoa_common+0x14>
    27d2:	a4 1b       	sub	r26, r20
    27d4:	83 95       	inc	r24
    27d6:	50 51       	subi	r21, 0x10	; 16
    27d8:	b9 f7       	brne	.-18     	; 0x27c8 <__utoa_common+0x6>
    27da:	a0 5d       	subi	r26, 0xD0	; 208
    27dc:	aa 33       	cpi	r26, 0x3A	; 58
    27de:	08 f0       	brcs	.+2      	; 0x27e2 <__utoa_common+0x20>
    27e0:	a9 5d       	subi	r26, 0xD9	; 217
    27e2:	a1 93       	st	Z+, r26
    27e4:	00 97       	sbiw	r24, 0x00	; 0
    27e6:	79 f7       	brne	.-34     	; 0x27c6 <__utoa_common+0x4>
    27e8:	b1 11       	cpse	r27, r1
    27ea:	b1 93       	st	Z+, r27
    27ec:	11 92       	st	Z+, r1
    27ee:	cb 01       	movw	r24, r22
    27f0:	00 c0       	rjmp	.+0      	; 0x27f2 <strrev>

000027f2 <strrev>:
    27f2:	dc 01       	movw	r26, r24
    27f4:	fc 01       	movw	r30, r24
    27f6:	67 2f       	mov	r22, r23
    27f8:	71 91       	ld	r23, Z+
    27fa:	77 23       	and	r23, r23
    27fc:	e1 f7       	brne	.-8      	; 0x27f6 <strrev+0x4>
    27fe:	32 97       	sbiw	r30, 0x02	; 2
    2800:	04 c0       	rjmp	.+8      	; 0x280a <strrev+0x18>
    2802:	7c 91       	ld	r23, X
    2804:	6d 93       	st	X+, r22
    2806:	70 83       	st	Z, r23
    2808:	62 91       	ld	r22, -Z
    280a:	ae 17       	cp	r26, r30
    280c:	bf 07       	cpc	r27, r31
    280e:	c8 f3       	brcs	.-14     	; 0x2802 <strrev+0x10>
    2810:	08 95       	ret

00002812 <_exit>:
    2812:	f8 94       	cli

00002814 <__stop_program>:
    2814:	ff cf       	rjmp	.-2      	; 0x2814 <__stop_program>
