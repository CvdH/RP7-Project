
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000082  00800200  00002752  000027e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002752  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000237  00800282  00800282  00002868  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002868  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002898  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a8  00000000  00000000  000028d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000782d  00000000  00000000  00002e80  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f4d  00000000  00000000  0000a6ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000474e  00000000  00000000  0000c5fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000014e0  00000000  00000000  00010d48  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001fb2  00000000  00000000  00012228  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000073f6  00000000  00000000  000141da  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000880  00000000  00000000  0001b5d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8a c1       	rjmp	.+788    	; 0x31a <__bad_interrupt>
       6:	00 00       	nop
       8:	88 c1       	rjmp	.+784    	; 0x31a <__bad_interrupt>
       a:	00 00       	nop
       c:	86 c1       	rjmp	.+780    	; 0x31a <__bad_interrupt>
       e:	00 00       	nop
      10:	84 c1       	rjmp	.+776    	; 0x31a <__bad_interrupt>
      12:	00 00       	nop
      14:	82 c1       	rjmp	.+772    	; 0x31a <__bad_interrupt>
      16:	00 00       	nop
      18:	80 c1       	rjmp	.+768    	; 0x31a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7e c1       	rjmp	.+764    	; 0x31a <__bad_interrupt>
      1e:	00 00       	nop
      20:	7c c1       	rjmp	.+760    	; 0x31a <__bad_interrupt>
      22:	00 00       	nop
      24:	8d c4       	rjmp	.+2330   	; 0x940 <__vector_9>
      26:	00 00       	nop
      28:	78 c1       	rjmp	.+752    	; 0x31a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	76 c1       	rjmp	.+748    	; 0x31a <__bad_interrupt>
      2e:	00 00       	nop
      30:	74 c1       	rjmp	.+744    	; 0x31a <__bad_interrupt>
      32:	00 00       	nop
      34:	72 c1       	rjmp	.+740    	; 0x31a <__bad_interrupt>
      36:	00 00       	nop
      38:	70 c1       	rjmp	.+736    	; 0x31a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6e c1       	rjmp	.+732    	; 0x31a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6c c1       	rjmp	.+728    	; 0x31a <__bad_interrupt>
      42:	00 00       	nop
      44:	e4 c6       	rjmp	.+3528   	; 0xe0e <__vector_17>
      46:	00 00       	nop
      48:	68 c1       	rjmp	.+720    	; 0x31a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	66 c1       	rjmp	.+716    	; 0x31a <__bad_interrupt>
      4e:	00 00       	nop
      50:	64 c1       	rjmp	.+712    	; 0x31a <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 a8 08 	jmp	0x1150	; 0x1150 <__vector_21>
      58:	60 c1       	rjmp	.+704    	; 0x31a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5e c1       	rjmp	.+700    	; 0x31a <__bad_interrupt>
      5e:	00 00       	nop
      60:	5c c1       	rjmp	.+696    	; 0x31a <__bad_interrupt>
      62:	00 00       	nop
      64:	5a c1       	rjmp	.+692    	; 0x31a <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__vector_26>
      6c:	56 c1       	rjmp	.+684    	; 0x31a <__bad_interrupt>
      6e:	00 00       	nop
      70:	54 c1       	rjmp	.+680    	; 0x31a <__bad_interrupt>
      72:	00 00       	nop
      74:	52 c1       	rjmp	.+676    	; 0x31a <__bad_interrupt>
      76:	00 00       	nop
      78:	50 c1       	rjmp	.+672    	; 0x31a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4e c1       	rjmp	.+668    	; 0x31a <__bad_interrupt>
      7e:	00 00       	nop
      80:	4c c1       	rjmp	.+664    	; 0x31a <__bad_interrupt>
      82:	00 00       	nop
      84:	4a c1       	rjmp	.+660    	; 0x31a <__bad_interrupt>
      86:	00 00       	nop
      88:	48 c1       	rjmp	.+656    	; 0x31a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fc c4       	rjmp	.+2552   	; 0xa86 <__vector_35>
      8e:	00 00       	nop
      90:	8d c3       	rjmp	.+1818   	; 0x7ac <__vector_36>
      92:	00 00       	nop
      94:	0c 94 90 0a 	jmp	0x1520	; 0x1520 <__vector_37>
      98:	40 c1       	rjmp	.+640    	; 0x31a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ac c1       	rjmp	.+856    	; 0x3f6 <__vector_39>
      9e:	00 00       	nop
      a0:	3c c1       	rjmp	.+632    	; 0x31a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	38 c1       	rjmp	.+624    	; 0x31a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	36 c1       	rjmp	.+620    	; 0x31a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	34 c1       	rjmp	.+616    	; 0x31a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	32 c1       	rjmp	.+612    	; 0x31a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	30 c1       	rjmp	.+608    	; 0x31a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2e c1       	rjmp	.+604    	; 0x31a <__bad_interrupt>
      be:	00 00       	nop
      c0:	2c c1       	rjmp	.+600    	; 0x31a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2a c1       	rjmp	.+596    	; 0x31a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	28 c1       	rjmp	.+592    	; 0x31a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 d9 0a 	jmp	0x15b2	; 0x15b2 <__vector_51>
      d0:	0c 94 38 0b 	jmp	0x1670	; 0x1670 <__vector_52>
      d4:	22 c1       	rjmp	.+580    	; 0x31a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 81 0b 	jmp	0x1702	; 0x1702 <__vector_54>
      dc:	0c 94 e0 0b 	jmp	0x17c0	; 0x17c0 <__vector_55>
      e0:	1c c1       	rjmp	.+568    	; 0x31a <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1a 02       	muls	r17, r26
      e6:	d5 02       	muls	r29, r21
      e8:	d5 02       	muls	r29, r21
      ea:	d5 02       	muls	r29, r21
      ec:	d5 02       	muls	r29, r21
      ee:	d5 02       	muls	r29, r21
      f0:	d5 02       	muls	r29, r21
      f2:	d5 02       	muls	r29, r21
      f4:	1a 02       	muls	r17, r26
      f6:	d5 02       	muls	r29, r21
      f8:	d5 02       	muls	r29, r21
      fa:	d5 02       	muls	r29, r21
      fc:	d5 02       	muls	r29, r21
      fe:	d5 02       	muls	r29, r21
     100:	d5 02       	muls	r29, r21
     102:	d5 02       	muls	r29, r21
     104:	1c 02       	muls	r17, r28
     106:	d5 02       	muls	r29, r21
     108:	d5 02       	muls	r29, r21
     10a:	d5 02       	muls	r29, r21
     10c:	d5 02       	muls	r29, r21
     10e:	d5 02       	muls	r29, r21
     110:	d5 02       	muls	r29, r21
     112:	d5 02       	muls	r29, r21
     114:	39 02       	muls	r19, r25
     116:	d5 02       	muls	r29, r21
     118:	d5 02       	muls	r29, r21
     11a:	d5 02       	muls	r29, r21
     11c:	d5 02       	muls	r29, r21
     11e:	d5 02       	muls	r29, r21
     120:	d5 02       	muls	r29, r21
     122:	d5 02       	muls	r29, r21
     124:	1c 02       	muls	r17, r28
     126:	d5 02       	muls	r29, r21
     128:	d5 02       	muls	r29, r21
     12a:	d5 02       	muls	r29, r21
     12c:	d5 02       	muls	r29, r21
     12e:	d5 02       	muls	r29, r21
     130:	d5 02       	muls	r29, r21
     132:	d5 02       	muls	r29, r21
     134:	39 02       	muls	r19, r25
     136:	d5 02       	muls	r29, r21
     138:	d5 02       	muls	r29, r21
     13a:	d5 02       	muls	r29, r21
     13c:	d5 02       	muls	r29, r21
     13e:	d5 02       	muls	r29, r21
     140:	d5 02       	muls	r29, r21
     142:	d5 02       	muls	r29, r21
     144:	d1 02       	muls	r29, r17
     146:	d5 02       	muls	r29, r21
     148:	d5 02       	muls	r29, r21
     14a:	d5 02       	muls	r29, r21
     14c:	d5 02       	muls	r29, r21
     14e:	d5 02       	muls	r29, r21
     150:	d5 02       	muls	r29, r21
     152:	d5 02       	muls	r29, r21
     154:	4d 02       	muls	r20, r29
     156:	d5 02       	muls	r29, r21
     158:	d5 02       	muls	r29, r21
     15a:	d5 02       	muls	r29, r21
     15c:	d5 02       	muls	r29, r21
     15e:	d5 02       	muls	r29, r21
     160:	d5 02       	muls	r29, r21
     162:	d5 02       	muls	r29, r21
     164:	70 02       	muls	r23, r16
     166:	d5 02       	muls	r29, r21
     168:	d5 02       	muls	r29, r21
     16a:	d5 02       	muls	r29, r21
     16c:	d5 02       	muls	r29, r21
     16e:	d5 02       	muls	r29, r21
     170:	d5 02       	muls	r29, r21
     172:	d5 02       	muls	r29, r21
     174:	41 02       	muls	r20, r17
     176:	d5 02       	muls	r29, r21
     178:	d5 02       	muls	r29, r21
     17a:	d5 02       	muls	r29, r21
     17c:	d5 02       	muls	r29, r21
     17e:	d5 02       	muls	r29, r21
     180:	d5 02       	muls	r29, r21
     182:	d5 02       	muls	r29, r21
     184:	5f 02       	muls	r21, r31
     186:	d5 02       	muls	r29, r21
     188:	d5 02       	muls	r29, r21
     18a:	d5 02       	muls	r29, r21
     18c:	d5 02       	muls	r29, r21
     18e:	d5 02       	muls	r29, r21
     190:	d5 02       	muls	r29, r21
     192:	d5 02       	muls	r29, r21
     194:	a7 02       	muls	r26, r23
     196:	d5 02       	muls	r29, r21
     198:	d5 02       	muls	r29, r21
     19a:	d5 02       	muls	r29, r21
     19c:	d5 02       	muls	r29, r21
     19e:	d5 02       	muls	r29, r21
     1a0:	d5 02       	muls	r29, r21
     1a2:	d5 02       	muls	r29, r21
     1a4:	a7 02       	muls	r26, r23
     1a6:	d5 02       	muls	r29, r21
     1a8:	d5 02       	muls	r29, r21
     1aa:	d5 02       	muls	r29, r21
     1ac:	d5 02       	muls	r29, r21
     1ae:	d5 02       	muls	r29, r21
     1b0:	d5 02       	muls	r29, r21
     1b2:	d5 02       	muls	r29, r21
     1b4:	a2 02       	muls	r26, r18
     1b6:	d5 02       	muls	r29, r21
     1b8:	d5 02       	muls	r29, r21
     1ba:	d5 02       	muls	r29, r21
     1bc:	d5 02       	muls	r29, r21
     1be:	d5 02       	muls	r29, r21
     1c0:	d5 02       	muls	r29, r21
     1c2:	d5 02       	muls	r29, r21
     1c4:	a2 02       	muls	r26, r18
     1c6:	d5 02       	muls	r29, r21
     1c8:	d5 02       	muls	r29, r21
     1ca:	d5 02       	muls	r29, r21
     1cc:	d5 02       	muls	r29, r21
     1ce:	d5 02       	muls	r29, r21
     1d0:	d5 02       	muls	r29, r21
     1d2:	d5 02       	muls	r29, r21
     1d4:	b2 02       	muls	r27, r18
     1d6:	d5 02       	muls	r29, r21
     1d8:	d5 02       	muls	r29, r21
     1da:	d5 02       	muls	r29, r21
     1dc:	d5 02       	muls	r29, r21
     1de:	d5 02       	muls	r29, r21
     1e0:	d5 02       	muls	r29, r21
     1e2:	d5 02       	muls	r29, r21
     1e4:	c7 02       	muls	r28, r23
     1e6:	d5 02       	muls	r29, r21
     1e8:	d5 02       	muls	r29, r21
     1ea:	d5 02       	muls	r29, r21
     1ec:	d5 02       	muls	r29, r21
     1ee:	d5 02       	muls	r29, r21
     1f0:	d5 02       	muls	r29, r21
     1f2:	d5 02       	muls	r29, r21
     1f4:	b2 02       	muls	r27, r18
     1f6:	d5 02       	muls	r29, r21
     1f8:	d5 02       	muls	r29, r21
     1fa:	d5 02       	muls	r29, r21
     1fc:	d5 02       	muls	r29, r21
     1fe:	d5 02       	muls	r29, r21
     200:	d5 02       	muls	r29, r21
     202:	d5 02       	muls	r29, r21
     204:	c7 02       	muls	r28, r23
     206:	d5 02       	muls	r29, r21
     208:	d5 02       	muls	r29, r21
     20a:	d5 02       	muls	r29, r21
     20c:	d5 02       	muls	r29, r21
     20e:	d5 02       	muls	r29, r21
     210:	d5 02       	muls	r29, r21
     212:	d5 02       	muls	r29, r21
     214:	cb 02       	muls	r28, r27
     216:	d5 02       	muls	r29, r21
     218:	d5 02       	muls	r29, r21
     21a:	d5 02       	muls	r29, r21
     21c:	d5 02       	muls	r29, r21
     21e:	d5 02       	muls	r29, r21
     220:	d5 02       	muls	r29, r21
     222:	d5 02       	muls	r29, r21
     224:	78 02       	muls	r23, r24
     226:	d5 02       	muls	r29, r21
     228:	d5 02       	muls	r29, r21
     22a:	d5 02       	muls	r29, r21
     22c:	d5 02       	muls	r29, r21
     22e:	d5 02       	muls	r29, r21
     230:	d5 02       	muls	r29, r21
     232:	d5 02       	muls	r29, r21
     234:	78 02       	muls	r23, r24
     236:	d5 02       	muls	r29, r21
     238:	d5 02       	muls	r29, r21
     23a:	d5 02       	muls	r29, r21
     23c:	d5 02       	muls	r29, r21
     23e:	d5 02       	muls	r29, r21
     240:	d5 02       	muls	r29, r21
     242:	d5 02       	muls	r29, r21
     244:	7a 02       	muls	r23, r26
     246:	d5 02       	muls	r29, r21
     248:	d5 02       	muls	r29, r21
     24a:	d5 02       	muls	r29, r21
     24c:	d5 02       	muls	r29, r21
     24e:	d5 02       	muls	r29, r21
     250:	d5 02       	muls	r29, r21
     252:	d5 02       	muls	r29, r21
     254:	8a 02       	muls	r24, r26
     256:	d5 02       	muls	r29, r21
     258:	d5 02       	muls	r29, r21
     25a:	d5 02       	muls	r29, r21
     25c:	d5 02       	muls	r29, r21
     25e:	d5 02       	muls	r29, r21
     260:	d5 02       	muls	r29, r21
     262:	d5 02       	muls	r29, r21
     264:	9e 02       	muls	r25, r30

00000266 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     266:	02 ec       	ldi	r16, 0xC2	; 194
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	fa ee       	ldi	r31, 0xEA	; 234
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	fe d1       	rcall	.+1020   	; 0x69e <uxListRemove>
     2a2:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <uxCurrentNumberOfTasks>
     2ac:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5c d0       	rcall	.+184    	; 0x378 <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5a d0       	rcall	.+180    	; 0x378 <vPortFree>
     2c4:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	66 d6       	rcall	.+3276   	; 0xfa2 <vPortYield>
     2d6:	5f d0       	rcall	.+190    	; 0x396 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	e2 e5       	ldi	r30, 0x52	; 82
     2f2:	f7 e2       	ldi	r31, 0x27	; 39
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	a2 38       	cpi	r26, 0x82	; 130
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	24 e0       	ldi	r18, 0x04	; 4
     306:	a2 e8       	ldi	r26, 0x82	; 130
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a9 3b       	cpi	r26, 0xB9	; 185
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	45 d4       	rcall	.+2186   	; 0xba0 <main>
     316:	0c 94 a7 13 	jmp	0x274e	; 0x274e <_exit>

0000031a <__bad_interrupt>:
     31a:	72 ce       	rjmp	.-796    	; 0x0 <__vectors>

0000031c <system_tick>:
     31c:	8f 93       	push	r24
     31e:	8f b7       	in	r24, 0x3f	; 63
     320:	8f 93       	push	r24
     322:	f8 94       	cli
     324:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <__system_time>
     328:	8f 5f       	subi	r24, 0xFF	; 255
     32a:	80 93 b5 04 	sts	0x04B5, r24	; 0x8004b5 <__system_time>
     32e:	80 91 b6 04 	lds	r24, 0x04B6	; 0x8004b6 <__system_time+0x1>
     332:	8f 4f       	sbci	r24, 0xFF	; 255
     334:	80 93 b6 04 	sts	0x04B6, r24	; 0x8004b6 <__system_time+0x1>
     338:	80 91 b7 04 	lds	r24, 0x04B7	; 0x8004b7 <__system_time+0x2>
     33c:	8f 4f       	sbci	r24, 0xFF	; 255
     33e:	80 93 b7 04 	sts	0x04B7, r24	; 0x8004b7 <__system_time+0x2>
     342:	80 91 b8 04 	lds	r24, 0x04B8	; 0x8004b8 <__system_time+0x3>
     346:	8f 4f       	sbci	r24, 0xFF	; 255
     348:	80 93 b8 04 	sts	0x04B8, r24	; 0x8004b8 <__system_time+0x3>
     34c:	8f 91       	pop	r24
     34e:	8f bf       	out	0x3f, r24	; 63
     350:	8f 91       	pop	r24
     352:	08 95       	ret

00000354 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35a:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     35e:	ce 01       	movw	r24, r28
     360:	0e 94 43 12 	call	0x2486	; 0x2486 <malloc>
     364:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     366:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36a:	20 97       	sbiw	r28, 0x00	; 0
     36c:	09 f4       	brne	.+2      	; 0x370 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     36e:	2c d0       	rcall	.+88     	; 0x3c8 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     370:	ce 01       	movw	r24, r28
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
	if( pv )
     37c:	00 97       	sbiw	r24, 0x00	; 0
     37e:	41 f0       	breq	.+16     	; 0x390 <vPortFree+0x18>
     380:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     382:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <vTaskSuspendAll>
		{
			free( pv );
     386:	ce 01       	movw	r24, r28
     388:	0e 94 db 12 	call	0x25b6	; 0x25b6 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38c:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <xTaskResumeAll>
	}
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39c:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a0:	80 b7       	in	r24, 0x30	; 48
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a6:	80 b7       	in	r24, 0x30	; 48
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ac:	83 b7       	in	r24, 0x33	; 51
     3ae:	81 7f       	andi	r24, 0xF1	; 241
     3b0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0

	sleep_enable();
     3b8:	83 b7       	in	r24, 0x33	; 51
     3ba:	81 60       	ori	r24, 0x01	; 1
     3bc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3be:	0f 90       	pop	r0
     3c0:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c2:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c4:	13 be       	out	0x33, r1	; 51
     3c6:	08 95       	ret

000003c8 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3ca:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3cc:	83 ed       	ldi	r24, 0xD3	; 211
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <vApplicationMallocFailedHook+0x8>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <vApplicationMallocFailedHook+0xe>
     3d6:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3d8:	1f 9a       	sbi	0x03, 7	; 3
     3da:	f8 cf       	rjmp	.-16     	; 0x3cc <vApplicationMallocFailedHook+0x4>

000003dc <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3dc:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3de:	2f 9a       	sbi	0x05, 7	; 5
     3e0:	2f e7       	ldi	r18, 0x7F	; 127
     3e2:	8a e1       	ldi	r24, 0x1A	; 26
     3e4:	96 e0       	ldi	r25, 0x06	; 6
     3e6:	21 50       	subi	r18, 0x01	; 1
     3e8:	80 40       	sbci	r24, 0x00	; 0
     3ea:	90 40       	sbci	r25, 0x00	; 0
     3ec:	e1 f7       	brne	.-8      	; 0x3e6 <vApplicationStackOverflowHook+0xa>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <vApplicationStackOverflowHook+0x14>
     3f0:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f2:	1f 9a       	sbi	0x03, 7	; 3
     3f4:	f5 cf       	rjmp	.-22     	; 0x3e0 <vApplicationStackOverflowHook+0x4>

000003f6 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f6:	1f 92       	push	r1
     3f8:	0f 92       	push	r0
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	0b b6       	in	r0, 0x3b	; 59
     402:	0f 92       	push	r0
     404:	2f 93       	push	r18
     406:	3f 93       	push	r19
     408:	8f 93       	push	r24
     40a:	9f 93       	push	r25
     40c:	af 93       	push	r26
     40e:	bf 93       	push	r27
     410:	ef 93       	push	r30
     412:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     414:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     418:	8e 2f       	mov	r24, r30
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	38 97       	sbiw	r30, 0x08	; 8
     420:	e1 3c       	cpi	r30, 0xC1	; 193
     422:	f1 05       	cpc	r31, r1
     424:	08 f0       	brcs	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	c1 c0       	rjmp	.+386    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     428:	88 27       	eor	r24, r24
     42a:	ee 58       	subi	r30, 0x8E	; 142
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	8f 4f       	sbci	r24, 0xFF	; 255
     430:	0c 94 22 12 	jmp	0x2444	; 0x2444 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     434:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     438:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     43c:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     440:	e8 17       	cp	r30, r24
     442:	70 f4       	brcc	.+28     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	8e 0f       	add	r24, r30
     448:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	ea 57       	subi	r30, 0x7A	; 122
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     458:	85 e8       	ldi	r24, 0x85	; 133
     45a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     45e:	ac c0       	rjmp	.+344    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     460:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     464:	81 60       	ori	r24, 0x01	; 1
     466:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46a:	84 e9       	ldi	r24, 0x94	; 148
     46c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     470:	a3 c0       	rjmp	.+326    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     476:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47a:	85 ee       	ldi	r24, 0xE5	; 229
     47c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     480:	9b c0       	rjmp	.+310    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     482:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e 0f       	add	r24, r30
     48a:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     492:	f0 e0       	ldi	r31, 0x00	; 0
     494:	ea 57       	subi	r30, 0x7A	; 122
     496:	fd 4f       	sbci	r31, 0xFD	; 253
     498:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49a:	20 91 82 02 	lds	r18, 0x0282	; 0x800282 <__data_end>
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	28 17       	cp	r18, r24
     4aa:	39 07       	cpc	r19, r25
     4ac:	24 f4       	brge	.+8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4ae:	85 ec       	ldi	r24, 0xC5	; 197
     4b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b4:	81 c0       	rjmp	.+258    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b6:	85 e8       	ldi	r24, 0x85	; 133
     4b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4bc:	7d c0       	rjmp	.+250    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4be:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c2:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	ea 57       	subi	r30, 0x7A	; 122
     4ca:	fd 4f       	sbci	r31, 0xFD	; 253
     4cc:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4ce:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     4d2:	81 60       	ori	r24, 0x01	; 1
     4d4:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4de:	6c c0       	rjmp	.+216    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e4:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4e8:	85 ed       	ldi	r24, 0xD5	; 213
     4ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4ee:	64 c0       	rjmp	.+200    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f0:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f4:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     4f8:	81 e0       	ldi	r24, 0x01	; 1
     4fa:	8e 0f       	add	r24, r30
     4fc:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	ea 57       	subi	r30, 0x7A	; 122
     504:	fd 4f       	sbci	r31, 0xFD	; 253
     506:	80 81       	ld	r24, Z
     508:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50c:	85 ec       	ldi	r24, 0xC5	; 197
     50e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     512:	52 c0       	rjmp	.+164    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     514:	90 91 82 02 	lds	r25, 0x0282	; 0x800282 <__data_end>
     518:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <I2C_msgSize>
     51c:	98 13       	cpse	r25, r24
     51e:	06 c0       	rjmp	.+12     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     520:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     524:	81 60       	ori	r24, 0x01	; 1
     526:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     530:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53a:	3e c0       	rjmp	.+124    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53c:	85 ec       	ldi	r24, 0xC5	; 197
     53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     544:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     548:	84 60       	ori	r24, 0x04	; 4
     54a:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     54e:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     558:	10 92 82 02 	sts	0x0282, r1	; 0x800282 <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55c:	85 ec       	ldi	r24, 0xC5	; 197
     55e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     564:	e0 91 82 02 	lds	r30, 0x0282	; 0x800282 <__data_end>
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e 0f       	add	r24, r30
     56c:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <__data_end>
     570:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	ea 57       	subi	r30, 0x7A	; 122
     578:	fd 4f       	sbci	r31, 0xFD	; 253
     57a:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57c:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <I2C_statusReg>
     580:	81 60       	ori	r24, 0x01	; 1
     582:	80 93 83 02 	sts	0x0283, r24	; 0x800283 <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     586:	85 ec       	ldi	r24, 0xC5	; 197
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58c:	15 c0       	rjmp	.+42     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     58e:	85 e8       	ldi	r24, 0x85	; 133
     590:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     594:	11 c0       	rjmp	.+34     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     596:	84 e0       	ldi	r24, 0x04	; 4
     598:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a2:	85 ee       	ldi	r24, 0xE5	; 229
     5a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5a8:	07 c0       	rjmp	.+14     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5aa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ae:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b2:	85 ed       	ldi	r24, 0xD5	; 213
     5b4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	3f 91       	pop	r19
     5c6:	2f 91       	pop	r18
     5c8:	0f 90       	pop	r0
     5ca:	0b be       	out	0x3b, r0	; 59
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	03 96       	adiw	r24, 0x03	; 3
     5da:	92 83       	std	Z+2, r25	; 0x02
     5dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5de:	2f ef       	ldi	r18, 0xFF	; 255
     5e0:	3f ef       	ldi	r19, 0xFF	; 255
     5e2:	34 83       	std	Z+4, r19	; 0x04
     5e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e6:	96 83       	std	Z+6, r25	; 0x06
     5e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ea:	90 87       	std	Z+8, r25	; 0x08
     5ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5ee:	10 82       	st	Z, r1
     5f0:	08 95       	ret

000005f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f2:	fc 01       	movw	r30, r24
     5f4:	11 86       	std	Z+9, r1	; 0x09
     5f6:	10 86       	std	Z+8, r1	; 0x08
     5f8:	08 95       	ret

000005fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	9c 01       	movw	r18, r24
     600:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     602:	dc 01       	movw	r26, r24
     604:	11 96       	adiw	r26, 0x01	; 1
     606:	cd 91       	ld	r28, X+
     608:	dc 91       	ld	r29, X
     60a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60c:	d3 83       	std	Z+3, r29	; 0x03
     60e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     610:	8c 81       	ldd	r24, Y+4	; 0x04
     612:	9d 81       	ldd	r25, Y+5	; 0x05
     614:	95 83       	std	Z+5, r25	; 0x05
     616:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	dc 01       	movw	r26, r24
     61e:	13 96       	adiw	r26, 0x03	; 3
     620:	7c 93       	st	X, r23
     622:	6e 93       	st	-X, r22
     624:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     626:	7d 83       	std	Y+5, r23	; 0x05
     628:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	31 87       	std	Z+9, r19	; 0x09
     62c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	f9 01       	movw	r30, r18
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     642:	48 81       	ld	r20, Y
     644:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     646:	4f 3f       	cpi	r20, 0xFF	; 255
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	52 07       	cpc	r21, r18
     64c:	21 f4       	brne	.+8      	; 0x656 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     64e:	fc 01       	movw	r30, r24
     650:	a7 81       	ldd	r26, Z+7	; 0x07
     652:	b0 85       	ldd	r27, Z+8	; 0x08
     654:	0d c0       	rjmp	.+26     	; 0x670 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     656:	dc 01       	movw	r26, r24
     658:	13 96       	adiw	r26, 0x03	; 3
     65a:	01 c0       	rjmp	.+2      	; 0x65e <vListInsert+0x22>
     65c:	df 01       	movw	r26, r30
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	ed 91       	ld	r30, X+
     662:	fc 91       	ld	r31, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	20 81       	ld	r18, Z
     668:	31 81       	ldd	r19, Z+1	; 0x01
     66a:	42 17       	cp	r20, r18
     66c:	53 07       	cpc	r21, r19
     66e:	b0 f7       	brcc	.-20     	; 0x65c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     670:	12 96       	adiw	r26, 0x02	; 2
     672:	ed 91       	ld	r30, X+
     674:	fc 91       	ld	r31, X
     676:	13 97       	sbiw	r26, 0x03	; 3
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67c:	d5 83       	std	Z+5, r29	; 0x05
     67e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     680:	bd 83       	std	Y+5, r27	; 0x05
     682:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     684:	13 96       	adiw	r26, 0x03	; 3
     686:	dc 93       	st	X, r29
     688:	ce 93       	st	-X, r28
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68c:	99 87       	std	Y+9, r25	; 0x09
     68e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     690:	fc 01       	movw	r30, r24
     692:	20 81       	ld	r18, Z
     694:	2f 5f       	subi	r18, 0xFF	; 255
     696:	20 83       	st	Z, r18
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a4:	a0 85       	ldd	r26, Z+8	; 0x08
     6a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6a8:	c2 81       	ldd	r28, Z+2	; 0x02
     6aa:	d3 81       	ldd	r29, Z+3	; 0x03
     6ac:	84 81       	ldd	r24, Z+4	; 0x04
     6ae:	95 81       	ldd	r25, Z+5	; 0x05
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b4:	c4 81       	ldd	r28, Z+4	; 0x04
     6b6:	d5 81       	ldd	r29, Z+5	; 0x05
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	9b 83       	std	Y+3, r25	; 0x03
     6be:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2
     6c8:	e8 17       	cp	r30, r24
     6ca:	f9 07       	cpc	r31, r25
     6cc:	31 f4       	brne	.+12     	; 0x6da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6ce:	84 81       	ldd	r24, Z+4	; 0x04
     6d0:	95 81       	ldd	r25, Z+5	; 0x05
     6d2:	12 96       	adiw	r26, 0x02	; 2
     6d4:	9c 93       	st	X, r25
     6d6:	8e 93       	st	-X, r24
     6d8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6da:	11 86       	std	Z+9, r1	; 0x09
     6dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6de:	8c 91       	ld	r24, X
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <watchdogTaak>:
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     6ea:	8f e9       	ldi	r24, 0x9F	; 159
     6ec:	9f e0       	ldi	r25, 0x0F	; 15
     6ee:	01 97       	sbiw	r24, 0x01	; 1
     6f0:	f1 f7       	brne	.-4      	; 0x6ee <watchdogTaak+0x4>
     6f2:	00 c0       	rjmp	.+0      	; 0x6f4 <watchdogTaak+0xa>
     6f4:	00 00       	nop
     6f6:	80 91 12 03 	lds	r24, 0x0312	; 0x800312 <watchdogSonar>
     6fa:	90 91 13 03 	lds	r25, 0x0313	; 0x800313 <watchdogSonar+0x1>
     6fe:	89 2b       	or	r24, r25
     700:	a1 f3       	breq	.-24     	; 0x6ea <watchdogTaak>
     702:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <watchdogServo>
     706:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <watchdogServo+0x1>
     70a:	89 2b       	or	r24, r25
     70c:	71 f3       	breq	.-36     	; 0x6ea <watchdogTaak>
     70e:	80 91 14 04 	lds	r24, 0x0414	; 0x800414 <watchdogTemp>
     712:	90 91 15 04 	lds	r25, 0x0415	; 0x800415 <watchdogTemp+0x1>
     716:	89 2b       	or	r24, r25
     718:	41 f3       	breq	.-48     	; 0x6ea <watchdogTaak>
     71a:	a8 95       	wdr
     71c:	10 92 13 03 	sts	0x0313, r1	; 0x800313 <watchdogSonar+0x1>
     720:	10 92 12 03 	sts	0x0312, r1	; 0x800312 <watchdogSonar>
     724:	10 92 21 04 	sts	0x0421, r1	; 0x800421 <watchdogServo+0x1>
     728:	10 92 20 04 	sts	0x0420, r1	; 0x800420 <watchdogServo>
     72c:	10 92 15 04 	sts	0x0415, r1	; 0x800415 <watchdogTemp+0x1>
     730:	10 92 14 04 	sts	0x0414, r1	; 0x800414 <watchdogTemp>
     734:	da cf       	rjmp	.-76     	; 0x6ea <watchdogTaak>

00000736 <initQ>:
     736:	40 e0       	ldi	r20, 0x00	; 0
     738:	62 e0       	ldi	r22, 0x02	; 2
     73a:	8a e0       	ldi	r24, 0x0A	; 10
     73c:	eb d5       	rcall	.+3030   	; 0x1314 <xQueueGenericCreate>
     73e:	90 93 1f 04 	sts	0x041F, r25	; 0x80041f <sonarAfstand+0x1>
     742:	80 93 1e 04 	sts	0x041E, r24	; 0x80041e <sonarAfstand>
     746:	89 2b       	or	r24, r25
     748:	41 f4       	brne	.+16     	; 0x75a <initQ+0x24>
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	62 e0       	ldi	r22, 0x02	; 2
     74e:	8a e0       	ldi	r24, 0x0A	; 10
     750:	e1 d5       	rcall	.+3010   	; 0x1314 <xQueueGenericCreate>
     752:	90 93 1f 04 	sts	0x041F, r25	; 0x80041f <sonarAfstand+0x1>
     756:	80 93 1e 04 	sts	0x041E, r24	; 0x80041e <sonarAfstand>
     75a:	40 e0       	ldi	r20, 0x00	; 0
     75c:	62 e0       	ldi	r22, 0x02	; 2
     75e:	8a e0       	ldi	r24, 0x0A	; 10
     760:	d9 d5       	rcall	.+2994   	; 0x1314 <xQueueGenericCreate>
     762:	90 93 1d 04 	sts	0x041D, r25	; 0x80041d <servoHoek+0x1>
     766:	80 93 1c 04 	sts	0x041C, r24	; 0x80041c <servoHoek>
     76a:	89 2b       	or	r24, r25
     76c:	41 f4       	brne	.+16     	; 0x77e <initQ+0x48>
     76e:	40 e0       	ldi	r20, 0x00	; 0
     770:	62 e0       	ldi	r22, 0x02	; 2
     772:	8a e0       	ldi	r24, 0x0A	; 10
     774:	cf d5       	rcall	.+2974   	; 0x1314 <xQueueGenericCreate>
     776:	90 93 1d 04 	sts	0x041D, r25	; 0x80041d <servoHoek+0x1>
     77a:	80 93 1c 04 	sts	0x041C, r24	; 0x80041c <servoHoek>
     77e:	08 95       	ret

00000780 <UART_Init>:
     780:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     784:	87 e6       	ldi	r24, 0x67	; 103
     786:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     78a:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     78e:	86 e0       	ldi	r24, 0x06	; 6
     790:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     794:	88 e1       	ldi	r24, 0x18	; 24
     796:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     79a:	08 95       	ret

0000079c <UART_Transmit>:
     79c:	e8 ec       	ldi	r30, 0xC8	; 200
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	90 81       	ld	r25, Z
     7a2:	95 ff       	sbrs	r25, 5
     7a4:	fd cf       	rjmp	.-6      	; 0x7a0 <UART_Transmit+0x4>
     7a6:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     7aa:	08 95       	ret

000007ac <__vector_36>:
     7ac:	1f 92       	push	r1
     7ae:	0f 92       	push	r0
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	0f 92       	push	r0
     7b4:	11 24       	eor	r1, r1
     7b6:	0b b6       	in	r0, 0x3b	; 59
     7b8:	0f 92       	push	r0
     7ba:	2f 93       	push	r18
     7bc:	3f 93       	push	r19
     7be:	4f 93       	push	r20
     7c0:	5f 93       	push	r21
     7c2:	6f 93       	push	r22
     7c4:	7f 93       	push	r23
     7c6:	8f 93       	push	r24
     7c8:	9f 93       	push	r25
     7ca:	af 93       	push	r26
     7cc:	bf 93       	push	r27
     7ce:	ef 93       	push	r30
     7d0:	ff 93       	push	r31
     7d2:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     7d6:	80 93 22 04 	sts	0x0422, r24	; 0x800422 <ontvang>
     7da:	e0 df       	rcall	.-64     	; 0x79c <UART_Transmit>
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	90 93 a9 02 	sts	0x02A9, r25	; 0x8002a9 <state+0x1>
     7e4:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <state>
     7e8:	ff 91       	pop	r31
     7ea:	ef 91       	pop	r30
     7ec:	bf 91       	pop	r27
     7ee:	af 91       	pop	r26
     7f0:	9f 91       	pop	r25
     7f2:	8f 91       	pop	r24
     7f4:	7f 91       	pop	r23
     7f6:	6f 91       	pop	r22
     7f8:	5f 91       	pop	r21
     7fa:	4f 91       	pop	r20
     7fc:	3f 91       	pop	r19
     7fe:	2f 91       	pop	r18
     800:	0f 90       	pop	r0
     802:	0b be       	out	0x3b, r0	; 59
     804:	0f 90       	pop	r0
     806:	0f be       	out	0x3f, r0	; 63
     808:	0f 90       	pop	r0
     80a:	1f 90       	pop	r1
     80c:	18 95       	reti

0000080e <UART_Transmit_String>:
     80e:	cf 93       	push	r28
     810:	df 93       	push	r29
     812:	ec 01       	movw	r28, r24
     814:	88 81       	ld	r24, Y
     816:	88 23       	and	r24, r24
     818:	29 f0       	breq	.+10     	; 0x824 <UART_Transmit_String+0x16>
     81a:	21 96       	adiw	r28, 0x01	; 1
     81c:	bf df       	rcall	.-130    	; 0x79c <UART_Transmit>
     81e:	89 91       	ld	r24, Y+
     820:	81 11       	cpse	r24, r1
     822:	fc cf       	rjmp	.-8      	; 0x81c <UART_Transmit_String+0xe>
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	08 95       	ret

0000082a <UART_Transmit_Integer>:
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	cd b7       	in	r28, 0x3d	; 61
     830:	de b7       	in	r29, 0x3e	; 62
     832:	61 97       	sbiw	r28, 0x11	; 17
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	f8 94       	cli
     838:	de bf       	out	0x3e, r29	; 62
     83a:	0f be       	out	0x3f, r0	; 63
     83c:	cd bf       	out	0x3d, r28	; 61
     83e:	dc 01       	movw	r26, r24
     840:	cb 01       	movw	r24, r22
     842:	4a e0       	ldi	r20, 0x0A	; 10
     844:	be 01       	movw	r22, r28
     846:	6f 5f       	subi	r22, 0xFF	; 255
     848:	7f 4f       	sbci	r23, 0xFF	; 255
     84a:	0e 94 74 13 	call	0x26e8	; 0x26e8 <__itoa_ncheck>
     84e:	ce 01       	movw	r24, r28
     850:	01 96       	adiw	r24, 0x01	; 1
     852:	dd df       	rcall	.-70     	; 0x80e <UART_Transmit_String>
     854:	61 96       	adiw	r28, 0x11	; 17
     856:	0f b6       	in	r0, 0x3f	; 63
     858:	f8 94       	cli
     85a:	de bf       	out	0x3e, r29	; 62
     85c:	0f be       	out	0x3f, r0	; 63
     85e:	cd bf       	out	0x3d, r28	; 61
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	08 95       	ret

00000866 <servoTaak>:
     866:	0a e8       	ldi	r16, 0x8A	; 138
     868:	10 e0       	ldi	r17, 0x00	; 0
     86a:	c1 e0       	ldi	r28, 0x01	; 1
     86c:	d0 e0       	ldi	r29, 0x00	; 0
     86e:	e1 2c       	mov	r14, r1
     870:	f1 2c       	mov	r15, r1
     872:	f0 92 1b 04 	sts	0x041B, r15	; 0x80041b <hoek+0x1>
     876:	e0 92 1a 04 	sts	0x041A, r14	; 0x80041a <hoek>
     87a:	c7 01       	movw	r24, r14
     87c:	99 27       	eor	r25, r25
     87e:	9c 01       	movw	r18, r24
     880:	22 0f       	add	r18, r18
     882:	33 1f       	adc	r19, r19
     884:	22 0f       	add	r18, r18
     886:	33 1f       	adc	r19, r19
     888:	22 0f       	add	r18, r18
     88a:	33 1f       	adc	r19, r19
     88c:	82 1b       	sub	r24, r18
     88e:	93 0b       	sbc	r25, r19
     890:	95 5b       	subi	r25, 0xB5	; 181
     892:	f8 01       	movw	r30, r16
     894:	91 83       	std	Z+1, r25	; 0x01
     896:	80 83       	st	Z, r24
     898:	ff ef       	ldi	r31, 0xFF	; 255
     89a:	24 e3       	ldi	r18, 0x34	; 52
     89c:	8c e0       	ldi	r24, 0x0C	; 12
     89e:	f1 50       	subi	r31, 0x01	; 1
     8a0:	20 40       	sbci	r18, 0x00	; 0
     8a2:	80 40       	sbci	r24, 0x00	; 0
     8a4:	e1 f7       	brne	.-8      	; 0x89e <servoTaak+0x38>
     8a6:	00 c0       	rjmp	.+0      	; 0x8a8 <servoTaak+0x42>
     8a8:	00 00       	nop
     8aa:	87 e0       	ldi	r24, 0x07	; 7
     8ac:	92 e0       	ldi	r25, 0x02	; 2
     8ae:	af df       	rcall	.-162    	; 0x80e <UART_Transmit_String>
     8b0:	60 91 1a 04 	lds	r22, 0x041A	; 0x80041a <hoek>
     8b4:	70 91 1b 04 	lds	r23, 0x041B	; 0x80041b <hoek+0x1>
     8b8:	07 2e       	mov	r0, r23
     8ba:	00 0c       	add	r0, r0
     8bc:	88 0b       	sbc	r24, r24
     8be:	99 0b       	sbc	r25, r25
     8c0:	b4 df       	rcall	.-152    	; 0x82a <UART_Transmit_Integer>
     8c2:	8e e0       	ldi	r24, 0x0E	; 14
     8c4:	92 e0       	ldi	r25, 0x02	; 2
     8c6:	a3 df       	rcall	.-186    	; 0x80e <UART_Transmit_String>
     8c8:	60 91 23 04 	lds	r22, 0x0423	; 0x800423 <afstand>
     8cc:	70 91 24 04 	lds	r23, 0x0424	; 0x800424 <afstand+0x1>
     8d0:	07 2e       	mov	r0, r23
     8d2:	00 0c       	add	r0, r0
     8d4:	88 0b       	sbc	r24, r24
     8d6:	99 0b       	sbc	r25, r25
     8d8:	a8 df       	rcall	.-176    	; 0x82a <UART_Transmit_Integer>
     8da:	89 e1       	ldi	r24, 0x19	; 25
     8dc:	92 e0       	ldi	r25, 0x02	; 2
     8de:	97 df       	rcall	.-210    	; 0x80e <UART_Transmit_String>
     8e0:	60 91 16 04 	lds	r22, 0x0416	; 0x800416 <temperatuur>
     8e4:	70 91 17 04 	lds	r23, 0x0417	; 0x800417 <temperatuur+0x1>
     8e8:	07 2e       	mov	r0, r23
     8ea:	00 0c       	add	r0, r0
     8ec:	88 0b       	sbc	r24, r24
     8ee:	99 0b       	sbc	r25, r25
     8f0:	9c df       	rcall	.-200    	; 0x82a <UART_Transmit_Integer>
     8f2:	88 e2       	ldi	r24, 0x28	; 40
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	8b df       	rcall	.-234    	; 0x80e <UART_Transmit_String>
     8f8:	60 91 18 04 	lds	r22, 0x0418	; 0x800418 <humidity>
     8fc:	70 91 19 04 	lds	r23, 0x0419	; 0x800419 <humidity+0x1>
     900:	07 2e       	mov	r0, r23
     902:	00 0c       	add	r0, r0
     904:	88 0b       	sbc	r24, r24
     906:	99 0b       	sbc	r25, r25
     908:	90 df       	rcall	.-224    	; 0x82a <UART_Transmit_Integer>
     90a:	8e e3       	ldi	r24, 0x3E	; 62
     90c:	92 e0       	ldi	r25, 0x02	; 2
     90e:	7f df       	rcall	.-258    	; 0x80e <UART_Transmit_String>
     910:	d0 93 21 04 	sts	0x0421, r29	; 0x800421 <watchdogServo+0x1>
     914:	c0 93 20 04 	sts	0x0420, r28	; 0x800420 <watchdogServo>
     918:	9b e1       	ldi	r25, 0x1B	; 27
     91a:	e9 0e       	add	r14, r25
     91c:	f1 1c       	adc	r15, r1
     91e:	e8 ed       	ldi	r30, 0xD8	; 216
     920:	ee 16       	cp	r14, r30
     922:	f1 04       	cpc	r15, r1
     924:	09 f0       	breq	.+2      	; 0x928 <servoTaak+0xc2>
     926:	a5 cf       	rjmp	.-182    	; 0x872 <servoTaak+0xc>
     928:	a2 cf       	rjmp	.-188    	; 0x86e <servoTaak+0x8>

0000092a <INT1_init>:
     92a:	e8 e6       	ldi	r30, 0x68	; 104
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	80 81       	ld	r24, Z
     930:	81 60       	ori	r24, 0x01	; 1
     932:	80 83       	st	Z, r24
     934:	eb e6       	ldi	r30, 0x6B	; 107
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	80 81       	ld	r24, Z
     93a:	82 60       	ori	r24, 0x02	; 2
     93c:	80 83       	st	Z, r24
     93e:	08 95       	ret

00000940 <__vector_9>:
     940:	1f 92       	push	r1
     942:	0f 92       	push	r0
     944:	0f b6       	in	r0, 0x3f	; 63
     946:	0f 92       	push	r0
     948:	11 24       	eor	r1, r1
     94a:	0b b6       	in	r0, 0x3b	; 59
     94c:	0f 92       	push	r0
     94e:	2f 93       	push	r18
     950:	3f 93       	push	r19
     952:	4f 93       	push	r20
     954:	5f 93       	push	r21
     956:	6f 93       	push	r22
     958:	7f 93       	push	r23
     95a:	8f 93       	push	r24
     95c:	9f 93       	push	r25
     95e:	af 93       	push	r26
     960:	bf 93       	push	r27
     962:	ef 93       	push	r30
     964:	ff 93       	push	r31
     966:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <running>
     96a:	88 23       	and	r24, r24
     96c:	d1 f1       	breq	.+116    	; 0x9e2 <__vector_9+0xa2>
     96e:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <up>
     972:	81 11       	cpse	r24, r1
     974:	10 c0       	rjmp	.+32     	; 0x996 <__vector_9+0x56>
     976:	81 e0       	ldi	r24, 0x01	; 1
     978:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <up>
     97c:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <timerCounter>
     980:	10 92 a3 02 	sts	0x02A3, r1	; 0x8002a3 <timerCounter+0x1>
     984:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <timerCounter+0x2>
     988:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <timerCounter+0x3>
     98c:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     990:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     994:	26 c0       	rjmp	.+76     	; 0x9e2 <__vector_9+0xa2>
     996:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <up>
     99a:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <timerCounter>
     99e:	30 91 a3 02 	lds	r19, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     9a2:	40 91 a4 02 	lds	r20, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     9a6:	50 91 a5 02 	lds	r21, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     9aa:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     9ae:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     9b2:	af ef       	ldi	r26, 0xFF	; 255
     9b4:	bf ef       	ldi	r27, 0xFF	; 255
     9b6:	0e 94 39 12 	call	0x2472	; 0x2472 <__muluhisi3>
     9ba:	6e 0f       	add	r22, r30
     9bc:	7f 1f       	adc	r23, r31
     9be:	81 1d       	adc	r24, r1
     9c0:	91 1d       	adc	r25, r1
     9c2:	24 e7       	ldi	r18, 0x74	; 116
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	40 e0       	ldi	r20, 0x00	; 0
     9c8:	50 e0       	ldi	r21, 0x00	; 0
     9ca:	0e 94 00 12 	call	0x2400	; 0x2400 <__udivmodsi4>
     9ce:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <result>
     9d2:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <result+0x1>
     9d6:	40 93 a0 02 	sts	0x02A0, r20	; 0x8002a0 <result+0x2>
     9da:	50 93 a1 02 	sts	0x02A1, r21	; 0x8002a1 <result+0x3>
     9de:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <running>
     9e2:	ff 91       	pop	r31
     9e4:	ef 91       	pop	r30
     9e6:	bf 91       	pop	r27
     9e8:	af 91       	pop	r26
     9ea:	9f 91       	pop	r25
     9ec:	8f 91       	pop	r24
     9ee:	7f 91       	pop	r23
     9f0:	6f 91       	pop	r22
     9f2:	5f 91       	pop	r21
     9f4:	4f 91       	pop	r20
     9f6:	3f 91       	pop	r19
     9f8:	2f 91       	pop	r18
     9fa:	0f 90       	pop	r0
     9fc:	0b be       	out	0x3b, r0	; 59
     9fe:	0f 90       	pop	r0
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	0f 90       	pop	r0
     a04:	1f 90       	pop	r1
     a06:	18 95       	reti

00000a08 <pulse>:
     a08:	28 98       	cbi	0x05, 0	; 5
     a0a:	85 e0       	ldi	r24, 0x05	; 5
     a0c:	8a 95       	dec	r24
     a0e:	f1 f7       	brne	.-4      	; 0xa0c <pulse+0x4>
     a10:	00 00       	nop
     a12:	28 9a       	sbi	0x05, 0	; 5
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <running>
     a1a:	85 e3       	ldi	r24, 0x35	; 53
     a1c:	8a 95       	dec	r24
     a1e:	f1 f7       	brne	.-4      	; 0xa1c <pulse+0x14>
     a20:	00 00       	nop
     a22:	28 98       	cbi	0x05, 0	; 5
     a24:	08 95       	ret

00000a26 <sonarTaak>:
     a26:	c1 e0       	ldi	r28, 0x01	; 1
     a28:	d0 e0       	ldi	r29, 0x00	; 0
     a2a:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <running>
     a2e:	81 11       	cpse	r24, r1
     a30:	16 c0       	rjmp	.+44     	; 0xa5e <sonarTaak+0x38>
     a32:	2f ef       	ldi	r18, 0xFF	; 255
     a34:	80 e7       	ldi	r24, 0x70	; 112
     a36:	92 e0       	ldi	r25, 0x02	; 2
     a38:	21 50       	subi	r18, 0x01	; 1
     a3a:	80 40       	sbci	r24, 0x00	; 0
     a3c:	90 40       	sbci	r25, 0x00	; 0
     a3e:	e1 f7       	brne	.-8      	; 0xa38 <sonarTaak+0x12>
     a40:	00 c0       	rjmp	.+0      	; 0xa42 <sonarTaak+0x1c>
     a42:	00 00       	nop
     a44:	e1 df       	rcall	.-62     	; 0xa08 <pulse>
     a46:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <result>
     a4a:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <result+0x1>
     a4e:	a0 91 a0 02 	lds	r26, 0x02A0	; 0x8002a0 <result+0x2>
     a52:	b0 91 a1 02 	lds	r27, 0x02A1	; 0x8002a1 <result+0x3>
     a56:	90 93 24 04 	sts	0x0424, r25	; 0x800424 <afstand+0x1>
     a5a:	80 93 23 04 	sts	0x0423, r24	; 0x800423 <afstand>
     a5e:	d0 93 13 03 	sts	0x0313, r29	; 0x800313 <watchdogSonar+0x1>
     a62:	c0 93 12 03 	sts	0x0312, r28	; 0x800312 <watchdogSonar>
     a66:	e1 cf       	rjmp	.-62     	; 0xa2a <sonarTaak+0x4>

00000a68 <timer3_init>:
     a68:	e1 e9       	ldi	r30, 0x91	; 145
     a6a:	f0 e0       	ldi	r31, 0x00	; 0
     a6c:	80 81       	ld	r24, Z
     a6e:	82 60       	ori	r24, 0x02	; 2
     a70:	80 83       	st	Z, r24
     a72:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a76:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a7a:	e1 e7       	ldi	r30, 0x71	; 113
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	80 81       	ld	r24, Z
     a80:	81 60       	ori	r24, 0x01	; 1
     a82:	80 83       	st	Z, r24
     a84:	08 95       	ret

00000a86 <__vector_35>:
     a86:	1f 92       	push	r1
     a88:	0f 92       	push	r0
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	0f 92       	push	r0
     a8e:	11 24       	eor	r1, r1
     a90:	0b b6       	in	r0, 0x3b	; 59
     a92:	0f 92       	push	r0
     a94:	2f 93       	push	r18
     a96:	3f 93       	push	r19
     a98:	4f 93       	push	r20
     a9a:	5f 93       	push	r21
     a9c:	6f 93       	push	r22
     a9e:	7f 93       	push	r23
     aa0:	8f 93       	push	r24
     aa2:	9f 93       	push	r25
     aa4:	af 93       	push	r26
     aa6:	bf 93       	push	r27
     aa8:	ef 93       	push	r30
     aaa:	ff 93       	push	r31
     aac:	80 91 a6 02 	lds	r24, 0x02A6	; 0x8002a6 <up>
     ab0:	88 23       	and	r24, r24
     ab2:	e9 f1       	breq	.+122    	; 0xb2e <__vector_35+0xa8>
     ab4:	80 91 a2 02 	lds	r24, 0x02A2	; 0x8002a2 <timerCounter>
     ab8:	90 91 a3 02 	lds	r25, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     abc:	a0 91 a4 02 	lds	r26, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     ac0:	b0 91 a5 02 	lds	r27, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     ac4:	01 96       	adiw	r24, 0x01	; 1
     ac6:	a1 1d       	adc	r26, r1
     ac8:	b1 1d       	adc	r27, r1
     aca:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <timerCounter>
     ace:	90 93 a3 02 	sts	0x02A3, r25	; 0x8002a3 <timerCounter+0x1>
     ad2:	a0 93 a4 02 	sts	0x02A4, r26	; 0x8002a4 <timerCounter+0x2>
     ad6:	b0 93 a5 02 	sts	0x02A5, r27	; 0x8002a5 <timerCounter+0x3>
     ada:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <timerCounter>
     ade:	30 91 a3 02 	lds	r19, 0x02A3	; 0x8002a3 <timerCounter+0x1>
     ae2:	40 91 a4 02 	lds	r20, 0x02A4	; 0x8002a4 <timerCounter+0x2>
     ae6:	50 91 a5 02 	lds	r21, 0x02A5	; 0x8002a5 <timerCounter+0x3>
     aea:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     aee:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     af2:	af ef       	ldi	r26, 0xFF	; 255
     af4:	bf ef       	ldi	r27, 0xFF	; 255
     af6:	0e 94 39 12 	call	0x2472	; 0x2472 <__muluhisi3>
     afa:	dc 01       	movw	r26, r24
     afc:	cb 01       	movw	r24, r22
     afe:	8e 0f       	add	r24, r30
     b00:	9f 1f       	adc	r25, r31
     b02:	a1 1d       	adc	r26, r1
     b04:	b1 1d       	adc	r27, r1
     b06:	81 30       	cpi	r24, 0x01	; 1
     b08:	94 4d       	sbci	r25, 0xD4	; 212
     b0a:	a0 43       	sbci	r26, 0x30	; 48
     b0c:	b1 05       	cpc	r27, r1
     b0e:	78 f0       	brcs	.+30     	; 0xb2e <__vector_35+0xa8>
     b10:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <up>
     b14:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <running>
     b18:	8f ef       	ldi	r24, 0xFF	; 255
     b1a:	9f ef       	ldi	r25, 0xFF	; 255
     b1c:	dc 01       	movw	r26, r24
     b1e:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <result>
     b22:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <result+0x1>
     b26:	a0 93 a0 02 	sts	0x02A0, r26	; 0x8002a0 <result+0x2>
     b2a:	b0 93 a1 02 	sts	0x02A1, r27	; 0x8002a1 <result+0x3>
     b2e:	ff 91       	pop	r31
     b30:	ef 91       	pop	r30
     b32:	bf 91       	pop	r27
     b34:	af 91       	pop	r26
     b36:	9f 91       	pop	r25
     b38:	8f 91       	pop	r24
     b3a:	7f 91       	pop	r23
     b3c:	6f 91       	pop	r22
     b3e:	5f 91       	pop	r21
     b40:	4f 91       	pop	r20
     b42:	3f 91       	pop	r19
     b44:	2f 91       	pop	r18
     b46:	0f 90       	pop	r0
     b48:	0b be       	out	0x3b, r0	; 59
     b4a:	0f 90       	pop	r0
     b4c:	0f be       	out	0x3f, r0	; 63
     b4e:	0f 90       	pop	r0
     b50:	1f 90       	pop	r1
     b52:	18 95       	reti

00000b54 <initServo>:
}

void initServo()
{
	DDRB |= (1 << PB6);
     b54:	26 9a       	sbi	0x04, 6	; 4
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
     b56:	82 e3       	ldi	r24, 0x32	; 50
     b58:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = (1 << WGM13) | (1 << CS11);
     b5c:	82 e1       	ldi	r24, 0x12	; 18
     b5e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	ICR1 = 20000;
     b62:	80 e2       	ldi	r24, 0x20	; 32
     b64:	9e e4       	ldi	r25, 0x4E	; 78
     b66:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     b6a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	TCNT1 = 0;
     b6e:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     b72:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     b76:	80 e0       	ldi	r24, 0x00	; 0
     b78:	9b e4       	ldi	r25, 0x4B	; 75
     b7a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     b7e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
	TCCR1B = (1 << WGM13) | (1 << CS11);
	ICR1 = 20000;
	TCNT1 = 0;
	turnServo(0);
	TIMSK1 |= (1 << 1);
     b82:	ef e6       	ldi	r30, 0x6F	; 111
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	80 81       	ld	r24, Z
     b88:	82 60       	ori	r24, 0x02	; 2
     b8a:	80 83       	st	Z, r24
     b8c:	08 95       	ret

00000b8e <init_master>:
}



void init_master() {
	TWSR = 0;
     b8e:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
     b92:	88 e4       	ldi	r24, 0x48	; 72
     b94:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
	TWCR = (1<<TWEN);
     b98:	84 e0       	ldi	r24, 0x04	; 4
     b9a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     b9e:	08 95       	ret

00000ba0 <main>:
//echo = digital pin 52
//servo = digital pin 12


int main() 
{
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
	sem = xSemaphoreCreateBinary();
     ba6:	43 e0       	ldi	r20, 0x03	; 3
     ba8:	60 e0       	ldi	r22, 0x00	; 0
     baa:	81 e0       	ldi	r24, 0x01	; 1
     bac:	b3 d3       	rcall	.+1894   	; 0x1314 <xQueueGenericCreate>
     bae:	90 93 11 03 	sts	0x0311, r25	; 0x800311 <sem+0x1>
     bb2:	80 93 10 03 	sts	0x0310, r24	; 0x800310 <sem>
	xSemaphoreGive(sem);
     bb6:	20 e0       	ldi	r18, 0x00	; 0
     bb8:	40 e0       	ldi	r20, 0x00	; 0
     bba:	50 e0       	ldi	r21, 0x00	; 0
     bbc:	60 e0       	ldi	r22, 0x00	; 0
     bbe:	70 e0       	ldi	r23, 0x00	; 0
     bc0:	d4 d3       	rcall	.+1960   	; 0x136a <xQueueGenericSend>
	DDRD|= 0x03;
     bc2:	8a b1       	in	r24, 0x0a	; 10
     bc4:	83 60       	ori	r24, 0x03	; 3
	DDRB |= (1 << TRIGGER);											// Trigger pin
	UART_Init();
     bc6:	8a b9       	out	0x0a, r24	; 10
	INT1_init();
     bc8:	20 9a       	sbi	0x04, 0	; 4
	timer3_init();
     bca:	da dd       	rcall	.-1100   	; 0x780 <UART_Init>
	initServo();
     bcc:	ae de       	rcall	.-676    	; 0x92a <INT1_init>
     bce:	4c df       	rcall	.-360    	; 0xa68 <timer3_init>
	sei();
     bd0:	c1 df       	rcall	.-126    	; 0xb54 <initServo>
	initQ();
     bd2:	78 94       	sei
     bd4:	b0 dd       	rcall	.-1184   	; 0x736 <initQ>
	init_master();
     bd6:	db df       	rcall	.-74     	; 0xb8e <init_master>
     bd8:	10 92 13 03 	sts	0x0313, r1	; 0x800313 <watchdogSonar+0x1>
	watchdogSonar=0;
     bdc:	10 92 12 03 	sts	0x0312, r1	; 0x800312 <watchdogSonar>
     be0:	10 92 21 04 	sts	0x0421, r1	; 0x800421 <watchdogServo+0x1>
	watchdogServo=0;
     be4:	10 92 20 04 	sts	0x0420, r1	; 0x800420 <watchdogServo>
     be8:	10 92 15 04 	sts	0x0415, r1	; 0x800415 <watchdogTemp+0x1>
	watchdogTemp=0;
     bec:	10 92 14 04 	sts	0x0414, r1	; 0x800414 <watchdogTemp>
     bf0:	98 e2       	ldi	r25, 0x28	; 40
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
     bf2:	88 e1       	ldi	r24, 0x18	; 24
     bf4:	0f b6       	in	r0, 0x3f	; 63
     bf6:	f8 94       	cli
     bf8:	a8 95       	wdr
     bfa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     bfe:	0f be       	out	0x3f, r0	; 63
     c00:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	wdt_enable(WDTO_4S);
	// Replace with your application code
//	UART_Transmit('a');
	UART_Transmit_String("setup done\n\r");
     c04:	84 e3       	ldi	r24, 0x34	; 52
     c06:	92 e0       	ldi	r25, 0x02	; 2
     c08:	02 de       	rcall	.-1020   	; 0x80e <UART_Transmit_String>
     c0a:	e1 2c       	mov	r14, r1
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,3,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
     c0c:	f1 2c       	mov	r15, r1
     c0e:	03 e0       	ldi	r16, 0x03	; 3
     c10:	20 e0       	ldi	r18, 0x00	; 0
     c12:	30 e0       	ldi	r19, 0x00	; 0
     c14:	40 e0       	ldi	r20, 0x00	; 0
     c16:	51 e0       	ldi	r21, 0x01	; 1
     c18:	61 e4       	ldi	r22, 0x41	; 65
     c1a:	72 e0       	ldi	r23, 0x02	; 2
     c1c:	83 e1       	ldi	r24, 0x13	; 19
     c1e:	95 e0       	ldi	r25, 0x05	; 5
     c20:	8f d6       	rcall	.+3358   	; 0x1940 <xTaskCreate>
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,3,NULL);			//code van Joris & Benjamin
     c22:	20 e0       	ldi	r18, 0x00	; 0
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	40 e0       	ldi	r20, 0x00	; 0
     c28:	51 e0       	ldi	r21, 0x01	; 1
     c2a:	6e e4       	ldi	r22, 0x4E	; 78
     c2c:	72 e0       	ldi	r23, 0x02	; 2
     c2e:	83 e3       	ldi	r24, 0x33	; 51
     c30:	94 e0       	ldi	r25, 0x04	; 4
     c32:	86 d6       	rcall	.+3340   	; 0x1940 <xTaskCreate>
	xTaskCreate(temperatuurTaak,"temperatuur Sensor",256,NULL,3,NULL);
     c34:	20 e0       	ldi	r18, 0x00	; 0
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	40 e0       	ldi	r20, 0x00	; 0
     c3a:	51 e0       	ldi	r21, 0x01	; 1
     c3c:	6a e5       	ldi	r22, 0x5A	; 90
     c3e:	72 e0       	ldi	r23, 0x02	; 2
     c40:	88 ea       	ldi	r24, 0xA8	; 168
     c42:	96 e0       	ldi	r25, 0x06	; 6
	xTaskCreate(watchdogTaak,"watchdog reset",256,NULL,4,NULL);
     c44:	7d d6       	rcall	.+3322   	; 0x1940 <xTaskCreate>
     c46:	04 e0       	ldi	r16, 0x04	; 4
     c48:	20 e0       	ldi	r18, 0x00	; 0
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	51 e0       	ldi	r21, 0x01	; 1
     c50:	6d e6       	ldi	r22, 0x6D	; 109
     c52:	72 e0       	ldi	r23, 0x02	; 2
     c54:	85 e7       	ldi	r24, 0x75	; 117
     c56:	93 e0       	ldi	r25, 0x03	; 3
     c58:	73 d6       	rcall	.+3302   	; 0x1940 <xTaskCreate>

	vTaskStartScheduler();
     c5a:	86 d7       	rcall	.+3852   	; 0x1b68 <vTaskStartScheduler>
     c5c:	80 e0       	ldi	r24, 0x00	; 0
}
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0f 91       	pop	r16
     c62:	ff 90       	pop	r15
     c64:	ef 90       	pop	r14
     c66:	08 95       	ret

00000c68 <ontvangen>:
     c68:	ef 92       	push	r14
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
	TWCR = (1<<TWEN);
}

void ontvangen(uint8_t ad,uint8_t b[],uint8_t max) {
     c6a:	ff 92       	push	r15
     c6c:	0f 93       	push	r16
     c6e:	1f 93       	push	r17
     c70:	cf 93       	push	r28
     c72:	df 93       	push	r29
	uint8_t op[15];
	
	//	UART_Transmit('a');

	TWCR |= (1<<TWSTA);
     c74:	ec eb       	ldi	r30, 0xBC	; 188
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	90 81       	ld	r25, Z
     c7a:	90 62       	ori	r25, 0x20	; 32
     c7c:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     c7e:	90 81       	ld	r25, Z
     c80:	99 23       	and	r25, r25
     c82:	ec f7       	brge	.-6      	; 0xc7e <ontvangen+0x16>
	op[0] = TWSR;
     c84:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>

	
	//UART_Transmit('b');

	TWDR=(ad<<1)+1;
     c88:	88 0f       	add	r24, r24
     c8a:	8f 5f       	subi	r24, 0xFF	; 255
     c8c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     c90:	84 e8       	ldi	r24, 0x84	; 132
     c92:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     c96:	ec eb       	ldi	r30, 0xBC	; 188
     c98:	f0 e0       	ldi	r31, 0x00	; 0
     c9a:	80 81       	ld	r24, Z
     c9c:	88 23       	and	r24, r24
     c9e:	ec f7       	brge	.-6      	; 0xc9a <ontvangen+0x32>

	op[1] = TWSR;
     ca0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	b[0]=TWDR;
     ca4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     ca8:	db 01       	movw	r26, r22
     caa:	8c 93       	st	X, r24
	
	uint8_t tel=0;
     cac:	90 e0       	ldi	r25, 0x00	; 0
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     cae:	50 e0       	ldi	r21, 0x00	; 0
     cb0:	41 50       	subi	r20, 0x01	; 1
     cb2:	51 09       	sbc	r21, r1
			TWCR=(1<<TWINT)|(1<<TWEN);
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     cb4:	ec eb       	ldi	r30, 0xBC	; 188
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	0f 2e       	mov	r0, r31
     cba:	f4 ec       	ldi	r31, 0xC4	; 196
     cbc:	ff 2e       	mov	r15, r31
     cbe:	f0 2d       	mov	r31, r0
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
			TWCR=(1<<TWINT)|(1<<TWEN);
     cc0:	0f 2e       	mov	r0, r31
     cc2:	f4 e8       	ldi	r31, 0x84	; 132
     cc4:	ef 2e       	mov	r14, r31
     cc6:	f0 2d       	mov	r31, r0
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
		//UART_Transmit('c3');
		op[tel] = TWSR;
     cc8:	09 eb       	ldi	r16, 0xB9	; 185
     cca:	10 e0       	ldi	r17, 0x00	; 0
		b[tel]=TWDR;
     ccc:	cb eb       	ldi	r28, 0xBB	; 187
     cce:	d0 e0       	ldi	r29, 0x00	; 0
	
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     cd0:	29 2f       	mov	r18, r25
     cd2:	30 e0       	ldi	r19, 0x00	; 0
     cd4:	24 17       	cp	r18, r20
     cd6:	35 07       	cpc	r19, r21
     cd8:	11 f4       	brne	.+4      	; 0xcde <ontvangen+0x76>
			TWCR=(1<<TWINT)|(1<<TWEN);
     cda:	e0 82       	st	Z, r14
     cdc:	01 c0       	rjmp	.+2      	; 0xce0 <ontvangen+0x78>
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     cde:	f0 82       	st	Z, r15
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
     ce0:	80 81       	ld	r24, Z
     ce2:	88 23       	and	r24, r24
     ce4:	ec f7       	brge	.-6      	; 0xce0 <ontvangen+0x78>
		//UART_Transmit('c3');
		op[tel] = TWSR;
     ce6:	d8 01       	movw	r26, r16
     ce8:	8c 91       	ld	r24, X
		b[tel]=TWDR;
     cea:	28 81       	ld	r18, Y
     cec:	db 01       	movw	r26, r22
     cee:	a9 0f       	add	r26, r25
     cf0:	b1 1d       	adc	r27, r1
     cf2:	2c 93       	st	X, r18
	}while(op[tel++] == 0x50);
     cf4:	9f 5f       	subi	r25, 0xFF	; 255
     cf6:	80 35       	cpi	r24, 0x50	; 80
     cf8:	59 f3       	breq	.-42     	; 0xcd0 <ontvangen+0x68>

	
	//UART_Transmit('d');

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     cfa:	84 e9       	ldi	r24, 0x94	; 148
     cfc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>

	//   for(uint8_t i=0;i<tel;++i) {
	//	 writeString("\n\r");writeInteger(op[i],16);
	//	 writeString(" data ");writeInteger(b[i],10);
	//   }
}
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	0f 91       	pop	r16
     d08:	ff 90       	pop	r15
     d0a:	ef 90       	pop	r14
     d0c:	08 95       	ret

00000d0e <verzenden>:

void verzenden(uint8_t ad,uint8_t b) {
	//  uint8_t op[5];

	TWCR |= (1<<TWSTA);
     d0e:	ec eb       	ldi	r30, 0xBC	; 188
     d10:	f0 e0       	ldi	r31, 0x00	; 0
     d12:	90 81       	ld	r25, Z
     d14:	90 62       	ori	r25, 0x20	; 32
     d16:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     d18:	90 81       	ld	r25, Z
     d1a:	99 23       	and	r25, r25
     d1c:	ec f7       	brge	.-6      	; 0xd18 <verzenden+0xa>
	//   op[0] = TWSR;
	TWDR=(ad<<1);
     d1e:	88 0f       	add	r24, r24
     d20:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     d24:	84 e8       	ldi	r24, 0x84	; 132
     d26:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     d2a:	ec eb       	ldi	r30, 0xBC	; 188
     d2c:	f0 e0       	ldi	r31, 0x00	; 0
     d2e:	80 81       	ld	r24, Z
     d30:	88 23       	and	r24, r24
     d32:	ec f7       	brge	.-6      	; 0xd2e <verzenden+0x20>
	//    op[1] = TWSR;

	TWDR=b;
     d34:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     d38:	84 e8       	ldi	r24, 0x84	; 132
     d3a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     d3e:	ec eb       	ldi	r30, 0xBC	; 188
     d40:	f0 e0       	ldi	r31, 0x00	; 0
     d42:	80 81       	ld	r24, Z
     d44:	88 23       	and	r24, r24
     d46:	ec f7       	brge	.-6      	; 0xd42 <verzenden+0x34>
	//  op[2] = TWSR;

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     d48:	84 e9       	ldi	r24, 0x94	; 148
     d4a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     d4e:	08 95       	ret

00000d50 <temperatuurTaak>:

	vTaskStartScheduler();
}


void temperatuurTaak(){
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	1f 92       	push	r1
     d56:	1f 92       	push	r1
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		humidity=((125*waarde)/65536.0) -6;

		watchdogTemp = 1;
     d5c:	01 e0       	ldi	r16, 0x01	; 1
     d5e:	10 e0       	ldi	r17, 0x00	; 0

	uint8_t data[2];
	uint32_t waarde =0;

	while(1){
		verzenden(0x40, 0xE3);
     d60:	63 ee       	ldi	r22, 0xE3	; 227
     d62:	80 e4       	ldi	r24, 0x40	; 64
     d64:	d4 df       	rcall	.-88     	; 0xd0e <verzenden>
		ontvangen(0x40, data, 2);
     d66:	42 e0       	ldi	r20, 0x02	; 2
     d68:	be 01       	movw	r22, r28
     d6a:	6f 5f       	subi	r22, 0xFF	; 255
     d6c:	7f 4f       	sbci	r23, 0xFF	; 255
     d6e:	80 e4       	ldi	r24, 0x40	; 64
     d70:	7b df       	rcall	.-266    	; 0xc68 <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		temperatuur=((175.72*waarde)/65536.0) -46.85;
     d72:	69 81       	ldd	r22, Y+1	; 0x01
     d74:	70 e0       	ldi	r23, 0x00	; 0
     d76:	76 2f       	mov	r23, r22
     d78:	66 27       	eor	r22, r22
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	68 2b       	or	r22, r24
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	0e 94 0f 11 	call	0x221e	; 0x221e <__floatunsisf>
     d86:	22 e5       	ldi	r18, 0x52	; 82
     d88:	38 eb       	ldi	r19, 0xB8	; 184
     d8a:	4f e2       	ldi	r20, 0x2F	; 47
     d8c:	53 e4       	ldi	r21, 0x43	; 67
     d8e:	0e 94 9d 11 	call	0x233a	; 0x233a <__mulsf3>
     d92:	20 e0       	ldi	r18, 0x00	; 0
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	40 e8       	ldi	r20, 0x80	; 128
     d98:	57 e3       	ldi	r21, 0x37	; 55
     d9a:	0e 94 9d 11 	call	0x233a	; 0x233a <__mulsf3>
     d9e:	26 e6       	ldi	r18, 0x66	; 102
     da0:	36 e6       	ldi	r19, 0x66	; 102
     da2:	4b e3       	ldi	r20, 0x3B	; 59
     da4:	52 e4       	ldi	r21, 0x42	; 66
     da6:	0e 94 79 10 	call	0x20f2	; 0x20f2 <__subsf3>
     daa:	0e 94 de 10 	call	0x21bc	; 0x21bc <__fixsfsi>
     dae:	70 93 17 04 	sts	0x0417, r23	; 0x800417 <temperatuur+0x1>
     db2:	60 93 16 04 	sts	0x0416, r22	; 0x800416 <temperatuur>

		verzenden(0x40, 0xE5);
     db6:	65 ee       	ldi	r22, 0xE5	; 229
     db8:	80 e4       	ldi	r24, 0x40	; 64
     dba:	a9 df       	rcall	.-174    	; 0xd0e <verzenden>
		ontvangen(0x40, data, 2);
     dbc:	42 e0       	ldi	r20, 0x02	; 2
     dbe:	be 01       	movw	r22, r28
     dc0:	6f 5f       	subi	r22, 0xFF	; 255
     dc2:	7f 4f       	sbci	r23, 0xFF	; 255
     dc4:	80 e4       	ldi	r24, 0x40	; 64
     dc6:	50 df       	rcall	.-352    	; 0xc68 <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		humidity=((125*waarde)/65536.0) -6;
     dc8:	29 81       	ldd	r18, Y+1	; 0x01
     dca:	30 e0       	ldi	r19, 0x00	; 0
     dcc:	32 2f       	mov	r19, r18
     dce:	22 27       	eor	r18, r18
     dd0:	8a 81       	ldd	r24, Y+2	; 0x02
     dd2:	28 2b       	or	r18, r24
     dd4:	ad e7       	ldi	r26, 0x7D	; 125
     dd6:	b0 e0       	ldi	r27, 0x00	; 0
     dd8:	0e 94 2a 12 	call	0x2454	; 0x2454 <__umulhisi3>
     ddc:	0e 94 0f 11 	call	0x221e	; 0x221e <__floatunsisf>
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	40 e8       	ldi	r20, 0x80	; 128
     de6:	57 e3       	ldi	r21, 0x37	; 55
     de8:	0e 94 9d 11 	call	0x233a	; 0x233a <__mulsf3>
     dec:	20 e0       	ldi	r18, 0x00	; 0
     dee:	30 e0       	ldi	r19, 0x00	; 0
     df0:	40 ec       	ldi	r20, 0xC0	; 192
     df2:	50 e4       	ldi	r21, 0x40	; 64
     df4:	0e 94 79 10 	call	0x20f2	; 0x20f2 <__subsf3>
     df8:	0e 94 de 10 	call	0x21bc	; 0x21bc <__fixsfsi>
     dfc:	70 93 19 04 	sts	0x0419, r23	; 0x800419 <humidity+0x1>
     e00:	60 93 18 04 	sts	0x0418, r22	; 0x800418 <humidity>

		watchdogTemp = 1;
     e04:	10 93 15 04 	sts	0x0415, r17	; 0x800415 <watchdogTemp+0x1>
     e08:	00 93 14 04 	sts	0x0414, r16	; 0x800414 <watchdogTemp>
     e0c:	a9 cf       	rjmp	.-174    	; 0xd60 <temperatuurTaak+0x10>

00000e0e <__vector_17>:
	// writeString(" ");writeInteger(op[1],16);
	// writeString(" ");writeInteger(op[2],16);
}

ISR(TIMER1_COMPA_vect)
{
     e0e:	1f 92       	push	r1
     e10:	0f 92       	push	r0
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	0f 92       	push	r0
     e16:	11 24       	eor	r1, r1
     e18:	8f 93       	push	r24
     e1a:	9f 93       	push	r25
	PORTB ^= (1 << PB6);
     e1c:	95 b1       	in	r25, 0x05	; 5
     e1e:	80 e4       	ldi	r24, 0x40	; 64
     e20:	89 27       	eor	r24, r25
     e22:	85 b9       	out	0x05, r24	; 5
}
     e24:	9f 91       	pop	r25
     e26:	8f 91       	pop	r24
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     e32:	31 e1       	ldi	r19, 0x11	; 17
     e34:	fc 01       	movw	r30, r24
     e36:	30 83       	st	Z, r19
     e38:	31 97       	sbiw	r30, 0x01	; 1
     e3a:	22 e2       	ldi	r18, 0x22	; 34
     e3c:	20 83       	st	Z, r18
     e3e:	31 97       	sbiw	r30, 0x01	; 1
     e40:	a3 e3       	ldi	r26, 0x33	; 51
     e42:	a0 83       	st	Z, r26
     e44:	31 97       	sbiw	r30, 0x01	; 1
     e46:	60 83       	st	Z, r22
     e48:	31 97       	sbiw	r30, 0x01	; 1
     e4a:	70 83       	st	Z, r23
     e4c:	31 97       	sbiw	r30, 0x01	; 1
     e4e:	10 82       	st	Z, r1
     e50:	31 97       	sbiw	r30, 0x01	; 1
     e52:	10 82       	st	Z, r1
     e54:	31 97       	sbiw	r30, 0x01	; 1
     e56:	60 e8       	ldi	r22, 0x80	; 128
     e58:	60 83       	st	Z, r22
     e5a:	31 97       	sbiw	r30, 0x01	; 1
     e5c:	10 82       	st	Z, r1
     e5e:	31 97       	sbiw	r30, 0x01	; 1
     e60:	10 82       	st	Z, r1
     e62:	31 97       	sbiw	r30, 0x01	; 1
     e64:	10 82       	st	Z, r1
     e66:	31 97       	sbiw	r30, 0x01	; 1
     e68:	62 e0       	ldi	r22, 0x02	; 2
     e6a:	60 83       	st	Z, r22
     e6c:	31 97       	sbiw	r30, 0x01	; 1
     e6e:	63 e0       	ldi	r22, 0x03	; 3
     e70:	60 83       	st	Z, r22
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	64 e0       	ldi	r22, 0x04	; 4
     e76:	60 83       	st	Z, r22
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	65 e0       	ldi	r22, 0x05	; 5
     e7c:	60 83       	st	Z, r22
     e7e:	31 97       	sbiw	r30, 0x01	; 1
     e80:	66 e0       	ldi	r22, 0x06	; 6
     e82:	60 83       	st	Z, r22
     e84:	31 97       	sbiw	r30, 0x01	; 1
     e86:	67 e0       	ldi	r22, 0x07	; 7
     e88:	60 83       	st	Z, r22
     e8a:	31 97       	sbiw	r30, 0x01	; 1
     e8c:	68 e0       	ldi	r22, 0x08	; 8
     e8e:	60 83       	st	Z, r22
     e90:	31 97       	sbiw	r30, 0x01	; 1
     e92:	69 e0       	ldi	r22, 0x09	; 9
     e94:	60 83       	st	Z, r22
     e96:	31 97       	sbiw	r30, 0x01	; 1
     e98:	60 e1       	ldi	r22, 0x10	; 16
     e9a:	60 83       	st	Z, r22
     e9c:	31 97       	sbiw	r30, 0x01	; 1
     e9e:	30 83       	st	Z, r19
     ea0:	31 97       	sbiw	r30, 0x01	; 1
     ea2:	32 e1       	ldi	r19, 0x12	; 18
     ea4:	30 83       	st	Z, r19
     ea6:	31 97       	sbiw	r30, 0x01	; 1
     ea8:	33 e1       	ldi	r19, 0x13	; 19
     eaa:	30 83       	st	Z, r19
     eac:	31 97       	sbiw	r30, 0x01	; 1
     eae:	34 e1       	ldi	r19, 0x14	; 20
     eb0:	30 83       	st	Z, r19
     eb2:	31 97       	sbiw	r30, 0x01	; 1
     eb4:	35 e1       	ldi	r19, 0x15	; 21
     eb6:	30 83       	st	Z, r19
     eb8:	31 97       	sbiw	r30, 0x01	; 1
     eba:	36 e1       	ldi	r19, 0x16	; 22
     ebc:	30 83       	st	Z, r19
     ebe:	31 97       	sbiw	r30, 0x01	; 1
     ec0:	37 e1       	ldi	r19, 0x17	; 23
     ec2:	30 83       	st	Z, r19
     ec4:	31 97       	sbiw	r30, 0x01	; 1
     ec6:	38 e1       	ldi	r19, 0x18	; 24
     ec8:	30 83       	st	Z, r19
     eca:	31 97       	sbiw	r30, 0x01	; 1
     ecc:	39 e1       	ldi	r19, 0x19	; 25
     ece:	30 83       	st	Z, r19
     ed0:	31 97       	sbiw	r30, 0x01	; 1
     ed2:	30 e2       	ldi	r19, 0x20	; 32
     ed4:	30 83       	st	Z, r19
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	31 e2       	ldi	r19, 0x21	; 33
     eda:	30 83       	st	Z, r19
     edc:	31 97       	sbiw	r30, 0x01	; 1
     ede:	20 83       	st	Z, r18
     ee0:	31 97       	sbiw	r30, 0x01	; 1
     ee2:	23 e2       	ldi	r18, 0x23	; 35
     ee4:	20 83       	st	Z, r18
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	40 83       	st	Z, r20
     eea:	31 97       	sbiw	r30, 0x01	; 1
     eec:	50 83       	st	Z, r21
     eee:	31 97       	sbiw	r30, 0x01	; 1
     ef0:	26 e2       	ldi	r18, 0x26	; 38
     ef2:	20 83       	st	Z, r18
     ef4:	31 97       	sbiw	r30, 0x01	; 1
     ef6:	27 e2       	ldi	r18, 0x27	; 39
     ef8:	20 83       	st	Z, r18
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	28 e2       	ldi	r18, 0x28	; 40
     efe:	20 83       	st	Z, r18
     f00:	31 97       	sbiw	r30, 0x01	; 1
     f02:	29 e2       	ldi	r18, 0x29	; 41
     f04:	20 83       	st	Z, r18
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	20 e3       	ldi	r18, 0x30	; 48
     f0a:	20 83       	st	Z, r18
     f0c:	31 97       	sbiw	r30, 0x01	; 1
     f0e:	21 e3       	ldi	r18, 0x31	; 49
     f10:	20 83       	st	Z, r18
     f12:	89 97       	sbiw	r24, 0x29	; 41
     f14:	08 95       	ret

00000f16 <xPortStartScheduler>:
     f16:	88 ec       	ldi	r24, 0xC8	; 200
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	90 93 26 04 	sts	0x0426, r25	; 0x800426 <portTickRateHz+0x1>
     f1e:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <portTickRateHz>
     f22:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <ticksRemainingInSec+0x1>
     f26:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <ticksRemainingInSec>
     f2a:	8d e4       	ldi	r24, 0x4D	; 77
     f2c:	87 bd       	out	0x27, r24	; 39
     f2e:	82 e0       	ldi	r24, 0x02	; 2
     f30:	84 bd       	out	0x24, r24	; 36
     f32:	85 e0       	ldi	r24, 0x05	; 5
     f34:	85 bd       	out	0x25, r24	; 37
     f36:	ee e6       	ldi	r30, 0x6E	; 110
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	82 60       	ori	r24, 0x02	; 2
     f3e:	80 83       	st	Z, r24
     f40:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
     f44:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
     f48:	cd 91       	ld	r28, X+
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	dd 91       	ld	r29, X+
     f4e:	de bf       	out	0x3e, r29	; 62
     f50:	ff 91       	pop	r31
     f52:	ef 91       	pop	r30
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	bf 91       	pop	r27
     f5a:	af 91       	pop	r26
     f5c:	9f 91       	pop	r25
     f5e:	8f 91       	pop	r24
     f60:	7f 91       	pop	r23
     f62:	6f 91       	pop	r22
     f64:	5f 91       	pop	r21
     f66:	4f 91       	pop	r20
     f68:	3f 91       	pop	r19
     f6a:	2f 91       	pop	r18
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	ff 90       	pop	r15
     f72:	ef 90       	pop	r14
     f74:	df 90       	pop	r13
     f76:	cf 90       	pop	r12
     f78:	bf 90       	pop	r11
     f7a:	af 90       	pop	r10
     f7c:	9f 90       	pop	r9
     f7e:	8f 90       	pop	r8
     f80:	7f 90       	pop	r7
     f82:	6f 90       	pop	r6
     f84:	5f 90       	pop	r5
     f86:	4f 90       	pop	r4
     f88:	3f 90       	pop	r3
     f8a:	2f 90       	pop	r2
     f8c:	1f 90       	pop	r1
     f8e:	0f 90       	pop	r0
     f90:	0c be       	out	0x3c, r0	; 60
     f92:	0f 90       	pop	r0
     f94:	0b be       	out	0x3b, r0	; 59
     f96:	0f 90       	pop	r0
     f98:	0f be       	out	0x3f, r0	; 63
     f9a:	0f 90       	pop	r0
     f9c:	08 95       	ret
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	08 95       	ret

00000fa2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     fa2:	0f 92       	push	r0
     fa4:	0f b6       	in	r0, 0x3f	; 63
     fa6:	f8 94       	cli
     fa8:	0f 92       	push	r0
     faa:	0b b6       	in	r0, 0x3b	; 59
     fac:	0f 92       	push	r0
     fae:	0c b6       	in	r0, 0x3c	; 60
     fb0:	0f 92       	push	r0
     fb2:	1f 92       	push	r1
     fb4:	11 24       	eor	r1, r1
     fb6:	2f 92       	push	r2
     fb8:	3f 92       	push	r3
     fba:	4f 92       	push	r4
     fbc:	5f 92       	push	r5
     fbe:	6f 92       	push	r6
     fc0:	7f 92       	push	r7
     fc2:	8f 92       	push	r8
     fc4:	9f 92       	push	r9
     fc6:	af 92       	push	r10
     fc8:	bf 92       	push	r11
     fca:	cf 92       	push	r12
     fcc:	df 92       	push	r13
     fce:	ef 92       	push	r14
     fd0:	ff 92       	push	r15
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	2f 93       	push	r18
     fd8:	3f 93       	push	r19
     fda:	4f 93       	push	r20
     fdc:	5f 93       	push	r21
     fde:	6f 93       	push	r22
     fe0:	7f 93       	push	r23
     fe2:	8f 93       	push	r24
     fe4:	9f 93       	push	r25
     fe6:	af 93       	push	r26
     fe8:	bf 93       	push	r27
     fea:	cf 93       	push	r28
     fec:	df 93       	push	r29
     fee:	ef 93       	push	r30
     ff0:	ff 93       	push	r31
     ff2:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
     ff6:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
     ffa:	0d b6       	in	r0, 0x3d	; 61
     ffc:	0d 92       	st	X+, r0
     ffe:	0e b6       	in	r0, 0x3e	; 62
    1000:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1002:	16 d7       	rcall	.+3628   	; 0x1e30 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1004:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    1008:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    100c:	cd 91       	ld	r28, X+
    100e:	cd bf       	out	0x3d, r28	; 61
    1010:	dd 91       	ld	r29, X+
    1012:	de bf       	out	0x3e, r29	; 62
    1014:	ff 91       	pop	r31
    1016:	ef 91       	pop	r30
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	bf 91       	pop	r27
    101e:	af 91       	pop	r26
    1020:	9f 91       	pop	r25
    1022:	8f 91       	pop	r24
    1024:	7f 91       	pop	r23
    1026:	6f 91       	pop	r22
    1028:	5f 91       	pop	r21
    102a:	4f 91       	pop	r20
    102c:	3f 91       	pop	r19
    102e:	2f 91       	pop	r18
    1030:	1f 91       	pop	r17
    1032:	0f 91       	pop	r16
    1034:	ff 90       	pop	r15
    1036:	ef 90       	pop	r14
    1038:	df 90       	pop	r13
    103a:	cf 90       	pop	r12
    103c:	bf 90       	pop	r11
    103e:	af 90       	pop	r10
    1040:	9f 90       	pop	r9
    1042:	8f 90       	pop	r8
    1044:	7f 90       	pop	r7
    1046:	6f 90       	pop	r6
    1048:	5f 90       	pop	r5
    104a:	4f 90       	pop	r4
    104c:	3f 90       	pop	r3
    104e:	2f 90       	pop	r2
    1050:	1f 90       	pop	r1
    1052:	0f 90       	pop	r0
    1054:	0c be       	out	0x3c, r0	; 60
    1056:	0f 90       	pop	r0
    1058:	0b be       	out	0x3b, r0	; 59
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63
    105e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1060:	08 95       	ret

00001062 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1062:	0f 92       	push	r0
    1064:	0f b6       	in	r0, 0x3f	; 63
    1066:	f8 94       	cli
    1068:	0f 92       	push	r0
    106a:	0b b6       	in	r0, 0x3b	; 59
    106c:	0f 92       	push	r0
    106e:	0c b6       	in	r0, 0x3c	; 60
    1070:	0f 92       	push	r0
    1072:	1f 92       	push	r1
    1074:	11 24       	eor	r1, r1
    1076:	2f 92       	push	r2
    1078:	3f 92       	push	r3
    107a:	4f 92       	push	r4
    107c:	5f 92       	push	r5
    107e:	6f 92       	push	r6
    1080:	7f 92       	push	r7
    1082:	8f 92       	push	r8
    1084:	9f 92       	push	r9
    1086:	af 92       	push	r10
    1088:	bf 92       	push	r11
    108a:	cf 92       	push	r12
    108c:	df 92       	push	r13
    108e:	ef 92       	push	r14
    1090:	ff 92       	push	r15
    1092:	0f 93       	push	r16
    1094:	1f 93       	push	r17
    1096:	2f 93       	push	r18
    1098:	3f 93       	push	r19
    109a:	4f 93       	push	r20
    109c:	5f 93       	push	r21
    109e:	6f 93       	push	r22
    10a0:	7f 93       	push	r23
    10a2:	8f 93       	push	r24
    10a4:	9f 93       	push	r25
    10a6:	af 93       	push	r26
    10a8:	bf 93       	push	r27
    10aa:	cf 93       	push	r28
    10ac:	df 93       	push	r29
    10ae:	ef 93       	push	r30
    10b0:	ff 93       	push	r31
    10b2:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    10b6:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    10ba:	0d b6       	in	r0, 0x3d	; 61
    10bc:	0d 92       	st	X+, r0
    10be:	0e b6       	in	r0, 0x3e	; 62
    10c0:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    10c2:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    10c4:	80 91 27 04 	lds	r24, 0x0427	; 0x800427 <ticksRemainingInSec>
    10c8:	90 91 28 04 	lds	r25, 0x0428	; 0x800428 <ticksRemainingInSec+0x1>
    10cc:	01 97       	sbiw	r24, 0x01	; 1
    10ce:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <ticksRemainingInSec+0x1>
    10d2:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <ticksRemainingInSec>
    10d6:	89 2b       	or	r24, r25
    10d8:	49 f4       	brne	.+18     	; 0x10ec <vPortYieldFromTick+0x8a>
	{
		system_tick();
    10da:	20 d9       	rcall	.-3520   	; 0x31c <system_tick>
		ticksRemainingInSec = portTickRateHz;
    10dc:	80 91 25 04 	lds	r24, 0x0425	; 0x800425 <portTickRateHz>
    10e0:	90 91 26 04 	lds	r25, 0x0426	; 0x800426 <portTickRateHz+0x1>
    10e4:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <ticksRemainingInSec+0x1>
    10e8:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    10ec:	6b d5       	rcall	.+2774   	; 0x1bc4 <xTaskIncrementTick>
	{
		vTaskSwitchContext();
    10ee:	81 11       	cpse	r24, r1
    10f0:	9f d6       	rcall	.+3390   	; 0x1e30 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    10f2:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    10f6:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    10fa:	cd 91       	ld	r28, X+
    10fc:	cd bf       	out	0x3d, r28	; 61
    10fe:	dd 91       	ld	r29, X+
    1100:	de bf       	out	0x3e, r29	; 62
    1102:	ff 91       	pop	r31
    1104:	ef 91       	pop	r30
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	bf 91       	pop	r27
    110c:	af 91       	pop	r26
    110e:	9f 91       	pop	r25
    1110:	8f 91       	pop	r24
    1112:	7f 91       	pop	r23
    1114:	6f 91       	pop	r22
    1116:	5f 91       	pop	r21
    1118:	4f 91       	pop	r20
    111a:	3f 91       	pop	r19
    111c:	2f 91       	pop	r18
    111e:	1f 91       	pop	r17
    1120:	0f 91       	pop	r16
    1122:	ff 90       	pop	r15
    1124:	ef 90       	pop	r14
    1126:	df 90       	pop	r13
    1128:	cf 90       	pop	r12
    112a:	bf 90       	pop	r11
    112c:	af 90       	pop	r10
    112e:	9f 90       	pop	r9
    1130:	8f 90       	pop	r8
    1132:	7f 90       	pop	r7
    1134:	6f 90       	pop	r6
    1136:	5f 90       	pop	r5
    1138:	4f 90       	pop	r4
    113a:	3f 90       	pop	r3
    113c:	2f 90       	pop	r2
    113e:	1f 90       	pop	r1
    1140:	0f 90       	pop	r0
    1142:	0c be       	out	0x3c, r0	; 60
    1144:	0f 90       	pop	r0
    1146:	0b be       	out	0x3b, r0	; 59
    1148:	0f 90       	pop	r0
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    114e:	08 95       	ret

00001150 <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1150:	88 df       	rcall	.-240    	; 0x1062 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1152:	18 95       	reti

00001154 <prvCopyDataToQueue>:
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
    1154:	0f 93       	push	r16
    1156:	1f 93       	push	r17
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	ec 01       	movw	r28, r24
    115e:	04 2f       	mov	r16, r20
    1160:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1162:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1164:	41 11       	cpse	r20, r1
    1166:	0b c0       	rjmp	.+22     	; 0x117e <prvCopyDataToQueue+0x2a>
    1168:	88 81       	ld	r24, Y
    116a:	99 81       	ldd	r25, Y+1	; 0x01
    116c:	89 2b       	or	r24, r25
    116e:	09 f0       	breq	.+2      	; 0x1172 <prvCopyDataToQueue+0x1e>
    1170:	41 c0       	rjmp	.+130    	; 0x11f4 <prvCopyDataToQueue+0xa0>
    1172:	8a 81       	ldd	r24, Y+2	; 0x02
    1174:	9b 81       	ldd	r25, Y+3	; 0x03
    1176:	7d d7       	rcall	.+3834   	; 0x2072 <xTaskPriorityDisinherit>
    1178:	1b 82       	std	Y+3, r1	; 0x03
    117a:	1a 82       	std	Y+2, r1	; 0x02
    117c:	42 c0       	rjmp	.+132    	; 0x1202 <prvCopyDataToQueue+0xae>
    117e:	01 11       	cpse	r16, r1
    1180:	17 c0       	rjmp	.+46     	; 0x11b0 <prvCopyDataToQueue+0x5c>
    1182:	50 e0       	ldi	r21, 0x00	; 0
    1184:	8c 81       	ldd	r24, Y+4	; 0x04
    1186:	9d 81       	ldd	r25, Y+5	; 0x05
    1188:	0e 94 64 13 	call	0x26c8	; 0x26c8 <memcpy>
    118c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    118e:	8c 81       	ldd	r24, Y+4	; 0x04
    1190:	9d 81       	ldd	r25, Y+5	; 0x05
    1192:	82 0f       	add	r24, r18
    1194:	91 1d       	adc	r25, r1
    1196:	9d 83       	std	Y+5, r25	; 0x05
    1198:	8c 83       	std	Y+4, r24	; 0x04
    119a:	2a 81       	ldd	r18, Y+2	; 0x02
    119c:	3b 81       	ldd	r19, Y+3	; 0x03
    119e:	82 17       	cp	r24, r18
    11a0:	93 07       	cpc	r25, r19
    11a2:	50 f1       	brcs	.+84     	; 0x11f8 <prvCopyDataToQueue+0xa4>
    11a4:	88 81       	ld	r24, Y
    11a6:	99 81       	ldd	r25, Y+1	; 0x01
    11a8:	9d 83       	std	Y+5, r25	; 0x05
    11aa:	8c 83       	std	Y+4, r24	; 0x04
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	29 c0       	rjmp	.+82     	; 0x1202 <prvCopyDataToQueue+0xae>
    11b0:	50 e0       	ldi	r21, 0x00	; 0
    11b2:	8e 81       	ldd	r24, Y+6	; 0x06
    11b4:	9f 81       	ldd	r25, Y+7	; 0x07
    11b6:	0e 94 64 13 	call	0x26c8	; 0x26c8 <memcpy>
    11ba:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	91 95       	neg	r25
    11c0:	81 95       	neg	r24
    11c2:	91 09       	sbc	r25, r1
    11c4:	2e 81       	ldd	r18, Y+6	; 0x06
    11c6:	3f 81       	ldd	r19, Y+7	; 0x07
    11c8:	28 0f       	add	r18, r24
    11ca:	39 1f       	adc	r19, r25
    11cc:	3f 83       	std	Y+7, r19	; 0x07
    11ce:	2e 83       	std	Y+6, r18	; 0x06
    11d0:	48 81       	ld	r20, Y
    11d2:	59 81       	ldd	r21, Y+1	; 0x01
    11d4:	24 17       	cp	r18, r20
    11d6:	35 07       	cpc	r19, r21
    11d8:	30 f4       	brcc	.+12     	; 0x11e6 <prvCopyDataToQueue+0x92>
    11da:	2a 81       	ldd	r18, Y+2	; 0x02
    11dc:	3b 81       	ldd	r19, Y+3	; 0x03
    11de:	82 0f       	add	r24, r18
    11e0:	93 1f       	adc	r25, r19
    11e2:	9f 83       	std	Y+7, r25	; 0x07
    11e4:	8e 83       	std	Y+6, r24	; 0x06
    11e6:	02 30       	cpi	r16, 0x02	; 2
    11e8:	49 f4       	brne	.+18     	; 0x11fc <prvCopyDataToQueue+0xa8>
    11ea:	11 23       	and	r17, r17
    11ec:	49 f0       	breq	.+18     	; 0x1200 <prvCopyDataToQueue+0xac>
    11ee:	11 50       	subi	r17, 0x01	; 1
    11f0:	80 e0       	ldi	r24, 0x00	; 0
    11f2:	07 c0       	rjmp	.+14     	; 0x1202 <prvCopyDataToQueue+0xae>
    11f4:	80 e0       	ldi	r24, 0x00	; 0
    11f6:	05 c0       	rjmp	.+10     	; 0x1202 <prvCopyDataToQueue+0xae>
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	03 c0       	rjmp	.+6      	; 0x1202 <prvCopyDataToQueue+0xae>
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	01 c0       	rjmp	.+2      	; 0x1202 <prvCopyDataToQueue+0xae>
    1200:	80 e0       	ldi	r24, 0x00	; 0
    1202:	1f 5f       	subi	r17, 0xFF	; 255
    1204:	1a 8f       	std	Y+26, r17	; 0x1a
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	1f 91       	pop	r17
    120c:	0f 91       	pop	r16
    120e:	08 95       	ret

00001210 <prvUnlockQueue>:
    1210:	ef 92       	push	r14
    1212:	ff 92       	push	r15
    1214:	0f 93       	push	r16
    1216:	1f 93       	push	r17
    1218:	cf 93       	push	r28
    121a:	8c 01       	movw	r16, r24
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	0f 92       	push	r0
    1222:	fc 01       	movw	r30, r24
    1224:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1226:	1c 16       	cp	r1, r28
    1228:	9c f4       	brge	.+38     	; 0x1250 <prvUnlockQueue+0x40>
    122a:	81 89       	ldd	r24, Z+17	; 0x11
    122c:	81 11       	cpse	r24, r1
    122e:	06 c0       	rjmp	.+12     	; 0x123c <prvUnlockQueue+0x2c>
    1230:	0f c0       	rjmp	.+30     	; 0x1250 <prvUnlockQueue+0x40>
    1232:	f8 01       	movw	r30, r16
    1234:	81 89       	ldd	r24, Z+17	; 0x11
    1236:	81 11       	cpse	r24, r1
    1238:	05 c0       	rjmp	.+10     	; 0x1244 <prvUnlockQueue+0x34>
    123a:	0a c0       	rjmp	.+20     	; 0x1250 <prvUnlockQueue+0x40>
    123c:	78 01       	movw	r14, r16
    123e:	f1 e1       	ldi	r31, 0x11	; 17
    1240:	ef 0e       	add	r14, r31
    1242:	f1 1c       	adc	r15, r1
    1244:	c7 01       	movw	r24, r14
    1246:	86 d6       	rcall	.+3340   	; 0x1f54 <xTaskRemoveFromEventList>
    1248:	81 11       	cpse	r24, r1
    124a:	0f d7       	rcall	.+3614   	; 0x206a <vTaskMissedYield>
    124c:	c1 50       	subi	r28, 0x01	; 1
    124e:	89 f7       	brne	.-30     	; 0x1232 <prvUnlockQueue+0x22>
    1250:	8f ef       	ldi	r24, 0xFF	; 255
    1252:	f8 01       	movw	r30, r16
    1254:	86 8f       	std	Z+30, r24	; 0x1e
    1256:	0f 90       	pop	r0
    1258:	0f be       	out	0x3f, r0	; 63
    125a:	0f b6       	in	r0, 0x3f	; 63
    125c:	f8 94       	cli
    125e:	0f 92       	push	r0
    1260:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1262:	1c 16       	cp	r1, r28
    1264:	9c f4       	brge	.+38     	; 0x128c <prvUnlockQueue+0x7c>
    1266:	80 85       	ldd	r24, Z+8	; 0x08
    1268:	81 11       	cpse	r24, r1
    126a:	06 c0       	rjmp	.+12     	; 0x1278 <prvUnlockQueue+0x68>
    126c:	0f c0       	rjmp	.+30     	; 0x128c <prvUnlockQueue+0x7c>
    126e:	f8 01       	movw	r30, r16
    1270:	80 85       	ldd	r24, Z+8	; 0x08
    1272:	81 11       	cpse	r24, r1
    1274:	05 c0       	rjmp	.+10     	; 0x1280 <prvUnlockQueue+0x70>
    1276:	0a c0       	rjmp	.+20     	; 0x128c <prvUnlockQueue+0x7c>
    1278:	78 01       	movw	r14, r16
    127a:	f8 e0       	ldi	r31, 0x08	; 8
    127c:	ef 0e       	add	r14, r31
    127e:	f1 1c       	adc	r15, r1
    1280:	c7 01       	movw	r24, r14
    1282:	68 d6       	rcall	.+3280   	; 0x1f54 <xTaskRemoveFromEventList>
    1284:	81 11       	cpse	r24, r1
    1286:	f1 d6       	rcall	.+3554   	; 0x206a <vTaskMissedYield>
    1288:	c1 50       	subi	r28, 0x01	; 1
    128a:	89 f7       	brne	.-30     	; 0x126e <prvUnlockQueue+0x5e>
    128c:	8f ef       	ldi	r24, 0xFF	; 255
    128e:	f8 01       	movw	r30, r16
    1290:	85 8f       	std	Z+29, r24	; 0x1d
    1292:	0f 90       	pop	r0
    1294:	0f be       	out	0x3f, r0	; 63
    1296:	cf 91       	pop	r28
    1298:	1f 91       	pop	r17
    129a:	0f 91       	pop	r16
    129c:	ff 90       	pop	r15
    129e:	ef 90       	pop	r14
    12a0:	08 95       	ret

000012a2 <xQueueGenericReset>:
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	ec 01       	movw	r28, r24
    12a8:	0f b6       	in	r0, 0x3f	; 63
    12aa:	f8 94       	cli
    12ac:	0f 92       	push	r0
    12ae:	48 81       	ld	r20, Y
    12b0:	59 81       	ldd	r21, Y+1	; 0x01
    12b2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12b4:	30 e0       	ldi	r19, 0x00	; 0
    12b6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    12b8:	72 9f       	mul	r23, r18
    12ba:	c0 01       	movw	r24, r0
    12bc:	73 9f       	mul	r23, r19
    12be:	90 0d       	add	r25, r0
    12c0:	11 24       	eor	r1, r1
    12c2:	fa 01       	movw	r30, r20
    12c4:	e8 0f       	add	r30, r24
    12c6:	f9 1f       	adc	r31, r25
    12c8:	fb 83       	std	Y+3, r31	; 0x03
    12ca:	ea 83       	std	Y+2, r30	; 0x02
    12cc:	1a 8e       	std	Y+26, r1	; 0x1a
    12ce:	5d 83       	std	Y+5, r21	; 0x05
    12d0:	4c 83       	std	Y+4, r20	; 0x04
    12d2:	82 1b       	sub	r24, r18
    12d4:	93 0b       	sbc	r25, r19
    12d6:	84 0f       	add	r24, r20
    12d8:	95 1f       	adc	r25, r21
    12da:	9f 83       	std	Y+7, r25	; 0x07
    12dc:	8e 83       	std	Y+6, r24	; 0x06
    12de:	8f ef       	ldi	r24, 0xFF	; 255
    12e0:	8d 8f       	std	Y+29, r24	; 0x1d
    12e2:	8e 8f       	std	Y+30, r24	; 0x1e
    12e4:	61 11       	cpse	r22, r1
    12e6:	0a c0       	rjmp	.+20     	; 0x12fc <xQueueGenericReset+0x5a>
    12e8:	88 85       	ldd	r24, Y+8	; 0x08
    12ea:	88 23       	and	r24, r24
    12ec:	69 f0       	breq	.+26     	; 0x1308 <xQueueGenericReset+0x66>
    12ee:	ce 01       	movw	r24, r28
    12f0:	08 96       	adiw	r24, 0x08	; 8
    12f2:	30 d6       	rcall	.+3168   	; 0x1f54 <xTaskRemoveFromEventList>
    12f4:	88 23       	and	r24, r24
    12f6:	41 f0       	breq	.+16     	; 0x1308 <xQueueGenericReset+0x66>
    12f8:	54 de       	rcall	.-856    	; 0xfa2 <vPortYield>
    12fa:	06 c0       	rjmp	.+12     	; 0x1308 <xQueueGenericReset+0x66>
    12fc:	ce 01       	movw	r24, r28
    12fe:	08 96       	adiw	r24, 0x08	; 8
    1300:	6a d9       	rcall	.-3372   	; 0x5d6 <vListInitialise>
    1302:	ce 01       	movw	r24, r28
    1304:	41 96       	adiw	r24, 0x11	; 17
    1306:	67 d9       	rcall	.-3378   	; 0x5d6 <vListInitialise>
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	df 91       	pop	r29
    1310:	cf 91       	pop	r28
    1312:	08 95       	ret

00001314 <xQueueGenericCreate>:
    1314:	0f 93       	push	r16
    1316:	1f 93       	push	r17
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	08 2f       	mov	r16, r24
    131e:	16 2f       	mov	r17, r22
    1320:	66 23       	and	r22, r22
    1322:	b1 f0       	breq	.+44     	; 0x1350 <xQueueGenericCreate+0x3c>
    1324:	86 9f       	mul	r24, r22
    1326:	c0 01       	movw	r24, r0
    1328:	11 24       	eor	r1, r1
    132a:	4f 96       	adiw	r24, 0x1f	; 31
    132c:	13 d8       	rcall	.-4058   	; 0x354 <pvPortMalloc>
    132e:	ec 01       	movw	r28, r24
    1330:	00 97       	sbiw	r24, 0x00	; 0
    1332:	39 f4       	brne	.+14     	; 0x1342 <xQueueGenericCreate+0x2e>
    1334:	14 c0       	rjmp	.+40     	; 0x135e <xQueueGenericCreate+0x4a>
    1336:	0b 8f       	std	Y+27, r16	; 0x1b
    1338:	1c 8f       	std	Y+28, r17	; 0x1c
    133a:	61 e0       	ldi	r22, 0x01	; 1
    133c:	ce 01       	movw	r24, r28
    133e:	b1 df       	rcall	.-158    	; 0x12a2 <xQueueGenericReset>
    1340:	0e c0       	rjmp	.+28     	; 0x135e <xQueueGenericCreate+0x4a>
    1342:	4f 96       	adiw	r24, 0x1f	; 31
    1344:	99 83       	std	Y+1, r25	; 0x01
    1346:	88 83       	st	Y, r24
    1348:	f6 cf       	rjmp	.-20     	; 0x1336 <xQueueGenericCreate+0x22>
    134a:	d9 83       	std	Y+1, r29	; 0x01
    134c:	c8 83       	st	Y, r28
    134e:	f3 cf       	rjmp	.-26     	; 0x1336 <xQueueGenericCreate+0x22>
    1350:	8f e1       	ldi	r24, 0x1F	; 31
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1358:	ec 01       	movw	r28, r24
    135a:	89 2b       	or	r24, r25
    135c:	b1 f7       	brne	.-20     	; 0x134a <xQueueGenericCreate+0x36>
    135e:	ce 01       	movw	r24, r28
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	1f 91       	pop	r17
    1366:	0f 91       	pop	r16
    1368:	08 95       	ret

0000136a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    136a:	9f 92       	push	r9
    136c:	af 92       	push	r10
    136e:	bf 92       	push	r11
    1370:	cf 92       	push	r12
    1372:	df 92       	push	r13
    1374:	ef 92       	push	r14
    1376:	ff 92       	push	r15
    1378:	0f 93       	push	r16
    137a:	1f 93       	push	r17
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
    1380:	00 d0       	rcall	.+0      	; 0x1382 <xQueueGenericSend+0x18>
    1382:	1f 92       	push	r1
    1384:	1f 92       	push	r1
    1386:	cd b7       	in	r28, 0x3d	; 61
    1388:	de b7       	in	r29, 0x3e	; 62
    138a:	8c 01       	movw	r16, r24
    138c:	6b 01       	movw	r12, r22
    138e:	5d 83       	std	Y+5, r21	; 0x05
    1390:	4c 83       	std	Y+4, r20	; 0x04
    1392:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1394:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1396:	99 24       	eor	r9, r9
    1398:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    139a:	7c 01       	movw	r14, r24
    139c:	88 e0       	ldi	r24, 0x08	; 8
    139e:	e8 0e       	add	r14, r24
    13a0:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13a8:	f8 01       	movw	r30, r16
    13aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    13ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    13ae:	98 17       	cp	r25, r24
    13b0:	18 f0       	brcs	.+6      	; 0x13b8 <xQueueGenericSend+0x4e>
    13b2:	f2 e0       	ldi	r31, 0x02	; 2
    13b4:	af 12       	cpse	r10, r31
    13b6:	15 c0       	rjmp	.+42     	; 0x13e2 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13b8:	4a 2d       	mov	r20, r10
    13ba:	b6 01       	movw	r22, r12
    13bc:	c8 01       	movw	r24, r16
    13be:	ca de       	rcall	.-620    	; 0x1154 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13c0:	f8 01       	movw	r30, r16
    13c2:	91 89       	ldd	r25, Z+17	; 0x11
    13c4:	99 23       	and	r25, r25
    13c6:	39 f0       	breq	.+14     	; 0x13d6 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13c8:	c8 01       	movw	r24, r16
    13ca:	41 96       	adiw	r24, 0x11	; 17
    13cc:	c3 d5       	rcall	.+2950   	; 0x1f54 <xTaskRemoveFromEventList>
    13ce:	88 23       	and	r24, r24
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    13d0:	21 f0       	breq	.+8      	; 0x13da <xQueueGenericSend+0x70>
    13d2:	e7 dd       	rcall	.-1074   	; 0xfa2 <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    13d4:	02 c0       	rjmp	.+4      	; 0x13da <xQueueGenericSend+0x70>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    13d6:	81 11       	cpse	r24, r1
    13d8:	e4 dd       	rcall	.-1080   	; 0xfa2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    13da:	0f 90       	pop	r0
    13dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	45 c0       	rjmp	.+138    	; 0x146c <xQueueGenericSend+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13e2:	8c 81       	ldd	r24, Y+4	; 0x04
    13e4:	9d 81       	ldd	r25, Y+5	; 0x05
    13e6:	89 2b       	or	r24, r25
    13e8:	21 f4       	brne	.+8      	; 0x13f2 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    13ee:	80 e0       	ldi	r24, 0x00	; 0
    13f0:	3d c0       	rjmp	.+122    	; 0x146c <xQueueGenericSend+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    13f2:	b1 10       	cpse	r11, r1
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13f4:	04 c0       	rjmp	.+8      	; 0x13fe <xQueueGenericSend+0x94>
    13f6:	ce 01       	movw	r24, r28
    13f8:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    13fa:	f4 d5       	rcall	.+3048   	; 0x1fe4 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    13fc:	b9 2c       	mov	r11, r9
    13fe:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1400:	0f be       	out	0x3f, r0	; 63
    1402:	da d3       	rcall	.+1972   	; 0x1bb8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	0f 92       	push	r0
    140a:	f8 01       	movw	r30, r16
    140c:	85 8d       	ldd	r24, Z+29	; 0x1d
    140e:	8f 3f       	cpi	r24, 0xFF	; 255
    1410:	09 f4       	brne	.+2      	; 0x1414 <xQueueGenericSend+0xaa>
    1412:	15 8e       	std	Z+29, r1	; 0x1d
    1414:	f8 01       	movw	r30, r16
    1416:	86 8d       	ldd	r24, Z+30	; 0x1e
    1418:	8f 3f       	cpi	r24, 0xFF	; 255
    141a:	09 f4       	brne	.+2      	; 0x141e <xQueueGenericSend+0xb4>
    141c:	16 8e       	std	Z+30, r1	; 0x1e
    141e:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1420:	0f be       	out	0x3f, r0	; 63
    1422:	be 01       	movw	r22, r28
    1424:	6c 5f       	subi	r22, 0xFC	; 252
    1426:	7f 4f       	sbci	r23, 0xFF	; 255
    1428:	ce 01       	movw	r24, r28
    142a:	01 96       	adiw	r24, 0x01	; 1
    142c:	e6 d5       	rcall	.+3020   	; 0x1ffa <xTaskCheckForTimeOut>
    142e:	81 11       	cpse	r24, r1
    1430:	19 c0       	rjmp	.+50     	; 0x1464 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1432:	0f b6       	in	r0, 0x3f	; 63
    1434:	f8 94       	cli
    1436:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1438:	f8 01       	movw	r30, r16
    143a:	92 8d       	ldd	r25, Z+26	; 0x1a
    143c:	83 8d       	ldd	r24, Z+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    143e:	0f 90       	pop	r0
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1440:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1442:	98 13       	cpse	r25, r24
    1444:	0b c0       	rjmp	.+22     	; 0x145c <xQueueGenericSend+0xf2>
    1446:	6c 81       	ldd	r22, Y+4	; 0x04
    1448:	7d 81       	ldd	r23, Y+5	; 0x05
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    144a:	c7 01       	movw	r24, r14
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    144c:	72 d5       	rcall	.+2788   	; 0x1f32 <vTaskPlaceOnEventList>
    144e:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
    1450:	df de       	rcall	.-578    	; 0x1210 <prvUnlockQueue>
    1452:	72 d4       	rcall	.+2276   	; 0x1d38 <xTaskResumeAll>
    1454:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1456:	a5 cf       	rjmp	.-182    	; 0x13a2 <xQueueGenericSend+0x38>
    1458:	a4 dd       	rcall	.-1208   	; 0xfa2 <vPortYield>
    145a:	a3 cf       	rjmp	.-186    	; 0x13a2 <xQueueGenericSend+0x38>
				( void ) xTaskResumeAll();
    145c:	c8 01       	movw	r24, r16
    145e:	d8 de       	rcall	.-592    	; 0x1210 <prvUnlockQueue>
    1460:	6b d4       	rcall	.+2262   	; 0x1d38 <xTaskResumeAll>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1462:	9f cf       	rjmp	.-194    	; 0x13a2 <xQueueGenericSend+0x38>
    1464:	c8 01       	movw	r24, r16
    1466:	d4 de       	rcall	.-600    	; 0x1210 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1468:	67 d4       	rcall	.+2254   	; 0x1d38 <xTaskResumeAll>
    146a:	80 e0       	ldi	r24, 0x00	; 0

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    146c:	0f 90       	pop	r0
		}
	}
}
    146e:	0f 90       	pop	r0
    1470:	0f 90       	pop	r0
    1472:	0f 90       	pop	r0
    1474:	0f 90       	pop	r0
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	ff 90       	pop	r15
    1480:	ef 90       	pop	r14
    1482:	df 90       	pop	r13
    1484:	cf 90       	pop	r12
    1486:	bf 90       	pop	r11
    1488:	af 90       	pop	r10
    148a:	9f 90       	pop	r9
    148c:	08 95       	ret

0000148e <__vector_26>:
    148e:	1f 92       	push	r1
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    1490:	0f 92       	push	r0
    1492:	0f b6       	in	r0, 0x3f	; 63
    1494:	0f 92       	push	r0
    1496:	11 24       	eor	r1, r1
    1498:	0b b6       	in	r0, 0x3b	; 59
    149a:	0f 92       	push	r0
    149c:	2f 93       	push	r18
    149e:	8f 93       	push	r24
    14a0:	9f 93       	push	r25
    14a2:	af 93       	push	r26
    14a4:	bf 93       	push	r27
    14a6:	ef 93       	push	r30
    14a8:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	0f 92       	push	r0
	{
	    count = buffer->count;
    14b0:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <xSerialPort+0xd>
    14b4:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    14b8:	0f 90       	pop	r0
    14ba:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    14bc:	89 2b       	or	r24, r25
    14be:	31 f4       	brne	.+12     	; 0x14cc <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    14c0:	e1 ec       	ldi	r30, 0xC1	; 193
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	80 81       	ld	r24, Z
    14c6:	8f 7d       	andi	r24, 0xDF	; 223
    14c8:	80 83       	st	Z, r24
    14ca:	1c c0       	rjmp	.+56     	; 0x1504 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    14cc:	e6 e3       	ldi	r30, 0x36	; 54
    14ce:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    14d0:	a4 81       	ldd	r26, Z+4	; 0x04
    14d2:	b5 81       	ldd	r27, Z+5	; 0x05
    14d4:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    14d6:	b5 83       	std	Z+5, r27	; 0x05
    14d8:	a4 83       	std	Z+4, r26	; 0x04
    14da:	80 85       	ldd	r24, Z+8	; 0x08
    14dc:	91 85       	ldd	r25, Z+9	; 0x09
    14de:	a8 17       	cp	r26, r24
    14e0:	b9 07       	cpc	r27, r25
    14e2:	21 f4       	brne	.+8      	; 0x14ec <__vector_26+0x5e>
	  buffer->out = buffer->start;
    14e4:	86 81       	ldd	r24, Z+6	; 0x06
    14e6:	97 81       	ldd	r25, Z+7	; 0x07
    14e8:	95 83       	std	Z+5, r25	; 0x05
    14ea:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    14ec:	0f b6       	in	r0, 0x3f	; 63
    14ee:	f8 94       	cli
    14f0:	0f 92       	push	r0
	{
	    buffer->count--;
    14f2:	80 81       	ld	r24, Z
    14f4:	91 81       	ldd	r25, Z+1	; 0x01
    14f6:	01 97       	sbiw	r24, 0x01	; 1
    14f8:	91 83       	std	Z+1, r25	; 0x01
    14fa:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    14fc:	0f 90       	pop	r0
    14fe:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    1500:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    1504:	ff 91       	pop	r31
    1506:	ef 91       	pop	r30
    1508:	bf 91       	pop	r27
    150a:	af 91       	pop	r26
    150c:	9f 91       	pop	r25
    150e:	8f 91       	pop	r24
    1510:	2f 91       	pop	r18
    1512:	0f 90       	pop	r0
    1514:	0b be       	out	0x3b, r0	; 59
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	0f 90       	pop	r0
    151c:	1f 90       	pop	r1
    151e:	18 95       	reti

00001520 <__vector_37>:
//}
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    1520:	1f 92       	push	r1
    1522:	0f 92       	push	r0
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	0f 92       	push	r0
    1528:	11 24       	eor	r1, r1
    152a:	0b b6       	in	r0, 0x3b	; 59
    152c:	0f 92       	push	r0
    152e:	2f 93       	push	r18
    1530:	8f 93       	push	r24
    1532:	9f 93       	push	r25
    1534:	af 93       	push	r26
    1536:	bf 93       	push	r27
    1538:	ef 93       	push	r30
    153a:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	f8 94       	cli
    1540:	0f 92       	push	r0
	{
	    count = buffer->count;
    1542:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <xSerial1Port+0xd>
    1546:	90 91 9d 04 	lds	r25, 0x049D	; 0x80049d <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    154a:	0f 90       	pop	r0
    154c:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    154e:	89 2b       	or	r24, r25
    1550:	31 f4       	brne	.+12     	; 0x155e <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1552:	e9 ec       	ldi	r30, 0xC9	; 201
    1554:	f0 e0       	ldi	r31, 0x00	; 0
    1556:	80 81       	ld	r24, Z
    1558:	8f 7d       	andi	r24, 0xDF	; 223
    155a:	80 83       	st	Z, r24
    155c:	1c c0       	rjmp	.+56     	; 0x1596 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    155e:	ec e9       	ldi	r30, 0x9C	; 156
    1560:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1562:	a4 81       	ldd	r26, Z+4	; 0x04
    1564:	b5 81       	ldd	r27, Z+5	; 0x05
    1566:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1568:	b5 83       	std	Z+5, r27	; 0x05
    156a:	a4 83       	std	Z+4, r26	; 0x04
    156c:	80 85       	ldd	r24, Z+8	; 0x08
    156e:	91 85       	ldd	r25, Z+9	; 0x09
    1570:	a8 17       	cp	r26, r24
    1572:	b9 07       	cpc	r27, r25
    1574:	21 f4       	brne	.+8      	; 0x157e <__vector_37+0x5e>
	  buffer->out = buffer->start;
    1576:	86 81       	ldd	r24, Z+6	; 0x06
    1578:	97 81       	ldd	r25, Z+7	; 0x07
    157a:	95 83       	std	Z+5, r25	; 0x05
    157c:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    157e:	0f b6       	in	r0, 0x3f	; 63
    1580:	f8 94       	cli
    1582:	0f 92       	push	r0
	{
	    buffer->count--;
    1584:	80 81       	ld	r24, Z
    1586:	91 81       	ldd	r25, Z+1	; 0x01
    1588:	01 97       	sbiw	r24, 0x01	; 1
    158a:	91 83       	std	Z+1, r25	; 0x01
    158c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    158e:	0f 90       	pop	r0
    1590:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1592:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    1596:	ff 91       	pop	r31
    1598:	ef 91       	pop	r30
    159a:	bf 91       	pop	r27
    159c:	af 91       	pop	r26
    159e:	9f 91       	pop	r25
    15a0:	8f 91       	pop	r24
    15a2:	2f 91       	pop	r18
    15a4:	0f 90       	pop	r0
    15a6:	0b be       	out	0x3b, r0	; 59
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
    15ac:	0f 90       	pop	r0
    15ae:	1f 90       	pop	r1
    15b0:	18 95       	reti

000015b2 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    15b2:	1f 92       	push	r1
    15b4:	0f 92       	push	r0
    15b6:	0f b6       	in	r0, 0x3f	; 63
    15b8:	0f 92       	push	r0
    15ba:	11 24       	eor	r1, r1
    15bc:	0b b6       	in	r0, 0x3b	; 59
    15be:	0f 92       	push	r0
    15c0:	2f 93       	push	r18
    15c2:	3f 93       	push	r19
    15c4:	4f 93       	push	r20
    15c6:	8f 93       	push	r24
    15c8:	9f 93       	push	r25
    15ca:	af 93       	push	r26
    15cc:	bf 93       	push	r27
    15ce:	ef 93       	push	r30
    15d0:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    15d2:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    15d6:	8c 71       	andi	r24, 0x1C	; 28
    15d8:	71 f0       	breq	.+28     	; 0x15f6 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    15da:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    15de:	88 23       	and	r24, r24
    15e0:	0c f0       	brlt	.+2      	; 0x15e4 <__vector_51+0x32>
    15e2:	36 c0       	rjmp	.+108    	; 0x1650 <__vector_51+0x9e>
    15e4:	a6 ed       	ldi	r26, 0xD6	; 214
    15e6:	b0 e0       	ldi	r27, 0x00	; 0
    15e8:	e0 ed       	ldi	r30, 0xD0	; 208
    15ea:	f0 e0       	ldi	r31, 0x00	; 0
    15ec:	8c 91       	ld	r24, X
    15ee:	80 81       	ld	r24, Z
    15f0:	88 23       	and	r24, r24
    15f2:	e4 f3       	brlt	.-8      	; 0x15ec <__vector_51+0x3a>
    15f4:	2d c0       	rjmp	.+90     	; 0x1650 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    15f6:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    15fa:	0f b6       	in	r0, 0x3f	; 63
    15fc:	f8 94       	cli
    15fe:	0f 92       	push	r0
	{
	    count = buffer->count;
    1600:	eb e4       	ldi	r30, 0x4B	; 75
    1602:	f4 e0       	ldi	r31, 0x04	; 4
    1604:	21 81       	ldd	r18, Z+1	; 0x01
    1606:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1608:	0f 90       	pop	r0
    160a:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    160c:	83 85       	ldd	r24, Z+11	; 0x0b
    160e:	94 85       	ldd	r25, Z+12	; 0x0c
    1610:	28 17       	cp	r18, r24
    1612:	39 07       	cpc	r19, r25
    1614:	e9 f0       	breq	.+58     	; 0x1650 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1616:	ec e4       	ldi	r30, 0x4C	; 76
    1618:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    161a:	a2 81       	ldd	r26, Z+2	; 0x02
    161c:	b3 81       	ldd	r27, Z+3	; 0x03
    161e:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1620:	82 81       	ldd	r24, Z+2	; 0x02
    1622:	93 81       	ldd	r25, Z+3	; 0x03
    1624:	01 96       	adiw	r24, 0x01	; 1
    1626:	93 83       	std	Z+3, r25	; 0x03
    1628:	82 83       	std	Z+2, r24	; 0x02
    162a:	20 85       	ldd	r18, Z+8	; 0x08
    162c:	31 85       	ldd	r19, Z+9	; 0x09
    162e:	82 17       	cp	r24, r18
    1630:	93 07       	cpc	r25, r19
    1632:	21 f4       	brne	.+8      	; 0x163c <__vector_51+0x8a>
	  buffer->in = buffer->start;
    1634:	86 81       	ldd	r24, Z+6	; 0x06
    1636:	97 81       	ldd	r25, Z+7	; 0x07
    1638:	93 83       	std	Z+3, r25	; 0x03
    163a:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    163c:	0f b6       	in	r0, 0x3f	; 63
    163e:	f8 94       	cli
    1640:	0f 92       	push	r0
	{
	    buffer->count++;
    1642:	80 81       	ld	r24, Z
    1644:	91 81       	ldd	r25, Z+1	; 0x01
    1646:	01 96       	adiw	r24, 0x01	; 1
    1648:	91 83       	std	Z+1, r25	; 0x01
    164a:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1650:	ff 91       	pop	r31
    1652:	ef 91       	pop	r30
    1654:	bf 91       	pop	r27
    1656:	af 91       	pop	r26
    1658:	9f 91       	pop	r25
    165a:	8f 91       	pop	r24
    165c:	4f 91       	pop	r20
    165e:	3f 91       	pop	r19
    1660:	2f 91       	pop	r18
    1662:	0f 90       	pop	r0
    1664:	0b be       	out	0x3b, r0	; 59
    1666:	0f 90       	pop	r0
    1668:	0f be       	out	0x3f, r0	; 63
    166a:	0f 90       	pop	r0
    166c:	1f 90       	pop	r1
    166e:	18 95       	reti

00001670 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1670:	1f 92       	push	r1
    1672:	0f 92       	push	r0
    1674:	0f b6       	in	r0, 0x3f	; 63
    1676:	0f 92       	push	r0
    1678:	11 24       	eor	r1, r1
    167a:	0b b6       	in	r0, 0x3b	; 59
    167c:	0f 92       	push	r0
    167e:	2f 93       	push	r18
    1680:	8f 93       	push	r24
    1682:	9f 93       	push	r25
    1684:	af 93       	push	r26
    1686:	bf 93       	push	r27
    1688:	ef 93       	push	r30
    168a:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    168c:	0f b6       	in	r0, 0x3f	; 63
    168e:	f8 94       	cli
    1690:	0f 92       	push	r0
	{
	    count = buffer->count;
    1692:	80 91 58 04 	lds	r24, 0x0458	; 0x800458 <xSerial2Port+0xd>
    1696:	90 91 59 04 	lds	r25, 0x0459	; 0x800459 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    169a:	0f 90       	pop	r0
    169c:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    169e:	89 2b       	or	r24, r25
    16a0:	31 f4       	brne	.+12     	; 0x16ae <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    16a2:	e1 ed       	ldi	r30, 0xD1	; 209
    16a4:	f0 e0       	ldi	r31, 0x00	; 0
    16a6:	80 81       	ld	r24, Z
    16a8:	8f 7d       	andi	r24, 0xDF	; 223
    16aa:	80 83       	st	Z, r24
    16ac:	1c c0       	rjmp	.+56     	; 0x16e6 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    16ae:	e8 e5       	ldi	r30, 0x58	; 88
    16b0:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    16b2:	a4 81       	ldd	r26, Z+4	; 0x04
    16b4:	b5 81       	ldd	r27, Z+5	; 0x05
    16b6:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    16b8:	b5 83       	std	Z+5, r27	; 0x05
    16ba:	a4 83       	std	Z+4, r26	; 0x04
    16bc:	80 85       	ldd	r24, Z+8	; 0x08
    16be:	91 85       	ldd	r25, Z+9	; 0x09
    16c0:	a8 17       	cp	r26, r24
    16c2:	b9 07       	cpc	r27, r25
    16c4:	21 f4       	brne	.+8      	; 0x16ce <__vector_52+0x5e>
	  buffer->out = buffer->start;
    16c6:	86 81       	ldd	r24, Z+6	; 0x06
    16c8:	97 81       	ldd	r25, Z+7	; 0x07
    16ca:	95 83       	std	Z+5, r25	; 0x05
    16cc:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    16ce:	0f b6       	in	r0, 0x3f	; 63
    16d0:	f8 94       	cli
    16d2:	0f 92       	push	r0
	{
	    buffer->count--;
    16d4:	80 81       	ld	r24, Z
    16d6:	91 81       	ldd	r25, Z+1	; 0x01
    16d8:	01 97       	sbiw	r24, 0x01	; 1
    16da:	91 83       	std	Z+1, r25	; 0x01
    16dc:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    16e2:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    16e6:	ff 91       	pop	r31
    16e8:	ef 91       	pop	r30
    16ea:	bf 91       	pop	r27
    16ec:	af 91       	pop	r26
    16ee:	9f 91       	pop	r25
    16f0:	8f 91       	pop	r24
    16f2:	2f 91       	pop	r18
    16f4:	0f 90       	pop	r0
    16f6:	0b be       	out	0x3b, r0	; 59
    16f8:	0f 90       	pop	r0
    16fa:	0f be       	out	0x3f, r0	; 63
    16fc:	0f 90       	pop	r0
    16fe:	1f 90       	pop	r1
    1700:	18 95       	reti

00001702 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    1702:	1f 92       	push	r1
    1704:	0f 92       	push	r0
    1706:	0f b6       	in	r0, 0x3f	; 63
    1708:	0f 92       	push	r0
    170a:	11 24       	eor	r1, r1
    170c:	0b b6       	in	r0, 0x3b	; 59
    170e:	0f 92       	push	r0
    1710:	2f 93       	push	r18
    1712:	3f 93       	push	r19
    1714:	4f 93       	push	r20
    1716:	8f 93       	push	r24
    1718:	9f 93       	push	r25
    171a:	af 93       	push	r26
    171c:	bf 93       	push	r27
    171e:	ef 93       	push	r30
    1720:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    1722:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1726:	8c 71       	andi	r24, 0x1C	; 28
    1728:	71 f0       	breq	.+28     	; 0x1746 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    172a:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    172e:	88 23       	and	r24, r24
    1730:	0c f0       	brlt	.+2      	; 0x1734 <__vector_54+0x32>
    1732:	36 c0       	rjmp	.+108    	; 0x17a0 <__vector_54+0x9e>
    1734:	a6 e3       	ldi	r26, 0x36	; 54
    1736:	b1 e0       	ldi	r27, 0x01	; 1
    1738:	e0 e3       	ldi	r30, 0x30	; 48
    173a:	f1 e0       	ldi	r31, 0x01	; 1
    173c:	8c 91       	ld	r24, X
    173e:	80 81       	ld	r24, Z
    1740:	88 23       	and	r24, r24
    1742:	e4 f3       	brlt	.-8      	; 0x173c <__vector_54+0x3a>
    1744:	2d c0       	rjmp	.+90     	; 0x17a0 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    1746:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	f8 94       	cli
    174e:	0f 92       	push	r0
	{
	    count = buffer->count;
    1750:	ed e6       	ldi	r30, 0x6D	; 109
    1752:	f4 e0       	ldi	r31, 0x04	; 4
    1754:	21 81       	ldd	r18, Z+1	; 0x01
    1756:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1758:	0f 90       	pop	r0
    175a:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    175c:	83 85       	ldd	r24, Z+11	; 0x0b
    175e:	94 85       	ldd	r25, Z+12	; 0x0c
    1760:	28 17       	cp	r18, r24
    1762:	39 07       	cpc	r19, r25
    1764:	e9 f0       	breq	.+58     	; 0x17a0 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1766:	ee e6       	ldi	r30, 0x6E	; 110
    1768:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    176a:	a2 81       	ldd	r26, Z+2	; 0x02
    176c:	b3 81       	ldd	r27, Z+3	; 0x03
    176e:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1770:	82 81       	ldd	r24, Z+2	; 0x02
    1772:	93 81       	ldd	r25, Z+3	; 0x03
    1774:	01 96       	adiw	r24, 0x01	; 1
    1776:	93 83       	std	Z+3, r25	; 0x03
    1778:	82 83       	std	Z+2, r24	; 0x02
    177a:	20 85       	ldd	r18, Z+8	; 0x08
    177c:	31 85       	ldd	r19, Z+9	; 0x09
    177e:	82 17       	cp	r24, r18
    1780:	93 07       	cpc	r25, r19
    1782:	21 f4       	brne	.+8      	; 0x178c <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1784:	86 81       	ldd	r24, Z+6	; 0x06
    1786:	97 81       	ldd	r25, Z+7	; 0x07
    1788:	93 83       	std	Z+3, r25	; 0x03
    178a:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
	{
	    buffer->count++;
    1792:	80 81       	ld	r24, Z
    1794:	91 81       	ldd	r25, Z+1	; 0x01
    1796:	01 96       	adiw	r24, 0x01	; 1
    1798:	91 83       	std	Z+1, r25	; 0x01
    179a:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    179c:	0f 90       	pop	r0
    179e:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    17a0:	ff 91       	pop	r31
    17a2:	ef 91       	pop	r30
    17a4:	bf 91       	pop	r27
    17a6:	af 91       	pop	r26
    17a8:	9f 91       	pop	r25
    17aa:	8f 91       	pop	r24
    17ac:	4f 91       	pop	r20
    17ae:	3f 91       	pop	r19
    17b0:	2f 91       	pop	r18
    17b2:	0f 90       	pop	r0
    17b4:	0b be       	out	0x3b, r0	; 59
    17b6:	0f 90       	pop	r0
    17b8:	0f be       	out	0x3f, r0	; 63
    17ba:	0f 90       	pop	r0
    17bc:	1f 90       	pop	r1
    17be:	18 95       	reti

000017c0 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    17c0:	1f 92       	push	r1
    17c2:	0f 92       	push	r0
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	0f 92       	push	r0
    17c8:	11 24       	eor	r1, r1
    17ca:	0b b6       	in	r0, 0x3b	; 59
    17cc:	0f 92       	push	r0
    17ce:	2f 93       	push	r18
    17d0:	8f 93       	push	r24
    17d2:	9f 93       	push	r25
    17d4:	af 93       	push	r26
    17d6:	bf 93       	push	r27
    17d8:	ef 93       	push	r30
    17da:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	0f 92       	push	r0
	{
	    count = buffer->count;
    17e2:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xSerial3Port+0xd>
    17e6:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    17ea:	0f 90       	pop	r0
    17ec:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    17ee:	89 2b       	or	r24, r25
    17f0:	31 f4       	brne	.+12     	; 0x17fe <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    17f2:	e1 e3       	ldi	r30, 0x31	; 49
    17f4:	f1 e0       	ldi	r31, 0x01	; 1
    17f6:	80 81       	ld	r24, Z
    17f8:	8f 7d       	andi	r24, 0xDF	; 223
    17fa:	80 83       	st	Z, r24
    17fc:	1c c0       	rjmp	.+56     	; 0x1836 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    17fe:	ea e7       	ldi	r30, 0x7A	; 122
    1800:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1802:	a4 81       	ldd	r26, Z+4	; 0x04
    1804:	b5 81       	ldd	r27, Z+5	; 0x05
    1806:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1808:	b5 83       	std	Z+5, r27	; 0x05
    180a:	a4 83       	std	Z+4, r26	; 0x04
    180c:	80 85       	ldd	r24, Z+8	; 0x08
    180e:	91 85       	ldd	r25, Z+9	; 0x09
    1810:	a8 17       	cp	r26, r24
    1812:	b9 07       	cpc	r27, r25
    1814:	21 f4       	brne	.+8      	; 0x181e <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1816:	86 81       	ldd	r24, Z+6	; 0x06
    1818:	97 81       	ldd	r25, Z+7	; 0x07
    181a:	95 83       	std	Z+5, r25	; 0x05
    181c:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    181e:	0f b6       	in	r0, 0x3f	; 63
    1820:	f8 94       	cli
    1822:	0f 92       	push	r0
	{
	    buffer->count--;
    1824:	80 81       	ld	r24, Z
    1826:	91 81       	ldd	r25, Z+1	; 0x01
    1828:	01 97       	sbiw	r24, 0x01	; 1
    182a:	91 83       	std	Z+1, r25	; 0x01
    182c:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    182e:	0f 90       	pop	r0
    1830:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1832:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1836:	ff 91       	pop	r31
    1838:	ef 91       	pop	r30
    183a:	bf 91       	pop	r27
    183c:	af 91       	pop	r26
    183e:	9f 91       	pop	r25
    1840:	8f 91       	pop	r24
    1842:	2f 91       	pop	r18
    1844:	0f 90       	pop	r0
    1846:	0b be       	out	0x3b, r0	; 59
    1848:	0f 90       	pop	r0
    184a:	0f be       	out	0x3f, r0	; 63
    184c:	0f 90       	pop	r0
    184e:	1f 90       	pop	r1
    1850:	18 95       	reti

00001852 <prvResetNextTaskUnblockTime>:
    1852:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1856:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    185a:	80 81       	ld	r24, Z
    185c:	81 11       	cpse	r24, r1
    185e:	07 c0       	rjmp	.+14     	; 0x186e <prvResetNextTaskUnblockTime+0x1c>
    1860:	8f ef       	ldi	r24, 0xFF	; 255
    1862:	9f ef       	ldi	r25, 0xFF	; 255
    1864:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1868:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    186c:	08 95       	ret
    186e:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1872:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1876:	05 80       	ldd	r0, Z+5	; 0x05
    1878:	f6 81       	ldd	r31, Z+6	; 0x06
    187a:	e0 2d       	mov	r30, r0
    187c:	06 80       	ldd	r0, Z+6	; 0x06
    187e:	f7 81       	ldd	r31, Z+7	; 0x07
    1880:	e0 2d       	mov	r30, r0
    1882:	82 81       	ldd	r24, Z+2	; 0x02
    1884:	93 81       	ldd	r25, Z+3	; 0x03
    1886:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    188a:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    188e:	08 95       	ret

00001890 <prvAddCurrentTaskToDelayedList>:
    1890:	ff 92       	push	r15
    1892:	0f 93       	push	r16
    1894:	1f 93       	push	r17
    1896:	cf 93       	push	r28
    1898:	df 93       	push	r29
    189a:	ec 01       	movw	r28, r24
    189c:	f6 2e       	mov	r15, r22
    189e:	00 91 b5 02 	lds	r16, 0x02B5	; 0x8002b5 <xTickCount>
    18a2:	10 91 b6 02 	lds	r17, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    18a6:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    18aa:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    18ae:	02 96       	adiw	r24, 0x02	; 2
    18b0:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    18b4:	cf 3f       	cpi	r28, 0xFF	; 255
    18b6:	8f ef       	ldi	r24, 0xFF	; 255
    18b8:	d8 07       	cpc	r29, r24
    18ba:	69 f4       	brne	.+26     	; 0x18d6 <prvAddCurrentTaskToDelayedList+0x46>
    18bc:	ff 20       	and	r15, r15
    18be:	59 f0       	breq	.+22     	; 0x18d6 <prvAddCurrentTaskToDelayedList+0x46>
    18c0:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    18c4:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    18c8:	6e 5f       	subi	r22, 0xFE	; 254
    18ca:	7f 4f       	sbci	r23, 0xFF	; 255
    18cc:	88 eb       	ldi	r24, 0xB8	; 184
    18ce:	92 e0       	ldi	r25, 0x02	; 2
    18d0:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    18d4:	2f c0       	rjmp	.+94     	; 0x1934 <prvAddCurrentTaskToDelayedList+0xa4>
    18d6:	c0 0f       	add	r28, r16
    18d8:	d1 1f       	adc	r29, r17
    18da:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    18de:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    18e2:	d3 83       	std	Z+3, r29	; 0x03
    18e4:	c2 83       	std	Z+2, r28	; 0x02
    18e6:	c0 17       	cp	r28, r16
    18e8:	d1 07       	cpc	r29, r17
    18ea:	68 f4       	brcc	.+26     	; 0x1906 <prvAddCurrentTaskToDelayedList+0x76>
    18ec:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    18f0:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    18f4:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <pxOverflowDelayedTaskList>
    18f8:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    18fc:	6e 5f       	subi	r22, 0xFE	; 254
    18fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1900:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1904:	17 c0       	rjmp	.+46     	; 0x1934 <prvAddCurrentTaskToDelayedList+0xa4>
    1906:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    190a:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    190e:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1912:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1916:	6e 5f       	subi	r22, 0xFE	; 254
    1918:	7f 4f       	sbci	r23, 0xFF	; 255
    191a:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    191e:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <xNextTaskUnblockTime>
    1922:	90 91 ae 02 	lds	r25, 0x02AE	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1926:	c8 17       	cp	r28, r24
    1928:	d9 07       	cpc	r29, r25
    192a:	20 f4       	brcc	.+8      	; 0x1934 <prvAddCurrentTaskToDelayedList+0xa4>
    192c:	d0 93 ae 02 	sts	0x02AE, r29	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1930:	c0 93 ad 02 	sts	0x02AD, r28	; 0x8002ad <xNextTaskUnblockTime>
    1934:	df 91       	pop	r29
    1936:	cf 91       	pop	r28
    1938:	1f 91       	pop	r17
    193a:	0f 91       	pop	r16
    193c:	ff 90       	pop	r15
    193e:	08 95       	ret

00001940 <xTaskCreate>:
    1940:	4f 92       	push	r4
    1942:	5f 92       	push	r5
    1944:	6f 92       	push	r6
    1946:	7f 92       	push	r7
    1948:	8f 92       	push	r8
    194a:	9f 92       	push	r9
    194c:	af 92       	push	r10
    194e:	bf 92       	push	r11
    1950:	cf 92       	push	r12
    1952:	df 92       	push	r13
    1954:	ef 92       	push	r14
    1956:	ff 92       	push	r15
    1958:	0f 93       	push	r16
    195a:	cf 93       	push	r28
    195c:	df 93       	push	r29
    195e:	4c 01       	movw	r8, r24
    1960:	6b 01       	movw	r12, r22
    1962:	5a 01       	movw	r10, r20
    1964:	29 01       	movw	r4, r18
    1966:	ca 01       	movw	r24, r20
    1968:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    196c:	3c 01       	movw	r6, r24
    196e:	89 2b       	or	r24, r25
    1970:	09 f4       	brne	.+2      	; 0x1974 <xTaskCreate+0x34>
    1972:	e9 c0       	rjmp	.+466    	; 0x1b46 <xTaskCreate+0x206>
    1974:	88 e2       	ldi	r24, 0x28	; 40
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    197c:	ec 01       	movw	r28, r24
    197e:	89 2b       	or	r24, r25
    1980:	a9 f0       	breq	.+42     	; 0x19ac <xTaskCreate+0x6c>
    1982:	78 8e       	std	Y+24, r7	; 0x18
    1984:	6f 8a       	std	Y+23, r6	; 0x17
    1986:	a5 01       	movw	r20, r10
    1988:	65 ea       	ldi	r22, 0xA5	; 165
    198a:	70 e0       	ldi	r23, 0x00	; 0
    198c:	c3 01       	movw	r24, r6
    198e:	a5 d6       	rcall	.+3402   	; 0x26da <memset>
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	a8 1a       	sub	r10, r24
    1994:	b1 08       	sbc	r11, r1
    1996:	8f 89       	ldd	r24, Y+23	; 0x17
    1998:	98 8d       	ldd	r25, Y+24	; 0x18
    199a:	a8 0e       	add	r10, r24
    199c:	b9 1e       	adc	r11, r25
    199e:	d6 01       	movw	r26, r12
    19a0:	8c 91       	ld	r24, X
    19a2:	89 8f       	std	Y+25, r24	; 0x19
    19a4:	8c 91       	ld	r24, X
    19a6:	81 11       	cpse	r24, r1
    19a8:	05 c0       	rjmp	.+10     	; 0x19b4 <xTaskCreate+0x74>
    19aa:	18 c0       	rjmp	.+48     	; 0x19dc <xTaskCreate+0x9c>
    19ac:	c3 01       	movw	r24, r6
    19ae:	0e 94 bc 01 	call	0x378	; 0x378 <vPortFree>
    19b2:	c9 c0       	rjmp	.+402    	; 0x1b46 <xTaskCreate+0x206>
    19b4:	ae 01       	movw	r20, r28
    19b6:	46 5e       	subi	r20, 0xE6	; 230
    19b8:	5f 4f       	sbci	r21, 0xFF	; 255
    19ba:	f6 01       	movw	r30, r12
    19bc:	31 96       	adiw	r30, 0x01	; 1
    19be:	b8 e0       	ldi	r27, 0x08	; 8
    19c0:	cb 0e       	add	r12, r27
    19c2:	d1 1c       	adc	r13, r1
    19c4:	cf 01       	movw	r24, r30
    19c6:	21 91       	ld	r18, Z+
    19c8:	da 01       	movw	r26, r20
    19ca:	2d 93       	st	X+, r18
    19cc:	ad 01       	movw	r20, r26
    19ce:	dc 01       	movw	r26, r24
    19d0:	8c 91       	ld	r24, X
    19d2:	88 23       	and	r24, r24
    19d4:	19 f0       	breq	.+6      	; 0x19dc <xTaskCreate+0x9c>
    19d6:	ec 15       	cp	r30, r12
    19d8:	fd 05       	cpc	r31, r13
    19da:	a1 f7       	brne	.-24     	; 0x19c4 <xTaskCreate+0x84>
    19dc:	18 a2       	std	Y+32, r1	; 0x20
    19de:	04 30       	cpi	r16, 0x04	; 4
    19e0:	08 f0       	brcs	.+2      	; 0x19e4 <xTaskCreate+0xa4>
    19e2:	03 e0       	ldi	r16, 0x03	; 3
    19e4:	0e 8b       	std	Y+22, r16	; 0x16
    19e6:	09 a3       	std	Y+33, r16	; 0x21
    19e8:	1a a2       	std	Y+34, r1	; 0x22
    19ea:	6e 01       	movw	r12, r28
    19ec:	b2 e0       	ldi	r27, 0x02	; 2
    19ee:	cb 0e       	add	r12, r27
    19f0:	d1 1c       	adc	r13, r1
    19f2:	c6 01       	movw	r24, r12
    19f4:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    19f8:	ce 01       	movw	r24, r28
    19fa:	0c 96       	adiw	r24, 0x0c	; 12
    19fc:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1a00:	d9 87       	std	Y+9, r29	; 0x09
    1a02:	c8 87       	std	Y+8, r28	; 0x08
    1a04:	84 e0       	ldi	r24, 0x04	; 4
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	80 1b       	sub	r24, r16
    1a0a:	91 09       	sbc	r25, r1
    1a0c:	9d 87       	std	Y+13, r25	; 0x0d
    1a0e:	8c 87       	std	Y+12, r24	; 0x0c
    1a10:	db 8b       	std	Y+19, r29	; 0x13
    1a12:	ca 8b       	std	Y+18, r28	; 0x12
    1a14:	1b a2       	std	Y+35, r1	; 0x23
    1a16:	1c a2       	std	Y+36, r1	; 0x24
    1a18:	1d a2       	std	Y+37, r1	; 0x25
    1a1a:	1e a2       	std	Y+38, r1	; 0x26
    1a1c:	1f a2       	std	Y+39, r1	; 0x27
    1a1e:	a2 01       	movw	r20, r4
    1a20:	b4 01       	movw	r22, r8
    1a22:	c5 01       	movw	r24, r10
    1a24:	06 da       	rcall	.-3060   	; 0xe32 <pxPortInitialiseStack>
    1a26:	99 83       	std	Y+1, r25	; 0x01
    1a28:	88 83       	st	Y, r24
    1a2a:	e1 14       	cp	r14, r1
    1a2c:	f1 04       	cpc	r15, r1
    1a2e:	19 f0       	breq	.+6      	; 0x1a36 <xTaskCreate+0xf6>
    1a30:	f7 01       	movw	r30, r14
    1a32:	d1 83       	std	Z+1, r29	; 0x01
    1a34:	c0 83       	st	Z, r28
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	0f 92       	push	r0
    1a3c:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1a40:	8f 5f       	subi	r24, 0xFF	; 255
    1a42:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <uxCurrentNumberOfTasks>
    1a46:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    1a4a:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1a4e:	89 2b       	or	r24, r25
    1a50:	d1 f5       	brne	.+116    	; 0x1ac6 <xTaskCreate+0x186>
    1a52:	d0 93 0f 03 	sts	0x030F, r29	; 0x80030f <pxCurrentTCB+0x1>
    1a56:	c0 93 0e 03 	sts	0x030E, r28	; 0x80030e <pxCurrentTCB>
    1a5a:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1a5e:	81 30       	cpi	r24, 0x01	; 1
    1a60:	09 f0       	breq	.+2      	; 0x1a64 <xTaskCreate+0x124>
    1a62:	41 c0       	rjmp	.+130    	; 0x1ae6 <xTaskCreate+0x1a6>
    1a64:	8a ee       	ldi	r24, 0xEA	; 234
    1a66:	92 e0       	ldi	r25, 0x02	; 2
    1a68:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a6c:	83 ef       	ldi	r24, 0xF3	; 243
    1a6e:	92 e0       	ldi	r25, 0x02	; 2
    1a70:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a74:	8c ef       	ldi	r24, 0xFC	; 252
    1a76:	92 e0       	ldi	r25, 0x02	; 2
    1a78:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a7c:	85 e0       	ldi	r24, 0x05	; 5
    1a7e:	93 e0       	ldi	r25, 0x03	; 3
    1a80:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a84:	81 ee       	ldi	r24, 0xE1	; 225
    1a86:	92 e0       	ldi	r25, 0x02	; 2
    1a88:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a8c:	88 ed       	ldi	r24, 0xD8	; 216
    1a8e:	92 e0       	ldi	r25, 0x02	; 2
    1a90:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a94:	8b ec       	ldi	r24, 0xCB	; 203
    1a96:	92 e0       	ldi	r25, 0x02	; 2
    1a98:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1a9c:	82 ec       	ldi	r24, 0xC2	; 194
    1a9e:	92 e0       	ldi	r25, 0x02	; 2
    1aa0:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1aa4:	88 eb       	ldi	r24, 0xB8	; 184
    1aa6:	92 e0       	ldi	r25, 0x02	; 2
    1aa8:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1aac:	81 ee       	ldi	r24, 0xE1	; 225
    1aae:	92 e0       	ldi	r25, 0x02	; 2
    1ab0:	90 93 d7 02 	sts	0x02D7, r25	; 0x8002d7 <pxDelayedTaskList+0x1>
    1ab4:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <pxDelayedTaskList>
    1ab8:	88 ed       	ldi	r24, 0xD8	; 216
    1aba:	92 e0       	ldi	r25, 0x02	; 2
    1abc:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1ac0:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <pxOverflowDelayedTaskList>
    1ac4:	10 c0       	rjmp	.+32     	; 0x1ae6 <xTaskCreate+0x1a6>
    1ac6:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <xSchedulerRunning>
    1aca:	81 11       	cpse	r24, r1
    1acc:	0c c0       	rjmp	.+24     	; 0x1ae6 <xTaskCreate+0x1a6>
    1ace:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1ad2:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1ad6:	96 89       	ldd	r25, Z+22	; 0x16
    1ad8:	8e 89       	ldd	r24, Y+22	; 0x16
    1ada:	89 17       	cp	r24, r25
    1adc:	20 f0       	brcs	.+8      	; 0x1ae6 <xTaskCreate+0x1a6>
    1ade:	d0 93 0f 03 	sts	0x030F, r29	; 0x80030f <pxCurrentTCB+0x1>
    1ae2:	c0 93 0e 03 	sts	0x030E, r28	; 0x80030e <pxCurrentTCB>
    1ae6:	80 91 af 02 	lds	r24, 0x02AF	; 0x8002af <uxTaskNumber>
    1aea:	8f 5f       	subi	r24, 0xFF	; 255
    1aec:	80 93 af 02 	sts	0x02AF, r24	; 0x8002af <uxTaskNumber>
    1af0:	8e 89       	ldd	r24, Y+22	; 0x16
    1af2:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1af6:	98 17       	cp	r25, r24
    1af8:	10 f4       	brcc	.+4      	; 0x1afe <xTaskCreate+0x1be>
    1afa:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	9c 01       	movw	r18, r24
    1b02:	22 0f       	add	r18, r18
    1b04:	33 1f       	adc	r19, r19
    1b06:	22 0f       	add	r18, r18
    1b08:	33 1f       	adc	r19, r19
    1b0a:	22 0f       	add	r18, r18
    1b0c:	33 1f       	adc	r19, r19
    1b0e:	82 0f       	add	r24, r18
    1b10:	93 1f       	adc	r25, r19
    1b12:	b6 01       	movw	r22, r12
    1b14:	86 51       	subi	r24, 0x16	; 22
    1b16:	9d 4f       	sbci	r25, 0xFD	; 253
    1b18:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1b1c:	0f 90       	pop	r0
    1b1e:	0f be       	out	0x3f, r0	; 63
    1b20:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <xSchedulerRunning>
    1b24:	88 23       	and	r24, r24
    1b26:	59 f0       	breq	.+22     	; 0x1b3e <xTaskCreate+0x1fe>
    1b28:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1b2c:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1b30:	96 89       	ldd	r25, Z+22	; 0x16
    1b32:	8e 89       	ldd	r24, Y+22	; 0x16
    1b34:	98 17       	cp	r25, r24
    1b36:	28 f4       	brcc	.+10     	; 0x1b42 <xTaskCreate+0x202>
    1b38:	34 da       	rcall	.-2968   	; 0xfa2 <vPortYield>
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	05 c0       	rjmp	.+10     	; 0x1b48 <xTaskCreate+0x208>
    1b3e:	81 e0       	ldi	r24, 0x01	; 1
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <xTaskCreate+0x208>
    1b42:	81 e0       	ldi	r24, 0x01	; 1
    1b44:	01 c0       	rjmp	.+2      	; 0x1b48 <xTaskCreate+0x208>
    1b46:	8f ef       	ldi	r24, 0xFF	; 255
    1b48:	df 91       	pop	r29
    1b4a:	cf 91       	pop	r28
    1b4c:	0f 91       	pop	r16
    1b4e:	ff 90       	pop	r15
    1b50:	ef 90       	pop	r14
    1b52:	df 90       	pop	r13
    1b54:	cf 90       	pop	r12
    1b56:	bf 90       	pop	r11
    1b58:	af 90       	pop	r10
    1b5a:	9f 90       	pop	r9
    1b5c:	8f 90       	pop	r8
    1b5e:	7f 90       	pop	r7
    1b60:	6f 90       	pop	r6
    1b62:	5f 90       	pop	r5
    1b64:	4f 90       	pop	r4
    1b66:	08 95       	ret

00001b68 <vTaskStartScheduler>:
    1b68:	ef 92       	push	r14
    1b6a:	ff 92       	push	r15
    1b6c:	0f 93       	push	r16
    1b6e:	0f 2e       	mov	r0, r31
    1b70:	fb ea       	ldi	r31, 0xAB	; 171
    1b72:	ef 2e       	mov	r14, r31
    1b74:	f2 e0       	ldi	r31, 0x02	; 2
    1b76:	ff 2e       	mov	r15, r31
    1b78:	f0 2d       	mov	r31, r0
    1b7a:	00 e0       	ldi	r16, 0x00	; 0
    1b7c:	20 e0       	ldi	r18, 0x00	; 0
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	45 e5       	ldi	r20, 0x55	; 85
    1b82:	50 e0       	ldi	r21, 0x00	; 0
    1b84:	6c e7       	ldi	r22, 0x7C	; 124
    1b86:	72 e0       	ldi	r23, 0x02	; 2
    1b88:	83 e3       	ldi	r24, 0x33	; 51
    1b8a:	91 e0       	ldi	r25, 0x01	; 1
    1b8c:	d9 de       	rcall	.-590    	; 0x1940 <xTaskCreate>
    1b8e:	81 30       	cpi	r24, 0x01	; 1
    1b90:	79 f4       	brne	.+30     	; 0x1bb0 <vTaskStartScheduler+0x48>
    1b92:	f8 94       	cli
    1b94:	8f ef       	ldi	r24, 0xFF	; 255
    1b96:	9f ef       	ldi	r25, 0xFF	; 255
    1b98:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1b9c:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	80 93 b3 02 	sts	0x02B3, r24	; 0x8002b3 <xSchedulerRunning>
    1ba6:	10 92 b6 02 	sts	0x02B6, r1	; 0x8002b6 <xTickCount+0x1>
    1baa:	10 92 b5 02 	sts	0x02B5, r1	; 0x8002b5 <xTickCount>
    1bae:	b3 d9       	rcall	.-3226   	; 0xf16 <xPortStartScheduler>
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	08 95       	ret

00001bb8 <vTaskSuspendAll>:
    1bb8:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1bbc:	8f 5f       	subi	r24, 0xFF	; 255
    1bbe:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <uxSchedulerSuspended>
    1bc2:	08 95       	ret

00001bc4 <xTaskIncrementTick>:
    1bc4:	cf 92       	push	r12
    1bc6:	df 92       	push	r13
    1bc8:	ef 92       	push	r14
    1bca:	ff 92       	push	r15
    1bcc:	0f 93       	push	r16
    1bce:	1f 93       	push	r17
    1bd0:	cf 93       	push	r28
    1bd2:	df 93       	push	r29
    1bd4:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1bd8:	81 11       	cpse	r24, r1
    1bda:	98 c0       	rjmp	.+304    	; 0x1d0c <xTaskIncrementTick+0x148>
    1bdc:	e0 90 b5 02 	lds	r14, 0x02B5	; 0x8002b5 <xTickCount>
    1be0:	f0 90 b6 02 	lds	r15, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    1be4:	8f ef       	ldi	r24, 0xFF	; 255
    1be6:	e8 1a       	sub	r14, r24
    1be8:	f8 0a       	sbc	r15, r24
    1bea:	f0 92 b6 02 	sts	0x02B6, r15	; 0x8002b6 <xTickCount+0x1>
    1bee:	e0 92 b5 02 	sts	0x02B5, r14	; 0x8002b5 <xTickCount>
    1bf2:	e1 14       	cp	r14, r1
    1bf4:	f1 04       	cpc	r15, r1
    1bf6:	b1 f4       	brne	.+44     	; 0x1c24 <xTaskIncrementTick+0x60>
    1bf8:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1bfc:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1c00:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <pxOverflowDelayedTaskList>
    1c04:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1c08:	30 93 d7 02 	sts	0x02D7, r19	; 0x8002d7 <pxDelayedTaskList+0x1>
    1c0c:	20 93 d6 02 	sts	0x02D6, r18	; 0x8002d6 <pxDelayedTaskList>
    1c10:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <pxOverflowDelayedTaskList+0x1>
    1c14:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <pxOverflowDelayedTaskList>
    1c18:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    1c1c:	8f 5f       	subi	r24, 0xFF	; 255
    1c1e:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <xNumOfOverflows>
    1c22:	17 de       	rcall	.-978    	; 0x1852 <prvResetNextTaskUnblockTime>
    1c24:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <xNextTaskUnblockTime>
    1c28:	90 91 ae 02 	lds	r25, 0x02AE	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1c2c:	e8 16       	cp	r14, r24
    1c2e:	f9 06       	cpc	r15, r25
    1c30:	10 f4       	brcc	.+4      	; 0x1c36 <xTaskIncrementTick+0x72>
    1c32:	d1 2c       	mov	r13, r1
    1c34:	53 c0       	rjmp	.+166    	; 0x1cdc <xTaskIncrementTick+0x118>
    1c36:	d1 2c       	mov	r13, r1
    1c38:	cc 24       	eor	r12, r12
    1c3a:	c3 94       	inc	r12
    1c3c:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1c40:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1c44:	80 81       	ld	r24, Z
    1c46:	81 11       	cpse	r24, r1
    1c48:	07 c0       	rjmp	.+14     	; 0x1c58 <xTaskIncrementTick+0x94>
    1c4a:	8f ef       	ldi	r24, 0xFF	; 255
    1c4c:	9f ef       	ldi	r25, 0xFF	; 255
    1c4e:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1c52:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1c56:	42 c0       	rjmp	.+132    	; 0x1cdc <xTaskIncrementTick+0x118>
    1c58:	e0 91 d6 02 	lds	r30, 0x02D6	; 0x8002d6 <pxDelayedTaskList>
    1c5c:	f0 91 d7 02 	lds	r31, 0x02D7	; 0x8002d7 <pxDelayedTaskList+0x1>
    1c60:	05 80       	ldd	r0, Z+5	; 0x05
    1c62:	f6 81       	ldd	r31, Z+6	; 0x06
    1c64:	e0 2d       	mov	r30, r0
    1c66:	c6 81       	ldd	r28, Z+6	; 0x06
    1c68:	d7 81       	ldd	r29, Z+7	; 0x07
    1c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c6c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c6e:	e8 16       	cp	r14, r24
    1c70:	f9 06       	cpc	r15, r25
    1c72:	28 f4       	brcc	.+10     	; 0x1c7e <xTaskIncrementTick+0xba>
    1c74:	90 93 ae 02 	sts	0x02AE, r25	; 0x8002ae <xNextTaskUnblockTime+0x1>
    1c78:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <xNextTaskUnblockTime>
    1c7c:	2f c0       	rjmp	.+94     	; 0x1cdc <xTaskIncrementTick+0x118>
    1c7e:	8e 01       	movw	r16, r28
    1c80:	0e 5f       	subi	r16, 0xFE	; 254
    1c82:	1f 4f       	sbci	r17, 0xFF	; 255
    1c84:	c8 01       	movw	r24, r16
    1c86:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1c8a:	8c 89       	ldd	r24, Y+20	; 0x14
    1c8c:	9d 89       	ldd	r25, Y+21	; 0x15
    1c8e:	89 2b       	or	r24, r25
    1c90:	21 f0       	breq	.+8      	; 0x1c9a <xTaskIncrementTick+0xd6>
    1c92:	ce 01       	movw	r24, r28
    1c94:	0c 96       	adiw	r24, 0x0c	; 12
    1c96:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1c9a:	8e 89       	ldd	r24, Y+22	; 0x16
    1c9c:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1ca0:	98 17       	cp	r25, r24
    1ca2:	10 f4       	brcc	.+4      	; 0x1ca8 <xTaskIncrementTick+0xe4>
    1ca4:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	9c 01       	movw	r18, r24
    1cac:	22 0f       	add	r18, r18
    1cae:	33 1f       	adc	r19, r19
    1cb0:	22 0f       	add	r18, r18
    1cb2:	33 1f       	adc	r19, r19
    1cb4:	22 0f       	add	r18, r18
    1cb6:	33 1f       	adc	r19, r19
    1cb8:	82 0f       	add	r24, r18
    1cba:	93 1f       	adc	r25, r19
    1cbc:	b8 01       	movw	r22, r16
    1cbe:	86 51       	subi	r24, 0x16	; 22
    1cc0:	9d 4f       	sbci	r25, 0xFD	; 253
    1cc2:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1cc6:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1cca:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1cce:	9e 89       	ldd	r25, Y+22	; 0x16
    1cd0:	86 89       	ldd	r24, Z+22	; 0x16
    1cd2:	98 17       	cp	r25, r24
    1cd4:	08 f4       	brcc	.+2      	; 0x1cd8 <xTaskIncrementTick+0x114>
    1cd6:	b2 cf       	rjmp	.-156    	; 0x1c3c <xTaskIncrementTick+0x78>
    1cd8:	dc 2c       	mov	r13, r12
    1cda:	b0 cf       	rjmp	.-160    	; 0x1c3c <xTaskIncrementTick+0x78>
    1cdc:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1ce0:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1ce4:	86 89       	ldd	r24, Z+22	; 0x16
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	fc 01       	movw	r30, r24
    1cea:	ee 0f       	add	r30, r30
    1cec:	ff 1f       	adc	r31, r31
    1cee:	ee 0f       	add	r30, r30
    1cf0:	ff 1f       	adc	r31, r31
    1cf2:	ee 0f       	add	r30, r30
    1cf4:	ff 1f       	adc	r31, r31
    1cf6:	8e 0f       	add	r24, r30
    1cf8:	9f 1f       	adc	r25, r31
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	e6 51       	subi	r30, 0x16	; 22
    1cfe:	fd 4f       	sbci	r31, 0xFD	; 253
    1d00:	80 81       	ld	r24, Z
    1d02:	82 30       	cpi	r24, 0x02	; 2
    1d04:	48 f0       	brcs	.+18     	; 0x1d18 <xTaskIncrementTick+0x154>
    1d06:	dd 24       	eor	r13, r13
    1d08:	d3 94       	inc	r13
    1d0a:	06 c0       	rjmp	.+12     	; 0x1d18 <xTaskIncrementTick+0x154>
    1d0c:	80 91 b2 02 	lds	r24, 0x02B2	; 0x8002b2 <uxPendedTicks>
    1d10:	8f 5f       	subi	r24, 0xFF	; 255
    1d12:	80 93 b2 02 	sts	0x02B2, r24	; 0x8002b2 <uxPendedTicks>
    1d16:	d1 2c       	mov	r13, r1
    1d18:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <xYieldPending>
    1d1c:	88 23       	and	r24, r24
    1d1e:	11 f0       	breq	.+4      	; 0x1d24 <xTaskIncrementTick+0x160>
    1d20:	dd 24       	eor	r13, r13
    1d22:	d3 94       	inc	r13
    1d24:	8d 2d       	mov	r24, r13
    1d26:	df 91       	pop	r29
    1d28:	cf 91       	pop	r28
    1d2a:	1f 91       	pop	r17
    1d2c:	0f 91       	pop	r16
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	df 90       	pop	r13
    1d34:	cf 90       	pop	r12
    1d36:	08 95       	ret

00001d38 <xTaskResumeAll>:
    1d38:	df 92       	push	r13
    1d3a:	ef 92       	push	r14
    1d3c:	ff 92       	push	r15
    1d3e:	0f 93       	push	r16
    1d40:	1f 93       	push	r17
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	0f b6       	in	r0, 0x3f	; 63
    1d48:	f8 94       	cli
    1d4a:	0f 92       	push	r0
    1d4c:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1d50:	81 50       	subi	r24, 0x01	; 1
    1d52:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <uxSchedulerSuspended>
    1d56:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1d5a:	81 11       	cpse	r24, r1
    1d5c:	5c c0       	rjmp	.+184    	; 0x1e16 <xTaskResumeAll+0xde>
    1d5e:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <uxCurrentNumberOfTasks>
    1d62:	81 11       	cpse	r24, r1
    1d64:	33 c0       	rjmp	.+102    	; 0x1dcc <xTaskResumeAll+0x94>
    1d66:	5a c0       	rjmp	.+180    	; 0x1e1c <xTaskResumeAll+0xe4>
    1d68:	d7 01       	movw	r26, r14
    1d6a:	15 96       	adiw	r26, 0x05	; 5
    1d6c:	ed 91       	ld	r30, X+
    1d6e:	fc 91       	ld	r31, X
    1d70:	16 97       	sbiw	r26, 0x06	; 6
    1d72:	c6 81       	ldd	r28, Z+6	; 0x06
    1d74:	d7 81       	ldd	r29, Z+7	; 0x07
    1d76:	ce 01       	movw	r24, r28
    1d78:	0c 96       	adiw	r24, 0x0c	; 12
    1d7a:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1d7e:	8e 01       	movw	r16, r28
    1d80:	0e 5f       	subi	r16, 0xFE	; 254
    1d82:	1f 4f       	sbci	r17, 0xFF	; 255
    1d84:	c8 01       	movw	r24, r16
    1d86:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1d8a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d8c:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1d90:	98 17       	cp	r25, r24
    1d92:	10 f4       	brcc	.+4      	; 0x1d98 <xTaskResumeAll+0x60>
    1d94:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	9c 01       	movw	r18, r24
    1d9c:	22 0f       	add	r18, r18
    1d9e:	33 1f       	adc	r19, r19
    1da0:	22 0f       	add	r18, r18
    1da2:	33 1f       	adc	r19, r19
    1da4:	22 0f       	add	r18, r18
    1da6:	33 1f       	adc	r19, r19
    1da8:	82 0f       	add	r24, r18
    1daa:	93 1f       	adc	r25, r19
    1dac:	b8 01       	movw	r22, r16
    1dae:	86 51       	subi	r24, 0x16	; 22
    1db0:	9d 4f       	sbci	r25, 0xFD	; 253
    1db2:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1db6:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1dba:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1dbe:	9e 89       	ldd	r25, Y+22	; 0x16
    1dc0:	86 89       	ldd	r24, Z+22	; 0x16
    1dc2:	98 17       	cp	r25, r24
    1dc4:	68 f0       	brcs	.+26     	; 0x1de0 <xTaskResumeAll+0xa8>
    1dc6:	d0 92 b1 02 	sts	0x02B1, r13	; 0x8002b1 <xYieldPending>
    1dca:	0a c0       	rjmp	.+20     	; 0x1de0 <xTaskResumeAll+0xa8>
    1dcc:	c0 e0       	ldi	r28, 0x00	; 0
    1dce:	d0 e0       	ldi	r29, 0x00	; 0
    1dd0:	0f 2e       	mov	r0, r31
    1dd2:	fb ec       	ldi	r31, 0xCB	; 203
    1dd4:	ef 2e       	mov	r14, r31
    1dd6:	f2 e0       	ldi	r31, 0x02	; 2
    1dd8:	ff 2e       	mov	r15, r31
    1dda:	f0 2d       	mov	r31, r0
    1ddc:	dd 24       	eor	r13, r13
    1dde:	d3 94       	inc	r13
    1de0:	f7 01       	movw	r30, r14
    1de2:	80 81       	ld	r24, Z
    1de4:	81 11       	cpse	r24, r1
    1de6:	c0 cf       	rjmp	.-128    	; 0x1d68 <xTaskResumeAll+0x30>
    1de8:	cd 2b       	or	r28, r29
    1dea:	09 f0       	breq	.+2      	; 0x1dee <xTaskResumeAll+0xb6>
    1dec:	32 dd       	rcall	.-1436   	; 0x1852 <prvResetNextTaskUnblockTime>
    1dee:	c0 91 b2 02 	lds	r28, 0x02B2	; 0x8002b2 <uxPendedTicks>
    1df2:	cc 23       	and	r28, r28
    1df4:	49 f0       	breq	.+18     	; 0x1e08 <xTaskResumeAll+0xd0>
    1df6:	d1 e0       	ldi	r29, 0x01	; 1
    1df8:	e5 de       	rcall	.-566    	; 0x1bc4 <xTaskIncrementTick>
    1dfa:	81 11       	cpse	r24, r1
    1dfc:	d0 93 b1 02 	sts	0x02B1, r29	; 0x8002b1 <xYieldPending>
    1e00:	c1 50       	subi	r28, 0x01	; 1
    1e02:	d1 f7       	brne	.-12     	; 0x1df8 <xTaskResumeAll+0xc0>
    1e04:	10 92 b2 02 	sts	0x02B2, r1	; 0x8002b2 <uxPendedTicks>
    1e08:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <xYieldPending>
    1e0c:	88 23       	and	r24, r24
    1e0e:	29 f0       	breq	.+10     	; 0x1e1a <xTaskResumeAll+0xe2>
    1e10:	c8 d8       	rcall	.-3696   	; 0xfa2 <vPortYield>
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	03 c0       	rjmp	.+6      	; 0x1e1c <xTaskResumeAll+0xe4>
    1e16:	80 e0       	ldi	r24, 0x00	; 0
    1e18:	01 c0       	rjmp	.+2      	; 0x1e1c <xTaskResumeAll+0xe4>
    1e1a:	80 e0       	ldi	r24, 0x00	; 0
    1e1c:	0f 90       	pop	r0
    1e1e:	0f be       	out	0x3f, r0	; 63
    1e20:	df 91       	pop	r29
    1e22:	cf 91       	pop	r28
    1e24:	1f 91       	pop	r17
    1e26:	0f 91       	pop	r16
    1e28:	ff 90       	pop	r15
    1e2a:	ef 90       	pop	r14
    1e2c:	df 90       	pop	r13
    1e2e:	08 95       	ret

00001e30 <vTaskSwitchContext>:
    1e30:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1e34:	88 23       	and	r24, r24
    1e36:	21 f0       	breq	.+8      	; 0x1e40 <vTaskSwitchContext+0x10>
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    1e3e:	08 95       	ret
    1e40:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <xYieldPending>
    1e44:	a0 91 0e 03 	lds	r26, 0x030E	; 0x80030e <pxCurrentTCB>
    1e48:	b0 91 0f 03 	lds	r27, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1e4c:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1e50:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1e54:	2d 91       	ld	r18, X+
    1e56:	3c 91       	ld	r19, X
    1e58:	87 89       	ldd	r24, Z+23	; 0x17
    1e5a:	90 8d       	ldd	r25, Z+24	; 0x18
    1e5c:	82 17       	cp	r24, r18
    1e5e:	93 07       	cpc	r25, r19
    1e60:	60 f0       	brcs	.+24     	; 0x1e7a <vTaskSwitchContext+0x4a>
    1e62:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    1e66:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1e6a:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <pxCurrentTCB>
    1e6e:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1e72:	67 5e       	subi	r22, 0xE7	; 231
    1e74:	7f 4f       	sbci	r23, 0xFF	; 255
    1e76:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vApplicationStackOverflowHook>
    1e7a:	20 91 b4 02 	lds	r18, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1e7e:	82 2f       	mov	r24, r18
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	fc 01       	movw	r30, r24
    1e84:	ee 0f       	add	r30, r30
    1e86:	ff 1f       	adc	r31, r31
    1e88:	ee 0f       	add	r30, r30
    1e8a:	ff 1f       	adc	r31, r31
    1e8c:	ee 0f       	add	r30, r30
    1e8e:	ff 1f       	adc	r31, r31
    1e90:	e8 0f       	add	r30, r24
    1e92:	f9 1f       	adc	r31, r25
    1e94:	e6 51       	subi	r30, 0x16	; 22
    1e96:	fd 4f       	sbci	r31, 0xFD	; 253
    1e98:	30 81       	ld	r19, Z
    1e9a:	31 11       	cpse	r19, r1
    1e9c:	11 c0       	rjmp	.+34     	; 0x1ec0 <vTaskSwitchContext+0x90>
    1e9e:	21 50       	subi	r18, 0x01	; 1
    1ea0:	82 2f       	mov	r24, r18
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	fc 01       	movw	r30, r24
    1ea6:	ee 0f       	add	r30, r30
    1ea8:	ff 1f       	adc	r31, r31
    1eaa:	ee 0f       	add	r30, r30
    1eac:	ff 1f       	adc	r31, r31
    1eae:	ee 0f       	add	r30, r30
    1eb0:	ff 1f       	adc	r31, r31
    1eb2:	e8 0f       	add	r30, r24
    1eb4:	f9 1f       	adc	r31, r25
    1eb6:	e6 51       	subi	r30, 0x16	; 22
    1eb8:	fd 4f       	sbci	r31, 0xFD	; 253
    1eba:	30 81       	ld	r19, Z
    1ebc:	33 23       	and	r19, r19
    1ebe:	79 f3       	breq	.-34     	; 0x1e9e <vTaskSwitchContext+0x6e>
    1ec0:	ac 01       	movw	r20, r24
    1ec2:	44 0f       	add	r20, r20
    1ec4:	55 1f       	adc	r21, r21
    1ec6:	44 0f       	add	r20, r20
    1ec8:	55 1f       	adc	r21, r21
    1eca:	44 0f       	add	r20, r20
    1ecc:	55 1f       	adc	r21, r21
    1ece:	48 0f       	add	r20, r24
    1ed0:	59 1f       	adc	r21, r25
    1ed2:	da 01       	movw	r26, r20
    1ed4:	a6 51       	subi	r26, 0x16	; 22
    1ed6:	bd 4f       	sbci	r27, 0xFD	; 253
    1ed8:	11 96       	adiw	r26, 0x01	; 1
    1eda:	ed 91       	ld	r30, X+
    1edc:	fc 91       	ld	r31, X
    1ede:	12 97       	sbiw	r26, 0x02	; 2
    1ee0:	02 80       	ldd	r0, Z+2	; 0x02
    1ee2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ee4:	e0 2d       	mov	r30, r0
    1ee6:	12 96       	adiw	r26, 0x02	; 2
    1ee8:	fc 93       	st	X, r31
    1eea:	ee 93       	st	-X, r30
    1eec:	11 97       	sbiw	r26, 0x01	; 1
    1eee:	43 51       	subi	r20, 0x13	; 19
    1ef0:	5d 4f       	sbci	r21, 0xFD	; 253
    1ef2:	e4 17       	cp	r30, r20
    1ef4:	f5 07       	cpc	r31, r21
    1ef6:	29 f4       	brne	.+10     	; 0x1f02 <vTaskSwitchContext+0xd2>
    1ef8:	42 81       	ldd	r20, Z+2	; 0x02
    1efa:	53 81       	ldd	r21, Z+3	; 0x03
    1efc:	fd 01       	movw	r30, r26
    1efe:	52 83       	std	Z+2, r21	; 0x02
    1f00:	41 83       	std	Z+1, r20	; 0x01
    1f02:	fc 01       	movw	r30, r24
    1f04:	ee 0f       	add	r30, r30
    1f06:	ff 1f       	adc	r31, r31
    1f08:	ee 0f       	add	r30, r30
    1f0a:	ff 1f       	adc	r31, r31
    1f0c:	ee 0f       	add	r30, r30
    1f0e:	ff 1f       	adc	r31, r31
    1f10:	8e 0f       	add	r24, r30
    1f12:	9f 1f       	adc	r25, r31
    1f14:	fc 01       	movw	r30, r24
    1f16:	e6 51       	subi	r30, 0x16	; 22
    1f18:	fd 4f       	sbci	r31, 0xFD	; 253
    1f1a:	01 80       	ldd	r0, Z+1	; 0x01
    1f1c:	f2 81       	ldd	r31, Z+2	; 0x02
    1f1e:	e0 2d       	mov	r30, r0
    1f20:	86 81       	ldd	r24, Z+6	; 0x06
    1f22:	97 81       	ldd	r25, Z+7	; 0x07
    1f24:	90 93 0f 03 	sts	0x030F, r25	; 0x80030f <pxCurrentTCB+0x1>
    1f28:	80 93 0e 03 	sts	0x030E, r24	; 0x80030e <pxCurrentTCB>
    1f2c:	20 93 b4 02 	sts	0x02B4, r18	; 0x8002b4 <uxTopReadyPriority>
    1f30:	08 95       	ret

00001f32 <vTaskPlaceOnEventList>:
    1f32:	cf 93       	push	r28
    1f34:	df 93       	push	r29
    1f36:	eb 01       	movw	r28, r22
    1f38:	60 91 0e 03 	lds	r22, 0x030E	; 0x80030e <pxCurrentTCB>
    1f3c:	70 91 0f 03 	lds	r23, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1f40:	64 5f       	subi	r22, 0xF4	; 244
    1f42:	7f 4f       	sbci	r23, 0xFF	; 255
    1f44:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1f48:	61 e0       	ldi	r22, 0x01	; 1
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	a1 dc       	rcall	.-1726   	; 0x1890 <prvAddCurrentTaskToDelayedList>
    1f4e:	df 91       	pop	r29
    1f50:	cf 91       	pop	r28
    1f52:	08 95       	ret

00001f54 <xTaskRemoveFromEventList>:
    1f54:	0f 93       	push	r16
    1f56:	1f 93       	push	r17
    1f58:	cf 93       	push	r28
    1f5a:	df 93       	push	r29
    1f5c:	dc 01       	movw	r26, r24
    1f5e:	15 96       	adiw	r26, 0x05	; 5
    1f60:	ed 91       	ld	r30, X+
    1f62:	fc 91       	ld	r31, X
    1f64:	16 97       	sbiw	r26, 0x06	; 6
    1f66:	c6 81       	ldd	r28, Z+6	; 0x06
    1f68:	d7 81       	ldd	r29, Z+7	; 0x07
    1f6a:	8e 01       	movw	r16, r28
    1f6c:	04 5f       	subi	r16, 0xF4	; 244
    1f6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f70:	c8 01       	movw	r24, r16
    1f72:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f76:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <uxSchedulerSuspended>
    1f7a:	81 11       	cpse	r24, r1
    1f7c:	1c c0       	rjmp	.+56     	; 0x1fb6 <xTaskRemoveFromEventList+0x62>
    1f7e:	0a 50       	subi	r16, 0x0A	; 10
    1f80:	11 09       	sbc	r17, r1
    1f82:	c8 01       	movw	r24, r16
    1f84:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f88:	8e 89       	ldd	r24, Y+22	; 0x16
    1f8a:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    1f8e:	98 17       	cp	r25, r24
    1f90:	10 f4       	brcc	.+4      	; 0x1f96 <xTaskRemoveFromEventList+0x42>
    1f92:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	9c 01       	movw	r18, r24
    1f9a:	22 0f       	add	r18, r18
    1f9c:	33 1f       	adc	r19, r19
    1f9e:	22 0f       	add	r18, r18
    1fa0:	33 1f       	adc	r19, r19
    1fa2:	22 0f       	add	r18, r18
    1fa4:	33 1f       	adc	r19, r19
    1fa6:	82 0f       	add	r24, r18
    1fa8:	93 1f       	adc	r25, r19
    1faa:	b8 01       	movw	r22, r16
    1fac:	86 51       	subi	r24, 0x16	; 22
    1fae:	9d 4f       	sbci	r25, 0xFD	; 253
    1fb0:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1fb4:	05 c0       	rjmp	.+10     	; 0x1fc0 <xTaskRemoveFromEventList+0x6c>
    1fb6:	b8 01       	movw	r22, r16
    1fb8:	8b ec       	ldi	r24, 0xCB	; 203
    1fba:	92 e0       	ldi	r25, 0x02	; 2
    1fbc:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1fc0:	e0 91 0e 03 	lds	r30, 0x030E	; 0x80030e <pxCurrentTCB>
    1fc4:	f0 91 0f 03 	lds	r31, 0x030F	; 0x80030f <pxCurrentTCB+0x1>
    1fc8:	9e 89       	ldd	r25, Y+22	; 0x16
    1fca:	86 89       	ldd	r24, Z+22	; 0x16
    1fcc:	89 17       	cp	r24, r25
    1fce:	20 f4       	brcc	.+8      	; 0x1fd8 <xTaskRemoveFromEventList+0x84>
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    1fd6:	01 c0       	rjmp	.+2      	; 0x1fda <xTaskRemoveFromEventList+0x86>
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	df 91       	pop	r29
    1fdc:	cf 91       	pop	r28
    1fde:	1f 91       	pop	r17
    1fe0:	0f 91       	pop	r16
    1fe2:	08 95       	ret

00001fe4 <vTaskSetTimeOutState>:
    1fe4:	20 91 b0 02 	lds	r18, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    1fe8:	fc 01       	movw	r30, r24
    1fea:	20 83       	st	Z, r18
    1fec:	20 91 b5 02 	lds	r18, 0x02B5	; 0x8002b5 <xTickCount>
    1ff0:	30 91 b6 02 	lds	r19, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    1ff4:	32 83       	std	Z+2, r19	; 0x02
    1ff6:	21 83       	std	Z+1, r18	; 0x01
    1ff8:	08 95       	ret

00001ffa <xTaskCheckForTimeOut>:
    1ffa:	0f b6       	in	r0, 0x3f	; 63
    1ffc:	f8 94       	cli
    1ffe:	0f 92       	push	r0
    2000:	40 91 b5 02 	lds	r20, 0x02B5	; 0x8002b5 <xTickCount>
    2004:	50 91 b6 02 	lds	r21, 0x02B6	; 0x8002b6 <xTickCount+0x1>
    2008:	db 01       	movw	r26, r22
    200a:	2d 91       	ld	r18, X+
    200c:	3c 91       	ld	r19, X
    200e:	2f 3f       	cpi	r18, 0xFF	; 255
    2010:	bf ef       	ldi	r27, 0xFF	; 255
    2012:	3b 07       	cpc	r19, r27
    2014:	11 f1       	breq	.+68     	; 0x205a <xTaskCheckForTimeOut+0x60>
    2016:	e0 91 b0 02 	lds	r30, 0x02B0	; 0x8002b0 <xNumOfOverflows>
    201a:	dc 01       	movw	r26, r24
    201c:	fc 91       	ld	r31, X
    201e:	fe 17       	cp	r31, r30
    2020:	39 f0       	breq	.+14     	; 0x2030 <xTaskCheckForTimeOut+0x36>
    2022:	11 96       	adiw	r26, 0x01	; 1
    2024:	ed 91       	ld	r30, X+
    2026:	fc 91       	ld	r31, X
    2028:	12 97       	sbiw	r26, 0x02	; 2
    202a:	4e 17       	cp	r20, r30
    202c:	5f 07       	cpc	r21, r31
    202e:	b8 f4       	brcc	.+46     	; 0x205e <xTaskCheckForTimeOut+0x64>
    2030:	dc 01       	movw	r26, r24
    2032:	11 96       	adiw	r26, 0x01	; 1
    2034:	ed 91       	ld	r30, X+
    2036:	fc 91       	ld	r31, X
    2038:	12 97       	sbiw	r26, 0x02	; 2
    203a:	da 01       	movw	r26, r20
    203c:	ae 1b       	sub	r26, r30
    203e:	bf 0b       	sbc	r27, r31
    2040:	a2 17       	cp	r26, r18
    2042:	b3 07       	cpc	r27, r19
    2044:	70 f4       	brcc	.+28     	; 0x2062 <xTaskCheckForTimeOut+0x68>
    2046:	db 01       	movw	r26, r22
    2048:	e4 1b       	sub	r30, r20
    204a:	f5 0b       	sbc	r31, r21
    204c:	2e 0f       	add	r18, r30
    204e:	3f 1f       	adc	r19, r31
    2050:	2d 93       	st	X+, r18
    2052:	3c 93       	st	X, r19
    2054:	c7 df       	rcall	.-114    	; 0x1fe4 <vTaskSetTimeOutState>
    2056:	80 e0       	ldi	r24, 0x00	; 0
    2058:	05 c0       	rjmp	.+10     	; 0x2064 <xTaskCheckForTimeOut+0x6a>
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	03 c0       	rjmp	.+6      	; 0x2064 <xTaskCheckForTimeOut+0x6a>
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	01 c0       	rjmp	.+2      	; 0x2064 <xTaskCheckForTimeOut+0x6a>
    2062:	81 e0       	ldi	r24, 0x01	; 1
    2064:	0f 90       	pop	r0
    2066:	0f be       	out	0x3f, r0	; 63
    2068:	08 95       	ret

0000206a <vTaskMissedYield>:
    206a:	81 e0       	ldi	r24, 0x01	; 1
    206c:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <xYieldPending>
    2070:	08 95       	ret

00002072 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2072:	0f 93       	push	r16
    2074:	1f 93       	push	r17
    2076:	cf 93       	push	r28
    2078:	df 93       	push	r29
    207a:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    207c:	89 2b       	or	r24, r25
    207e:	79 f1       	breq	.+94     	; 0x20de <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2080:	82 a1       	ldd	r24, Z+34	; 0x22
    2082:	81 50       	subi	r24, 0x01	; 1
    2084:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2086:	26 89       	ldd	r18, Z+22	; 0x16
    2088:	91 a1       	ldd	r25, Z+33	; 0x21
    208a:	29 17       	cp	r18, r25
    208c:	51 f1       	breq	.+84     	; 0x20e2 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    208e:	81 11       	cpse	r24, r1
    2090:	2a c0       	rjmp	.+84     	; 0x20e6 <xTaskPriorityDisinherit+0x74>
    2092:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2094:	8f 01       	movw	r16, r30
    2096:	0e 5f       	subi	r16, 0xFE	; 254
    2098:	1f 4f       	sbci	r17, 0xFF	; 255
    209a:	c8 01       	movw	r24, r16
    209c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    20a0:	89 a1       	ldd	r24, Y+33	; 0x21
    20a2:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20a4:	24 e0       	ldi	r18, 0x04	; 4
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	28 1b       	sub	r18, r24
    20aa:	31 09       	sbc	r19, r1
    20ac:	3d 87       	std	Y+13, r19	; 0x0d
    20ae:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    20b0:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <uxTopReadyPriority>
    20b4:	98 17       	cp	r25, r24
    20b6:	10 f4       	brcc	.+4      	; 0x20bc <xTaskPriorityDisinherit+0x4a>
    20b8:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxTopReadyPriority>
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	9c 01       	movw	r18, r24
    20c0:	22 0f       	add	r18, r18
    20c2:	33 1f       	adc	r19, r19
    20c4:	22 0f       	add	r18, r18
    20c6:	33 1f       	adc	r19, r19
    20c8:	22 0f       	add	r18, r18
    20ca:	33 1f       	adc	r19, r19
    20cc:	82 0f       	add	r24, r18
    20ce:	93 1f       	adc	r25, r19
    20d0:	b8 01       	movw	r22, r16
    20d2:	86 51       	subi	r24, 0x16	; 22
    20d4:	9d 4f       	sbci	r25, 0xFD	; 253
    20d6:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	05 c0       	rjmp	.+10     	; 0x20e8 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    20de:	80 e0       	ldi	r24, 0x00	; 0
    20e0:	03 c0       	rjmp	.+6      	; 0x20e8 <xTaskPriorityDisinherit+0x76>
    20e2:	80 e0       	ldi	r24, 0x00	; 0
    20e4:	01 c0       	rjmp	.+2      	; 0x20e8 <xTaskPriorityDisinherit+0x76>
    20e6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	1f 91       	pop	r17
    20ee:	0f 91       	pop	r16
    20f0:	08 95       	ret

000020f2 <__subsf3>:
    20f2:	50 58       	subi	r21, 0x80	; 128

000020f4 <__addsf3>:
    20f4:	bb 27       	eor	r27, r27
    20f6:	aa 27       	eor	r26, r26
    20f8:	0e d0       	rcall	.+28     	; 0x2116 <__addsf3x>
    20fa:	e5 c0       	rjmp	.+458    	; 0x22c6 <__fp_round>
    20fc:	d6 d0       	rcall	.+428    	; 0x22aa <__fp_pscA>
    20fe:	30 f0       	brcs	.+12     	; 0x210c <__addsf3+0x18>
    2100:	db d0       	rcall	.+438    	; 0x22b8 <__fp_pscB>
    2102:	20 f0       	brcs	.+8      	; 0x210c <__addsf3+0x18>
    2104:	31 f4       	brne	.+12     	; 0x2112 <__addsf3+0x1e>
    2106:	9f 3f       	cpi	r25, 0xFF	; 255
    2108:	11 f4       	brne	.+4      	; 0x210e <__addsf3+0x1a>
    210a:	1e f4       	brtc	.+6      	; 0x2112 <__addsf3+0x1e>
    210c:	cb c0       	rjmp	.+406    	; 0x22a4 <__fp_nan>
    210e:	0e f4       	brtc	.+2      	; 0x2112 <__addsf3+0x1e>
    2110:	e0 95       	com	r30
    2112:	e7 fb       	bst	r30, 7
    2114:	c1 c0       	rjmp	.+386    	; 0x2298 <__fp_inf>

00002116 <__addsf3x>:
    2116:	e9 2f       	mov	r30, r25
    2118:	e7 d0       	rcall	.+462    	; 0x22e8 <__fp_split3>
    211a:	80 f3       	brcs	.-32     	; 0x20fc <__addsf3+0x8>
    211c:	ba 17       	cp	r27, r26
    211e:	62 07       	cpc	r22, r18
    2120:	73 07       	cpc	r23, r19
    2122:	84 07       	cpc	r24, r20
    2124:	95 07       	cpc	r25, r21
    2126:	18 f0       	brcs	.+6      	; 0x212e <__addsf3x+0x18>
    2128:	71 f4       	brne	.+28     	; 0x2146 <__addsf3x+0x30>
    212a:	9e f5       	brtc	.+102    	; 0x2192 <__addsf3x+0x7c>
    212c:	ff c0       	rjmp	.+510    	; 0x232c <__fp_zero>
    212e:	0e f4       	brtc	.+2      	; 0x2132 <__addsf3x+0x1c>
    2130:	e0 95       	com	r30
    2132:	0b 2e       	mov	r0, r27
    2134:	ba 2f       	mov	r27, r26
    2136:	a0 2d       	mov	r26, r0
    2138:	0b 01       	movw	r0, r22
    213a:	b9 01       	movw	r22, r18
    213c:	90 01       	movw	r18, r0
    213e:	0c 01       	movw	r0, r24
    2140:	ca 01       	movw	r24, r20
    2142:	a0 01       	movw	r20, r0
    2144:	11 24       	eor	r1, r1
    2146:	ff 27       	eor	r31, r31
    2148:	59 1b       	sub	r21, r25
    214a:	99 f0       	breq	.+38     	; 0x2172 <__addsf3x+0x5c>
    214c:	59 3f       	cpi	r21, 0xF9	; 249
    214e:	50 f4       	brcc	.+20     	; 0x2164 <__addsf3x+0x4e>
    2150:	50 3e       	cpi	r21, 0xE0	; 224
    2152:	68 f1       	brcs	.+90     	; 0x21ae <__addsf3x+0x98>
    2154:	1a 16       	cp	r1, r26
    2156:	f0 40       	sbci	r31, 0x00	; 0
    2158:	a2 2f       	mov	r26, r18
    215a:	23 2f       	mov	r18, r19
    215c:	34 2f       	mov	r19, r20
    215e:	44 27       	eor	r20, r20
    2160:	58 5f       	subi	r21, 0xF8	; 248
    2162:	f3 cf       	rjmp	.-26     	; 0x214a <__addsf3x+0x34>
    2164:	46 95       	lsr	r20
    2166:	37 95       	ror	r19
    2168:	27 95       	ror	r18
    216a:	a7 95       	ror	r26
    216c:	f0 40       	sbci	r31, 0x00	; 0
    216e:	53 95       	inc	r21
    2170:	c9 f7       	brne	.-14     	; 0x2164 <__addsf3x+0x4e>
    2172:	7e f4       	brtc	.+30     	; 0x2192 <__addsf3x+0x7c>
    2174:	1f 16       	cp	r1, r31
    2176:	ba 0b       	sbc	r27, r26
    2178:	62 0b       	sbc	r22, r18
    217a:	73 0b       	sbc	r23, r19
    217c:	84 0b       	sbc	r24, r20
    217e:	ba f0       	brmi	.+46     	; 0x21ae <__addsf3x+0x98>
    2180:	91 50       	subi	r25, 0x01	; 1
    2182:	a1 f0       	breq	.+40     	; 0x21ac <__addsf3x+0x96>
    2184:	ff 0f       	add	r31, r31
    2186:	bb 1f       	adc	r27, r27
    2188:	66 1f       	adc	r22, r22
    218a:	77 1f       	adc	r23, r23
    218c:	88 1f       	adc	r24, r24
    218e:	c2 f7       	brpl	.-16     	; 0x2180 <__addsf3x+0x6a>
    2190:	0e c0       	rjmp	.+28     	; 0x21ae <__addsf3x+0x98>
    2192:	ba 0f       	add	r27, r26
    2194:	62 1f       	adc	r22, r18
    2196:	73 1f       	adc	r23, r19
    2198:	84 1f       	adc	r24, r20
    219a:	48 f4       	brcc	.+18     	; 0x21ae <__addsf3x+0x98>
    219c:	87 95       	ror	r24
    219e:	77 95       	ror	r23
    21a0:	67 95       	ror	r22
    21a2:	b7 95       	ror	r27
    21a4:	f7 95       	ror	r31
    21a6:	9e 3f       	cpi	r25, 0xFE	; 254
    21a8:	08 f0       	brcs	.+2      	; 0x21ac <__addsf3x+0x96>
    21aa:	b3 cf       	rjmp	.-154    	; 0x2112 <__addsf3+0x1e>
    21ac:	93 95       	inc	r25
    21ae:	88 0f       	add	r24, r24
    21b0:	08 f0       	brcs	.+2      	; 0x21b4 <__addsf3x+0x9e>
    21b2:	99 27       	eor	r25, r25
    21b4:	ee 0f       	add	r30, r30
    21b6:	97 95       	ror	r25
    21b8:	87 95       	ror	r24
    21ba:	08 95       	ret

000021bc <__fixsfsi>:
    21bc:	04 d0       	rcall	.+8      	; 0x21c6 <__fixunssfsi>
    21be:	68 94       	set
    21c0:	b1 11       	cpse	r27, r1
    21c2:	b5 c0       	rjmp	.+362    	; 0x232e <__fp_szero>
    21c4:	08 95       	ret

000021c6 <__fixunssfsi>:
    21c6:	98 d0       	rcall	.+304    	; 0x22f8 <__fp_splitA>
    21c8:	88 f0       	brcs	.+34     	; 0x21ec <__fixunssfsi+0x26>
    21ca:	9f 57       	subi	r25, 0x7F	; 127
    21cc:	90 f0       	brcs	.+36     	; 0x21f2 <__fixunssfsi+0x2c>
    21ce:	b9 2f       	mov	r27, r25
    21d0:	99 27       	eor	r25, r25
    21d2:	b7 51       	subi	r27, 0x17	; 23
    21d4:	a0 f0       	brcs	.+40     	; 0x21fe <__fixunssfsi+0x38>
    21d6:	d1 f0       	breq	.+52     	; 0x220c <__stack+0xd>
    21d8:	66 0f       	add	r22, r22
    21da:	77 1f       	adc	r23, r23
    21dc:	88 1f       	adc	r24, r24
    21de:	99 1f       	adc	r25, r25
    21e0:	1a f0       	brmi	.+6      	; 0x21e8 <__fixunssfsi+0x22>
    21e2:	ba 95       	dec	r27
    21e4:	c9 f7       	brne	.-14     	; 0x21d8 <__fixunssfsi+0x12>
    21e6:	12 c0       	rjmp	.+36     	; 0x220c <__stack+0xd>
    21e8:	b1 30       	cpi	r27, 0x01	; 1
    21ea:	81 f0       	breq	.+32     	; 0x220c <__stack+0xd>
    21ec:	9f d0       	rcall	.+318    	; 0x232c <__fp_zero>
    21ee:	b1 e0       	ldi	r27, 0x01	; 1
    21f0:	08 95       	ret
    21f2:	9c c0       	rjmp	.+312    	; 0x232c <__fp_zero>
    21f4:	67 2f       	mov	r22, r23
    21f6:	78 2f       	mov	r23, r24
    21f8:	88 27       	eor	r24, r24
    21fa:	b8 5f       	subi	r27, 0xF8	; 248
    21fc:	39 f0       	breq	.+14     	; 0x220c <__stack+0xd>
    21fe:	b9 3f       	cpi	r27, 0xF9	; 249
    2200:	cc f3       	brlt	.-14     	; 0x21f4 <__fixunssfsi+0x2e>
    2202:	86 95       	lsr	r24
    2204:	77 95       	ror	r23
    2206:	67 95       	ror	r22
    2208:	b3 95       	inc	r27
    220a:	d9 f7       	brne	.-10     	; 0x2202 <__stack+0x3>
    220c:	3e f4       	brtc	.+14     	; 0x221c <__stack+0x1d>
    220e:	90 95       	com	r25
    2210:	80 95       	com	r24
    2212:	70 95       	com	r23
    2214:	61 95       	neg	r22
    2216:	7f 4f       	sbci	r23, 0xFF	; 255
    2218:	8f 4f       	sbci	r24, 0xFF	; 255
    221a:	9f 4f       	sbci	r25, 0xFF	; 255
    221c:	08 95       	ret

0000221e <__floatunsisf>:
    221e:	e8 94       	clt
    2220:	09 c0       	rjmp	.+18     	; 0x2234 <__floatsisf+0x12>

00002222 <__floatsisf>:
    2222:	97 fb       	bst	r25, 7
    2224:	3e f4       	brtc	.+14     	; 0x2234 <__floatsisf+0x12>
    2226:	90 95       	com	r25
    2228:	80 95       	com	r24
    222a:	70 95       	com	r23
    222c:	61 95       	neg	r22
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	8f 4f       	sbci	r24, 0xFF	; 255
    2232:	9f 4f       	sbci	r25, 0xFF	; 255
    2234:	99 23       	and	r25, r25
    2236:	a9 f0       	breq	.+42     	; 0x2262 <__floatsisf+0x40>
    2238:	f9 2f       	mov	r31, r25
    223a:	96 e9       	ldi	r25, 0x96	; 150
    223c:	bb 27       	eor	r27, r27
    223e:	93 95       	inc	r25
    2240:	f6 95       	lsr	r31
    2242:	87 95       	ror	r24
    2244:	77 95       	ror	r23
    2246:	67 95       	ror	r22
    2248:	b7 95       	ror	r27
    224a:	f1 11       	cpse	r31, r1
    224c:	f8 cf       	rjmp	.-16     	; 0x223e <__floatsisf+0x1c>
    224e:	fa f4       	brpl	.+62     	; 0x228e <__floatsisf+0x6c>
    2250:	bb 0f       	add	r27, r27
    2252:	11 f4       	brne	.+4      	; 0x2258 <__floatsisf+0x36>
    2254:	60 ff       	sbrs	r22, 0
    2256:	1b c0       	rjmp	.+54     	; 0x228e <__floatsisf+0x6c>
    2258:	6f 5f       	subi	r22, 0xFF	; 255
    225a:	7f 4f       	sbci	r23, 0xFF	; 255
    225c:	8f 4f       	sbci	r24, 0xFF	; 255
    225e:	9f 4f       	sbci	r25, 0xFF	; 255
    2260:	16 c0       	rjmp	.+44     	; 0x228e <__floatsisf+0x6c>
    2262:	88 23       	and	r24, r24
    2264:	11 f0       	breq	.+4      	; 0x226a <__floatsisf+0x48>
    2266:	96 e9       	ldi	r25, 0x96	; 150
    2268:	11 c0       	rjmp	.+34     	; 0x228c <__floatsisf+0x6a>
    226a:	77 23       	and	r23, r23
    226c:	21 f0       	breq	.+8      	; 0x2276 <__floatsisf+0x54>
    226e:	9e e8       	ldi	r25, 0x8E	; 142
    2270:	87 2f       	mov	r24, r23
    2272:	76 2f       	mov	r23, r22
    2274:	05 c0       	rjmp	.+10     	; 0x2280 <__floatsisf+0x5e>
    2276:	66 23       	and	r22, r22
    2278:	71 f0       	breq	.+28     	; 0x2296 <__floatsisf+0x74>
    227a:	96 e8       	ldi	r25, 0x86	; 134
    227c:	86 2f       	mov	r24, r22
    227e:	70 e0       	ldi	r23, 0x00	; 0
    2280:	60 e0       	ldi	r22, 0x00	; 0
    2282:	2a f0       	brmi	.+10     	; 0x228e <__floatsisf+0x6c>
    2284:	9a 95       	dec	r25
    2286:	66 0f       	add	r22, r22
    2288:	77 1f       	adc	r23, r23
    228a:	88 1f       	adc	r24, r24
    228c:	da f7       	brpl	.-10     	; 0x2284 <__floatsisf+0x62>
    228e:	88 0f       	add	r24, r24
    2290:	96 95       	lsr	r25
    2292:	87 95       	ror	r24
    2294:	97 f9       	bld	r25, 7
    2296:	08 95       	ret

00002298 <__fp_inf>:
    2298:	97 f9       	bld	r25, 7
    229a:	9f 67       	ori	r25, 0x7F	; 127
    229c:	80 e8       	ldi	r24, 0x80	; 128
    229e:	70 e0       	ldi	r23, 0x00	; 0
    22a0:	60 e0       	ldi	r22, 0x00	; 0
    22a2:	08 95       	ret

000022a4 <__fp_nan>:
    22a4:	9f ef       	ldi	r25, 0xFF	; 255
    22a6:	80 ec       	ldi	r24, 0xC0	; 192
    22a8:	08 95       	ret

000022aa <__fp_pscA>:
    22aa:	00 24       	eor	r0, r0
    22ac:	0a 94       	dec	r0
    22ae:	16 16       	cp	r1, r22
    22b0:	17 06       	cpc	r1, r23
    22b2:	18 06       	cpc	r1, r24
    22b4:	09 06       	cpc	r0, r25
    22b6:	08 95       	ret

000022b8 <__fp_pscB>:
    22b8:	00 24       	eor	r0, r0
    22ba:	0a 94       	dec	r0
    22bc:	12 16       	cp	r1, r18
    22be:	13 06       	cpc	r1, r19
    22c0:	14 06       	cpc	r1, r20
    22c2:	05 06       	cpc	r0, r21
    22c4:	08 95       	ret

000022c6 <__fp_round>:
    22c6:	09 2e       	mov	r0, r25
    22c8:	03 94       	inc	r0
    22ca:	00 0c       	add	r0, r0
    22cc:	11 f4       	brne	.+4      	; 0x22d2 <__fp_round+0xc>
    22ce:	88 23       	and	r24, r24
    22d0:	52 f0       	brmi	.+20     	; 0x22e6 <__fp_round+0x20>
    22d2:	bb 0f       	add	r27, r27
    22d4:	40 f4       	brcc	.+16     	; 0x22e6 <__fp_round+0x20>
    22d6:	bf 2b       	or	r27, r31
    22d8:	11 f4       	brne	.+4      	; 0x22de <__fp_round+0x18>
    22da:	60 ff       	sbrs	r22, 0
    22dc:	04 c0       	rjmp	.+8      	; 0x22e6 <__fp_round+0x20>
    22de:	6f 5f       	subi	r22, 0xFF	; 255
    22e0:	7f 4f       	sbci	r23, 0xFF	; 255
    22e2:	8f 4f       	sbci	r24, 0xFF	; 255
    22e4:	9f 4f       	sbci	r25, 0xFF	; 255
    22e6:	08 95       	ret

000022e8 <__fp_split3>:
    22e8:	57 fd       	sbrc	r21, 7
    22ea:	90 58       	subi	r25, 0x80	; 128
    22ec:	44 0f       	add	r20, r20
    22ee:	55 1f       	adc	r21, r21
    22f0:	59 f0       	breq	.+22     	; 0x2308 <__fp_splitA+0x10>
    22f2:	5f 3f       	cpi	r21, 0xFF	; 255
    22f4:	71 f0       	breq	.+28     	; 0x2312 <__fp_splitA+0x1a>
    22f6:	47 95       	ror	r20

000022f8 <__fp_splitA>:
    22f8:	88 0f       	add	r24, r24
    22fa:	97 fb       	bst	r25, 7
    22fc:	99 1f       	adc	r25, r25
    22fe:	61 f0       	breq	.+24     	; 0x2318 <__fp_splitA+0x20>
    2300:	9f 3f       	cpi	r25, 0xFF	; 255
    2302:	79 f0       	breq	.+30     	; 0x2322 <__fp_splitA+0x2a>
    2304:	87 95       	ror	r24
    2306:	08 95       	ret
    2308:	12 16       	cp	r1, r18
    230a:	13 06       	cpc	r1, r19
    230c:	14 06       	cpc	r1, r20
    230e:	55 1f       	adc	r21, r21
    2310:	f2 cf       	rjmp	.-28     	; 0x22f6 <__fp_split3+0xe>
    2312:	46 95       	lsr	r20
    2314:	f1 df       	rcall	.-30     	; 0x22f8 <__fp_splitA>
    2316:	08 c0       	rjmp	.+16     	; 0x2328 <__fp_splitA+0x30>
    2318:	16 16       	cp	r1, r22
    231a:	17 06       	cpc	r1, r23
    231c:	18 06       	cpc	r1, r24
    231e:	99 1f       	adc	r25, r25
    2320:	f1 cf       	rjmp	.-30     	; 0x2304 <__fp_splitA+0xc>
    2322:	86 95       	lsr	r24
    2324:	71 05       	cpc	r23, r1
    2326:	61 05       	cpc	r22, r1
    2328:	08 94       	sec
    232a:	08 95       	ret

0000232c <__fp_zero>:
    232c:	e8 94       	clt

0000232e <__fp_szero>:
    232e:	bb 27       	eor	r27, r27
    2330:	66 27       	eor	r22, r22
    2332:	77 27       	eor	r23, r23
    2334:	cb 01       	movw	r24, r22
    2336:	97 f9       	bld	r25, 7
    2338:	08 95       	ret

0000233a <__mulsf3>:
    233a:	0b d0       	rcall	.+22     	; 0x2352 <__mulsf3x>
    233c:	c4 cf       	rjmp	.-120    	; 0x22c6 <__fp_round>
    233e:	b5 df       	rcall	.-150    	; 0x22aa <__fp_pscA>
    2340:	28 f0       	brcs	.+10     	; 0x234c <__mulsf3+0x12>
    2342:	ba df       	rcall	.-140    	; 0x22b8 <__fp_pscB>
    2344:	18 f0       	brcs	.+6      	; 0x234c <__mulsf3+0x12>
    2346:	95 23       	and	r25, r21
    2348:	09 f0       	breq	.+2      	; 0x234c <__mulsf3+0x12>
    234a:	a6 cf       	rjmp	.-180    	; 0x2298 <__fp_inf>
    234c:	ab cf       	rjmp	.-170    	; 0x22a4 <__fp_nan>
    234e:	11 24       	eor	r1, r1
    2350:	ee cf       	rjmp	.-36     	; 0x232e <__fp_szero>

00002352 <__mulsf3x>:
    2352:	ca df       	rcall	.-108    	; 0x22e8 <__fp_split3>
    2354:	a0 f3       	brcs	.-24     	; 0x233e <__mulsf3+0x4>

00002356 <__mulsf3_pse>:
    2356:	95 9f       	mul	r25, r21
    2358:	d1 f3       	breq	.-12     	; 0x234e <__mulsf3+0x14>
    235a:	95 0f       	add	r25, r21
    235c:	50 e0       	ldi	r21, 0x00	; 0
    235e:	55 1f       	adc	r21, r21
    2360:	62 9f       	mul	r22, r18
    2362:	f0 01       	movw	r30, r0
    2364:	72 9f       	mul	r23, r18
    2366:	bb 27       	eor	r27, r27
    2368:	f0 0d       	add	r31, r0
    236a:	b1 1d       	adc	r27, r1
    236c:	63 9f       	mul	r22, r19
    236e:	aa 27       	eor	r26, r26
    2370:	f0 0d       	add	r31, r0
    2372:	b1 1d       	adc	r27, r1
    2374:	aa 1f       	adc	r26, r26
    2376:	64 9f       	mul	r22, r20
    2378:	66 27       	eor	r22, r22
    237a:	b0 0d       	add	r27, r0
    237c:	a1 1d       	adc	r26, r1
    237e:	66 1f       	adc	r22, r22
    2380:	82 9f       	mul	r24, r18
    2382:	22 27       	eor	r18, r18
    2384:	b0 0d       	add	r27, r0
    2386:	a1 1d       	adc	r26, r1
    2388:	62 1f       	adc	r22, r18
    238a:	73 9f       	mul	r23, r19
    238c:	b0 0d       	add	r27, r0
    238e:	a1 1d       	adc	r26, r1
    2390:	62 1f       	adc	r22, r18
    2392:	83 9f       	mul	r24, r19
    2394:	a0 0d       	add	r26, r0
    2396:	61 1d       	adc	r22, r1
    2398:	22 1f       	adc	r18, r18
    239a:	74 9f       	mul	r23, r20
    239c:	33 27       	eor	r19, r19
    239e:	a0 0d       	add	r26, r0
    23a0:	61 1d       	adc	r22, r1
    23a2:	23 1f       	adc	r18, r19
    23a4:	84 9f       	mul	r24, r20
    23a6:	60 0d       	add	r22, r0
    23a8:	21 1d       	adc	r18, r1
    23aa:	82 2f       	mov	r24, r18
    23ac:	76 2f       	mov	r23, r22
    23ae:	6a 2f       	mov	r22, r26
    23b0:	11 24       	eor	r1, r1
    23b2:	9f 57       	subi	r25, 0x7F	; 127
    23b4:	50 40       	sbci	r21, 0x00	; 0
    23b6:	8a f0       	brmi	.+34     	; 0x23da <__mulsf3_pse+0x84>
    23b8:	e1 f0       	breq	.+56     	; 0x23f2 <__mulsf3_pse+0x9c>
    23ba:	88 23       	and	r24, r24
    23bc:	4a f0       	brmi	.+18     	; 0x23d0 <__mulsf3_pse+0x7a>
    23be:	ee 0f       	add	r30, r30
    23c0:	ff 1f       	adc	r31, r31
    23c2:	bb 1f       	adc	r27, r27
    23c4:	66 1f       	adc	r22, r22
    23c6:	77 1f       	adc	r23, r23
    23c8:	88 1f       	adc	r24, r24
    23ca:	91 50       	subi	r25, 0x01	; 1
    23cc:	50 40       	sbci	r21, 0x00	; 0
    23ce:	a9 f7       	brne	.-22     	; 0x23ba <__mulsf3_pse+0x64>
    23d0:	9e 3f       	cpi	r25, 0xFE	; 254
    23d2:	51 05       	cpc	r21, r1
    23d4:	70 f0       	brcs	.+28     	; 0x23f2 <__mulsf3_pse+0x9c>
    23d6:	60 cf       	rjmp	.-320    	; 0x2298 <__fp_inf>
    23d8:	aa cf       	rjmp	.-172    	; 0x232e <__fp_szero>
    23da:	5f 3f       	cpi	r21, 0xFF	; 255
    23dc:	ec f3       	brlt	.-6      	; 0x23d8 <__mulsf3_pse+0x82>
    23de:	98 3e       	cpi	r25, 0xE8	; 232
    23e0:	dc f3       	brlt	.-10     	; 0x23d8 <__mulsf3_pse+0x82>
    23e2:	86 95       	lsr	r24
    23e4:	77 95       	ror	r23
    23e6:	67 95       	ror	r22
    23e8:	b7 95       	ror	r27
    23ea:	f7 95       	ror	r31
    23ec:	e7 95       	ror	r30
    23ee:	9f 5f       	subi	r25, 0xFF	; 255
    23f0:	c1 f7       	brne	.-16     	; 0x23e2 <__mulsf3_pse+0x8c>
    23f2:	fe 2b       	or	r31, r30
    23f4:	88 0f       	add	r24, r24
    23f6:	91 1d       	adc	r25, r1
    23f8:	96 95       	lsr	r25
    23fa:	87 95       	ror	r24
    23fc:	97 f9       	bld	r25, 7
    23fe:	08 95       	ret

00002400 <__udivmodsi4>:
    2400:	a1 e2       	ldi	r26, 0x21	; 33
    2402:	1a 2e       	mov	r1, r26
    2404:	aa 1b       	sub	r26, r26
    2406:	bb 1b       	sub	r27, r27
    2408:	fd 01       	movw	r30, r26
    240a:	0d c0       	rjmp	.+26     	; 0x2426 <__udivmodsi4_ep>

0000240c <__udivmodsi4_loop>:
    240c:	aa 1f       	adc	r26, r26
    240e:	bb 1f       	adc	r27, r27
    2410:	ee 1f       	adc	r30, r30
    2412:	ff 1f       	adc	r31, r31
    2414:	a2 17       	cp	r26, r18
    2416:	b3 07       	cpc	r27, r19
    2418:	e4 07       	cpc	r30, r20
    241a:	f5 07       	cpc	r31, r21
    241c:	20 f0       	brcs	.+8      	; 0x2426 <__udivmodsi4_ep>
    241e:	a2 1b       	sub	r26, r18
    2420:	b3 0b       	sbc	r27, r19
    2422:	e4 0b       	sbc	r30, r20
    2424:	f5 0b       	sbc	r31, r21

00002426 <__udivmodsi4_ep>:
    2426:	66 1f       	adc	r22, r22
    2428:	77 1f       	adc	r23, r23
    242a:	88 1f       	adc	r24, r24
    242c:	99 1f       	adc	r25, r25
    242e:	1a 94       	dec	r1
    2430:	69 f7       	brne	.-38     	; 0x240c <__udivmodsi4_loop>
    2432:	60 95       	com	r22
    2434:	70 95       	com	r23
    2436:	80 95       	com	r24
    2438:	90 95       	com	r25
    243a:	9b 01       	movw	r18, r22
    243c:	ac 01       	movw	r20, r24
    243e:	bd 01       	movw	r22, r26
    2440:	cf 01       	movw	r24, r30
    2442:	08 95       	ret

00002444 <__tablejump2__>:
    2444:	ee 0f       	add	r30, r30
    2446:	ff 1f       	adc	r31, r31
    2448:	88 1f       	adc	r24, r24
    244a:	8b bf       	out	0x3b, r24	; 59
    244c:	07 90       	elpm	r0, Z+
    244e:	f6 91       	elpm	r31, Z
    2450:	e0 2d       	mov	r30, r0
    2452:	19 94       	eijmp

00002454 <__umulhisi3>:
    2454:	a2 9f       	mul	r26, r18
    2456:	b0 01       	movw	r22, r0
    2458:	b3 9f       	mul	r27, r19
    245a:	c0 01       	movw	r24, r0
    245c:	a3 9f       	mul	r26, r19
    245e:	70 0d       	add	r23, r0
    2460:	81 1d       	adc	r24, r1
    2462:	11 24       	eor	r1, r1
    2464:	91 1d       	adc	r25, r1
    2466:	b2 9f       	mul	r27, r18
    2468:	70 0d       	add	r23, r0
    246a:	81 1d       	adc	r24, r1
    246c:	11 24       	eor	r1, r1
    246e:	91 1d       	adc	r25, r1
    2470:	08 95       	ret

00002472 <__muluhisi3>:
    2472:	f0 df       	rcall	.-32     	; 0x2454 <__umulhisi3>
    2474:	a5 9f       	mul	r26, r21
    2476:	90 0d       	add	r25, r0
    2478:	b4 9f       	mul	r27, r20
    247a:	90 0d       	add	r25, r0
    247c:	a4 9f       	mul	r26, r20
    247e:	80 0d       	add	r24, r0
    2480:	91 1d       	adc	r25, r1
    2482:	11 24       	eor	r1, r1
    2484:	08 95       	ret

00002486 <malloc>:
    2486:	0f 93       	push	r16
    2488:	1f 93       	push	r17
    248a:	cf 93       	push	r28
    248c:	df 93       	push	r29
    248e:	82 30       	cpi	r24, 0x02	; 2
    2490:	91 05       	cpc	r25, r1
    2492:	10 f4       	brcc	.+4      	; 0x2498 <malloc+0x12>
    2494:	82 e0       	ldi	r24, 0x02	; 2
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	e0 91 b3 04 	lds	r30, 0x04B3	; 0x8004b3 <__flp>
    249c:	f0 91 b4 04 	lds	r31, 0x04B4	; 0x8004b4 <__flp+0x1>
    24a0:	20 e0       	ldi	r18, 0x00	; 0
    24a2:	30 e0       	ldi	r19, 0x00	; 0
    24a4:	a0 e0       	ldi	r26, 0x00	; 0
    24a6:	b0 e0       	ldi	r27, 0x00	; 0
    24a8:	30 97       	sbiw	r30, 0x00	; 0
    24aa:	19 f1       	breq	.+70     	; 0x24f2 <malloc+0x6c>
    24ac:	40 81       	ld	r20, Z
    24ae:	51 81       	ldd	r21, Z+1	; 0x01
    24b0:	02 81       	ldd	r16, Z+2	; 0x02
    24b2:	13 81       	ldd	r17, Z+3	; 0x03
    24b4:	48 17       	cp	r20, r24
    24b6:	59 07       	cpc	r21, r25
    24b8:	c8 f0       	brcs	.+50     	; 0x24ec <malloc+0x66>
    24ba:	84 17       	cp	r24, r20
    24bc:	95 07       	cpc	r25, r21
    24be:	69 f4       	brne	.+26     	; 0x24da <malloc+0x54>
    24c0:	10 97       	sbiw	r26, 0x00	; 0
    24c2:	31 f0       	breq	.+12     	; 0x24d0 <malloc+0x4a>
    24c4:	12 96       	adiw	r26, 0x02	; 2
    24c6:	0c 93       	st	X, r16
    24c8:	12 97       	sbiw	r26, 0x02	; 2
    24ca:	13 96       	adiw	r26, 0x03	; 3
    24cc:	1c 93       	st	X, r17
    24ce:	27 c0       	rjmp	.+78     	; 0x251e <malloc+0x98>
    24d0:	00 93 b3 04 	sts	0x04B3, r16	; 0x8004b3 <__flp>
    24d4:	10 93 b4 04 	sts	0x04B4, r17	; 0x8004b4 <__flp+0x1>
    24d8:	22 c0       	rjmp	.+68     	; 0x251e <malloc+0x98>
    24da:	21 15       	cp	r18, r1
    24dc:	31 05       	cpc	r19, r1
    24de:	19 f0       	breq	.+6      	; 0x24e6 <malloc+0x60>
    24e0:	42 17       	cp	r20, r18
    24e2:	53 07       	cpc	r21, r19
    24e4:	18 f4       	brcc	.+6      	; 0x24ec <malloc+0x66>
    24e6:	9a 01       	movw	r18, r20
    24e8:	bd 01       	movw	r22, r26
    24ea:	ef 01       	movw	r28, r30
    24ec:	df 01       	movw	r26, r30
    24ee:	f8 01       	movw	r30, r16
    24f0:	db cf       	rjmp	.-74     	; 0x24a8 <malloc+0x22>
    24f2:	21 15       	cp	r18, r1
    24f4:	31 05       	cpc	r19, r1
    24f6:	f9 f0       	breq	.+62     	; 0x2536 <malloc+0xb0>
    24f8:	28 1b       	sub	r18, r24
    24fa:	39 0b       	sbc	r19, r25
    24fc:	24 30       	cpi	r18, 0x04	; 4
    24fe:	31 05       	cpc	r19, r1
    2500:	80 f4       	brcc	.+32     	; 0x2522 <malloc+0x9c>
    2502:	8a 81       	ldd	r24, Y+2	; 0x02
    2504:	9b 81       	ldd	r25, Y+3	; 0x03
    2506:	61 15       	cp	r22, r1
    2508:	71 05       	cpc	r23, r1
    250a:	21 f0       	breq	.+8      	; 0x2514 <malloc+0x8e>
    250c:	fb 01       	movw	r30, r22
    250e:	93 83       	std	Z+3, r25	; 0x03
    2510:	82 83       	std	Z+2, r24	; 0x02
    2512:	04 c0       	rjmp	.+8      	; 0x251c <malloc+0x96>
    2514:	90 93 b4 04 	sts	0x04B4, r25	; 0x8004b4 <__flp+0x1>
    2518:	80 93 b3 04 	sts	0x04B3, r24	; 0x8004b3 <__flp>
    251c:	fe 01       	movw	r30, r28
    251e:	32 96       	adiw	r30, 0x02	; 2
    2520:	44 c0       	rjmp	.+136    	; 0x25aa <malloc+0x124>
    2522:	fe 01       	movw	r30, r28
    2524:	e2 0f       	add	r30, r18
    2526:	f3 1f       	adc	r31, r19
    2528:	81 93       	st	Z+, r24
    252a:	91 93       	st	Z+, r25
    252c:	22 50       	subi	r18, 0x02	; 2
    252e:	31 09       	sbc	r19, r1
    2530:	39 83       	std	Y+1, r19	; 0x01
    2532:	28 83       	st	Y, r18
    2534:	3a c0       	rjmp	.+116    	; 0x25aa <malloc+0x124>
    2536:	20 91 b1 04 	lds	r18, 0x04B1	; 0x8004b1 <__brkval>
    253a:	30 91 b2 04 	lds	r19, 0x04B2	; 0x8004b2 <__brkval+0x1>
    253e:	23 2b       	or	r18, r19
    2540:	41 f4       	brne	.+16     	; 0x2552 <malloc+0xcc>
    2542:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2546:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    254a:	30 93 b2 04 	sts	0x04B2, r19	; 0x8004b2 <__brkval+0x1>
    254e:	20 93 b1 04 	sts	0x04B1, r18	; 0x8004b1 <__brkval>
    2552:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2556:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    255a:	21 15       	cp	r18, r1
    255c:	31 05       	cpc	r19, r1
    255e:	41 f4       	brne	.+16     	; 0x2570 <malloc+0xea>
    2560:	2d b7       	in	r18, 0x3d	; 61
    2562:	3e b7       	in	r19, 0x3e	; 62
    2564:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2568:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    256c:	24 1b       	sub	r18, r20
    256e:	35 0b       	sbc	r19, r21
    2570:	e0 91 b1 04 	lds	r30, 0x04B1	; 0x8004b1 <__brkval>
    2574:	f0 91 b2 04 	lds	r31, 0x04B2	; 0x8004b2 <__brkval+0x1>
    2578:	e2 17       	cp	r30, r18
    257a:	f3 07       	cpc	r31, r19
    257c:	a0 f4       	brcc	.+40     	; 0x25a6 <malloc+0x120>
    257e:	2e 1b       	sub	r18, r30
    2580:	3f 0b       	sbc	r19, r31
    2582:	28 17       	cp	r18, r24
    2584:	39 07       	cpc	r19, r25
    2586:	78 f0       	brcs	.+30     	; 0x25a6 <malloc+0x120>
    2588:	ac 01       	movw	r20, r24
    258a:	4e 5f       	subi	r20, 0xFE	; 254
    258c:	5f 4f       	sbci	r21, 0xFF	; 255
    258e:	24 17       	cp	r18, r20
    2590:	35 07       	cpc	r19, r21
    2592:	48 f0       	brcs	.+18     	; 0x25a6 <malloc+0x120>
    2594:	4e 0f       	add	r20, r30
    2596:	5f 1f       	adc	r21, r31
    2598:	50 93 b2 04 	sts	0x04B2, r21	; 0x8004b2 <__brkval+0x1>
    259c:	40 93 b1 04 	sts	0x04B1, r20	; 0x8004b1 <__brkval>
    25a0:	81 93       	st	Z+, r24
    25a2:	91 93       	st	Z+, r25
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <malloc+0x124>
    25a6:	e0 e0       	ldi	r30, 0x00	; 0
    25a8:	f0 e0       	ldi	r31, 0x00	; 0
    25aa:	cf 01       	movw	r24, r30
    25ac:	df 91       	pop	r29
    25ae:	cf 91       	pop	r28
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	08 95       	ret

000025b6 <free>:
    25b6:	cf 93       	push	r28
    25b8:	df 93       	push	r29
    25ba:	00 97       	sbiw	r24, 0x00	; 0
    25bc:	09 f4       	brne	.+2      	; 0x25c0 <free+0xa>
    25be:	81 c0       	rjmp	.+258    	; 0x26c2 <free+0x10c>
    25c0:	fc 01       	movw	r30, r24
    25c2:	32 97       	sbiw	r30, 0x02	; 2
    25c4:	13 82       	std	Z+3, r1	; 0x03
    25c6:	12 82       	std	Z+2, r1	; 0x02
    25c8:	a0 91 b3 04 	lds	r26, 0x04B3	; 0x8004b3 <__flp>
    25cc:	b0 91 b4 04 	lds	r27, 0x04B4	; 0x8004b4 <__flp+0x1>
    25d0:	10 97       	sbiw	r26, 0x00	; 0
    25d2:	81 f4       	brne	.+32     	; 0x25f4 <free+0x3e>
    25d4:	20 81       	ld	r18, Z
    25d6:	31 81       	ldd	r19, Z+1	; 0x01
    25d8:	82 0f       	add	r24, r18
    25da:	93 1f       	adc	r25, r19
    25dc:	20 91 b1 04 	lds	r18, 0x04B1	; 0x8004b1 <__brkval>
    25e0:	30 91 b2 04 	lds	r19, 0x04B2	; 0x8004b2 <__brkval+0x1>
    25e4:	28 17       	cp	r18, r24
    25e6:	39 07       	cpc	r19, r25
    25e8:	51 f5       	brne	.+84     	; 0x263e <free+0x88>
    25ea:	f0 93 b2 04 	sts	0x04B2, r31	; 0x8004b2 <__brkval+0x1>
    25ee:	e0 93 b1 04 	sts	0x04B1, r30	; 0x8004b1 <__brkval>
    25f2:	67 c0       	rjmp	.+206    	; 0x26c2 <free+0x10c>
    25f4:	ed 01       	movw	r28, r26
    25f6:	20 e0       	ldi	r18, 0x00	; 0
    25f8:	30 e0       	ldi	r19, 0x00	; 0
    25fa:	ce 17       	cp	r28, r30
    25fc:	df 07       	cpc	r29, r31
    25fe:	40 f4       	brcc	.+16     	; 0x2610 <free+0x5a>
    2600:	4a 81       	ldd	r20, Y+2	; 0x02
    2602:	5b 81       	ldd	r21, Y+3	; 0x03
    2604:	9e 01       	movw	r18, r28
    2606:	41 15       	cp	r20, r1
    2608:	51 05       	cpc	r21, r1
    260a:	f1 f0       	breq	.+60     	; 0x2648 <free+0x92>
    260c:	ea 01       	movw	r28, r20
    260e:	f5 cf       	rjmp	.-22     	; 0x25fa <free+0x44>
    2610:	d3 83       	std	Z+3, r29	; 0x03
    2612:	c2 83       	std	Z+2, r28	; 0x02
    2614:	40 81       	ld	r20, Z
    2616:	51 81       	ldd	r21, Z+1	; 0x01
    2618:	84 0f       	add	r24, r20
    261a:	95 1f       	adc	r25, r21
    261c:	c8 17       	cp	r28, r24
    261e:	d9 07       	cpc	r29, r25
    2620:	59 f4       	brne	.+22     	; 0x2638 <free+0x82>
    2622:	88 81       	ld	r24, Y
    2624:	99 81       	ldd	r25, Y+1	; 0x01
    2626:	84 0f       	add	r24, r20
    2628:	95 1f       	adc	r25, r21
    262a:	02 96       	adiw	r24, 0x02	; 2
    262c:	91 83       	std	Z+1, r25	; 0x01
    262e:	80 83       	st	Z, r24
    2630:	8a 81       	ldd	r24, Y+2	; 0x02
    2632:	9b 81       	ldd	r25, Y+3	; 0x03
    2634:	93 83       	std	Z+3, r25	; 0x03
    2636:	82 83       	std	Z+2, r24	; 0x02
    2638:	21 15       	cp	r18, r1
    263a:	31 05       	cpc	r19, r1
    263c:	29 f4       	brne	.+10     	; 0x2648 <free+0x92>
    263e:	f0 93 b4 04 	sts	0x04B4, r31	; 0x8004b4 <__flp+0x1>
    2642:	e0 93 b3 04 	sts	0x04B3, r30	; 0x8004b3 <__flp>
    2646:	3d c0       	rjmp	.+122    	; 0x26c2 <free+0x10c>
    2648:	e9 01       	movw	r28, r18
    264a:	fb 83       	std	Y+3, r31	; 0x03
    264c:	ea 83       	std	Y+2, r30	; 0x02
    264e:	49 91       	ld	r20, Y+
    2650:	59 91       	ld	r21, Y+
    2652:	c4 0f       	add	r28, r20
    2654:	d5 1f       	adc	r29, r21
    2656:	ec 17       	cp	r30, r28
    2658:	fd 07       	cpc	r31, r29
    265a:	61 f4       	brne	.+24     	; 0x2674 <free+0xbe>
    265c:	80 81       	ld	r24, Z
    265e:	91 81       	ldd	r25, Z+1	; 0x01
    2660:	84 0f       	add	r24, r20
    2662:	95 1f       	adc	r25, r21
    2664:	02 96       	adiw	r24, 0x02	; 2
    2666:	e9 01       	movw	r28, r18
    2668:	99 83       	std	Y+1, r25	; 0x01
    266a:	88 83       	st	Y, r24
    266c:	82 81       	ldd	r24, Z+2	; 0x02
    266e:	93 81       	ldd	r25, Z+3	; 0x03
    2670:	9b 83       	std	Y+3, r25	; 0x03
    2672:	8a 83       	std	Y+2, r24	; 0x02
    2674:	e0 e0       	ldi	r30, 0x00	; 0
    2676:	f0 e0       	ldi	r31, 0x00	; 0
    2678:	12 96       	adiw	r26, 0x02	; 2
    267a:	8d 91       	ld	r24, X+
    267c:	9c 91       	ld	r25, X
    267e:	13 97       	sbiw	r26, 0x03	; 3
    2680:	00 97       	sbiw	r24, 0x00	; 0
    2682:	19 f0       	breq	.+6      	; 0x268a <free+0xd4>
    2684:	fd 01       	movw	r30, r26
    2686:	dc 01       	movw	r26, r24
    2688:	f7 cf       	rjmp	.-18     	; 0x2678 <free+0xc2>
    268a:	8d 91       	ld	r24, X+
    268c:	9c 91       	ld	r25, X
    268e:	11 97       	sbiw	r26, 0x01	; 1
    2690:	9d 01       	movw	r18, r26
    2692:	2e 5f       	subi	r18, 0xFE	; 254
    2694:	3f 4f       	sbci	r19, 0xFF	; 255
    2696:	82 0f       	add	r24, r18
    2698:	93 1f       	adc	r25, r19
    269a:	20 91 b1 04 	lds	r18, 0x04B1	; 0x8004b1 <__brkval>
    269e:	30 91 b2 04 	lds	r19, 0x04B2	; 0x8004b2 <__brkval+0x1>
    26a2:	28 17       	cp	r18, r24
    26a4:	39 07       	cpc	r19, r25
    26a6:	69 f4       	brne	.+26     	; 0x26c2 <free+0x10c>
    26a8:	30 97       	sbiw	r30, 0x00	; 0
    26aa:	29 f4       	brne	.+10     	; 0x26b6 <free+0x100>
    26ac:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <__flp+0x1>
    26b0:	10 92 b3 04 	sts	0x04B3, r1	; 0x8004b3 <__flp>
    26b4:	02 c0       	rjmp	.+4      	; 0x26ba <free+0x104>
    26b6:	13 82       	std	Z+3, r1	; 0x03
    26b8:	12 82       	std	Z+2, r1	; 0x02
    26ba:	b0 93 b2 04 	sts	0x04B2, r27	; 0x8004b2 <__brkval+0x1>
    26be:	a0 93 b1 04 	sts	0x04B1, r26	; 0x8004b1 <__brkval>
    26c2:	df 91       	pop	r29
    26c4:	cf 91       	pop	r28
    26c6:	08 95       	ret

000026c8 <memcpy>:
    26c8:	fb 01       	movw	r30, r22
    26ca:	dc 01       	movw	r26, r24
    26cc:	02 c0       	rjmp	.+4      	; 0x26d2 <memcpy+0xa>
    26ce:	01 90       	ld	r0, Z+
    26d0:	0d 92       	st	X+, r0
    26d2:	41 50       	subi	r20, 0x01	; 1
    26d4:	50 40       	sbci	r21, 0x00	; 0
    26d6:	d8 f7       	brcc	.-10     	; 0x26ce <memcpy+0x6>
    26d8:	08 95       	ret

000026da <memset>:
    26da:	dc 01       	movw	r26, r24
    26dc:	01 c0       	rjmp	.+2      	; 0x26e0 <memset+0x6>
    26de:	6d 93       	st	X+, r22
    26e0:	41 50       	subi	r20, 0x01	; 1
    26e2:	50 40       	sbci	r21, 0x00	; 0
    26e4:	e0 f7       	brcc	.-8      	; 0x26de <memset+0x4>
    26e6:	08 95       	ret

000026e8 <__itoa_ncheck>:
    26e8:	bb 27       	eor	r27, r27
    26ea:	4a 30       	cpi	r20, 0x0A	; 10
    26ec:	31 f4       	brne	.+12     	; 0x26fa <__itoa_ncheck+0x12>
    26ee:	99 23       	and	r25, r25
    26f0:	22 f4       	brpl	.+8      	; 0x26fa <__itoa_ncheck+0x12>
    26f2:	bd e2       	ldi	r27, 0x2D	; 45
    26f4:	90 95       	com	r25
    26f6:	81 95       	neg	r24
    26f8:	9f 4f       	sbci	r25, 0xFF	; 255
    26fa:	01 c0       	rjmp	.+2      	; 0x26fe <__utoa_common>

000026fc <__utoa_ncheck>:
    26fc:	bb 27       	eor	r27, r27

000026fe <__utoa_common>:
    26fe:	fb 01       	movw	r30, r22
    2700:	55 27       	eor	r21, r21
    2702:	aa 27       	eor	r26, r26
    2704:	88 0f       	add	r24, r24
    2706:	99 1f       	adc	r25, r25
    2708:	aa 1f       	adc	r26, r26
    270a:	a4 17       	cp	r26, r20
    270c:	10 f0       	brcs	.+4      	; 0x2712 <__utoa_common+0x14>
    270e:	a4 1b       	sub	r26, r20
    2710:	83 95       	inc	r24
    2712:	50 51       	subi	r21, 0x10	; 16
    2714:	b9 f7       	brne	.-18     	; 0x2704 <__utoa_common+0x6>
    2716:	a0 5d       	subi	r26, 0xD0	; 208
    2718:	aa 33       	cpi	r26, 0x3A	; 58
    271a:	08 f0       	brcs	.+2      	; 0x271e <__utoa_common+0x20>
    271c:	a9 5d       	subi	r26, 0xD9	; 217
    271e:	a1 93       	st	Z+, r26
    2720:	00 97       	sbiw	r24, 0x00	; 0
    2722:	79 f7       	brne	.-34     	; 0x2702 <__utoa_common+0x4>
    2724:	b1 11       	cpse	r27, r1
    2726:	b1 93       	st	Z+, r27
    2728:	11 92       	st	Z+, r1
    272a:	cb 01       	movw	r24, r22
    272c:	00 c0       	rjmp	.+0      	; 0x272e <strrev>

0000272e <strrev>:
    272e:	dc 01       	movw	r26, r24
    2730:	fc 01       	movw	r30, r24
    2732:	67 2f       	mov	r22, r23
    2734:	71 91       	ld	r23, Z+
    2736:	77 23       	and	r23, r23
    2738:	e1 f7       	brne	.-8      	; 0x2732 <strrev+0x4>
    273a:	32 97       	sbiw	r30, 0x02	; 2
    273c:	04 c0       	rjmp	.+8      	; 0x2746 <strrev+0x18>
    273e:	7c 91       	ld	r23, X
    2740:	6d 93       	st	X+, r22
    2742:	70 83       	st	Z, r23
    2744:	62 91       	ld	r22, -Z
    2746:	ae 17       	cp	r26, r30
    2748:	bf 07       	cpc	r27, r31
    274a:	c8 f3       	brcs	.-14     	; 0x273e <strrev+0x10>
    274c:	08 95       	ret

0000274e <_exit>:
    274e:	f8 94       	cli

00002750 <__stop_program>:
    2750:	ff cf       	rjmp	.-2      	; 0x2750 <__stop_program>
