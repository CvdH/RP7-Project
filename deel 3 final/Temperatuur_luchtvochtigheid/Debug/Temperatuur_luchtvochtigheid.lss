
Temperatuur_luchtvochtigheid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800200  00002b14  00002ba8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b14  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000237  0080028c  0080028c  00002c34  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c34  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c64  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005a8  00000000  00000000  00002ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007a0f  00000000  00000000  0000324c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f33  00000000  00000000  0000ac5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000490b  00000000  00000000  0000cb8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001500  00000000  00000000  0001149c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ff2  00000000  00000000  0001299c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000073d1  00000000  00000000  0001498e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000898  00000000  00000000  0001bd5f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	6c c1       	rjmp	.+728    	; 0x2da <__ctors_end>
       2:	00 00       	nop
       4:	8a c1       	rjmp	.+788    	; 0x31a <__bad_interrupt>
       6:	00 00       	nop
       8:	88 c1       	rjmp	.+784    	; 0x31a <__bad_interrupt>
       a:	00 00       	nop
       c:	86 c1       	rjmp	.+780    	; 0x31a <__bad_interrupt>
       e:	00 00       	nop
      10:	84 c1       	rjmp	.+776    	; 0x31a <__bad_interrupt>
      12:	00 00       	nop
      14:	82 c1       	rjmp	.+772    	; 0x31a <__bad_interrupt>
      16:	00 00       	nop
      18:	80 c1       	rjmp	.+768    	; 0x31a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	7e c1       	rjmp	.+764    	; 0x31a <__bad_interrupt>
      1e:	00 00       	nop
      20:	7c c1       	rjmp	.+760    	; 0x31a <__bad_interrupt>
      22:	00 00       	nop
      24:	f3 c4       	rjmp	.+2534   	; 0xa0c <__vector_9>
      26:	00 00       	nop
      28:	78 c1       	rjmp	.+752    	; 0x31a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	76 c1       	rjmp	.+748    	; 0x31a <__bad_interrupt>
      2e:	00 00       	nop
      30:	74 c1       	rjmp	.+744    	; 0x31a <__bad_interrupt>
      32:	00 00       	nop
      34:	72 c1       	rjmp	.+740    	; 0x31a <__bad_interrupt>
      36:	00 00       	nop
      38:	70 c1       	rjmp	.+736    	; 0x31a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	6e c1       	rjmp	.+732    	; 0x31a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6c c1       	rjmp	.+728    	; 0x31a <__bad_interrupt>
      42:	00 00       	nop
      44:	64 c7       	rjmp	.+3784   	; 0xf0e <__vector_17>
      46:	00 00       	nop
      48:	68 c1       	rjmp	.+720    	; 0x31a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	66 c1       	rjmp	.+716    	; 0x31a <__bad_interrupt>
      4e:	00 00       	nop
      50:	64 c1       	rjmp	.+712    	; 0x31a <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 29 09 	jmp	0x1252	; 0x1252 <__vector_21>
      58:	60 c1       	rjmp	.+704    	; 0x31a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	5e c1       	rjmp	.+700    	; 0x31a <__bad_interrupt>
      5e:	00 00       	nop
      60:	5c c1       	rjmp	.+696    	; 0x31a <__bad_interrupt>
      62:	00 00       	nop
      64:	5a c1       	rjmp	.+692    	; 0x31a <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 a2 0b 	jmp	0x1744	; 0x1744 <__vector_26>
      6c:	56 c1       	rjmp	.+684    	; 0x31a <__bad_interrupt>
      6e:	00 00       	nop
      70:	54 c1       	rjmp	.+680    	; 0x31a <__bad_interrupt>
      72:	00 00       	nop
      74:	52 c1       	rjmp	.+676    	; 0x31a <__bad_interrupt>
      76:	00 00       	nop
      78:	50 c1       	rjmp	.+672    	; 0x31a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4e c1       	rjmp	.+668    	; 0x31a <__bad_interrupt>
      7e:	00 00       	nop
      80:	4c c1       	rjmp	.+664    	; 0x31a <__bad_interrupt>
      82:	00 00       	nop
      84:	4a c1       	rjmp	.+660    	; 0x31a <__bad_interrupt>
      86:	00 00       	nop
      88:	48 c1       	rjmp	.+656    	; 0x31a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	60 c5       	rjmp	.+2752   	; 0xb4e <__vector_35>
      8e:	00 00       	nop
      90:	eb c3       	rjmp	.+2006   	; 0x868 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 eb 0b 	jmp	0x17d6	; 0x17d6 <__vector_37>
      98:	40 c1       	rjmp	.+640    	; 0x31a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ac c1       	rjmp	.+856    	; 0x3f6 <__vector_39>
      9e:	00 00       	nop
      a0:	3c c1       	rjmp	.+632    	; 0x31a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__bad_interrupt>
      a6:	00 00       	nop
      a8:	38 c1       	rjmp	.+624    	; 0x31a <__bad_interrupt>
      aa:	00 00       	nop
      ac:	36 c1       	rjmp	.+620    	; 0x31a <__bad_interrupt>
      ae:	00 00       	nop
      b0:	34 c1       	rjmp	.+616    	; 0x31a <__bad_interrupt>
      b2:	00 00       	nop
      b4:	32 c1       	rjmp	.+612    	; 0x31a <__bad_interrupt>
      b6:	00 00       	nop
      b8:	30 c1       	rjmp	.+608    	; 0x31a <__bad_interrupt>
      ba:	00 00       	nop
      bc:	2e c1       	rjmp	.+604    	; 0x31a <__bad_interrupt>
      be:	00 00       	nop
      c0:	2c c1       	rjmp	.+600    	; 0x31a <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2a c1       	rjmp	.+596    	; 0x31a <__bad_interrupt>
      c6:	00 00       	nop
      c8:	28 c1       	rjmp	.+592    	; 0x31a <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 34 0c 	jmp	0x1868	; 0x1868 <__vector_51>
      d0:	0c 94 93 0c 	jmp	0x1926	; 0x1926 <__vector_52>
      d4:	22 c1       	rjmp	.+580    	; 0x31a <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__vector_54>
      dc:	0c 94 3b 0d 	jmp	0x1a76	; 0x1a76 <__vector_55>
      e0:	1c c1       	rjmp	.+568    	; 0x31a <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1a 02       	muls	r17, r26
      e6:	d5 02       	muls	r29, r21
      e8:	d5 02       	muls	r29, r21
      ea:	d5 02       	muls	r29, r21
      ec:	d5 02       	muls	r29, r21
      ee:	d5 02       	muls	r29, r21
      f0:	d5 02       	muls	r29, r21
      f2:	d5 02       	muls	r29, r21
      f4:	1a 02       	muls	r17, r26
      f6:	d5 02       	muls	r29, r21
      f8:	d5 02       	muls	r29, r21
      fa:	d5 02       	muls	r29, r21
      fc:	d5 02       	muls	r29, r21
      fe:	d5 02       	muls	r29, r21
     100:	d5 02       	muls	r29, r21
     102:	d5 02       	muls	r29, r21
     104:	1c 02       	muls	r17, r28
     106:	d5 02       	muls	r29, r21
     108:	d5 02       	muls	r29, r21
     10a:	d5 02       	muls	r29, r21
     10c:	d5 02       	muls	r29, r21
     10e:	d5 02       	muls	r29, r21
     110:	d5 02       	muls	r29, r21
     112:	d5 02       	muls	r29, r21
     114:	39 02       	muls	r19, r25
     116:	d5 02       	muls	r29, r21
     118:	d5 02       	muls	r29, r21
     11a:	d5 02       	muls	r29, r21
     11c:	d5 02       	muls	r29, r21
     11e:	d5 02       	muls	r29, r21
     120:	d5 02       	muls	r29, r21
     122:	d5 02       	muls	r29, r21
     124:	1c 02       	muls	r17, r28
     126:	d5 02       	muls	r29, r21
     128:	d5 02       	muls	r29, r21
     12a:	d5 02       	muls	r29, r21
     12c:	d5 02       	muls	r29, r21
     12e:	d5 02       	muls	r29, r21
     130:	d5 02       	muls	r29, r21
     132:	d5 02       	muls	r29, r21
     134:	39 02       	muls	r19, r25
     136:	d5 02       	muls	r29, r21
     138:	d5 02       	muls	r29, r21
     13a:	d5 02       	muls	r29, r21
     13c:	d5 02       	muls	r29, r21
     13e:	d5 02       	muls	r29, r21
     140:	d5 02       	muls	r29, r21
     142:	d5 02       	muls	r29, r21
     144:	d1 02       	muls	r29, r17
     146:	d5 02       	muls	r29, r21
     148:	d5 02       	muls	r29, r21
     14a:	d5 02       	muls	r29, r21
     14c:	d5 02       	muls	r29, r21
     14e:	d5 02       	muls	r29, r21
     150:	d5 02       	muls	r29, r21
     152:	d5 02       	muls	r29, r21
     154:	4d 02       	muls	r20, r29
     156:	d5 02       	muls	r29, r21
     158:	d5 02       	muls	r29, r21
     15a:	d5 02       	muls	r29, r21
     15c:	d5 02       	muls	r29, r21
     15e:	d5 02       	muls	r29, r21
     160:	d5 02       	muls	r29, r21
     162:	d5 02       	muls	r29, r21
     164:	70 02       	muls	r23, r16
     166:	d5 02       	muls	r29, r21
     168:	d5 02       	muls	r29, r21
     16a:	d5 02       	muls	r29, r21
     16c:	d5 02       	muls	r29, r21
     16e:	d5 02       	muls	r29, r21
     170:	d5 02       	muls	r29, r21
     172:	d5 02       	muls	r29, r21
     174:	41 02       	muls	r20, r17
     176:	d5 02       	muls	r29, r21
     178:	d5 02       	muls	r29, r21
     17a:	d5 02       	muls	r29, r21
     17c:	d5 02       	muls	r29, r21
     17e:	d5 02       	muls	r29, r21
     180:	d5 02       	muls	r29, r21
     182:	d5 02       	muls	r29, r21
     184:	5f 02       	muls	r21, r31
     186:	d5 02       	muls	r29, r21
     188:	d5 02       	muls	r29, r21
     18a:	d5 02       	muls	r29, r21
     18c:	d5 02       	muls	r29, r21
     18e:	d5 02       	muls	r29, r21
     190:	d5 02       	muls	r29, r21
     192:	d5 02       	muls	r29, r21
     194:	a7 02       	muls	r26, r23
     196:	d5 02       	muls	r29, r21
     198:	d5 02       	muls	r29, r21
     19a:	d5 02       	muls	r29, r21
     19c:	d5 02       	muls	r29, r21
     19e:	d5 02       	muls	r29, r21
     1a0:	d5 02       	muls	r29, r21
     1a2:	d5 02       	muls	r29, r21
     1a4:	a7 02       	muls	r26, r23
     1a6:	d5 02       	muls	r29, r21
     1a8:	d5 02       	muls	r29, r21
     1aa:	d5 02       	muls	r29, r21
     1ac:	d5 02       	muls	r29, r21
     1ae:	d5 02       	muls	r29, r21
     1b0:	d5 02       	muls	r29, r21
     1b2:	d5 02       	muls	r29, r21
     1b4:	a2 02       	muls	r26, r18
     1b6:	d5 02       	muls	r29, r21
     1b8:	d5 02       	muls	r29, r21
     1ba:	d5 02       	muls	r29, r21
     1bc:	d5 02       	muls	r29, r21
     1be:	d5 02       	muls	r29, r21
     1c0:	d5 02       	muls	r29, r21
     1c2:	d5 02       	muls	r29, r21
     1c4:	a2 02       	muls	r26, r18
     1c6:	d5 02       	muls	r29, r21
     1c8:	d5 02       	muls	r29, r21
     1ca:	d5 02       	muls	r29, r21
     1cc:	d5 02       	muls	r29, r21
     1ce:	d5 02       	muls	r29, r21
     1d0:	d5 02       	muls	r29, r21
     1d2:	d5 02       	muls	r29, r21
     1d4:	b2 02       	muls	r27, r18
     1d6:	d5 02       	muls	r29, r21
     1d8:	d5 02       	muls	r29, r21
     1da:	d5 02       	muls	r29, r21
     1dc:	d5 02       	muls	r29, r21
     1de:	d5 02       	muls	r29, r21
     1e0:	d5 02       	muls	r29, r21
     1e2:	d5 02       	muls	r29, r21
     1e4:	c7 02       	muls	r28, r23
     1e6:	d5 02       	muls	r29, r21
     1e8:	d5 02       	muls	r29, r21
     1ea:	d5 02       	muls	r29, r21
     1ec:	d5 02       	muls	r29, r21
     1ee:	d5 02       	muls	r29, r21
     1f0:	d5 02       	muls	r29, r21
     1f2:	d5 02       	muls	r29, r21
     1f4:	b2 02       	muls	r27, r18
     1f6:	d5 02       	muls	r29, r21
     1f8:	d5 02       	muls	r29, r21
     1fa:	d5 02       	muls	r29, r21
     1fc:	d5 02       	muls	r29, r21
     1fe:	d5 02       	muls	r29, r21
     200:	d5 02       	muls	r29, r21
     202:	d5 02       	muls	r29, r21
     204:	c7 02       	muls	r28, r23
     206:	d5 02       	muls	r29, r21
     208:	d5 02       	muls	r29, r21
     20a:	d5 02       	muls	r29, r21
     20c:	d5 02       	muls	r29, r21
     20e:	d5 02       	muls	r29, r21
     210:	d5 02       	muls	r29, r21
     212:	d5 02       	muls	r29, r21
     214:	cb 02       	muls	r28, r27
     216:	d5 02       	muls	r29, r21
     218:	d5 02       	muls	r29, r21
     21a:	d5 02       	muls	r29, r21
     21c:	d5 02       	muls	r29, r21
     21e:	d5 02       	muls	r29, r21
     220:	d5 02       	muls	r29, r21
     222:	d5 02       	muls	r29, r21
     224:	78 02       	muls	r23, r24
     226:	d5 02       	muls	r29, r21
     228:	d5 02       	muls	r29, r21
     22a:	d5 02       	muls	r29, r21
     22c:	d5 02       	muls	r29, r21
     22e:	d5 02       	muls	r29, r21
     230:	d5 02       	muls	r29, r21
     232:	d5 02       	muls	r29, r21
     234:	78 02       	muls	r23, r24
     236:	d5 02       	muls	r29, r21
     238:	d5 02       	muls	r29, r21
     23a:	d5 02       	muls	r29, r21
     23c:	d5 02       	muls	r29, r21
     23e:	d5 02       	muls	r29, r21
     240:	d5 02       	muls	r29, r21
     242:	d5 02       	muls	r29, r21
     244:	7a 02       	muls	r23, r26
     246:	d5 02       	muls	r29, r21
     248:	d5 02       	muls	r29, r21
     24a:	d5 02       	muls	r29, r21
     24c:	d5 02       	muls	r29, r21
     24e:	d5 02       	muls	r29, r21
     250:	d5 02       	muls	r29, r21
     252:	d5 02       	muls	r29, r21
     254:	8a 02       	muls	r24, r26
     256:	d5 02       	muls	r29, r21
     258:	d5 02       	muls	r29, r21
     25a:	d5 02       	muls	r29, r21
     25c:	d5 02       	muls	r29, r21
     25e:	d5 02       	muls	r29, r21
     260:	d5 02       	muls	r29, r21
     262:	d5 02       	muls	r29, r21
     264:	9e 02       	muls	r25, r30

00000266 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     266:	0c ec       	ldi	r16, 0xCC	; 204
     268:	12 e0       	ldi	r17, 0x02	; 2
     26a:	0f 2e       	mov	r0, r31
     26c:	f4 ef       	ldi	r31, 0xF4	; 244
     26e:	ef 2e       	mov	r14, r31
     270:	f2 e0       	ldi	r31, 0x02	; 2
     272:	ff 2e       	mov	r15, r31
     274:	f0 2d       	mov	r31, r0
     276:	26 c0       	rjmp	.+76     	; 0x2c4 <prvIdleTask+0x5e>
     278:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskSuspendAll>
     27c:	d8 01       	movw	r26, r16
     27e:	cc 91       	ld	r28, X
     280:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <xTaskResumeAll>
     284:	cc 23       	and	r28, r28
     286:	f1 f0       	breq	.+60     	; 0x2c4 <prvIdleTask+0x5e>
     288:	0f b6       	in	r0, 0x3f	; 63
     28a:	f8 94       	cli
     28c:	0f 92       	push	r0
     28e:	d8 01       	movw	r26, r16
     290:	15 96       	adiw	r26, 0x05	; 5
     292:	ed 91       	ld	r30, X+
     294:	fc 91       	ld	r31, X
     296:	16 97       	sbiw	r26, 0x06	; 6
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	ce 01       	movw	r24, r28
     29e:	02 96       	adiw	r24, 0x02	; 2
     2a0:	fe d1       	rcall	.+1020   	; 0x69e <uxListRemove>
     2a2:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxCurrentNumberOfTasks>
     2a6:	81 50       	subi	r24, 0x01	; 1
     2a8:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <uxCurrentNumberOfTasks>
     2ac:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <uxDeletedTasksWaitingCleanUp>
     2b0:	81 50       	subi	r24, 0x01	; 1
     2b2:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <uxDeletedTasksWaitingCleanUp>
     2b6:	0f 90       	pop	r0
     2b8:	0f be       	out	0x3f, r0	; 63
     2ba:	8f 89       	ldd	r24, Y+23	; 0x17
     2bc:	98 8d       	ldd	r25, Y+24	; 0x18
     2be:	5c d0       	rcall	.+184    	; 0x378 <vPortFree>
     2c0:	ce 01       	movw	r24, r28
     2c2:	5a d0       	rcall	.+180    	; 0x378 <vPortFree>
     2c4:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <uxDeletedTasksWaitingCleanUp>
     2c8:	81 11       	cpse	r24, r1
     2ca:	d6 cf       	rjmp	.-84     	; 0x278 <prvIdleTask+0x12>
     2cc:	f7 01       	movw	r30, r14
     2ce:	80 81       	ld	r24, Z
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	08 f0       	brcs	.+2      	; 0x2d6 <prvIdleTask+0x70>
     2d4:	e6 d6       	rcall	.+3532   	; 0x10a2 <vPortYield>
     2d6:	5f d0       	rcall	.+190    	; 0x396 <vApplicationIdleHook>
     2d8:	f5 cf       	rjmp	.-22     	; 0x2c4 <prvIdleTask+0x5e>

000002da <__ctors_end>:
     2da:	11 24       	eor	r1, r1
     2dc:	1f be       	out	0x3f, r1	; 63
     2de:	cf ef       	ldi	r28, 0xFF	; 255
     2e0:	d1 e2       	ldi	r29, 0x21	; 33
     2e2:	de bf       	out	0x3e, r29	; 62
     2e4:	cd bf       	out	0x3d, r28	; 61
     2e6:	00 e0       	ldi	r16, 0x00	; 0
     2e8:	0c bf       	out	0x3c, r16	; 60

000002ea <__do_copy_data>:
     2ea:	12 e0       	ldi	r17, 0x02	; 2
     2ec:	a0 e0       	ldi	r26, 0x00	; 0
     2ee:	b2 e0       	ldi	r27, 0x02	; 2
     2f0:	e4 e1       	ldi	r30, 0x14	; 20
     2f2:	fb e2       	ldi	r31, 0x2B	; 43
     2f4:	00 e0       	ldi	r16, 0x00	; 0
     2f6:	0b bf       	out	0x3b, r16	; 59
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <__do_copy_data+0x14>
     2fa:	07 90       	elpm	r0, Z+
     2fc:	0d 92       	st	X+, r0
     2fe:	ac 38       	cpi	r26, 0x8C	; 140
     300:	b1 07       	cpc	r27, r17
     302:	d9 f7       	brne	.-10     	; 0x2fa <__do_copy_data+0x10>

00000304 <__do_clear_bss>:
     304:	24 e0       	ldi	r18, 0x04	; 4
     306:	ac e8       	ldi	r26, 0x8C	; 140
     308:	b2 e0       	ldi	r27, 0x02	; 2
     30a:	01 c0       	rjmp	.+2      	; 0x30e <.do_clear_bss_start>

0000030c <.do_clear_bss_loop>:
     30c:	1d 92       	st	X+, r1

0000030e <.do_clear_bss_start>:
     30e:	a3 3c       	cpi	r26, 0xC3	; 195
     310:	b2 07       	cpc	r27, r18
     312:	e1 f7       	brne	.-8      	; 0x30c <.do_clear_bss_loop>
     314:	a9 d4       	rcall	.+2386   	; 0xc68 <main>
     316:	0c 94 88 15 	jmp	0x2b10	; 0x2b10 <_exit>

0000031a <__bad_interrupt>:
     31a:	72 ce       	rjmp	.-796    	; 0x0 <__vectors>

0000031c <system_tick>:
     31c:	8f 93       	push	r24
     31e:	8f b7       	in	r24, 0x3f	; 63
     320:	8f 93       	push	r24
     322:	f8 94       	cli
     324:	80 91 bf 04 	lds	r24, 0x04BF	; 0x8004bf <__system_time>
     328:	8f 5f       	subi	r24, 0xFF	; 255
     32a:	80 93 bf 04 	sts	0x04BF, r24	; 0x8004bf <__system_time>
     32e:	80 91 c0 04 	lds	r24, 0x04C0	; 0x8004c0 <__system_time+0x1>
     332:	8f 4f       	sbci	r24, 0xFF	; 255
     334:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <__system_time+0x1>
     338:	80 91 c1 04 	lds	r24, 0x04C1	; 0x8004c1 <__system_time+0x2>
     33c:	8f 4f       	sbci	r24, 0xFF	; 255
     33e:	80 93 c1 04 	sts	0x04C1, r24	; 0x8004c1 <__system_time+0x2>
     342:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <__system_time+0x3>
     346:	8f 4f       	sbci	r24, 0xFF	; 255
     348:	80 93 c2 04 	sts	0x04C2, r24	; 0x8004c2 <__system_time+0x3>
     34c:	8f 91       	pop	r24
     34e:	8f bf       	out	0x3f, r24	; 63
     350:	8f 91       	pop	r24
     352:	08 95       	ret

00000354 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     35a:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     35e:	ce 01       	movw	r24, r28
     360:	0e 94 24 14 	call	0x2848	; 0x2848 <malloc>
     364:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     366:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     36a:	20 97       	sbiw	r28, 0x00	; 0
     36c:	09 f4       	brne	.+2      	; 0x370 <pvPortMalloc+0x1c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     36e:	2c d0       	rcall	.+88     	; 0x3c8 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
     370:	ce 01       	movw	r24, r28
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	08 95       	ret

00000378 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
	if( pv )
     37c:	00 97       	sbiw	r24, 0x00	; 0
     37e:	41 f0       	breq	.+16     	; 0x390 <vPortFree+0x18>
     380:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     382:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskSuspendAll>
		{
			free( pv );
     386:	ce 01       	movw	r24, r28
     388:	0e 94 bc 14 	call	0x2978	; 0x2978 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     38c:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <xTaskResumeAll>
	}
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	08 95       	ret

00000396 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DIDR0 = 0xFF;
     396:	8f ef       	ldi	r24, 0xFF	; 255
     398:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     39c:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     3a0:	80 b7       	in	r24, 0x30	; 48
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     3a6:	80 b7       	in	r24, 0x30	; 48
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     3ac:	83 b7       	in	r24, 0x33	; 51
     3ae:	81 7f       	andi	r24, 0xF1	; 241
     3b0:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     3b2:	0f b6       	in	r0, 0x3f	; 63
     3b4:	f8 94       	cli
     3b6:	0f 92       	push	r0

	sleep_enable();
     3b8:	83 b7       	in	r24, 0x33	; 51
     3ba:	81 60       	ori	r24, 0x01	; 1
     3bc:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     3be:	0f 90       	pop	r0
     3c0:	0f be       	out	0x3f, r0	; 63

	sleep_cpu();		// good night.
     3c2:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     3c4:	13 be       	out	0x33, r1	; 51
     3c6:	08 95       	ret

000003c8 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Mega with 2560
	DDRB  |= _BV(DDB7);
     3c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3ca:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3cc:	83 ed       	ldi	r24, 0xD3	; 211
     3ce:	90 e3       	ldi	r25, 0x30	; 48
     3d0:	01 97       	sbiw	r24, 0x01	; 1
     3d2:	f1 f7       	brne	.-4      	; 0x3d0 <vApplicationMallocFailedHook+0x8>
     3d4:	00 c0       	rjmp	.+0      	; 0x3d6 <vApplicationMallocFailedHook+0xe>
     3d6:	00 00       	nop

	for(;;)
	{
		_delay_ms(50);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     3d8:	1f 9a       	sbi	0x03, 7	; 3
     3da:	f8 cf       	rjmp	.-16     	; 0x3cc <vApplicationMallocFailedHook+0x4>

000003dc <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Mega with 2560
	DDRB  |= _BV(DDB7);
     3dc:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     3de:	2f 9a       	sbi	0x05, 7	; 5
     3e0:	2f e7       	ldi	r18, 0x7F	; 127
     3e2:	8a e1       	ldi	r24, 0x1A	; 26
     3e4:	96 e0       	ldi	r25, 0x06	; 6
     3e6:	21 50       	subi	r18, 0x01	; 1
     3e8:	80 40       	sbci	r24, 0x00	; 0
     3ea:	90 40       	sbci	r25, 0x00	; 0
     3ec:	e1 f7       	brne	.-8      	; 0x3e6 <vApplicationStackOverflowHook+0xa>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <vApplicationStackOverflowHook+0x14>
     3f0:	00 00       	nop

	for(;;)
	{
		_delay_ms(2000);
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     3f2:	1f 9a       	sbi	0x03, 7	; 3
     3f4:	f5 cf       	rjmp	.-22     	; 0x3e0 <vApplicationStackOverflowHook+0x4>

000003f6 <__vector_39>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect) __attribute__((hot, flatten));
ISR(TWI_vect)
{
     3f6:	1f 92       	push	r1
     3f8:	0f 92       	push	r0
     3fa:	0f b6       	in	r0, 0x3f	; 63
     3fc:	0f 92       	push	r0
     3fe:	11 24       	eor	r1, r1
     400:	0b b6       	in	r0, 0x3b	; 59
     402:	0f 92       	push	r0
     404:	2f 93       	push	r18
     406:	3f 93       	push	r19
     408:	8f 93       	push	r24
     40a:	9f 93       	push	r25
     40c:	af 93       	push	r26
     40e:	bf 93       	push	r27
     410:	ef 93       	push	r30
     412:	ff 93       	push	r31
  static uint8_t I2C_bufPtr;

  switch (TWSR)
     414:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     418:	8e 2f       	mov	r24, r30
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	fc 01       	movw	r30, r24
     41e:	38 97       	sbiw	r30, 0x08	; 8
     420:	e1 3c       	cpi	r30, 0xC1	; 193
     422:	f1 05       	cpc	r31, r1
     424:	08 f0       	brcs	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	c1 c0       	rjmp	.+386    	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
     428:	88 27       	eor	r24, r24
     42a:	ee 58       	subi	r30, 0x8E	; 142
     42c:	ff 4f       	sbci	r31, 0xFF	; 255
     42e:	8f 4f       	sbci	r24, 0xFF	; 255
     430:	0c 94 03 14 	jmp	0x2806	; 0x2806 <__tablejump2__>
  {

    case I2C_START:             // START has been transmitted
    case I2C_REP_START:         // Repeated START has been transmitted
		I2C_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     434:	10 92 8c 02 	sts	0x028C, r1	; 0x80028c <__data_end>

// Master Transmitter

    case I2C_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case I2C_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
		if (I2C_bufPtr < I2C_msgSize)
     438:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <__data_end>
     43c:	80 91 8f 02 	lds	r24, 0x028F	; 0x80028f <I2C_msgSize>
     440:	e8 17       	cp	r30, r24
     442:	70 f4       	brcc	.+28     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
		{
			TWDR = I2C_buf[I2C_bufPtr++];
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	8e 0f       	add	r24, r30
     448:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <__data_end>
     44c:	f0 e0       	ldi	r31, 0x00	; 0
     44e:	e0 57       	subi	r30, 0x70	; 112
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     458:	85 e8       	ldi	r24, 0x85	; 133
     45a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     45e:	ac c0       	rjmp	.+344    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //
		}else                    // Send STOP after last byte
		{
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     460:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     464:	81 60       	ori	r24, 0x01	; 1
     466:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     46a:	84 e9       	ldi	r24, 0x94	; 148
     46c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     470:	a3 c0       	rjmp	.+326    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
		}
		break;

    case I2C_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case I2C_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     472:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     476:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    // Reset TWI Interface and send START.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     47a:	85 ee       	ldi	r24, 0xE5	; 229
     47c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|    		// Send Start.
				(0<<TWWC);
		break;
     480:	9b c0       	rjmp	.+310    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// Master Receiver

    case I2C_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
		I2C_buf[I2C_bufPtr++] = TWDR;
     482:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <__data_end>
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	8e 0f       	add	r24, r30
     48a:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <__data_end>
     48e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     492:	f0 e0       	ldi	r31, 0x00	; 0
     494:	e0 57       	subi	r30, 0x70	; 112
     496:	fd 4f       	sbci	r31, 0xFD	; 253
     498:	80 83       	st	Z, r24

    case I2C_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
		if (I2C_bufPtr < (I2C_msgSize-1) )                  // Detect the last byte to NACK it.
     49a:	20 91 8c 02 	lds	r18, 0x028C	; 0x80028c <__data_end>
     49e:	30 e0       	ldi	r19, 0x00	; 0
     4a0:	80 91 8f 02 	lds	r24, 0x028F	; 0x80028f <I2C_msgSize>
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	28 17       	cp	r18, r24
     4aa:	39 07       	cpc	r19, r25
     4ac:	24 f4       	brge	.+8      	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4ae:	85 ec       	ldi	r24, 0xC5	; 197
     4b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4b4:	81 c0       	rjmp	.+258    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //
		}else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4b6:	85 e8       	ldi	r24, 0x85	; 133
     4b8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     4bc:	7d c0       	rjmp	.+250    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
				   (0<<TWWC);                                 //
		}
		break;

    case I2C_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
		I2C_buf[I2C_bufPtr] = TWDR;
     4be:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     4c2:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <__data_end>
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	e0 57       	subi	r30, 0x70	; 112
     4ca:	fd 4f       	sbci	r31, 0xFD	; 253
     4cc:	80 83       	st	Z, r24
		I2C_statusReg.lastTransOK = true;                 // Set status bits to completed successfully.
     4ce:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     4d2:	81 60       	ori	r24, 0x01	; 1
     4d4:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     4d8:	84 ed       	ldi	r24, 0xD4	; 212
     4da:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
			   (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
			   (0<<TWWC);                                 //
		break;
     4de:	6c c0       	rjmp	.+216    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>



    case I2C_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
 	    I2C_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     4e0:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     4e4:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
		// Reset TWI Interface and send STOP.
		TWCR = 	(1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     4e8:	85 ed       	ldi	r24, 0xD5	; 213
     4ea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
				(1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
				(1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Send stop.
				(0<<TWWC);
		break;
     4ee:	64 c0       	rjmp	.+200    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Transmitter

	case I2C_STX_ADR_ACK:			// Own SLA+R has been received; ACK has been returned
	case I2C_STX_ADR_ACK_M_ARB_LOST:// Arbitration lost in SLA+R/W as Master; own SLA+R has
									// been received; ACK has been returned
	    I2C_bufPtr   = 0;	    	// Set buffer pointer to first data location
     4f0:	10 92 8c 02 	sts	0x028C, r1	; 0x80028c <__data_end>


	case I2C_STX_DATA_ACK:		// Data byte in TWDR has been transmitted; ACK has been received
	    TWDR = I2C_buf[I2C_bufPtr++];
     4f4:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <__data_end>
     4f8:	81 e0       	ldi	r24, 0x01	; 1
     4fa:	8e 0f       	add	r24, r30
     4fc:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <__data_end>
     500:	f0 e0       	ldi	r31, 0x00	; 0
     502:	e0 57       	subi	r30, 0x70	; 112
     504:	fd 4f       	sbci	r31, 0xFD	; 253
     506:	80 81       	ld	r24, Z
     508:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	    						// Enable TWI Interrupt and clear the flag to send byte
	    TWCR = 	(1<<TWEN) |
     50c:	85 ec       	ldi	r24, 0xC5	; 197
     50e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
	    break;
     512:	52 c0       	rjmp	.+164    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


	case I2C_STX_DATA_NACK:  	// Data byte in TWDR has been transmitted; NACK has been received.
	    						// I.e. this could be the end of the transmission.
	    if (I2C_bufPtr == I2C_msgSize) 	    // Have we transmitted all expected data?
     514:	90 91 8c 02 	lds	r25, 0x028C	; 0x80028c <__data_end>
     518:	80 91 8f 02 	lds	r24, 0x028F	; 0x80028f <I2C_msgSize>
     51c:	98 13       	cpse	r25, r24
     51e:	06 c0       	rjmp	.+12     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
	    {
	        I2C_statusReg.lastTransOK = true; // Set status bits to completed successfully.
     520:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     524:	81 60       	ori	r24, 0x01	; 1
     526:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__LOCK_REGION_LENGTH__+0x134>
	    }
	    else
	    {
	        I2C_state = TWSR;     // Master has sent a NACK before all data where sent, Store I2C State as error message.
     52c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     530:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>
	    }

	    // Put I2C Transceiver in passive mode.
	    // Enable I2C-interface and release I2C pins
	    TWCR = (1<<TWEN)|
     534:	84 e0       	ldi	r24, 0x04	; 4
     536:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	           (0<<TWIE)|(0<<TWINT)|                // Disable Interrupt
	           (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|     // Do not acknowledge on any new requests.
	           (0<<TWWC);
	   break;
     53a:	3e c0       	rjmp	.+124    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


    case I2C_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted TWEA = ; ACK has been received

    	// Enable TWI Interrupt and clear the flag to send byte
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     53c:	85 ec       	ldi	r24, 0xC5	; 197
     53e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Acknowledge on any new requests.
               (0<<TWWC);

	    break;
     542:	3a c0       	rjmp	.+116    	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>
// Slave Receiver

	case I2C_SRX_GEN_ACK:				// General call address has been received; ACK has been returned
	case I2C_SRX_GEN_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; General call
										// address has been received; ACK has been returned
	    I2C_statusReg.genAddressCall = true;
     544:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     548:	84 60       	ori	r24, 0x04	; 4
     54a:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>

	case I2C_SRX_ADR_ACK:		// Own SLA+W has been received ACK has been returned
	case I2C_SRX_ADR_ACK_M_ARB_LOST:	// Arbitration lost in SLA+R/W as Master; own SLA+W
										// has been received; ACK has been returned

	    I2C_statusReg.RxDataInBuf = true; // Don't need to clear I2C_statusRegister.generalAddressCall due to that it is the default state.
     54e:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>

	    I2C_bufPtr   = 0;	    // Set buffer pointer to first data location
     558:	10 92 8c 02 	sts	0x028C, r1	; 0x80028c <__data_end>
	    // Reset the TWI Interrupt to wait for a new event.

	    // TWI Interface enabled
	    // Enable TWI Interrupt and clear the flag to send byte
	    // Expect ACK on this transmission
	    TWCR =  (1<<TWEN)|
     55c:	85 ec       	ldi	r24, 0xC5	; 197
     55e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	    		(1<<TWIE)|(1<<TWINT)|
	    		(1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|
	    		(0<<TWWC);
		break;
     562:	2a c0       	rjmp	.+84     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

	case I2C_SRX_ADR_DATA_ACK:	// Previously addressed with own SLA+W; data has been received; ACK has been returned
	case I2C_SRX_GEN_DATA_ACK:	// Previously addressed with general call; data has been received; ACK has been returned

		I2C_buf[I2C_bufPtr++] = TWDR;
     564:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <__data_end>
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	8e 0f       	add	r24, r30
     56c:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <__data_end>
     570:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	e0 57       	subi	r30, 0x70	; 112
     578:	fd 4f       	sbci	r31, 0xFD	; 253
     57a:	80 83       	st	Z, r24

		I2C_statusReg.lastTransOK = true;		// Set flag transmission successful.
     57c:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <I2C_statusReg>
     580:	81 60       	ori	r24, 0x01	; 1
     582:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <I2C_statusReg>

		// Reset the TWI Interrupt to wait for a new event.
		TWCR = (1<<TWEN)|                          // TWI Interface enabled
     586:	85 ec       	ldi	r24, 0xC5	; 197
     588:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
		       (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
		       (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Send ACK after next reception
		       (0<<TWWC);
		break;
     58c:	15 c0       	rjmp	.+42     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_ADR_DATA_NACK: // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case I2C_SRX_GEN_DATA_NACK: // Previously addressed with general call; data has been received; NOT ACK has been returned

    	// NOT ACK back at the Master
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     58e:	85 e8       	ldi	r24, 0x85	; 133
     590:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (1<<TWIE)|(1<<TWINT)|               // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
		break;
     594:	11 c0       	rjmp	.+34     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_SRX_STOP_RESTART:  // A STOP condition or repeated START condition has been received while still addressed as Slave

    	I2C_checkBusyAfterStop = I2C_HOW_MANY_BUSY_CHECKS_AFTER_STOP; // do some busy checks before hitting the bus again.
     596:	84 e0       	ldi	r24, 0x04	; 4
     598:	80 93 8e 02 	sts	0x028E, r24	; 0x80028e <I2C_checkBusyAfterStop>

        // Put TWI Transceiver in passive mode.
        TWCR = (1<<TWEN)|                          // Enable TWI-interface and release TWI pins
     59c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
               (0<<TWIE)|(0<<TWINT)|               // Disable Interrupt
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|    // Do not acknowledge on any new requests.
               (0<<TWWC);
        break;
     5a0:	0b c0       	rjmp	.+22     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>


// ERRORS AND FAULT CONDITIONS

    case I2C_ARB_LOST:          						// Arbitration lost
		TWCR = (1<<TWEN)|                               // TWI Interface enabled
     5a2:	85 ee       	ldi	r24, 0xE5	; 229
     5a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			   (1<<TWIE)|(1<<TWINT)|                    // Enable TWI Interrupt and clear the flag
			   (1<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|         // Initiate a (RE)START condition.
			   (0<<TWWC);                               //
		break;
     5a8:	07 c0       	rjmp	.+14     	; 0x5b8 <__LOCK_REGION_LENGTH__+0x1b8>

    case I2C_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    case I2C_NO_STATE:          // No relevant state information available TWINT = 0

    default:
		I2C_state = TWSR;                               // Store TWSR and automatically sets clears noErrors bit.
     5aa:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
     5ae:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <I2C_state>

														// Reset TWI Interface
		TWCR = (1<<TWEN)|                          		// Enable TWI-interface and release TWI pins
     5b2:	85 ed       	ldi	r24, 0xD5	; 213
     5b4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
			 (1<<TWIE)|(1<<TWINT)|               		// Enable TWI Interrupt and clear the flag
			 (1<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|    		// Acknowledge on any new requests. Send stop.
			 (0<<TWWC);                               	//
      	break;
  }
}
     5b8:	ff 91       	pop	r31
     5ba:	ef 91       	pop	r30
     5bc:	bf 91       	pop	r27
     5be:	af 91       	pop	r26
     5c0:	9f 91       	pop	r25
     5c2:	8f 91       	pop	r24
     5c4:	3f 91       	pop	r19
     5c6:	2f 91       	pop	r18
     5c8:	0f 90       	pop	r0
     5ca:	0b be       	out	0x3b, r0	; 59
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5d8:	03 96       	adiw	r24, 0x03	; 3
     5da:	92 83       	std	Z+2, r25	; 0x02
     5dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5de:	2f ef       	ldi	r18, 0xFF	; 255
     5e0:	3f ef       	ldi	r19, 0xFF	; 255
     5e2:	34 83       	std	Z+4, r19	; 0x04
     5e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e6:	96 83       	std	Z+6, r25	; 0x06
     5e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ea:	90 87       	std	Z+8, r25	; 0x08
     5ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5ee:	10 82       	st	Z, r1
     5f0:	08 95       	ret

000005f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5f2:	fc 01       	movw	r30, r24
     5f4:	11 86       	std	Z+9, r1	; 0x09
     5f6:	10 86       	std	Z+8, r1	; 0x08
     5f8:	08 95       	ret

000005fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	9c 01       	movw	r18, r24
     600:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     602:	dc 01       	movw	r26, r24
     604:	11 96       	adiw	r26, 0x01	; 1
     606:	cd 91       	ld	r28, X+
     608:	dc 91       	ld	r29, X
     60a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     60c:	d3 83       	std	Z+3, r29	; 0x03
     60e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     610:	8c 81       	ldd	r24, Y+4	; 0x04
     612:	9d 81       	ldd	r25, Y+5	; 0x05
     614:	95 83       	std	Z+5, r25	; 0x05
     616:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     618:	8c 81       	ldd	r24, Y+4	; 0x04
     61a:	9d 81       	ldd	r25, Y+5	; 0x05
     61c:	dc 01       	movw	r26, r24
     61e:	13 96       	adiw	r26, 0x03	; 3
     620:	7c 93       	st	X, r23
     622:	6e 93       	st	-X, r22
     624:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     626:	7d 83       	std	Y+5, r23	; 0x05
     628:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62a:	31 87       	std	Z+9, r19	; 0x09
     62c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     62e:	f9 01       	movw	r30, r18
     630:	80 81       	ld	r24, Z
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	80 83       	st	Z, r24
}
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	08 95       	ret

0000063c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     642:	48 81       	ld	r20, Y
     644:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     646:	4f 3f       	cpi	r20, 0xFF	; 255
     648:	2f ef       	ldi	r18, 0xFF	; 255
     64a:	52 07       	cpc	r21, r18
     64c:	21 f4       	brne	.+8      	; 0x656 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     64e:	fc 01       	movw	r30, r24
     650:	a7 81       	ldd	r26, Z+7	; 0x07
     652:	b0 85       	ldd	r27, Z+8	; 0x08
     654:	0d c0       	rjmp	.+26     	; 0x670 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     656:	dc 01       	movw	r26, r24
     658:	13 96       	adiw	r26, 0x03	; 3
     65a:	01 c0       	rjmp	.+2      	; 0x65e <vListInsert+0x22>
     65c:	df 01       	movw	r26, r30
     65e:	12 96       	adiw	r26, 0x02	; 2
     660:	ed 91       	ld	r30, X+
     662:	fc 91       	ld	r31, X
     664:	13 97       	sbiw	r26, 0x03	; 3
     666:	20 81       	ld	r18, Z
     668:	31 81       	ldd	r19, Z+1	; 0x01
     66a:	42 17       	cp	r20, r18
     66c:	53 07       	cpc	r21, r19
     66e:	b0 f7       	brcc	.-20     	; 0x65c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     670:	12 96       	adiw	r26, 0x02	; 2
     672:	ed 91       	ld	r30, X+
     674:	fc 91       	ld	r31, X
     676:	13 97       	sbiw	r26, 0x03	; 3
     678:	fb 83       	std	Y+3, r31	; 0x03
     67a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     67c:	d5 83       	std	Z+5, r29	; 0x05
     67e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     680:	bd 83       	std	Y+5, r27	; 0x05
     682:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     684:	13 96       	adiw	r26, 0x03	; 3
     686:	dc 93       	st	X, r29
     688:	ce 93       	st	-X, r28
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     68c:	99 87       	std	Y+9, r25	; 0x09
     68e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     690:	fc 01       	movw	r30, r24
     692:	20 81       	ld	r18, Z
     694:	2f 5f       	subi	r18, 0xFF	; 255
     696:	20 83       	st	Z, r18
}
     698:	df 91       	pop	r29
     69a:	cf 91       	pop	r28
     69c:	08 95       	ret

0000069e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6a4:	a0 85       	ldd	r26, Z+8	; 0x08
     6a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6a8:	c2 81       	ldd	r28, Z+2	; 0x02
     6aa:	d3 81       	ldd	r29, Z+3	; 0x03
     6ac:	84 81       	ldd	r24, Z+4	; 0x04
     6ae:	95 81       	ldd	r25, Z+5	; 0x05
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6b4:	c4 81       	ldd	r28, Z+4	; 0x04
     6b6:	d5 81       	ldd	r29, Z+5	; 0x05
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	9b 83       	std	Y+3, r25	; 0x03
     6be:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2
     6c8:	e8 17       	cp	r30, r24
     6ca:	f9 07       	cpc	r31, r25
     6cc:	31 f4       	brne	.+12     	; 0x6da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6ce:	84 81       	ldd	r24, Z+4	; 0x04
     6d0:	95 81       	ldd	r25, Z+5	; 0x05
     6d2:	12 96       	adiw	r26, 0x02	; 2
     6d4:	9c 93       	st	X, r25
     6d6:	8e 93       	st	-X, r24
     6d8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6da:	11 86       	std	Z+9, r1	; 0x09
     6dc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6de:	8c 91       	ld	r24, X
     6e0:	81 50       	subi	r24, 0x01	; 1
     6e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <watchdogTaak>:
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     6ea:	88 ec       	ldi	r24, 0xC8	; 200
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vTaskDelay>
     6f2:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <watchdogSonar>
     6f6:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <watchdogSonar+0x1>
     6fa:	89 2b       	or	r24, r25
     6fc:	b1 f3       	breq	.-20     	; 0x6ea <watchdogTaak>
     6fe:	80 91 28 04 	lds	r24, 0x0428	; 0x800428 <watchdogServo>
     702:	90 91 29 04 	lds	r25, 0x0429	; 0x800429 <watchdogServo+0x1>
     706:	89 2b       	or	r24, r25
     708:	81 f3       	breq	.-32     	; 0x6ea <watchdogTaak>
     70a:	80 91 22 04 	lds	r24, 0x0422	; 0x800422 <watchdogTemp>
     70e:	90 91 23 04 	lds	r25, 0x0423	; 0x800423 <watchdogTemp+0x1>
     712:	89 2b       	or	r24, r25
     714:	51 f3       	breq	.-44     	; 0x6ea <watchdogTaak>
     716:	a8 95       	wdr
     718:	10 92 1f 03 	sts	0x031F, r1	; 0x80031f <watchdogSonar+0x1>
     71c:	10 92 1e 03 	sts	0x031E, r1	; 0x80031e <watchdogSonar>
     720:	10 92 29 04 	sts	0x0429, r1	; 0x800429 <watchdogServo+0x1>
     724:	10 92 28 04 	sts	0x0428, r1	; 0x800428 <watchdogServo>
     728:	10 92 23 04 	sts	0x0423, r1	; 0x800423 <watchdogTemp+0x1>
     72c:	10 92 22 04 	sts	0x0422, r1	; 0x800422 <watchdogTemp>
     730:	dc cf       	rjmp	.-72     	; 0x6ea <watchdogTaak>

00000732 <servoTaak>:
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	1f 92       	push	r1
     738:	1f 92       	push	r1
     73a:	cd b7       	in	r28, 0x3d	; 61
     73c:	de b7       	in	r29, 0x3e	; 62
     73e:	0f 2e       	mov	r0, r31
     740:	fa e8       	ldi	r31, 0x8A	; 138
     742:	cf 2e       	mov	r12, r31
     744:	d1 2c       	mov	r13, r1
     746:	f0 2d       	mov	r31, r0
     748:	a1 2c       	mov	r10, r1
     74a:	b1 2c       	mov	r11, r1
     74c:	ee 24       	eor	r14, r14
     74e:	e3 94       	inc	r14
     750:	f1 2c       	mov	r15, r1
     752:	00 e0       	ldi	r16, 0x00	; 0
     754:	10 e0       	ldi	r17, 0x00	; 0
     756:	1a 83       	std	Y+2, r17	; 0x02
     758:	09 83       	std	Y+1, r16	; 0x01
     75a:	c8 01       	movw	r24, r16
     75c:	99 27       	eor	r25, r25
     75e:	9c 01       	movw	r18, r24
     760:	22 0f       	add	r18, r18
     762:	33 1f       	adc	r19, r19
     764:	22 0f       	add	r18, r18
     766:	33 1f       	adc	r19, r19
     768:	22 0f       	add	r18, r18
     76a:	33 1f       	adc	r19, r19
     76c:	82 1b       	sub	r24, r18
     76e:	93 0b       	sbc	r25, r19
     770:	95 5b       	subi	r25, 0xB5	; 181
     772:	f6 01       	movw	r30, r12
     774:	91 83       	std	Z+1, r25	; 0x01
     776:	80 83       	st	Z, r24
     778:	20 e0       	ldi	r18, 0x00	; 0
     77a:	4a 2d       	mov	r20, r10
     77c:	5b 2d       	mov	r21, r11
     77e:	be 01       	movw	r22, r28
     780:	6f 5f       	subi	r22, 0xFF	; 255
     782:	7f 4f       	sbci	r23, 0xFF	; 255
     784:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <hoekQueue>
     788:	90 91 1b 03 	lds	r25, 0x031B	; 0x80031b <hoekQueue+0x1>
     78c:	96 d6       	rcall	.+3372   	; 0x14ba <xQueueGenericSend>
     78e:	84 e6       	ldi	r24, 0x64	; 100
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vTaskDelay>
     796:	f0 92 29 04 	sts	0x0429, r15	; 0x800429 <watchdogServo+0x1>
     79a:	e0 92 28 04 	sts	0x0428, r14	; 0x800428 <watchdogServo>
     79e:	05 5e       	subi	r16, 0xE5	; 229
     7a0:	1f 4f       	sbci	r17, 0xFF	; 255
     7a2:	08 3d       	cpi	r16, 0xD8	; 216
     7a4:	11 05       	cpc	r17, r1
     7a6:	b9 f6       	brne	.-82     	; 0x756 <servoTaak+0x24>
     7a8:	d4 cf       	rjmp	.-88     	; 0x752 <servoTaak+0x20>

000007aa <initQ>:
     7aa:	40 e0       	ldi	r20, 0x00	; 0
     7ac:	62 e0       	ldi	r22, 0x02	; 2
     7ae:	8a e0       	ldi	r24, 0x0A	; 10
     7b0:	58 d6       	rcall	.+3248   	; 0x1462 <xQueueGenericCreate>
     7b2:	90 93 21 04 	sts	0x0421, r25	; 0x800421 <afstandQueue+0x1>
     7b6:	80 93 20 04 	sts	0x0420, r24	; 0x800420 <afstandQueue>
     7ba:	89 2b       	or	r24, r25
     7bc:	41 f4       	brne	.+16     	; 0x7ce <initQ+0x24>
     7be:	40 e0       	ldi	r20, 0x00	; 0
     7c0:	62 e0       	ldi	r22, 0x02	; 2
     7c2:	8a e0       	ldi	r24, 0x0A	; 10
     7c4:	4e d6       	rcall	.+3228   	; 0x1462 <xQueueGenericCreate>
     7c6:	90 93 21 04 	sts	0x0421, r25	; 0x800421 <afstandQueue+0x1>
     7ca:	80 93 20 04 	sts	0x0420, r24	; 0x800420 <afstandQueue>
     7ce:	40 e0       	ldi	r20, 0x00	; 0
     7d0:	62 e0       	ldi	r22, 0x02	; 2
     7d2:	8a e0       	ldi	r24, 0x0A	; 10
     7d4:	46 d6       	rcall	.+3212   	; 0x1462 <xQueueGenericCreate>
     7d6:	90 93 1b 03 	sts	0x031B, r25	; 0x80031b <hoekQueue+0x1>
     7da:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <hoekQueue>
     7de:	89 2b       	or	r24, r25
     7e0:	41 f4       	brne	.+16     	; 0x7f2 <initQ+0x48>
     7e2:	40 e0       	ldi	r20, 0x00	; 0
     7e4:	62 e0       	ldi	r22, 0x02	; 2
     7e6:	8a e0       	ldi	r24, 0x0A	; 10
     7e8:	3c d6       	rcall	.+3192   	; 0x1462 <xQueueGenericCreate>
     7ea:	90 93 1b 03 	sts	0x031B, r25	; 0x80031b <hoekQueue+0x1>
     7ee:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <hoekQueue>
     7f2:	40 e0       	ldi	r20, 0x00	; 0
     7f4:	62 e0       	ldi	r22, 0x02	; 2
     7f6:	8a e0       	ldi	r24, 0x0A	; 10
     7f8:	34 d6       	rcall	.+3176   	; 0x1462 <xQueueGenericCreate>
     7fa:	90 93 2c 04 	sts	0x042C, r25	; 0x80042c <temperatuurQueue+0x1>
     7fe:	80 93 2b 04 	sts	0x042B, r24	; 0x80042b <temperatuurQueue>
     802:	89 2b       	or	r24, r25
     804:	41 f4       	brne	.+16     	; 0x816 <initQ+0x6c>
     806:	40 e0       	ldi	r20, 0x00	; 0
     808:	62 e0       	ldi	r22, 0x02	; 2
     80a:	8a e0       	ldi	r24, 0x0A	; 10
     80c:	2a d6       	rcall	.+3156   	; 0x1462 <xQueueGenericCreate>
     80e:	90 93 2c 04 	sts	0x042C, r25	; 0x80042c <temperatuurQueue+0x1>
     812:	80 93 2b 04 	sts	0x042B, r24	; 0x80042b <temperatuurQueue>
     816:	40 e0       	ldi	r20, 0x00	; 0
     818:	62 e0       	ldi	r22, 0x02	; 2
     81a:	8a e0       	ldi	r24, 0x0A	; 10
     81c:	22 d6       	rcall	.+3140   	; 0x1462 <xQueueGenericCreate>
     81e:	90 93 2e 04 	sts	0x042E, r25	; 0x80042e <humidityQueue+0x1>
     822:	80 93 2d 04 	sts	0x042D, r24	; 0x80042d <humidityQueue>
     826:	89 2b       	or	r24, r25
     828:	41 f4       	brne	.+16     	; 0x83a <initQ+0x90>
     82a:	40 e0       	ldi	r20, 0x00	; 0
     82c:	62 e0       	ldi	r22, 0x02	; 2
     82e:	8a e0       	ldi	r24, 0x0A	; 10
     830:	18 d6       	rcall	.+3120   	; 0x1462 <xQueueGenericCreate>
     832:	90 93 2e 04 	sts	0x042E, r25	; 0x80042e <humidityQueue+0x1>
     836:	80 93 2d 04 	sts	0x042D, r24	; 0x80042d <humidityQueue>
     83a:	08 95       	ret

0000083c <UART_Init>:
     83c:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     840:	87 e6       	ldi	r24, 0x67	; 103
     842:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     846:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     84a:	86 e0       	ldi	r24, 0x06	; 6
     84c:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     850:	88 e1       	ldi	r24, 0x18	; 24
     852:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     856:	08 95       	ret

00000858 <UART_Transmit>:
     858:	e8 ec       	ldi	r30, 0xC8	; 200
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	90 81       	ld	r25, Z
     85e:	95 ff       	sbrs	r25, 5
     860:	fd cf       	rjmp	.-6      	; 0x85c <UART_Transmit+0x4>
     862:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     866:	08 95       	ret

00000868 <__vector_36>:
     868:	1f 92       	push	r1
     86a:	0f 92       	push	r0
     86c:	0f b6       	in	r0, 0x3f	; 63
     86e:	0f 92       	push	r0
     870:	11 24       	eor	r1, r1
     872:	0b b6       	in	r0, 0x3b	; 59
     874:	0f 92       	push	r0
     876:	2f 93       	push	r18
     878:	3f 93       	push	r19
     87a:	4f 93       	push	r20
     87c:	5f 93       	push	r21
     87e:	6f 93       	push	r22
     880:	7f 93       	push	r23
     882:	8f 93       	push	r24
     884:	9f 93       	push	r25
     886:	af 93       	push	r26
     888:	bf 93       	push	r27
     88a:	ef 93       	push	r30
     88c:	ff 93       	push	r31
     88e:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     892:	80 93 2a 04 	sts	0x042A, r24	; 0x80042a <ontvang>
     896:	e0 df       	rcall	.-64     	; 0x858 <UART_Transmit>
     898:	81 e0       	ldi	r24, 0x01	; 1
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	90 93 b3 02 	sts	0x02B3, r25	; 0x8002b3 <state+0x1>
     8a0:	80 93 b2 02 	sts	0x02B2, r24	; 0x8002b2 <state>
     8a4:	ff 91       	pop	r31
     8a6:	ef 91       	pop	r30
     8a8:	bf 91       	pop	r27
     8aa:	af 91       	pop	r26
     8ac:	9f 91       	pop	r25
     8ae:	8f 91       	pop	r24
     8b0:	7f 91       	pop	r23
     8b2:	6f 91       	pop	r22
     8b4:	5f 91       	pop	r21
     8b6:	4f 91       	pop	r20
     8b8:	3f 91       	pop	r19
     8ba:	2f 91       	pop	r18
     8bc:	0f 90       	pop	r0
     8be:	0b be       	out	0x3b, r0	; 59
     8c0:	0f 90       	pop	r0
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	0f 90       	pop	r0
     8c6:	1f 90       	pop	r1
     8c8:	18 95       	reti

000008ca <UART_Transmit_String>:
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	ec 01       	movw	r28, r24
     8d0:	88 81       	ld	r24, Y
     8d2:	88 23       	and	r24, r24
     8d4:	29 f0       	breq	.+10     	; 0x8e0 <UART_Transmit_String+0x16>
     8d6:	21 96       	adiw	r28, 0x01	; 1
     8d8:	bf df       	rcall	.-130    	; 0x858 <UART_Transmit>
     8da:	89 91       	ld	r24, Y+
     8dc:	81 11       	cpse	r24, r1
     8de:	fc cf       	rjmp	.-8      	; 0x8d8 <UART_Transmit_String+0xe>
     8e0:	df 91       	pop	r29
     8e2:	cf 91       	pop	r28
     8e4:	08 95       	ret

000008e6 <UART_Transmit_Integer>:
     8e6:	cf 93       	push	r28
     8e8:	df 93       	push	r29
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	61 97       	sbiw	r28, 0x11	; 17
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	de bf       	out	0x3e, r29	; 62
     8f6:	0f be       	out	0x3f, r0	; 63
     8f8:	cd bf       	out	0x3d, r28	; 61
     8fa:	dc 01       	movw	r26, r24
     8fc:	cb 01       	movw	r24, r22
     8fe:	4a e0       	ldi	r20, 0x0A	; 10
     900:	be 01       	movw	r22, r28
     902:	6f 5f       	subi	r22, 0xFF	; 255
     904:	7f 4f       	sbci	r23, 0xFF	; 255
     906:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <__itoa_ncheck>
     90a:	ce 01       	movw	r24, r28
     90c:	01 96       	adiw	r24, 0x01	; 1
     90e:	dd df       	rcall	.-70     	; 0x8ca <UART_Transmit_String>
     910:	61 96       	adiw	r28, 0x11	; 17
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	f8 94       	cli
     916:	de bf       	out	0x3e, r29	; 62
     918:	0f be       	out	0x3f, r0	; 63
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	df 91       	pop	r29
     91e:	cf 91       	pop	r28
     920:	08 95       	ret

00000922 <printTaak>:
     922:	cf 93       	push	r28
     924:	df 93       	push	r29
     926:	cd b7       	in	r28, 0x3d	; 61
     928:	de b7       	in	r29, 0x3e	; 62
     92a:	28 97       	sbiw	r28, 0x08	; 8
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	de bf       	out	0x3e, r29	; 62
     932:	0f be       	out	0x3f, r0	; 63
     934:	cd bf       	out	0x3d, r28	; 61
     936:	20 e0       	ldi	r18, 0x00	; 0
     938:	40 e0       	ldi	r20, 0x00	; 0
     93a:	50 e0       	ldi	r21, 0x00	; 0
     93c:	be 01       	movw	r22, r28
     93e:	6d 5f       	subi	r22, 0xFD	; 253
     940:	7f 4f       	sbci	r23, 0xFF	; 255
     942:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <afstandQueue>
     946:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <afstandQueue+0x1>
     94a:	49 d6       	rcall	.+3218   	; 0x15de <xQueueGenericReceive>
     94c:	81 30       	cpi	r24, 0x01	; 1
     94e:	99 f7       	brne	.-26     	; 0x936 <printTaak+0x14>
     950:	20 e0       	ldi	r18, 0x00	; 0
     952:	40 e0       	ldi	r20, 0x00	; 0
     954:	50 e0       	ldi	r21, 0x00	; 0
     956:	be 01       	movw	r22, r28
     958:	6f 5f       	subi	r22, 0xFF	; 255
     95a:	7f 4f       	sbci	r23, 0xFF	; 255
     95c:	80 91 1a 03 	lds	r24, 0x031A	; 0x80031a <hoekQueue>
     960:	90 91 1b 03 	lds	r25, 0x031B	; 0x80031b <hoekQueue+0x1>
     964:	3c d6       	rcall	.+3192   	; 0x15de <xQueueGenericReceive>
     966:	81 30       	cpi	r24, 0x01	; 1
     968:	31 f7       	brne	.-52     	; 0x936 <printTaak+0x14>
     96a:	20 e0       	ldi	r18, 0x00	; 0
     96c:	40 e0       	ldi	r20, 0x00	; 0
     96e:	50 e0       	ldi	r21, 0x00	; 0
     970:	be 01       	movw	r22, r28
     972:	6b 5f       	subi	r22, 0xFB	; 251
     974:	7f 4f       	sbci	r23, 0xFF	; 255
     976:	80 91 2b 04 	lds	r24, 0x042B	; 0x80042b <temperatuurQueue>
     97a:	90 91 2c 04 	lds	r25, 0x042C	; 0x80042c <temperatuurQueue+0x1>
     97e:	2f d6       	rcall	.+3166   	; 0x15de <xQueueGenericReceive>
     980:	81 30       	cpi	r24, 0x01	; 1
     982:	c9 f6       	brne	.-78     	; 0x936 <printTaak+0x14>
     984:	20 e0       	ldi	r18, 0x00	; 0
     986:	40 e0       	ldi	r20, 0x00	; 0
     988:	50 e0       	ldi	r21, 0x00	; 0
     98a:	be 01       	movw	r22, r28
     98c:	69 5f       	subi	r22, 0xF9	; 249
     98e:	7f 4f       	sbci	r23, 0xFF	; 255
     990:	80 91 2d 04 	lds	r24, 0x042D	; 0x80042d <humidityQueue>
     994:	90 91 2e 04 	lds	r25, 0x042E	; 0x80042e <humidityQueue+0x1>
     998:	22 d6       	rcall	.+3140   	; 0x15de <xQueueGenericReceive>
     99a:	81 30       	cpi	r24, 0x01	; 1
     99c:	61 f6       	brne	.-104    	; 0x936 <printTaak+0x14>
     99e:	87 e0       	ldi	r24, 0x07	; 7
     9a0:	92 e0       	ldi	r25, 0x02	; 2
     9a2:	93 df       	rcall	.-218    	; 0x8ca <UART_Transmit_String>
     9a4:	69 81       	ldd	r22, Y+1	; 0x01
     9a6:	7a 81       	ldd	r23, Y+2	; 0x02
     9a8:	07 2e       	mov	r0, r23
     9aa:	00 0c       	add	r0, r0
     9ac:	88 0b       	sbc	r24, r24
     9ae:	99 0b       	sbc	r25, r25
     9b0:	9a df       	rcall	.-204    	; 0x8e6 <UART_Transmit_Integer>
     9b2:	8e e0       	ldi	r24, 0x0E	; 14
     9b4:	92 e0       	ldi	r25, 0x02	; 2
     9b6:	89 df       	rcall	.-238    	; 0x8ca <UART_Transmit_String>
     9b8:	6b 81       	ldd	r22, Y+3	; 0x03
     9ba:	7c 81       	ldd	r23, Y+4	; 0x04
     9bc:	07 2e       	mov	r0, r23
     9be:	00 0c       	add	r0, r0
     9c0:	88 0b       	sbc	r24, r24
     9c2:	99 0b       	sbc	r25, r25
     9c4:	90 df       	rcall	.-224    	; 0x8e6 <UART_Transmit_Integer>
     9c6:	89 e1       	ldi	r24, 0x19	; 25
     9c8:	92 e0       	ldi	r25, 0x02	; 2
     9ca:	7f df       	rcall	.-258    	; 0x8ca <UART_Transmit_String>
     9cc:	6d 81       	ldd	r22, Y+5	; 0x05
     9ce:	7e 81       	ldd	r23, Y+6	; 0x06
     9d0:	07 2e       	mov	r0, r23
     9d2:	00 0c       	add	r0, r0
     9d4:	88 0b       	sbc	r24, r24
     9d6:	99 0b       	sbc	r25, r25
     9d8:	86 df       	rcall	.-244    	; 0x8e6 <UART_Transmit_Integer>
     9da:	88 e2       	ldi	r24, 0x28	; 40
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	75 df       	rcall	.-278    	; 0x8ca <UART_Transmit_String>
     9e0:	6f 81       	ldd	r22, Y+7	; 0x07
     9e2:	78 85       	ldd	r23, Y+8	; 0x08
     9e4:	07 2e       	mov	r0, r23
     9e6:	00 0c       	add	r0, r0
     9e8:	88 0b       	sbc	r24, r24
     9ea:	99 0b       	sbc	r25, r25
     9ec:	7c df       	rcall	.-264    	; 0x8e6 <UART_Transmit_Integer>
     9ee:	8e e3       	ldi	r24, 0x3E	; 62
     9f0:	92 e0       	ldi	r25, 0x02	; 2
     9f2:	6b df       	rcall	.-298    	; 0x8ca <UART_Transmit_String>
     9f4:	a0 cf       	rjmp	.-192    	; 0x936 <printTaak+0x14>

000009f6 <INT1_init>:
     9f6:	e8 e6       	ldi	r30, 0x68	; 104
     9f8:	f0 e0       	ldi	r31, 0x00	; 0
     9fa:	80 81       	ld	r24, Z
     9fc:	81 60       	ori	r24, 0x01	; 1
     9fe:	80 83       	st	Z, r24
     a00:	eb e6       	ldi	r30, 0x6B	; 107
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	82 60       	ori	r24, 0x02	; 2
     a08:	80 83       	st	Z, r24
     a0a:	08 95       	ret

00000a0c <__vector_9>:
     a0c:	1f 92       	push	r1
     a0e:	0f 92       	push	r0
     a10:	0f b6       	in	r0, 0x3f	; 63
     a12:	0f 92       	push	r0
     a14:	11 24       	eor	r1, r1
     a16:	0b b6       	in	r0, 0x3b	; 59
     a18:	0f 92       	push	r0
     a1a:	2f 93       	push	r18
     a1c:	3f 93       	push	r19
     a1e:	4f 93       	push	r20
     a20:	5f 93       	push	r21
     a22:	6f 93       	push	r22
     a24:	7f 93       	push	r23
     a26:	8f 93       	push	r24
     a28:	9f 93       	push	r25
     a2a:	af 93       	push	r26
     a2c:	bf 93       	push	r27
     a2e:	ef 93       	push	r30
     a30:	ff 93       	push	r31
     a32:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <running>
     a36:	88 23       	and	r24, r24
     a38:	d1 f1       	breq	.+116    	; 0xaae <__vector_9+0xa2>
     a3a:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <up>
     a3e:	81 11       	cpse	r24, r1
     a40:	10 c0       	rjmp	.+32     	; 0xa62 <__vector_9+0x56>
     a42:	81 e0       	ldi	r24, 0x01	; 1
     a44:	80 93 b0 02 	sts	0x02B0, r24	; 0x8002b0 <up>
     a48:	10 92 ac 02 	sts	0x02AC, r1	; 0x8002ac <timerCounter>
     a4c:	10 92 ad 02 	sts	0x02AD, r1	; 0x8002ad <timerCounter+0x1>
     a50:	10 92 ae 02 	sts	0x02AE, r1	; 0x8002ae <timerCounter+0x2>
     a54:	10 92 af 02 	sts	0x02AF, r1	; 0x8002af <timerCounter+0x3>
     a58:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a5c:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a60:	26 c0       	rjmp	.+76     	; 0xaae <__vector_9+0xa2>
     a62:	10 92 b0 02 	sts	0x02B0, r1	; 0x8002b0 <up>
     a66:	20 91 ac 02 	lds	r18, 0x02AC	; 0x8002ac <timerCounter>
     a6a:	30 91 ad 02 	lds	r19, 0x02AD	; 0x8002ad <timerCounter+0x1>
     a6e:	40 91 ae 02 	lds	r20, 0x02AE	; 0x8002ae <timerCounter+0x2>
     a72:	50 91 af 02 	lds	r21, 0x02AF	; 0x8002af <timerCounter+0x3>
     a76:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     a7a:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     a7e:	af ef       	ldi	r26, 0xFF	; 255
     a80:	bf ef       	ldi	r27, 0xFF	; 255
     a82:	0e 94 1a 14 	call	0x2834	; 0x2834 <__muluhisi3>
     a86:	6e 0f       	add	r22, r30
     a88:	7f 1f       	adc	r23, r31
     a8a:	81 1d       	adc	r24, r1
     a8c:	91 1d       	adc	r25, r1
     a8e:	24 e7       	ldi	r18, 0x74	; 116
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	40 e0       	ldi	r20, 0x00	; 0
     a94:	50 e0       	ldi	r21, 0x00	; 0
     a96:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <__udivmodsi4>
     a9a:	20 93 a8 02 	sts	0x02A8, r18	; 0x8002a8 <result>
     a9e:	30 93 a9 02 	sts	0x02A9, r19	; 0x8002a9 <result+0x1>
     aa2:	40 93 aa 02 	sts	0x02AA, r20	; 0x8002aa <result+0x2>
     aa6:	50 93 ab 02 	sts	0x02AB, r21	; 0x8002ab <result+0x3>
     aaa:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <running>
     aae:	ff 91       	pop	r31
     ab0:	ef 91       	pop	r30
     ab2:	bf 91       	pop	r27
     ab4:	af 91       	pop	r26
     ab6:	9f 91       	pop	r25
     ab8:	8f 91       	pop	r24
     aba:	7f 91       	pop	r23
     abc:	6f 91       	pop	r22
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	0f 90       	pop	r0
     ac8:	0b be       	out	0x3b, r0	; 59
     aca:	0f 90       	pop	r0
     acc:	0f be       	out	0x3f, r0	; 63
     ace:	0f 90       	pop	r0
     ad0:	1f 90       	pop	r1
     ad2:	18 95       	reti

00000ad4 <pulse>:
     ad4:	28 98       	cbi	0x05, 0	; 5
     ad6:	85 e0       	ldi	r24, 0x05	; 5
     ad8:	8a 95       	dec	r24
     ada:	f1 f7       	brne	.-4      	; 0xad8 <pulse+0x4>
     adc:	00 00       	nop
     ade:	28 9a       	sbi	0x05, 0	; 5
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	80 93 b1 02 	sts	0x02B1, r24	; 0x8002b1 <running>
     ae6:	85 e3       	ldi	r24, 0x35	; 53
     ae8:	8a 95       	dec	r24
     aea:	f1 f7       	brne	.-4      	; 0xae8 <pulse+0x14>
     aec:	00 00       	nop
     aee:	28 98       	cbi	0x05, 0	; 5
     af0:	08 95       	ret

00000af2 <sonarTaak>:
     af2:	c1 e0       	ldi	r28, 0x01	; 1
     af4:	d0 e0       	ldi	r29, 0x00	; 0
     af6:	80 91 b1 02 	lds	r24, 0x02B1	; 0x8002b1 <running>
     afa:	81 11       	cpse	r24, r1
     afc:	14 c0       	rjmp	.+40     	; 0xb26 <sonarTaak+0x34>
     afe:	2f ef       	ldi	r18, 0xFF	; 255
     b00:	80 e7       	ldi	r24, 0x70	; 112
     b02:	92 e0       	ldi	r25, 0x02	; 2
     b04:	21 50       	subi	r18, 0x01	; 1
     b06:	80 40       	sbci	r24, 0x00	; 0
     b08:	90 40       	sbci	r25, 0x00	; 0
     b0a:	e1 f7       	brne	.-8      	; 0xb04 <sonarTaak+0x12>
     b0c:	00 c0       	rjmp	.+0      	; 0xb0e <sonarTaak+0x1c>
     b0e:	00 00       	nop
     b10:	e1 df       	rcall	.-62     	; 0xad4 <pulse>
     b12:	20 e0       	ldi	r18, 0x00	; 0
     b14:	40 e0       	ldi	r20, 0x00	; 0
     b16:	50 e0       	ldi	r21, 0x00	; 0
     b18:	68 ea       	ldi	r22, 0xA8	; 168
     b1a:	72 e0       	ldi	r23, 0x02	; 2
     b1c:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <afstandQueue>
     b20:	90 91 21 04 	lds	r25, 0x0421	; 0x800421 <afstandQueue+0x1>
     b24:	ca d4       	rcall	.+2452   	; 0x14ba <xQueueGenericSend>
     b26:	d0 93 1f 03 	sts	0x031F, r29	; 0x80031f <watchdogSonar+0x1>
     b2a:	c0 93 1e 03 	sts	0x031E, r28	; 0x80031e <watchdogSonar>
     b2e:	e3 cf       	rjmp	.-58     	; 0xaf6 <sonarTaak+0x4>

00000b30 <timer3_init>:
     b30:	e1 e9       	ldi	r30, 0x91	; 145
     b32:	f0 e0       	ldi	r31, 0x00	; 0
     b34:	80 81       	ld	r24, Z
     b36:	82 60       	ori	r24, 0x02	; 2
     b38:	80 83       	st	Z, r24
     b3a:	10 92 95 00 	sts	0x0095, r1	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     b3e:	10 92 94 00 	sts	0x0094, r1	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     b42:	e1 e7       	ldi	r30, 0x71	; 113
     b44:	f0 e0       	ldi	r31, 0x00	; 0
     b46:	80 81       	ld	r24, Z
     b48:	81 60       	ori	r24, 0x01	; 1
     b4a:	80 83       	st	Z, r24
     b4c:	08 95       	ret

00000b4e <__vector_35>:
     b4e:	1f 92       	push	r1
     b50:	0f 92       	push	r0
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	0f 92       	push	r0
     b56:	11 24       	eor	r1, r1
     b58:	0b b6       	in	r0, 0x3b	; 59
     b5a:	0f 92       	push	r0
     b5c:	2f 93       	push	r18
     b5e:	3f 93       	push	r19
     b60:	4f 93       	push	r20
     b62:	5f 93       	push	r21
     b64:	6f 93       	push	r22
     b66:	7f 93       	push	r23
     b68:	8f 93       	push	r24
     b6a:	9f 93       	push	r25
     b6c:	af 93       	push	r26
     b6e:	bf 93       	push	r27
     b70:	ef 93       	push	r30
     b72:	ff 93       	push	r31
     b74:	80 91 b0 02 	lds	r24, 0x02B0	; 0x8002b0 <up>
     b78:	88 23       	and	r24, r24
     b7a:	e9 f1       	breq	.+122    	; 0xbf6 <__vector_35+0xa8>
     b7c:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <timerCounter>
     b80:	90 91 ad 02 	lds	r25, 0x02AD	; 0x8002ad <timerCounter+0x1>
     b84:	a0 91 ae 02 	lds	r26, 0x02AE	; 0x8002ae <timerCounter+0x2>
     b88:	b0 91 af 02 	lds	r27, 0x02AF	; 0x8002af <timerCounter+0x3>
     b8c:	01 96       	adiw	r24, 0x01	; 1
     b8e:	a1 1d       	adc	r26, r1
     b90:	b1 1d       	adc	r27, r1
     b92:	80 93 ac 02 	sts	0x02AC, r24	; 0x8002ac <timerCounter>
     b96:	90 93 ad 02 	sts	0x02AD, r25	; 0x8002ad <timerCounter+0x1>
     b9a:	a0 93 ae 02 	sts	0x02AE, r26	; 0x8002ae <timerCounter+0x2>
     b9e:	b0 93 af 02 	sts	0x02AF, r27	; 0x8002af <timerCounter+0x3>
     ba2:	20 91 ac 02 	lds	r18, 0x02AC	; 0x8002ac <timerCounter>
     ba6:	30 91 ad 02 	lds	r19, 0x02AD	; 0x8002ad <timerCounter+0x1>
     baa:	40 91 ae 02 	lds	r20, 0x02AE	; 0x8002ae <timerCounter+0x2>
     bae:	50 91 af 02 	lds	r21, 0x02AF	; 0x8002af <timerCounter+0x3>
     bb2:	e0 91 94 00 	lds	r30, 0x0094	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
     bb6:	f0 91 95 00 	lds	r31, 0x0095	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
     bba:	af ef       	ldi	r26, 0xFF	; 255
     bbc:	bf ef       	ldi	r27, 0xFF	; 255
     bbe:	0e 94 1a 14 	call	0x2834	; 0x2834 <__muluhisi3>
     bc2:	dc 01       	movw	r26, r24
     bc4:	cb 01       	movw	r24, r22
     bc6:	8e 0f       	add	r24, r30
     bc8:	9f 1f       	adc	r25, r31
     bca:	a1 1d       	adc	r26, r1
     bcc:	b1 1d       	adc	r27, r1
     bce:	81 30       	cpi	r24, 0x01	; 1
     bd0:	94 4d       	sbci	r25, 0xD4	; 212
     bd2:	a0 43       	sbci	r26, 0x30	; 48
     bd4:	b1 05       	cpc	r27, r1
     bd6:	78 f0       	brcs	.+30     	; 0xbf6 <__vector_35+0xa8>
     bd8:	10 92 b0 02 	sts	0x02B0, r1	; 0x8002b0 <up>
     bdc:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <running>
     be0:	8f ef       	ldi	r24, 0xFF	; 255
     be2:	9f ef       	ldi	r25, 0xFF	; 255
     be4:	dc 01       	movw	r26, r24
     be6:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <result>
     bea:	90 93 a9 02 	sts	0x02A9, r25	; 0x8002a9 <result+0x1>
     bee:	a0 93 aa 02 	sts	0x02AA, r26	; 0x8002aa <result+0x2>
     bf2:	b0 93 ab 02 	sts	0x02AB, r27	; 0x8002ab <result+0x3>
     bf6:	ff 91       	pop	r31
     bf8:	ef 91       	pop	r30
     bfa:	bf 91       	pop	r27
     bfc:	af 91       	pop	r26
     bfe:	9f 91       	pop	r25
     c00:	8f 91       	pop	r24
     c02:	7f 91       	pop	r23
     c04:	6f 91       	pop	r22
     c06:	5f 91       	pop	r21
     c08:	4f 91       	pop	r20
     c0a:	3f 91       	pop	r19
     c0c:	2f 91       	pop	r18
     c0e:	0f 90       	pop	r0
     c10:	0b be       	out	0x3b, r0	; 59
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
     c16:	0f 90       	pop	r0
     c18:	1f 90       	pop	r1
     c1a:	18 95       	reti

00000c1c <initServo>:
}

void initServo()
{
	DDRB |= (1 << PB6);
     c1c:	26 9a       	sbi	0x04, 6	; 4
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
     c1e:	82 e3       	ldi	r24, 0x32	; 50
     c20:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = (1 << WGM13) | (1 << CS11);
     c24:	82 e1       	ldi	r24, 0x12	; 18
     c26:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	ICR1 = 20000;
     c2a:	80 e2       	ldi	r24, 0x20	; 32
     c2c:	9e e4       	ldi	r25, 0x4E	; 78
     c2e:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     c32:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	TCNT1 = 0;
     c36:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
     c3a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
	}
}

void turnServo(uint8_t degrees)
{
	OCR1B = 20000 - (degrees * (1300 / 180) + 800);
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	9b e4       	ldi	r25, 0x4B	; 75
     c42:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     c46:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	TCCR1A = (1 << WGM11)| (1 << COM1B0) | (1 << COM1B1);
	TCCR1B = (1 << WGM13) | (1 << CS11);
	ICR1 = 20000;
	TCNT1 = 0;
	turnServo(0);
	TIMSK1 |= (1 << 1);
     c4a:	ef e6       	ldi	r30, 0x6F	; 111
     c4c:	f0 e0       	ldi	r31, 0x00	; 0
     c4e:	80 81       	ld	r24, Z
     c50:	82 60       	ori	r24, 0x02	; 2
     c52:	80 83       	st	Z, r24
     c54:	08 95       	ret

00000c56 <init_master>:
}



void init_master() {
	TWSR = 0;
     c56:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
     c5a:	88 e4       	ldi	r24, 0x48	; 72
     c5c:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
	TWCR = (1<<TWEN);
     c60:	84 e0       	ldi	r24, 0x04	; 4
     c62:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     c66:	08 95       	ret

00000c68 <main>:
//echo = digital pin 52
//servo = digital pin 12


int main() 
{
     c68:	ef 92       	push	r14
     c6a:	ff 92       	push	r15
     c6c:	0f 93       	push	r16
	sem = xSemaphoreCreateBinary();
     c6e:	43 e0       	ldi	r20, 0x03	; 3
     c70:	60 e0       	ldi	r22, 0x00	; 0
     c72:	81 e0       	ldi	r24, 0x01	; 1
     c74:	f6 d3       	rcall	.+2028   	; 0x1462 <xQueueGenericCreate>
     c76:	90 93 1d 03 	sts	0x031D, r25	; 0x80031d <sem+0x1>
     c7a:	80 93 1c 03 	sts	0x031C, r24	; 0x80031c <sem>
	xSemaphoreGive(sem);
     c7e:	20 e0       	ldi	r18, 0x00	; 0
     c80:	40 e0       	ldi	r20, 0x00	; 0
     c82:	50 e0       	ldi	r21, 0x00	; 0
     c84:	60 e0       	ldi	r22, 0x00	; 0
     c86:	70 e0       	ldi	r23, 0x00	; 0
     c88:	18 d4       	rcall	.+2096   	; 0x14ba <xQueueGenericSend>
	DDRD|= 0x03;
     c8a:	8a b1       	in	r24, 0x0a	; 10
     c8c:	83 60       	ori	r24, 0x03	; 3
	DDRB |= (1 << TRIGGER);											// Trigger pin
	UART_Init();
     c8e:	8a b9       	out	0x0a, r24	; 10
	INT1_init();
     c90:	20 9a       	sbi	0x04, 0	; 4
	timer3_init();
     c92:	d4 dd       	rcall	.-1112   	; 0x83c <UART_Init>
	initServo();
     c94:	b0 de       	rcall	.-672    	; 0x9f6 <INT1_init>
     c96:	4c df       	rcall	.-360    	; 0xb30 <timer3_init>
	sei();
     c98:	c1 df       	rcall	.-126    	; 0xc1c <initServo>
	initQ();
     c9a:	78 94       	sei
     c9c:	86 dd       	rcall	.-1268   	; 0x7aa <initQ>
	init_master();
     c9e:	db df       	rcall	.-74     	; 0xc56 <init_master>
     ca0:	10 92 1f 03 	sts	0x031F, r1	; 0x80031f <watchdogSonar+0x1>
	watchdogSonar=0;
     ca4:	10 92 1e 03 	sts	0x031E, r1	; 0x80031e <watchdogSonar>
     ca8:	10 92 29 04 	sts	0x0429, r1	; 0x800429 <watchdogServo+0x1>
	watchdogServo=0;
     cac:	10 92 28 04 	sts	0x0428, r1	; 0x800428 <watchdogServo>
     cb0:	10 92 23 04 	sts	0x0423, r1	; 0x800423 <watchdogTemp+0x1>
	watchdogTemp=0;
     cb4:	10 92 22 04 	sts	0x0422, r1	; 0x800422 <watchdogTemp>
     cb8:	98 e2       	ldi	r25, 0x28	; 40
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
     cba:	88 e1       	ldi	r24, 0x18	; 24
     cbc:	0f b6       	in	r0, 0x3f	; 63
     cbe:	f8 94       	cli
     cc0:	a8 95       	wdr
     cc2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     cc6:	0f be       	out	0x3f, r0	; 63
     cc8:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
	wdt_enable(WDTO_4S);
	// Replace with your application code
//	UART_Transmit('a');
	UART_Transmit_String("setup done\n\r");
     ccc:	84 e3       	ldi	r24, 0x34	; 52
     cce:	92 e0       	ldi	r25, 0x02	; 2
     cd0:	fc dd       	rcall	.-1032   	; 0x8ca <UART_Transmit_String>
     cd2:	e1 2c       	mov	r14, r1
	xTaskCreate(sonarTaak,"Sonar Sensor",256,NULL,1,NULL);			//lees sonar sensor uit en schrijf afstand naar sonar queue
     cd4:	f1 2c       	mov	r15, r1
     cd6:	01 e0       	ldi	r16, 0x01	; 1
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	40 e0       	ldi	r20, 0x00	; 0
     cde:	51 e0       	ldi	r21, 0x01	; 1
     ce0:	61 e4       	ldi	r22, 0x41	; 65
     ce2:	72 e0       	ldi	r23, 0x02	; 2
     ce4:	89 e7       	ldi	r24, 0x79	; 121
     ce6:	95 e0       	ldi	r25, 0x05	; 5
     ce8:	86 d7       	rcall	.+3852   	; 0x1bf6 <xTaskCreate>
	xTaskCreate(servoTaak,"Servo Motor",256,NULL,1,NULL);			//code van Joris & Benjamin
     cea:	20 e0       	ldi	r18, 0x00	; 0
     cec:	30 e0       	ldi	r19, 0x00	; 0
     cee:	40 e0       	ldi	r20, 0x00	; 0
     cf0:	51 e0       	ldi	r21, 0x01	; 1
     cf2:	6e e4       	ldi	r22, 0x4E	; 78
     cf4:	72 e0       	ldi	r23, 0x02	; 2
     cf6:	89 e9       	ldi	r24, 0x99	; 153
     cf8:	93 e0       	ldi	r25, 0x03	; 3
     cfa:	7d d7       	rcall	.+3834   	; 0x1bf6 <xTaskCreate>
	xTaskCreate(temperatuurTaak,"Temperatuur Sensor",256,NULL,1,NULL);
     cfc:	20 e0       	ldi	r18, 0x00	; 0
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	40 e0       	ldi	r20, 0x00	; 0
     d02:	51 e0       	ldi	r21, 0x01	; 1
     d04:	6a e5       	ldi	r22, 0x5A	; 90
     d06:	72 e0       	ldi	r23, 0x02	; 2
     d08:	86 e1       	ldi	r24, 0x16	; 22
     d0a:	97 e0       	ldi	r25, 0x07	; 7
     d0c:	74 d7       	rcall	.+3816   	; 0x1bf6 <xTaskCreate>
	xTaskCreate(printTaak,"Print Taak",256,NULL,1,NULL);
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	40 e0       	ldi	r20, 0x00	; 0
     d14:	51 e0       	ldi	r21, 0x01	; 1
     d16:	6d e6       	ldi	r22, 0x6D	; 109
     d18:	72 e0       	ldi	r23, 0x02	; 2
     d1a:	81 e9       	ldi	r24, 0x91	; 145
     d1c:	94 e0       	ldi	r25, 0x04	; 4
     d1e:	6b d7       	rcall	.+3798   	; 0x1bf6 <xTaskCreate>
	//xTaskCreate(testTaak,"temperatuur Sensor",256,NULL,3,NULL);
	xTaskCreate(watchdogTaak,"Watchdog Reset",256,NULL,2,NULL);
     d20:	02 e0       	ldi	r16, 0x02	; 2
     d22:	20 e0       	ldi	r18, 0x00	; 0
     d24:	30 e0       	ldi	r19, 0x00	; 0
     d26:	40 e0       	ldi	r20, 0x00	; 0
     d28:	51 e0       	ldi	r21, 0x01	; 1
     d2a:	68 e7       	ldi	r22, 0x78	; 120
     d2c:	72 e0       	ldi	r23, 0x02	; 2
     d2e:	85 e7       	ldi	r24, 0x75	; 117
     d30:	93 e0       	ldi	r25, 0x03	; 3
     d32:	61 d7       	rcall	.+3778   	; 0x1bf6 <xTaskCreate>
     d34:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <vTaskStartScheduler>

	vTaskStartScheduler();
     d38:	80 e0       	ldi	r24, 0x00	; 0
}
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	0f 91       	pop	r16
     d3e:	ff 90       	pop	r15
     d40:	ef 90       	pop	r14
     d42:	08 95       	ret

00000d44 <ontvangen>:
     d44:	ef 92       	push	r14
	// Set bit rate
	TWBR = ( ( F_CPU / 100000 ) - 16) / 2;
	TWCR = (1<<TWEN);
}

void ontvangen(uint8_t ad,uint8_t b[],uint8_t max) {
     d46:	ff 92       	push	r15
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
	uint8_t op[15];
	
	//	UART_Transmit('a');

	TWCR |= (1<<TWSTA);
     d50:	ec eb       	ldi	r30, 0xBC	; 188
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	90 81       	ld	r25, Z
     d56:	90 62       	ori	r25, 0x20	; 32
     d58:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     d5a:	90 81       	ld	r25, Z
     d5c:	99 23       	and	r25, r25
     d5e:	ec f7       	brge	.-6      	; 0xd5a <ontvangen+0x16>
	op[0] = TWSR;
     d60:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>

	
	//UART_Transmit('b');

	TWDR=(ad<<1)+1;
     d64:	88 0f       	add	r24, r24
     d66:	8f 5f       	subi	r24, 0xFF	; 255
     d68:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     d6c:	84 e8       	ldi	r24, 0x84	; 132
     d6e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     d72:	ec eb       	ldi	r30, 0xBC	; 188
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	88 23       	and	r24, r24
     d7a:	ec f7       	brge	.-6      	; 0xd76 <ontvangen+0x32>

	op[1] = TWSR;
     d7c:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
	b[0]=TWDR;
     d80:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
     d84:	db 01       	movw	r26, r22
     d86:	8c 93       	st	X, r24
	
	uint8_t tel=0;
     d88:	90 e0       	ldi	r25, 0x00	; 0
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     d8a:	50 e0       	ldi	r21, 0x00	; 0
     d8c:	41 50       	subi	r20, 0x01	; 1
     d8e:	51 09       	sbc	r21, r1
			TWCR=(1<<TWINT)|(1<<TWEN);
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     d90:	ec eb       	ldi	r30, 0xBC	; 188
     d92:	f0 e0       	ldi	r31, 0x00	; 0
     d94:	0f 2e       	mov	r0, r31
     d96:	f4 ec       	ldi	r31, 0xC4	; 196
     d98:	ff 2e       	mov	r15, r31
     d9a:	f0 2d       	mov	r31, r0
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
			TWCR=(1<<TWINT)|(1<<TWEN);
     d9c:	0f 2e       	mov	r0, r31
     d9e:	f4 e8       	ldi	r31, 0x84	; 132
     da0:	ef 2e       	mov	r14, r31
     da2:	f0 2d       	mov	r31, r0
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
		//UART_Transmit('c3');
		op[tel] = TWSR;
     da4:	09 eb       	ldi	r16, 0xB9	; 185
     da6:	10 e0       	ldi	r17, 0x00	; 0
		b[tel]=TWDR;
     da8:	cb eb       	ldi	r28, 0xBB	; 187
     daa:	d0 e0       	ldi	r29, 0x00	; 0
	
	uint8_t tel=0;
	do{
		
		//UART_Transmit('c');
		if(tel == max-1){
     dac:	29 2f       	mov	r18, r25
     dae:	30 e0       	ldi	r19, 0x00	; 0
     db0:	24 17       	cp	r18, r20
     db2:	35 07       	cpc	r19, r21
     db4:	11 f4       	brne	.+4      	; 0xdba <ontvangen+0x76>
			TWCR=(1<<TWINT)|(1<<TWEN);
     db6:	e0 82       	st	Z, r14
     db8:	01 c0       	rjmp	.+2      	; 0xdbc <ontvangen+0x78>
			//UART_Transmit('c1');
			}else{
			TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     dba:	f0 82       	st	Z, r15
			//UART_Transmit('c2');
		}
		while(!(TWCR & (1<<TWINT))); //blijft hier vastzitten
     dbc:	80 81       	ld	r24, Z
     dbe:	88 23       	and	r24, r24
     dc0:	ec f7       	brge	.-6      	; 0xdbc <ontvangen+0x78>
		//UART_Transmit('c3');
		op[tel] = TWSR;
     dc2:	d8 01       	movw	r26, r16
     dc4:	8c 91       	ld	r24, X
		b[tel]=TWDR;
     dc6:	28 81       	ld	r18, Y
     dc8:	db 01       	movw	r26, r22
     dca:	a9 0f       	add	r26, r25
     dcc:	b1 1d       	adc	r27, r1
     dce:	2c 93       	st	X, r18
	}while(op[tel++] == 0x50);
     dd0:	9f 5f       	subi	r25, 0xFF	; 255
     dd2:	80 35       	cpi	r24, 0x50	; 80
     dd4:	59 f3       	breq	.-42     	; 0xdac <ontvangen+0x68>

	
	//UART_Transmit('d');

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     dd6:	84 e9       	ldi	r24, 0x94	; 148
     dd8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>

	//   for(uint8_t i=0;i<tel;++i) {
	//	 writeString("\n\r");writeInteger(op[i],16);
	//	 writeString(" data ");writeInteger(b[i],10);
	//   }
}
     ddc:	df 91       	pop	r29
     dde:	cf 91       	pop	r28
     de0:	1f 91       	pop	r17
     de2:	0f 91       	pop	r16
     de4:	ff 90       	pop	r15
     de6:	ef 90       	pop	r14
     de8:	08 95       	ret

00000dea <verzenden>:

void verzenden(uint8_t ad,uint8_t b) {
	//  uint8_t op[5];

	TWCR |= (1<<TWSTA);
     dea:	ec eb       	ldi	r30, 0xBC	; 188
     dec:	f0 e0       	ldi	r31, 0x00	; 0
     dee:	90 81       	ld	r25, Z
     df0:	90 62       	ori	r25, 0x20	; 32
     df2:	90 83       	st	Z, r25
	while(!(TWCR & (1<<TWINT)));
     df4:	90 81       	ld	r25, Z
     df6:	99 23       	and	r25, r25
     df8:	ec f7       	brge	.-6      	; 0xdf4 <verzenden+0xa>
	//   op[0] = TWSR;
	TWDR=(ad<<1);
     dfa:	88 0f       	add	r24, r24
     dfc:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     e00:	84 e8       	ldi	r24, 0x84	; 132
     e02:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     e06:	ec eb       	ldi	r30, 0xBC	; 188
     e08:	f0 e0       	ldi	r31, 0x00	; 0
     e0a:	80 81       	ld	r24, Z
     e0c:	88 23       	and	r24, r24
     e0e:	ec f7       	brge	.-6      	; 0xe0a <verzenden+0x20>
	//    op[1] = TWSR;

	TWDR=b;
     e10:	60 93 bb 00 	sts	0x00BB, r22	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
	TWCR=(1<<TWINT)|(1<<TWEN);
     e14:	84 e8       	ldi	r24, 0x84	; 132
     e16:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
	while(!(TWCR & (1<<TWINT)));
     e1a:	ec eb       	ldi	r30, 0xBC	; 188
     e1c:	f0 e0       	ldi	r31, 0x00	; 0
     e1e:	80 81       	ld	r24, Z
     e20:	88 23       	and	r24, r24
     e22:	ec f7       	brge	.-6      	; 0xe1e <verzenden+0x34>
	//  op[2] = TWSR;

	TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     e24:	84 e9       	ldi	r24, 0x94	; 148
     e26:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
     e2a:	08 95       	ret

00000e2c <temperatuurTaak>:
	DDRA =0xFF;

	}
}

void temperatuurTaak(){
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	00 d0       	rcall	.+0      	; 0xe32 <temperatuurTaak+0x6>
     e32:	00 d0       	rcall	.+0      	; 0xe34 <temperatuurTaak+0x8>
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		int humidity=((125*waarde)/65536.0) -6;
		xQueueSend(humidityQueue, (void*) &humidity, 0);

		watchdogTemp = 1;
     e38:	01 e0       	ldi	r16, 0x01	; 1
     e3a:	10 e0       	ldi	r17, 0x00	; 0

	uint8_t data[2];
	uint32_t waarde =0;

	while(1){
		verzenden(0x40, 0xE3);
     e3c:	63 ee       	ldi	r22, 0xE3	; 227
     e3e:	80 e4       	ldi	r24, 0x40	; 64
     e40:	d4 df       	rcall	.-88     	; 0xdea <verzenden>
		ontvangen(0x40, data, 2);
     e42:	42 e0       	ldi	r20, 0x02	; 2
     e44:	be 01       	movw	r22, r28
     e46:	6f 5f       	subi	r22, 0xFF	; 255
     e48:	7f 4f       	sbci	r23, 0xFF	; 255
     e4a:	80 e4       	ldi	r24, 0x40	; 64
     e4c:	7b df       	rcall	.-266    	; 0xd44 <ontvangen>
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		int temperatuur=((175.72*waarde)/65536.0) -46.85;
     e4e:	69 81       	ldd	r22, Y+1	; 0x01
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	76 2f       	mov	r23, r22
     e54:	66 27       	eor	r22, r22
     e56:	8a 81       	ldd	r24, Y+2	; 0x02
     e58:	68 2b       	or	r22, r24
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <__floatunsisf>
     e62:	22 e5       	ldi	r18, 0x52	; 82
     e64:	38 eb       	ldi	r19, 0xB8	; 184
     e66:	4f e2       	ldi	r20, 0x2F	; 47
     e68:	53 e4       	ldi	r21, 0x43	; 67
     e6a:	0e 94 7e 13 	call	0x26fc	; 0x26fc <__mulsf3>
     e6e:	20 e0       	ldi	r18, 0x00	; 0
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	40 e8       	ldi	r20, 0x80	; 128
     e74:	57 e3       	ldi	r21, 0x37	; 55
     e76:	0e 94 7e 13 	call	0x26fc	; 0x26fc <__mulsf3>
     e7a:	26 e6       	ldi	r18, 0x66	; 102
     e7c:	36 e6       	ldi	r19, 0x66	; 102
     e7e:	4b e3       	ldi	r20, 0x3B	; 59
     e80:	52 e4       	ldi	r21, 0x42	; 66
     e82:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <__subsf3>
     e86:	0e 94 bf 12 	call	0x257e	; 0x257e <__fixsfsi>
     e8a:	7e 83       	std	Y+6, r23	; 0x06
     e8c:	6d 83       	std	Y+5, r22	; 0x05
		xQueueSend(temperatuurQueue, (void*) &temperatuur, 0);
     e8e:	20 e0       	ldi	r18, 0x00	; 0
     e90:	40 e0       	ldi	r20, 0x00	; 0
     e92:	50 e0       	ldi	r21, 0x00	; 0
     e94:	be 01       	movw	r22, r28
     e96:	6b 5f       	subi	r22, 0xFB	; 251
     e98:	7f 4f       	sbci	r23, 0xFF	; 255
     e9a:	80 91 2b 04 	lds	r24, 0x042B	; 0x80042b <temperatuurQueue>
     e9e:	90 91 2c 04 	lds	r25, 0x042C	; 0x80042c <temperatuurQueue+0x1>
     ea2:	0b d3       	rcall	.+1558   	; 0x14ba <xQueueGenericSend>

		verzenden(0x40, 0xE5);
     ea4:	65 ee       	ldi	r22, 0xE5	; 229
     ea6:	80 e4       	ldi	r24, 0x40	; 64
     ea8:	a0 df       	rcall	.-192    	; 0xdea <verzenden>
     eaa:	42 e0       	ldi	r20, 0x02	; 2
		ontvangen(0x40, data, 2);
     eac:	be 01       	movw	r22, r28
     eae:	6f 5f       	subi	r22, 0xFF	; 255
     eb0:	7f 4f       	sbci	r23, 0xFF	; 255
     eb2:	80 e4       	ldi	r24, 0x40	; 64
     eb4:	47 df       	rcall	.-370    	; 0xd44 <ontvangen>
     eb6:	29 81       	ldd	r18, Y+1	; 0x01
		
		waarde = ((uint16_t)data[0]<<8) | data[1];
		
		int humidity=((125*waarde)/65536.0) -6;
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	32 2f       	mov	r19, r18
     ebc:	22 27       	eor	r18, r18
     ebe:	8a 81       	ldd	r24, Y+2	; 0x02
     ec0:	28 2b       	or	r18, r24
     ec2:	ad e7       	ldi	r26, 0x7D	; 125
     ec4:	b0 e0       	ldi	r27, 0x00	; 0
     ec6:	0e 94 0b 14 	call	0x2816	; 0x2816 <__umulhisi3>
     eca:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <__floatunsisf>
     ece:	20 e0       	ldi	r18, 0x00	; 0
     ed0:	30 e0       	ldi	r19, 0x00	; 0
     ed2:	40 e8       	ldi	r20, 0x80	; 128
     ed4:	57 e3       	ldi	r21, 0x37	; 55
     ed6:	0e 94 7e 13 	call	0x26fc	; 0x26fc <__mulsf3>
     eda:	20 e0       	ldi	r18, 0x00	; 0
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	40 ec       	ldi	r20, 0xC0	; 192
     ee0:	50 e4       	ldi	r21, 0x40	; 64
     ee2:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <__subsf3>
     ee6:	0e 94 bf 12 	call	0x257e	; 0x257e <__fixsfsi>
     eea:	7c 83       	std	Y+4, r23	; 0x04
     eec:	6b 83       	std	Y+3, r22	; 0x03
     eee:	20 e0       	ldi	r18, 0x00	; 0
		xQueueSend(humidityQueue, (void*) &humidity, 0);
     ef0:	40 e0       	ldi	r20, 0x00	; 0
     ef2:	50 e0       	ldi	r21, 0x00	; 0
     ef4:	be 01       	movw	r22, r28
     ef6:	6d 5f       	subi	r22, 0xFD	; 253
     ef8:	7f 4f       	sbci	r23, 0xFF	; 255
     efa:	80 91 2d 04 	lds	r24, 0x042D	; 0x80042d <humidityQueue>
     efe:	90 91 2e 04 	lds	r25, 0x042E	; 0x80042e <humidityQueue+0x1>
     f02:	db d2       	rcall	.+1462   	; 0x14ba <xQueueGenericSend>
     f04:	10 93 23 04 	sts	0x0423, r17	; 0x800423 <watchdogTemp+0x1>

		watchdogTemp = 1;
     f08:	00 93 22 04 	sts	0x0422, r16	; 0x800422 <watchdogTemp>
     f0c:	97 cf       	rjmp	.-210    	; 0xe3c <temperatuurTaak+0x10>

00000f0e <__vector_17>:
     f0e:	1f 92       	push	r1
	// writeString(" ");writeInteger(op[1],16);
	// writeString(" ");writeInteger(op[2],16);
}

ISR(TIMER1_COMPA_vect)
{
     f10:	0f 92       	push	r0
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	0f 92       	push	r0
     f16:	11 24       	eor	r1, r1
     f18:	8f 93       	push	r24
     f1a:	9f 93       	push	r25
	PORTB ^= (1 << PB6);
     f1c:	95 b1       	in	r25, 0x05	; 5
     f1e:	80 e4       	ldi	r24, 0x40	; 64
     f20:	89 27       	eor	r24, r25
     f22:	85 b9       	out	0x05, r24	; 5
}
     f24:	9f 91       	pop	r25
     f26:	8f 91       	pop	r24
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	0f 90       	pop	r0
     f2e:	1f 90       	pop	r1
     f30:	18 95       	reti

00000f32 <pxPortInitialiseStack>:

#if defined (portUSE_WDTO)
        wdt_disable();											// disable Watchdog Timer

#elif defined( portUSE_TIMER0 )
        portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     f32:	31 e1       	ldi	r19, 0x11	; 17
     f34:	fc 01       	movw	r30, r24
     f36:	30 83       	st	Z, r19
     f38:	31 97       	sbiw	r30, 0x01	; 1
     f3a:	22 e2       	ldi	r18, 0x22	; 34
     f3c:	20 83       	st	Z, r18
     f3e:	31 97       	sbiw	r30, 0x01	; 1
     f40:	a3 e3       	ldi	r26, 0x33	; 51
     f42:	a0 83       	st	Z, r26
     f44:	31 97       	sbiw	r30, 0x01	; 1
     f46:	60 83       	st	Z, r22
     f48:	31 97       	sbiw	r30, 0x01	; 1
     f4a:	70 83       	st	Z, r23
     f4c:	31 97       	sbiw	r30, 0x01	; 1
     f4e:	10 82       	st	Z, r1
     f50:	31 97       	sbiw	r30, 0x01	; 1
     f52:	10 82       	st	Z, r1
     f54:	31 97       	sbiw	r30, 0x01	; 1
     f56:	60 e8       	ldi	r22, 0x80	; 128
     f58:	60 83       	st	Z, r22
     f5a:	31 97       	sbiw	r30, 0x01	; 1
     f5c:	10 82       	st	Z, r1
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	10 82       	st	Z, r1
     f62:	31 97       	sbiw	r30, 0x01	; 1
     f64:	10 82       	st	Z, r1
     f66:	31 97       	sbiw	r30, 0x01	; 1
     f68:	62 e0       	ldi	r22, 0x02	; 2
     f6a:	60 83       	st	Z, r22
     f6c:	31 97       	sbiw	r30, 0x01	; 1
     f6e:	63 e0       	ldi	r22, 0x03	; 3
     f70:	60 83       	st	Z, r22
     f72:	31 97       	sbiw	r30, 0x01	; 1
     f74:	64 e0       	ldi	r22, 0x04	; 4
     f76:	60 83       	st	Z, r22
     f78:	31 97       	sbiw	r30, 0x01	; 1
     f7a:	65 e0       	ldi	r22, 0x05	; 5
     f7c:	60 83       	st	Z, r22
     f7e:	31 97       	sbiw	r30, 0x01	; 1
     f80:	66 e0       	ldi	r22, 0x06	; 6
     f82:	60 83       	st	Z, r22
     f84:	31 97       	sbiw	r30, 0x01	; 1
     f86:	67 e0       	ldi	r22, 0x07	; 7
     f88:	60 83       	st	Z, r22
     f8a:	31 97       	sbiw	r30, 0x01	; 1
     f8c:	68 e0       	ldi	r22, 0x08	; 8
     f8e:	60 83       	st	Z, r22
     f90:	31 97       	sbiw	r30, 0x01	; 1
     f92:	69 e0       	ldi	r22, 0x09	; 9
     f94:	60 83       	st	Z, r22
     f96:	31 97       	sbiw	r30, 0x01	; 1
     f98:	60 e1       	ldi	r22, 0x10	; 16
     f9a:	60 83       	st	Z, r22
     f9c:	31 97       	sbiw	r30, 0x01	; 1
     f9e:	30 83       	st	Z, r19
     fa0:	31 97       	sbiw	r30, 0x01	; 1
     fa2:	32 e1       	ldi	r19, 0x12	; 18
     fa4:	30 83       	st	Z, r19
     fa6:	31 97       	sbiw	r30, 0x01	; 1
     fa8:	33 e1       	ldi	r19, 0x13	; 19
     faa:	30 83       	st	Z, r19
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	34 e1       	ldi	r19, 0x14	; 20
     fb0:	30 83       	st	Z, r19
     fb2:	31 97       	sbiw	r30, 0x01	; 1
     fb4:	35 e1       	ldi	r19, 0x15	; 21
     fb6:	30 83       	st	Z, r19
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	36 e1       	ldi	r19, 0x16	; 22
     fbc:	30 83       	st	Z, r19
     fbe:	31 97       	sbiw	r30, 0x01	; 1
     fc0:	37 e1       	ldi	r19, 0x17	; 23
     fc2:	30 83       	st	Z, r19
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	38 e1       	ldi	r19, 0x18	; 24
     fc8:	30 83       	st	Z, r19
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	39 e1       	ldi	r19, 0x19	; 25
     fce:	30 83       	st	Z, r19
     fd0:	31 97       	sbiw	r30, 0x01	; 1
     fd2:	30 e2       	ldi	r19, 0x20	; 32
     fd4:	30 83       	st	Z, r19
     fd6:	31 97       	sbiw	r30, 0x01	; 1
     fd8:	31 e2       	ldi	r19, 0x21	; 33
     fda:	30 83       	st	Z, r19
     fdc:	31 97       	sbiw	r30, 0x01	; 1
     fde:	20 83       	st	Z, r18
     fe0:	31 97       	sbiw	r30, 0x01	; 1
     fe2:	23 e2       	ldi	r18, 0x23	; 35
     fe4:	20 83       	st	Z, r18
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	40 83       	st	Z, r20
     fea:	31 97       	sbiw	r30, 0x01	; 1
     fec:	50 83       	st	Z, r21
     fee:	31 97       	sbiw	r30, 0x01	; 1
     ff0:	26 e2       	ldi	r18, 0x26	; 38
     ff2:	20 83       	st	Z, r18
     ff4:	31 97       	sbiw	r30, 0x01	; 1
     ff6:	27 e2       	ldi	r18, 0x27	; 39
     ff8:	20 83       	st	Z, r18
     ffa:	31 97       	sbiw	r30, 0x01	; 1
     ffc:	28 e2       	ldi	r18, 0x28	; 40
     ffe:	20 83       	st	Z, r18
    1000:	31 97       	sbiw	r30, 0x01	; 1
    1002:	29 e2       	ldi	r18, 0x29	; 41
    1004:	20 83       	st	Z, r18
    1006:	31 97       	sbiw	r30, 0x01	; 1
    1008:	20 e3       	ldi	r18, 0x30	; 48
    100a:	20 83       	st	Z, r18
    100c:	31 97       	sbiw	r30, 0x01	; 1
    100e:	21 e3       	ldi	r18, 0x31	; 49
    1010:	20 83       	st	Z, r18
    1012:	89 97       	sbiw	r24, 0x29	; 41
    1014:	08 95       	ret

00001016 <xPortStartScheduler>:
    1016:	88 ec       	ldi	r24, 0xC8	; 200
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	90 93 30 04 	sts	0x0430, r25	; 0x800430 <portTickRateHz+0x1>
    101e:	80 93 2f 04 	sts	0x042F, r24	; 0x80042f <portTickRateHz>
    1022:	90 93 32 04 	sts	0x0432, r25	; 0x800432 <ticksRemainingInSec+0x1>
    1026:	80 93 31 04 	sts	0x0431, r24	; 0x800431 <ticksRemainingInSec>
    102a:	8d e4       	ldi	r24, 0x4D	; 77
    102c:	87 bd       	out	0x27, r24	; 39
    102e:	82 e0       	ldi	r24, 0x02	; 2
    1030:	84 bd       	out	0x24, r24	; 36
    1032:	85 e0       	ldi	r24, 0x05	; 5
    1034:	85 bd       	out	0x25, r24	; 37
    1036:	ee e6       	ldi	r30, 0x6E	; 110
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	80 81       	ld	r24, Z
    103c:	82 60       	ori	r24, 0x02	; 2
    103e:	80 83       	st	Z, r24
    1040:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    1044:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1048:	cd 91       	ld	r28, X+
    104a:	cd bf       	out	0x3d, r28	; 61
    104c:	dd 91       	ld	r29, X+
    104e:	de bf       	out	0x3e, r29	; 62
    1050:	ff 91       	pop	r31
    1052:	ef 91       	pop	r30
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	bf 91       	pop	r27
    105a:	af 91       	pop	r26
    105c:	9f 91       	pop	r25
    105e:	8f 91       	pop	r24
    1060:	7f 91       	pop	r23
    1062:	6f 91       	pop	r22
    1064:	5f 91       	pop	r21
    1066:	4f 91       	pop	r20
    1068:	3f 91       	pop	r19
    106a:	2f 91       	pop	r18
    106c:	1f 91       	pop	r17
    106e:	0f 91       	pop	r16
    1070:	ff 90       	pop	r15
    1072:	ef 90       	pop	r14
    1074:	df 90       	pop	r13
    1076:	cf 90       	pop	r12
    1078:	bf 90       	pop	r11
    107a:	af 90       	pop	r10
    107c:	9f 90       	pop	r9
    107e:	8f 90       	pop	r8
    1080:	7f 90       	pop	r7
    1082:	6f 90       	pop	r6
    1084:	5f 90       	pop	r5
    1086:	4f 90       	pop	r4
    1088:	3f 90       	pop	r3
    108a:	2f 90       	pop	r2
    108c:	1f 90       	pop	r1
    108e:	0f 90       	pop	r0
    1090:	0c be       	out	0x3c, r0	; 60
    1092:	0f 90       	pop	r0
    1094:	0b be       	out	0x3b, r0	; 59
    1096:	0f 90       	pop	r0
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	0f 90       	pop	r0
    109c:	08 95       	ret
    109e:	81 e0       	ldi	r24, 0x01	; 1
    10a0:	08 95       	ret

000010a2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    10a2:	0f 92       	push	r0
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	f8 94       	cli
    10a8:	0f 92       	push	r0
    10aa:	0b b6       	in	r0, 0x3b	; 59
    10ac:	0f 92       	push	r0
    10ae:	0c b6       	in	r0, 0x3c	; 60
    10b0:	0f 92       	push	r0
    10b2:	1f 92       	push	r1
    10b4:	11 24       	eor	r1, r1
    10b6:	2f 92       	push	r2
    10b8:	3f 92       	push	r3
    10ba:	4f 92       	push	r4
    10bc:	5f 92       	push	r5
    10be:	6f 92       	push	r6
    10c0:	7f 92       	push	r7
    10c2:	8f 92       	push	r8
    10c4:	9f 92       	push	r9
    10c6:	af 92       	push	r10
    10c8:	bf 92       	push	r11
    10ca:	cf 92       	push	r12
    10cc:	df 92       	push	r13
    10ce:	ef 92       	push	r14
    10d0:	ff 92       	push	r15
    10d2:	0f 93       	push	r16
    10d4:	1f 93       	push	r17
    10d6:	2f 93       	push	r18
    10d8:	3f 93       	push	r19
    10da:	4f 93       	push	r20
    10dc:	5f 93       	push	r21
    10de:	6f 93       	push	r22
    10e0:	7f 93       	push	r23
    10e2:	8f 93       	push	r24
    10e4:	9f 93       	push	r25
    10e6:	af 93       	push	r26
    10e8:	bf 93       	push	r27
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	ef 93       	push	r30
    10f0:	ff 93       	push	r31
    10f2:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    10f6:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    10fa:	0d b6       	in	r0, 0x3d	; 61
    10fc:	0d 92       	st	X+, r0
    10fe:	0e b6       	in	r0, 0x3e	; 62
    1100:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1102:	0e 94 85 10 	call	0x210a	; 0x210a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1106:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    110a:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    110e:	cd 91       	ld	r28, X+
    1110:	cd bf       	out	0x3d, r28	; 61
    1112:	dd 91       	ld	r29, X+
    1114:	de bf       	out	0x3e, r29	; 62
    1116:	ff 91       	pop	r31
    1118:	ef 91       	pop	r30
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	bf 91       	pop	r27
    1120:	af 91       	pop	r26
    1122:	9f 91       	pop	r25
    1124:	8f 91       	pop	r24
    1126:	7f 91       	pop	r23
    1128:	6f 91       	pop	r22
    112a:	5f 91       	pop	r21
    112c:	4f 91       	pop	r20
    112e:	3f 91       	pop	r19
    1130:	2f 91       	pop	r18
    1132:	1f 91       	pop	r17
    1134:	0f 91       	pop	r16
    1136:	ff 90       	pop	r15
    1138:	ef 90       	pop	r14
    113a:	df 90       	pop	r13
    113c:	cf 90       	pop	r12
    113e:	bf 90       	pop	r11
    1140:	af 90       	pop	r10
    1142:	9f 90       	pop	r9
    1144:	8f 90       	pop	r8
    1146:	7f 90       	pop	r7
    1148:	6f 90       	pop	r6
    114a:	5f 90       	pop	r5
    114c:	4f 90       	pop	r4
    114e:	3f 90       	pop	r3
    1150:	2f 90       	pop	r2
    1152:	1f 90       	pop	r1
    1154:	0f 90       	pop	r0
    1156:	0c be       	out	0x3c, r0	; 60
    1158:	0f 90       	pop	r0
    115a:	0b be       	out	0x3b, r0	; 59
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1162:	08 95       	ret

00001164 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1164:	0f 92       	push	r0
    1166:	0f b6       	in	r0, 0x3f	; 63
    1168:	f8 94       	cli
    116a:	0f 92       	push	r0
    116c:	0b b6       	in	r0, 0x3b	; 59
    116e:	0f 92       	push	r0
    1170:	0c b6       	in	r0, 0x3c	; 60
    1172:	0f 92       	push	r0
    1174:	1f 92       	push	r1
    1176:	11 24       	eor	r1, r1
    1178:	2f 92       	push	r2
    117a:	3f 92       	push	r3
    117c:	4f 92       	push	r4
    117e:	5f 92       	push	r5
    1180:	6f 92       	push	r6
    1182:	7f 92       	push	r7
    1184:	8f 92       	push	r8
    1186:	9f 92       	push	r9
    1188:	af 92       	push	r10
    118a:	bf 92       	push	r11
    118c:	cf 92       	push	r12
    118e:	df 92       	push	r13
    1190:	ef 92       	push	r14
    1192:	ff 92       	push	r15
    1194:	0f 93       	push	r16
    1196:	1f 93       	push	r17
    1198:	2f 93       	push	r18
    119a:	3f 93       	push	r19
    119c:	4f 93       	push	r20
    119e:	5f 93       	push	r21
    11a0:	6f 93       	push	r22
    11a2:	7f 93       	push	r23
    11a4:	8f 93       	push	r24
    11a6:	9f 93       	push	r25
    11a8:	af 93       	push	r26
    11aa:	bf 93       	push	r27
    11ac:	cf 93       	push	r28
    11ae:	df 93       	push	r29
    11b0:	ef 93       	push	r30
    11b2:	ff 93       	push	r31
    11b4:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    11b8:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    11bc:	0d b6       	in	r0, 0x3d	; 61
    11be:	0d 92       	st	X+, r0
    11c0:	0e b6       	in	r0, 0x3e	; 62
    11c2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    11c4:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    11c6:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <ticksRemainingInSec>
    11ca:	90 91 32 04 	lds	r25, 0x0432	; 0x800432 <ticksRemainingInSec+0x1>
    11ce:	01 97       	sbiw	r24, 0x01	; 1
    11d0:	90 93 32 04 	sts	0x0432, r25	; 0x800432 <ticksRemainingInSec+0x1>
    11d4:	80 93 31 04 	sts	0x0431, r24	; 0x800431 <ticksRemainingInSec>
    11d8:	89 2b       	or	r24, r25
    11da:	49 f4       	brne	.+18     	; 0x11ee <vPortYieldFromTick+0x8a>
	{
		system_tick();
    11dc:	9f d8       	rcall	.-3778   	; 0x31c <system_tick>
		ticksRemainingInSec = portTickRateHz;
    11de:	80 91 2f 04 	lds	r24, 0x042F	; 0x80042f <portTickRateHz>
    11e2:	90 91 30 04 	lds	r25, 0x0430	; 0x800430 <portTickRateHz+0x1>
    11e6:	90 93 32 04 	sts	0x0432, r25	; 0x800432 <ticksRemainingInSec+0x1>
    11ea:	80 93 31 04 	sts	0x0431, r24	; 0x800431 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    11ee:	45 d6       	rcall	.+3210   	; 0x1e7a <xTaskIncrementTick>
	{
		vTaskSwitchContext();
    11f0:	81 11       	cpse	r24, r1
    11f2:	8b d7       	rcall	.+3862   	; 0x210a <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    11f4:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    11f8:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    11fc:	cd 91       	ld	r28, X+
    11fe:	cd bf       	out	0x3d, r28	; 61
    1200:	dd 91       	ld	r29, X+
    1202:	de bf       	out	0x3e, r29	; 62
    1204:	ff 91       	pop	r31
    1206:	ef 91       	pop	r30
    1208:	df 91       	pop	r29
    120a:	cf 91       	pop	r28
    120c:	bf 91       	pop	r27
    120e:	af 91       	pop	r26
    1210:	9f 91       	pop	r25
    1212:	8f 91       	pop	r24
    1214:	7f 91       	pop	r23
    1216:	6f 91       	pop	r22
    1218:	5f 91       	pop	r21
    121a:	4f 91       	pop	r20
    121c:	3f 91       	pop	r19
    121e:	2f 91       	pop	r18
    1220:	1f 91       	pop	r17
    1222:	0f 91       	pop	r16
    1224:	ff 90       	pop	r15
    1226:	ef 90       	pop	r14
    1228:	df 90       	pop	r13
    122a:	cf 90       	pop	r12
    122c:	bf 90       	pop	r11
    122e:	af 90       	pop	r10
    1230:	9f 90       	pop	r9
    1232:	8f 90       	pop	r8
    1234:	7f 90       	pop	r7
    1236:	6f 90       	pop	r6
    1238:	5f 90       	pop	r5
    123a:	4f 90       	pop	r4
    123c:	3f 90       	pop	r3
    123e:	2f 90       	pop	r2
    1240:	1f 90       	pop	r1
    1242:	0f 90       	pop	r0
    1244:	0c be       	out	0x3c, r0	; 60
    1246:	0f 90       	pop	r0
    1248:	0b be       	out	0x3b, r0	; 59
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1250:	08 95       	ret

00001252 <__vector_21>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1252:	88 df       	rcall	.-240    	; 0x1164 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1254:	18 95       	reti

00001256 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	0f 92       	push	r0
    125c:	fc 01       	movw	r30, r24
    125e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	91 11       	cpse	r25, r1
    1268:	80 e0       	ldi	r24, 0x00	; 0
    126a:	08 95       	ret

0000126c <prvCopyDataToQueue>:
    126c:	0f 93       	push	r16
    126e:	1f 93       	push	r17
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	ec 01       	movw	r28, r24
    1276:	04 2f       	mov	r16, r20
    1278:	1a 8d       	ldd	r17, Y+26	; 0x1a
    127a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    127c:	41 11       	cpse	r20, r1
    127e:	0c c0       	rjmp	.+24     	; 0x1298 <prvCopyDataToQueue+0x2c>
    1280:	88 81       	ld	r24, Y
    1282:	99 81       	ldd	r25, Y+1	; 0x01
    1284:	89 2b       	or	r24, r25
    1286:	09 f0       	breq	.+2      	; 0x128a <prvCopyDataToQueue+0x1e>
    1288:	42 c0       	rjmp	.+132    	; 0x130e <prvCopyDataToQueue+0xa2>
    128a:	8a 81       	ldd	r24, Y+2	; 0x02
    128c:	9b 81       	ldd	r25, Y+3	; 0x03
    128e:	0e 94 08 12 	call	0x2410	; 0x2410 <xTaskPriorityDisinherit>
    1292:	1b 82       	std	Y+3, r1	; 0x03
    1294:	1a 82       	std	Y+2, r1	; 0x02
    1296:	42 c0       	rjmp	.+132    	; 0x131c <prvCopyDataToQueue+0xb0>
    1298:	01 11       	cpse	r16, r1
    129a:	17 c0       	rjmp	.+46     	; 0x12ca <prvCopyDataToQueue+0x5e>
    129c:	50 e0       	ldi	r21, 0x00	; 0
    129e:	8c 81       	ldd	r24, Y+4	; 0x04
    12a0:	9d 81       	ldd	r25, Y+5	; 0x05
    12a2:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <memcpy>
    12a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12a8:	8c 81       	ldd	r24, Y+4	; 0x04
    12aa:	9d 81       	ldd	r25, Y+5	; 0x05
    12ac:	82 0f       	add	r24, r18
    12ae:	91 1d       	adc	r25, r1
    12b0:	9d 83       	std	Y+5, r25	; 0x05
    12b2:	8c 83       	std	Y+4, r24	; 0x04
    12b4:	2a 81       	ldd	r18, Y+2	; 0x02
    12b6:	3b 81       	ldd	r19, Y+3	; 0x03
    12b8:	82 17       	cp	r24, r18
    12ba:	93 07       	cpc	r25, r19
    12bc:	50 f1       	brcs	.+84     	; 0x1312 <prvCopyDataToQueue+0xa6>
    12be:	88 81       	ld	r24, Y
    12c0:	99 81       	ldd	r25, Y+1	; 0x01
    12c2:	9d 83       	std	Y+5, r25	; 0x05
    12c4:	8c 83       	std	Y+4, r24	; 0x04
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	29 c0       	rjmp	.+82     	; 0x131c <prvCopyDataToQueue+0xb0>
    12ca:	50 e0       	ldi	r21, 0x00	; 0
    12cc:	8e 81       	ldd	r24, Y+6	; 0x06
    12ce:	9f 81       	ldd	r25, Y+7	; 0x07
    12d0:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <memcpy>
    12d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	91 95       	neg	r25
    12da:	81 95       	neg	r24
    12dc:	91 09       	sbc	r25, r1
    12de:	2e 81       	ldd	r18, Y+6	; 0x06
    12e0:	3f 81       	ldd	r19, Y+7	; 0x07
    12e2:	28 0f       	add	r18, r24
    12e4:	39 1f       	adc	r19, r25
    12e6:	3f 83       	std	Y+7, r19	; 0x07
    12e8:	2e 83       	std	Y+6, r18	; 0x06
    12ea:	48 81       	ld	r20, Y
    12ec:	59 81       	ldd	r21, Y+1	; 0x01
    12ee:	24 17       	cp	r18, r20
    12f0:	35 07       	cpc	r19, r21
    12f2:	30 f4       	brcc	.+12     	; 0x1300 <prvCopyDataToQueue+0x94>
    12f4:	2a 81       	ldd	r18, Y+2	; 0x02
    12f6:	3b 81       	ldd	r19, Y+3	; 0x03
    12f8:	82 0f       	add	r24, r18
    12fa:	93 1f       	adc	r25, r19
    12fc:	9f 83       	std	Y+7, r25	; 0x07
    12fe:	8e 83       	std	Y+6, r24	; 0x06
    1300:	02 30       	cpi	r16, 0x02	; 2
    1302:	49 f4       	brne	.+18     	; 0x1316 <prvCopyDataToQueue+0xaa>
    1304:	11 23       	and	r17, r17
    1306:	49 f0       	breq	.+18     	; 0x131a <prvCopyDataToQueue+0xae>
    1308:	11 50       	subi	r17, 0x01	; 1
    130a:	80 e0       	ldi	r24, 0x00	; 0
    130c:	07 c0       	rjmp	.+14     	; 0x131c <prvCopyDataToQueue+0xb0>
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	05 c0       	rjmp	.+10     	; 0x131c <prvCopyDataToQueue+0xb0>
    1312:	80 e0       	ldi	r24, 0x00	; 0
    1314:	03 c0       	rjmp	.+6      	; 0x131c <prvCopyDataToQueue+0xb0>
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	01 c0       	rjmp	.+2      	; 0x131c <prvCopyDataToQueue+0xb0>
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	1f 5f       	subi	r17, 0xFF	; 255
    131e:	1a 8f       	std	Y+26, r17	; 0x1a
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	08 95       	ret

0000132a <prvCopyDataFromQueue>:
    132a:	fc 01       	movw	r30, r24
    132c:	44 8d       	ldd	r20, Z+28	; 0x1c
    132e:	44 23       	and	r20, r20
    1330:	a9 f0       	breq	.+42     	; 0x135c <prvCopyDataFromQueue+0x32>
    1332:	50 e0       	ldi	r21, 0x00	; 0
    1334:	26 81       	ldd	r18, Z+6	; 0x06
    1336:	37 81       	ldd	r19, Z+7	; 0x07
    1338:	24 0f       	add	r18, r20
    133a:	35 1f       	adc	r19, r21
    133c:	37 83       	std	Z+7, r19	; 0x07
    133e:	26 83       	std	Z+6, r18	; 0x06
    1340:	82 81       	ldd	r24, Z+2	; 0x02
    1342:	93 81       	ldd	r25, Z+3	; 0x03
    1344:	28 17       	cp	r18, r24
    1346:	39 07       	cpc	r19, r25
    1348:	20 f0       	brcs	.+8      	; 0x1352 <prvCopyDataFromQueue+0x28>
    134a:	80 81       	ld	r24, Z
    134c:	91 81       	ldd	r25, Z+1	; 0x01
    134e:	97 83       	std	Z+7, r25	; 0x07
    1350:	86 83       	std	Z+6, r24	; 0x06
    1352:	cb 01       	movw	r24, r22
    1354:	66 81       	ldd	r22, Z+6	; 0x06
    1356:	77 81       	ldd	r23, Z+7	; 0x07
    1358:	0c 94 45 15 	jmp	0x2a8a	; 0x2a8a <memcpy>
    135c:	08 95       	ret

0000135e <prvUnlockQueue>:
    135e:	ef 92       	push	r14
    1360:	ff 92       	push	r15
    1362:	0f 93       	push	r16
    1364:	1f 93       	push	r17
    1366:	cf 93       	push	r28
    1368:	8c 01       	movw	r16, r24
    136a:	0f b6       	in	r0, 0x3f	; 63
    136c:	f8 94       	cli
    136e:	0f 92       	push	r0
    1370:	fc 01       	movw	r30, r24
    1372:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1374:	1c 16       	cp	r1, r28
    1376:	9c f4       	brge	.+38     	; 0x139e <prvUnlockQueue+0x40>
    1378:	81 89       	ldd	r24, Z+17	; 0x11
    137a:	81 11       	cpse	r24, r1
    137c:	06 c0       	rjmp	.+12     	; 0x138a <prvUnlockQueue+0x2c>
    137e:	0f c0       	rjmp	.+30     	; 0x139e <prvUnlockQueue+0x40>
    1380:	f8 01       	movw	r30, r16
    1382:	81 89       	ldd	r24, Z+17	; 0x11
    1384:	81 11       	cpse	r24, r1
    1386:	05 c0       	rjmp	.+10     	; 0x1392 <prvUnlockQueue+0x34>
    1388:	0a c0       	rjmp	.+20     	; 0x139e <prvUnlockQueue+0x40>
    138a:	78 01       	movw	r14, r16
    138c:	f1 e1       	ldi	r31, 0x11	; 17
    138e:	ef 0e       	add	r14, r31
    1390:	f1 1c       	adc	r15, r1
    1392:	c7 01       	movw	r24, r14
    1394:	4c d7       	rcall	.+3736   	; 0x222e <xTaskRemoveFromEventList>
    1396:	81 11       	cpse	r24, r1
    1398:	d5 d7       	rcall	.+4010   	; 0x2344 <vTaskMissedYield>
    139a:	c1 50       	subi	r28, 0x01	; 1
    139c:	89 f7       	brne	.-30     	; 0x1380 <prvUnlockQueue+0x22>
    139e:	8f ef       	ldi	r24, 0xFF	; 255
    13a0:	f8 01       	movw	r30, r16
    13a2:	86 8f       	std	Z+30, r24	; 0x1e
    13a4:	0f 90       	pop	r0
    13a6:	0f be       	out	0x3f, r0	; 63
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	0f 92       	push	r0
    13ae:	c5 8d       	ldd	r28, Z+29	; 0x1d
    13b0:	1c 16       	cp	r1, r28
    13b2:	9c f4       	brge	.+38     	; 0x13da <prvUnlockQueue+0x7c>
    13b4:	80 85       	ldd	r24, Z+8	; 0x08
    13b6:	81 11       	cpse	r24, r1
    13b8:	06 c0       	rjmp	.+12     	; 0x13c6 <prvUnlockQueue+0x68>
    13ba:	0f c0       	rjmp	.+30     	; 0x13da <prvUnlockQueue+0x7c>
    13bc:	f8 01       	movw	r30, r16
    13be:	80 85       	ldd	r24, Z+8	; 0x08
    13c0:	81 11       	cpse	r24, r1
    13c2:	05 c0       	rjmp	.+10     	; 0x13ce <prvUnlockQueue+0x70>
    13c4:	0a c0       	rjmp	.+20     	; 0x13da <prvUnlockQueue+0x7c>
    13c6:	78 01       	movw	r14, r16
    13c8:	f8 e0       	ldi	r31, 0x08	; 8
    13ca:	ef 0e       	add	r14, r31
    13cc:	f1 1c       	adc	r15, r1
    13ce:	c7 01       	movw	r24, r14
    13d0:	2e d7       	rcall	.+3676   	; 0x222e <xTaskRemoveFromEventList>
    13d2:	81 11       	cpse	r24, r1
    13d4:	b7 d7       	rcall	.+3950   	; 0x2344 <vTaskMissedYield>
    13d6:	c1 50       	subi	r28, 0x01	; 1
    13d8:	89 f7       	brne	.-30     	; 0x13bc <prvUnlockQueue+0x5e>
    13da:	8f ef       	ldi	r24, 0xFF	; 255
    13dc:	f8 01       	movw	r30, r16
    13de:	85 8f       	std	Z+29, r24	; 0x1d
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	cf 91       	pop	r28
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	08 95       	ret

000013f0 <xQueueGenericReset>:
    13f0:	cf 93       	push	r28
    13f2:	df 93       	push	r29
    13f4:	ec 01       	movw	r28, r24
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	f8 94       	cli
    13fa:	0f 92       	push	r0
    13fc:	48 81       	ld	r20, Y
    13fe:	59 81       	ldd	r21, Y+1	; 0x01
    1400:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1406:	72 9f       	mul	r23, r18
    1408:	c0 01       	movw	r24, r0
    140a:	73 9f       	mul	r23, r19
    140c:	90 0d       	add	r25, r0
    140e:	11 24       	eor	r1, r1
    1410:	fa 01       	movw	r30, r20
    1412:	e8 0f       	add	r30, r24
    1414:	f9 1f       	adc	r31, r25
    1416:	fb 83       	std	Y+3, r31	; 0x03
    1418:	ea 83       	std	Y+2, r30	; 0x02
    141a:	1a 8e       	std	Y+26, r1	; 0x1a
    141c:	5d 83       	std	Y+5, r21	; 0x05
    141e:	4c 83       	std	Y+4, r20	; 0x04
    1420:	82 1b       	sub	r24, r18
    1422:	93 0b       	sbc	r25, r19
    1424:	84 0f       	add	r24, r20
    1426:	95 1f       	adc	r25, r21
    1428:	9f 83       	std	Y+7, r25	; 0x07
    142a:	8e 83       	std	Y+6, r24	; 0x06
    142c:	8f ef       	ldi	r24, 0xFF	; 255
    142e:	8d 8f       	std	Y+29, r24	; 0x1d
    1430:	8e 8f       	std	Y+30, r24	; 0x1e
    1432:	61 11       	cpse	r22, r1
    1434:	0a c0       	rjmp	.+20     	; 0x144a <xQueueGenericReset+0x5a>
    1436:	88 85       	ldd	r24, Y+8	; 0x08
    1438:	88 23       	and	r24, r24
    143a:	69 f0       	breq	.+26     	; 0x1456 <xQueueGenericReset+0x66>
    143c:	ce 01       	movw	r24, r28
    143e:	08 96       	adiw	r24, 0x08	; 8
    1440:	f6 d6       	rcall	.+3564   	; 0x222e <xTaskRemoveFromEventList>
    1442:	88 23       	and	r24, r24
    1444:	41 f0       	breq	.+16     	; 0x1456 <xQueueGenericReset+0x66>
    1446:	2d de       	rcall	.-934    	; 0x10a2 <vPortYield>
    1448:	06 c0       	rjmp	.+12     	; 0x1456 <xQueueGenericReset+0x66>
    144a:	ce 01       	movw	r24, r28
    144c:	08 96       	adiw	r24, 0x08	; 8
    144e:	c3 d8       	rcall	.-3706   	; 0x5d6 <vListInitialise>
    1450:	ce 01       	movw	r24, r28
    1452:	41 96       	adiw	r24, 0x11	; 17
    1454:	c0 d8       	rcall	.-3712   	; 0x5d6 <vListInitialise>
    1456:	0f 90       	pop	r0
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	df 91       	pop	r29
    145e:	cf 91       	pop	r28
    1460:	08 95       	ret

00001462 <xQueueGenericCreate>:
    1462:	0f 93       	push	r16
    1464:	1f 93       	push	r17
    1466:	cf 93       	push	r28
    1468:	df 93       	push	r29
    146a:	08 2f       	mov	r16, r24
    146c:	16 2f       	mov	r17, r22
    146e:	66 23       	and	r22, r22
    1470:	b9 f0       	breq	.+46     	; 0x14a0 <xQueueGenericCreate+0x3e>
    1472:	86 9f       	mul	r24, r22
    1474:	c0 01       	movw	r24, r0
    1476:	11 24       	eor	r1, r1
    1478:	4f 96       	adiw	r24, 0x1f	; 31
    147a:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    147e:	ec 01       	movw	r28, r24
    1480:	00 97       	sbiw	r24, 0x00	; 0
    1482:	39 f4       	brne	.+14     	; 0x1492 <xQueueGenericCreate+0x30>
    1484:	14 c0       	rjmp	.+40     	; 0x14ae <xQueueGenericCreate+0x4c>
    1486:	0b 8f       	std	Y+27, r16	; 0x1b
    1488:	1c 8f       	std	Y+28, r17	; 0x1c
    148a:	61 e0       	ldi	r22, 0x01	; 1
    148c:	ce 01       	movw	r24, r28
    148e:	b0 df       	rcall	.-160    	; 0x13f0 <xQueueGenericReset>
    1490:	0e c0       	rjmp	.+28     	; 0x14ae <xQueueGenericCreate+0x4c>
    1492:	4f 96       	adiw	r24, 0x1f	; 31
    1494:	99 83       	std	Y+1, r25	; 0x01
    1496:	88 83       	st	Y, r24
    1498:	f6 cf       	rjmp	.-20     	; 0x1486 <xQueueGenericCreate+0x24>
    149a:	d9 83       	std	Y+1, r29	; 0x01
    149c:	c8 83       	st	Y, r28
    149e:	f3 cf       	rjmp	.-26     	; 0x1486 <xQueueGenericCreate+0x24>
    14a0:	8f e1       	ldi	r24, 0x1F	; 31
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    14a8:	ec 01       	movw	r28, r24
    14aa:	89 2b       	or	r24, r25
    14ac:	b1 f7       	brne	.-20     	; 0x149a <xQueueGenericCreate+0x38>
    14ae:	ce 01       	movw	r24, r28
    14b0:	df 91       	pop	r29
    14b2:	cf 91       	pop	r28
    14b4:	1f 91       	pop	r17
    14b6:	0f 91       	pop	r16
    14b8:	08 95       	ret

000014ba <xQueueGenericSend>:
    14ba:	9f 92       	push	r9
    14bc:	af 92       	push	r10
    14be:	bf 92       	push	r11
    14c0:	cf 92       	push	r12
    14c2:	df 92       	push	r13
    14c4:	ef 92       	push	r14
    14c6:	ff 92       	push	r15
    14c8:	0f 93       	push	r16
    14ca:	1f 93       	push	r17
    14cc:	cf 93       	push	r28
    14ce:	df 93       	push	r29
    14d0:	00 d0       	rcall	.+0      	; 0x14d2 <xQueueGenericSend+0x18>
    14d2:	1f 92       	push	r1
    14d4:	1f 92       	push	r1
    14d6:	cd b7       	in	r28, 0x3d	; 61
    14d8:	de b7       	in	r29, 0x3e	; 62
    14da:	8c 01       	movw	r16, r24
    14dc:	6b 01       	movw	r12, r22
    14de:	5d 83       	std	Y+5, r21	; 0x05
    14e0:	4c 83       	std	Y+4, r20	; 0x04
    14e2:	a2 2e       	mov	r10, r18
    14e4:	b1 2c       	mov	r11, r1
    14e6:	99 24       	eor	r9, r9
    14e8:	93 94       	inc	r9
    14ea:	7c 01       	movw	r14, r24
    14ec:	88 e0       	ldi	r24, 0x08	; 8
    14ee:	e8 0e       	add	r14, r24
    14f0:	f1 1c       	adc	r15, r1
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	0f 92       	push	r0
    14f8:	f8 01       	movw	r30, r16
    14fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    14fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    14fe:	98 17       	cp	r25, r24
    1500:	18 f0       	brcs	.+6      	; 0x1508 <xQueueGenericSend+0x4e>
    1502:	f2 e0       	ldi	r31, 0x02	; 2
    1504:	af 12       	cpse	r10, r31
    1506:	15 c0       	rjmp	.+42     	; 0x1532 <xQueueGenericSend+0x78>
    1508:	4a 2d       	mov	r20, r10
    150a:	b6 01       	movw	r22, r12
    150c:	c8 01       	movw	r24, r16
    150e:	ae de       	rcall	.-676    	; 0x126c <prvCopyDataToQueue>
    1510:	f8 01       	movw	r30, r16
    1512:	91 89       	ldd	r25, Z+17	; 0x11
    1514:	99 23       	and	r25, r25
    1516:	39 f0       	breq	.+14     	; 0x1526 <xQueueGenericSend+0x6c>
    1518:	c8 01       	movw	r24, r16
    151a:	41 96       	adiw	r24, 0x11	; 17
    151c:	88 d6       	rcall	.+3344   	; 0x222e <xTaskRemoveFromEventList>
    151e:	88 23       	and	r24, r24
    1520:	21 f0       	breq	.+8      	; 0x152a <xQueueGenericSend+0x70>
    1522:	bf dd       	rcall	.-1154   	; 0x10a2 <vPortYield>
    1524:	02 c0       	rjmp	.+4      	; 0x152a <xQueueGenericSend+0x70>
    1526:	81 11       	cpse	r24, r1
    1528:	bc dd       	rcall	.-1160   	; 0x10a2 <vPortYield>
    152a:	0f 90       	pop	r0
    152c:	0f be       	out	0x3f, r0	; 63
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	45 c0       	rjmp	.+138    	; 0x15bc <xQueueGenericSend+0x102>
    1532:	8c 81       	ldd	r24, Y+4	; 0x04
    1534:	9d 81       	ldd	r25, Y+5	; 0x05
    1536:	89 2b       	or	r24, r25
    1538:	21 f4       	brne	.+8      	; 0x1542 <xQueueGenericSend+0x88>
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	3d c0       	rjmp	.+122    	; 0x15bc <xQueueGenericSend+0x102>
    1542:	b1 10       	cpse	r11, r1
    1544:	04 c0       	rjmp	.+8      	; 0x154e <xQueueGenericSend+0x94>
    1546:	ce 01       	movw	r24, r28
    1548:	01 96       	adiw	r24, 0x01	; 1
    154a:	b9 d6       	rcall	.+3442   	; 0x22be <vTaskSetTimeOutState>
    154c:	b9 2c       	mov	r11, r9
    154e:	0f 90       	pop	r0
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	8d d4       	rcall	.+2330   	; 0x1e6e <vTaskSuspendAll>
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	0f 92       	push	r0
    155a:	f8 01       	movw	r30, r16
    155c:	85 8d       	ldd	r24, Z+29	; 0x1d
    155e:	8f 3f       	cpi	r24, 0xFF	; 255
    1560:	09 f4       	brne	.+2      	; 0x1564 <xQueueGenericSend+0xaa>
    1562:	15 8e       	std	Z+29, r1	; 0x1d
    1564:	f8 01       	movw	r30, r16
    1566:	86 8d       	ldd	r24, Z+30	; 0x1e
    1568:	8f 3f       	cpi	r24, 0xFF	; 255
    156a:	09 f4       	brne	.+2      	; 0x156e <xQueueGenericSend+0xb4>
    156c:	16 8e       	std	Z+30, r1	; 0x1e
    156e:	0f 90       	pop	r0
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	be 01       	movw	r22, r28
    1574:	6c 5f       	subi	r22, 0xFC	; 252
    1576:	7f 4f       	sbci	r23, 0xFF	; 255
    1578:	ce 01       	movw	r24, r28
    157a:	01 96       	adiw	r24, 0x01	; 1
    157c:	ab d6       	rcall	.+3414   	; 0x22d4 <xTaskCheckForTimeOut>
    157e:	81 11       	cpse	r24, r1
    1580:	19 c0       	rjmp	.+50     	; 0x15b4 <xQueueGenericSend+0xfa>
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	0f 92       	push	r0
    1588:	f8 01       	movw	r30, r16
    158a:	92 8d       	ldd	r25, Z+26	; 0x1a
    158c:	83 8d       	ldd	r24, Z+27	; 0x1b
    158e:	0f 90       	pop	r0
    1590:	0f be       	out	0x3f, r0	; 63
    1592:	98 13       	cpse	r25, r24
    1594:	0b c0       	rjmp	.+22     	; 0x15ac <xQueueGenericSend+0xf2>
    1596:	6c 81       	ldd	r22, Y+4	; 0x04
    1598:	7d 81       	ldd	r23, Y+5	; 0x05
    159a:	c7 01       	movw	r24, r14
    159c:	37 d6       	rcall	.+3182   	; 0x220c <vTaskPlaceOnEventList>
    159e:	c8 01       	movw	r24, r16
    15a0:	de de       	rcall	.-580    	; 0x135e <prvUnlockQueue>
    15a2:	25 d5       	rcall	.+2634   	; 0x1fee <xTaskResumeAll>
    15a4:	81 11       	cpse	r24, r1
    15a6:	a5 cf       	rjmp	.-182    	; 0x14f2 <xQueueGenericSend+0x38>
    15a8:	7c dd       	rcall	.-1288   	; 0x10a2 <vPortYield>
    15aa:	a3 cf       	rjmp	.-186    	; 0x14f2 <xQueueGenericSend+0x38>
    15ac:	c8 01       	movw	r24, r16
    15ae:	d7 de       	rcall	.-594    	; 0x135e <prvUnlockQueue>
    15b0:	1e d5       	rcall	.+2620   	; 0x1fee <xTaskResumeAll>
    15b2:	9f cf       	rjmp	.-194    	; 0x14f2 <xQueueGenericSend+0x38>
    15b4:	c8 01       	movw	r24, r16
    15b6:	d3 de       	rcall	.-602    	; 0x135e <prvUnlockQueue>
    15b8:	1a d5       	rcall	.+2612   	; 0x1fee <xTaskResumeAll>
    15ba:	80 e0       	ldi	r24, 0x00	; 0
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	0f 90       	pop	r0
    15c4:	0f 90       	pop	r0
    15c6:	df 91       	pop	r29
    15c8:	cf 91       	pop	r28
    15ca:	1f 91       	pop	r17
    15cc:	0f 91       	pop	r16
    15ce:	ff 90       	pop	r15
    15d0:	ef 90       	pop	r14
    15d2:	df 90       	pop	r13
    15d4:	cf 90       	pop	r12
    15d6:	bf 90       	pop	r11
    15d8:	af 90       	pop	r10
    15da:	9f 90       	pop	r9
    15dc:	08 95       	ret

000015de <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    15de:	8f 92       	push	r8
    15e0:	9f 92       	push	r9
    15e2:	af 92       	push	r10
    15e4:	bf 92       	push	r11
    15e6:	cf 92       	push	r12
    15e8:	df 92       	push	r13
    15ea:	ef 92       	push	r14
    15ec:	ff 92       	push	r15
    15ee:	0f 93       	push	r16
    15f0:	1f 93       	push	r17
    15f2:	cf 93       	push	r28
    15f4:	df 93       	push	r29
    15f6:	00 d0       	rcall	.+0      	; 0x15f8 <xQueueGenericReceive+0x1a>
    15f8:	1f 92       	push	r1
    15fa:	1f 92       	push	r1
    15fc:	cd b7       	in	r28, 0x3d	; 61
    15fe:	de b7       	in	r29, 0x3e	; 62
    1600:	8c 01       	movw	r16, r24
    1602:	5b 01       	movw	r10, r22
    1604:	5d 83       	std	Y+5, r21	; 0x05
    1606:	4c 83       	std	Y+4, r20	; 0x04
    1608:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    160a:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    160c:	99 24       	eor	r9, r9
    160e:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1610:	6c 01       	movw	r12, r24
    1612:	81 e1       	ldi	r24, 0x11	; 17
    1614:	c8 0e       	add	r12, r24
    1616:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    161e:	f8 01       	movw	r30, r16
    1620:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1622:	ff 20       	and	r15, r15
    1624:	61 f1       	breq	.+88     	; 0x167e <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1626:	c6 80       	ldd	r12, Z+6	; 0x06
    1628:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    162a:	b5 01       	movw	r22, r10
    162c:	c8 01       	movw	r24, r16
    162e:	7d de       	rcall	.-774    	; 0x132a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1630:	81 10       	cpse	r8, r1
    1632:	16 c0       	rjmp	.+44     	; 0x1660 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1634:	fa 94       	dec	r15
    1636:	f8 01       	movw	r30, r16
    1638:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    163a:	80 81       	ld	r24, Z
    163c:	91 81       	ldd	r25, Z+1	; 0x01
    163e:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1640:	21 f4       	brne	.+8      	; 0x164a <xQueueGenericReceive+0x6c>
    1642:	26 d7       	rcall	.+3660   	; 0x2490 <pvTaskIncrementMutexHeldCount>
    1644:	f8 01       	movw	r30, r16
    1646:	93 83       	std	Z+3, r25	; 0x03
    1648:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    164a:	f8 01       	movw	r30, r16
    164c:	80 85       	ldd	r24, Z+8	; 0x08
    164e:	88 23       	and	r24, r24
    1650:	91 f0       	breq	.+36     	; 0x1676 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1652:	c8 01       	movw	r24, r16
    1654:	08 96       	adiw	r24, 0x08	; 8
    1656:	eb d5       	rcall	.+3030   	; 0x222e <xTaskRemoveFromEventList>
    1658:	88 23       	and	r24, r24
						{
							queueYIELD_IF_USING_PREEMPTION();
    165a:	69 f0       	breq	.+26     	; 0x1676 <xQueueGenericReceive+0x98>
    165c:	22 dd       	rcall	.-1468   	; 0x10a2 <vPortYield>
    165e:	0b c0       	rjmp	.+22     	; 0x1676 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1660:	f8 01       	movw	r30, r16
    1662:	d7 82       	std	Z+7, r13	; 0x07
    1664:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1666:	81 89       	ldd	r24, Z+17	; 0x11
    1668:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    166a:	29 f0       	breq	.+10     	; 0x1676 <xQueueGenericReceive+0x98>
    166c:	c8 01       	movw	r24, r16
    166e:	41 96       	adiw	r24, 0x11	; 17
    1670:	de d5       	rcall	.+3004   	; 0x222e <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1672:	81 11       	cpse	r24, r1
    1674:	16 dd       	rcall	.-1492   	; 0x10a2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1676:	0f 90       	pop	r0
    1678:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	51 c0       	rjmp	.+162    	; 0x1720 <xQueueGenericReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    167e:	8c 81       	ldd	r24, Y+4	; 0x04
    1680:	9d 81       	ldd	r25, Y+5	; 0x05
    1682:	89 2b       	or	r24, r25
    1684:	21 f4       	brne	.+8      	; 0x168e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1686:	0f 90       	pop	r0
    1688:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    168a:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
    168c:	49 c0       	rjmp	.+146    	; 0x1720 <xQueueGenericReceive+0x142>
    168e:	e1 10       	cpse	r14, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1690:	04 c0       	rjmp	.+8      	; 0x169a <xQueueGenericReceive+0xbc>
    1692:	ce 01       	movw	r24, r28
    1694:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
    1696:	13 d6       	rcall	.+3110   	; 0x22be <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1698:	e9 2c       	mov	r14, r9
    169a:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    169c:	0f be       	out	0x3f, r0	; 63
    169e:	e7 d3       	rcall	.+1998   	; 0x1e6e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	0f 92       	push	r0
    16a6:	f8 01       	movw	r30, r16
    16a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    16aa:	8f 3f       	cpi	r24, 0xFF	; 255
    16ac:	09 f4       	brne	.+2      	; 0x16b0 <xQueueGenericReceive+0xd2>
    16ae:	15 8e       	std	Z+29, r1	; 0x1d
    16b0:	f8 01       	movw	r30, r16
    16b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16b4:	8f 3f       	cpi	r24, 0xFF	; 255
    16b6:	09 f4       	brne	.+2      	; 0x16ba <xQueueGenericReceive+0xdc>
    16b8:	16 8e       	std	Z+30, r1	; 0x1e
    16ba:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	be 01       	movw	r22, r28
    16c0:	6c 5f       	subi	r22, 0xFC	; 252
    16c2:	7f 4f       	sbci	r23, 0xFF	; 255
    16c4:	ce 01       	movw	r24, r28
    16c6:	01 96       	adiw	r24, 0x01	; 1
    16c8:	05 d6       	rcall	.+3082   	; 0x22d4 <xTaskCheckForTimeOut>
    16ca:	81 11       	cpse	r24, r1
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16cc:	20 c0       	rjmp	.+64     	; 0x170e <xQueueGenericReceive+0x130>
    16ce:	c8 01       	movw	r24, r16
    16d0:	c2 dd       	rcall	.-1148   	; 0x1256 <prvIsQueueEmpty>
    16d2:	88 23       	and	r24, r24
    16d4:	c1 f0       	breq	.+48     	; 0x1706 <xQueueGenericReceive+0x128>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16d6:	f8 01       	movw	r30, r16
    16d8:	80 81       	ld	r24, Z
    16da:	91 81       	ldd	r25, Z+1	; 0x01
    16dc:	89 2b       	or	r24, r25
					{
						taskENTER_CRITICAL();
    16de:	41 f4       	brne	.+16     	; 0x16f0 <xQueueGenericReceive+0x112>
    16e0:	0f b6       	in	r0, 0x3f	; 63
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    16e2:	f8 94       	cli
    16e4:	0f 92       	push	r0
						}
						taskEXIT_CRITICAL();
    16e6:	82 81       	ldd	r24, Z+2	; 0x02
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16e8:	93 81       	ldd	r25, Z+3	; 0x03
    16ea:	30 d6       	rcall	.+3168   	; 0x234c <vTaskPriorityInherit>
    16ec:	0f 90       	pop	r0
				prvUnlockQueue( pxQueue );
    16ee:	0f be       	out	0x3f, r0	; 63
				if( xTaskResumeAll() == pdFALSE )
    16f0:	6c 81       	ldd	r22, Y+4	; 0x04
    16f2:	7d 81       	ldd	r23, Y+5	; 0x05
    16f4:	c6 01       	movw	r24, r12
				{
					portYIELD_WITHIN_API();
    16f6:	8a d5       	rcall	.+2836   	; 0x220c <vTaskPlaceOnEventList>
    16f8:	c8 01       	movw	r24, r16
    16fa:	31 de       	rcall	.-926    	; 0x135e <prvUnlockQueue>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16fc:	78 d4       	rcall	.+2288   	; 0x1fee <xTaskResumeAll>
    16fe:	81 11       	cpse	r24, r1
    1700:	8b cf       	rjmp	.-234    	; 0x1618 <xQueueGenericReceive+0x3a>
				( void ) xTaskResumeAll();
    1702:	cf dc       	rcall	.-1634   	; 0x10a2 <vPortYield>
    1704:	89 cf       	rjmp	.-238    	; 0x1618 <xQueueGenericReceive+0x3a>
    1706:	c8 01       	movw	r24, r16
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1708:	2a de       	rcall	.-940    	; 0x135e <prvUnlockQueue>
    170a:	71 d4       	rcall	.+2274   	; 0x1fee <xTaskResumeAll>
    170c:	85 cf       	rjmp	.-246    	; 0x1618 <xQueueGenericReceive+0x3a>
			( void ) xTaskResumeAll();
    170e:	c8 01       	movw	r24, r16
    1710:	26 de       	rcall	.-948    	; 0x135e <prvUnlockQueue>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1712:	6d d4       	rcall	.+2266   	; 0x1fee <xTaskResumeAll>
    1714:	c8 01       	movw	r24, r16
    1716:	9f dd       	rcall	.-1218   	; 0x1256 <prvIsQueueEmpty>
    1718:	88 23       	and	r24, r24
    171a:	09 f4       	brne	.+2      	; 0x171e <xQueueGenericReceive+0x140>
    171c:	7d cf       	rjmp	.-262    	; 0x1618 <xQueueGenericReceive+0x3a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    171e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1720:	0f 90       	pop	r0
    1722:	0f 90       	pop	r0
    1724:	0f 90       	pop	r0
    1726:	0f 90       	pop	r0
    1728:	0f 90       	pop	r0
    172a:	df 91       	pop	r29
    172c:	cf 91       	pop	r28
    172e:	1f 91       	pop	r17
    1730:	0f 91       	pop	r16
    1732:	ff 90       	pop	r15
    1734:	ef 90       	pop	r14
    1736:	df 90       	pop	r13
    1738:	cf 90       	pop	r12
    173a:	bf 90       	pop	r11
    173c:	af 90       	pop	r10
    173e:	9f 90       	pop	r9
    1740:	8f 90       	pop	r8
    1742:	08 95       	ret

00001744 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    1744:	1f 92       	push	r1
    1746:	0f 92       	push	r0
    1748:	0f b6       	in	r0, 0x3f	; 63
    174a:	0f 92       	push	r0
    174c:	11 24       	eor	r1, r1
    174e:	0b b6       	in	r0, 0x3b	; 59
    1750:	0f 92       	push	r0
    1752:	2f 93       	push	r18
    1754:	8f 93       	push	r24
    1756:	9f 93       	push	r25
    1758:	af 93       	push	r26
    175a:	bf 93       	push	r27
    175c:	ef 93       	push	r30
    175e:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
	{
	    count = buffer->count;
    1766:	80 91 40 04 	lds	r24, 0x0440	; 0x800440 <xSerialPort+0xd>
    176a:	90 91 41 04 	lds	r25, 0x0441	; 0x800441 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    1772:	89 2b       	or	r24, r25
    1774:	31 f4       	brne	.+12     	; 0x1782 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    1776:	e1 ec       	ldi	r30, 0xC1	; 193
    1778:	f0 e0       	ldi	r31, 0x00	; 0
    177a:	80 81       	ld	r24, Z
    177c:	8f 7d       	andi	r24, 0xDF	; 223
    177e:	80 83       	st	Z, r24
    1780:	1c c0       	rjmp	.+56     	; 0x17ba <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1782:	e0 e4       	ldi	r30, 0x40	; 64
    1784:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1786:	a4 81       	ldd	r26, Z+4	; 0x04
    1788:	b5 81       	ldd	r27, Z+5	; 0x05
    178a:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    178c:	b5 83       	std	Z+5, r27	; 0x05
    178e:	a4 83       	std	Z+4, r26	; 0x04
    1790:	80 85       	ldd	r24, Z+8	; 0x08
    1792:	91 85       	ldd	r25, Z+9	; 0x09
    1794:	a8 17       	cp	r26, r24
    1796:	b9 07       	cpc	r27, r25
    1798:	21 f4       	brne	.+8      	; 0x17a2 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    179a:	86 81       	ldd	r24, Z+6	; 0x06
    179c:	97 81       	ldd	r25, Z+7	; 0x07
    179e:	95 83       	std	Z+5, r25	; 0x05
    17a0:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    17a2:	0f b6       	in	r0, 0x3f	; 63
    17a4:	f8 94       	cli
    17a6:	0f 92       	push	r0
	{
	    buffer->count--;
    17a8:	80 81       	ld	r24, Z
    17aa:	91 81       	ldd	r25, Z+1	; 0x01
    17ac:	01 97       	sbiw	r24, 0x01	; 1
    17ae:	91 83       	std	Z+1, r25	; 0x01
    17b0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    17b2:	0f 90       	pop	r0
    17b4:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    17b6:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    17ba:	ff 91       	pop	r31
    17bc:	ef 91       	pop	r30
    17be:	bf 91       	pop	r27
    17c0:	af 91       	pop	r26
    17c2:	9f 91       	pop	r25
    17c4:	8f 91       	pop	r24
    17c6:	2f 91       	pop	r18
    17c8:	0f 90       	pop	r0
    17ca:	0b be       	out	0x3b, r0	; 59
    17cc:	0f 90       	pop	r0
    17ce:	0f be       	out	0x3f, r0	; 63
    17d0:	0f 90       	pop	r0
    17d2:	1f 90       	pop	r1
    17d4:	18 95       	reti

000017d6 <__vector_37>:
//}
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    17d6:	1f 92       	push	r1
    17d8:	0f 92       	push	r0
    17da:	0f b6       	in	r0, 0x3f	; 63
    17dc:	0f 92       	push	r0
    17de:	11 24       	eor	r1, r1
    17e0:	0b b6       	in	r0, 0x3b	; 59
    17e2:	0f 92       	push	r0
    17e4:	2f 93       	push	r18
    17e6:	8f 93       	push	r24
    17e8:	9f 93       	push	r25
    17ea:	af 93       	push	r26
    17ec:	bf 93       	push	r27
    17ee:	ef 93       	push	r30
    17f0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
	{
	    count = buffer->count;
    17f8:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <xSerial1Port+0xd>
    17fc:	90 91 a7 04 	lds	r25, 0x04A7	; 0x8004a7 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    1804:	89 2b       	or	r24, r25
    1806:	31 f4       	brne	.+12     	; 0x1814 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    1808:	e9 ec       	ldi	r30, 0xC9	; 201
    180a:	f0 e0       	ldi	r31, 0x00	; 0
    180c:	80 81       	ld	r24, Z
    180e:	8f 7d       	andi	r24, 0xDF	; 223
    1810:	80 83       	st	Z, r24
    1812:	1c c0       	rjmp	.+56     	; 0x184c <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1814:	e6 ea       	ldi	r30, 0xA6	; 166
    1816:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1818:	a4 81       	ldd	r26, Z+4	; 0x04
    181a:	b5 81       	ldd	r27, Z+5	; 0x05
    181c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    181e:	b5 83       	std	Z+5, r27	; 0x05
    1820:	a4 83       	std	Z+4, r26	; 0x04
    1822:	80 85       	ldd	r24, Z+8	; 0x08
    1824:	91 85       	ldd	r25, Z+9	; 0x09
    1826:	a8 17       	cp	r26, r24
    1828:	b9 07       	cpc	r27, r25
    182a:	21 f4       	brne	.+8      	; 0x1834 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    182c:	86 81       	ldd	r24, Z+6	; 0x06
    182e:	97 81       	ldd	r25, Z+7	; 0x07
    1830:	95 83       	std	Z+5, r25	; 0x05
    1832:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
	{
	    buffer->count--;
    183a:	80 81       	ld	r24, Z
    183c:	91 81       	ldd	r25, Z+1	; 0x01
    183e:	01 97       	sbiw	r24, 0x01	; 1
    1840:	91 83       	std	Z+1, r25	; 0x01
    1842:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    1848:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    184c:	ff 91       	pop	r31
    184e:	ef 91       	pop	r30
    1850:	bf 91       	pop	r27
    1852:	af 91       	pop	r26
    1854:	9f 91       	pop	r25
    1856:	8f 91       	pop	r24
    1858:	2f 91       	pop	r18
    185a:	0f 90       	pop	r0
    185c:	0b be       	out	0x3b, r0	; 59
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63
    1862:	0f 90       	pop	r0
    1864:	1f 90       	pop	r1
    1866:	18 95       	reti

00001868 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    1868:	1f 92       	push	r1
    186a:	0f 92       	push	r0
    186c:	0f b6       	in	r0, 0x3f	; 63
    186e:	0f 92       	push	r0
    1870:	11 24       	eor	r1, r1
    1872:	0b b6       	in	r0, 0x3b	; 59
    1874:	0f 92       	push	r0
    1876:	2f 93       	push	r18
    1878:	3f 93       	push	r19
    187a:	4f 93       	push	r20
    187c:	8f 93       	push	r24
    187e:	9f 93       	push	r25
    1880:	af 93       	push	r26
    1882:	bf 93       	push	r27
    1884:	ef 93       	push	r30
    1886:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    1888:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    188c:	8c 71       	andi	r24, 0x1C	; 28
    188e:	71 f0       	breq	.+28     	; 0x18ac <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    1890:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1894:	88 23       	and	r24, r24
    1896:	0c f0       	brlt	.+2      	; 0x189a <__vector_51+0x32>
    1898:	36 c0       	rjmp	.+108    	; 0x1906 <__vector_51+0x9e>
    189a:	a6 ed       	ldi	r26, 0xD6	; 214
    189c:	b0 e0       	ldi	r27, 0x00	; 0
    189e:	e0 ed       	ldi	r30, 0xD0	; 208
    18a0:	f0 e0       	ldi	r31, 0x00	; 0
    18a2:	8c 91       	ld	r24, X
    18a4:	80 81       	ld	r24, Z
    18a6:	88 23       	and	r24, r24
    18a8:	e4 f3       	brlt	.-8      	; 0x18a2 <__vector_51+0x3a>
    18aa:	2d c0       	rjmp	.+90     	; 0x1906 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    18ac:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
	{
	    count = buffer->count;
    18b6:	e5 e5       	ldi	r30, 0x55	; 85
    18b8:	f4 e0       	ldi	r31, 0x04	; 4
    18ba:	21 81       	ldd	r18, Z+1	; 0x01
    18bc:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    18be:	0f 90       	pop	r0
    18c0:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    18c2:	83 85       	ldd	r24, Z+11	; 0x0b
    18c4:	94 85       	ldd	r25, Z+12	; 0x0c
    18c6:	28 17       	cp	r18, r24
    18c8:	39 07       	cpc	r19, r25
    18ca:	e9 f0       	breq	.+58     	; 0x1906 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    18cc:	e6 e5       	ldi	r30, 0x56	; 86
    18ce:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    18d0:	a2 81       	ldd	r26, Z+2	; 0x02
    18d2:	b3 81       	ldd	r27, Z+3	; 0x03
    18d4:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    18d6:	82 81       	ldd	r24, Z+2	; 0x02
    18d8:	93 81       	ldd	r25, Z+3	; 0x03
    18da:	01 96       	adiw	r24, 0x01	; 1
    18dc:	93 83       	std	Z+3, r25	; 0x03
    18de:	82 83       	std	Z+2, r24	; 0x02
    18e0:	20 85       	ldd	r18, Z+8	; 0x08
    18e2:	31 85       	ldd	r19, Z+9	; 0x09
    18e4:	82 17       	cp	r24, r18
    18e6:	93 07       	cpc	r25, r19
    18e8:	21 f4       	brne	.+8      	; 0x18f2 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    18ea:	86 81       	ldd	r24, Z+6	; 0x06
    18ec:	97 81       	ldd	r25, Z+7	; 0x07
    18ee:	93 83       	std	Z+3, r25	; 0x03
    18f0:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	0f 92       	push	r0
	{
	    buffer->count++;
    18f8:	80 81       	ld	r24, Z
    18fa:	91 81       	ldd	r25, Z+1	; 0x01
    18fc:	01 96       	adiw	r24, 0x01	; 1
    18fe:	91 83       	std	Z+1, r25	; 0x01
    1900:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1902:	0f 90       	pop	r0
    1904:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    1906:	ff 91       	pop	r31
    1908:	ef 91       	pop	r30
    190a:	bf 91       	pop	r27
    190c:	af 91       	pop	r26
    190e:	9f 91       	pop	r25
    1910:	8f 91       	pop	r24
    1912:	4f 91       	pop	r20
    1914:	3f 91       	pop	r19
    1916:	2f 91       	pop	r18
    1918:	0f 90       	pop	r0
    191a:	0b be       	out	0x3b, r0	; 59
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	0f 90       	pop	r0
    1922:	1f 90       	pop	r1
    1924:	18 95       	reti

00001926 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    1926:	1f 92       	push	r1
    1928:	0f 92       	push	r0
    192a:	0f b6       	in	r0, 0x3f	; 63
    192c:	0f 92       	push	r0
    192e:	11 24       	eor	r1, r1
    1930:	0b b6       	in	r0, 0x3b	; 59
    1932:	0f 92       	push	r0
    1934:	2f 93       	push	r18
    1936:	8f 93       	push	r24
    1938:	9f 93       	push	r25
    193a:	af 93       	push	r26
    193c:	bf 93       	push	r27
    193e:	ef 93       	push	r30
    1940:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	0f 92       	push	r0
	{
	    count = buffer->count;
    1948:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <xSerial2Port+0xd>
    194c:	90 91 63 04 	lds	r25, 0x0463	; 0x800463 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    1954:	89 2b       	or	r24, r25
    1956:	31 f4       	brne	.+12     	; 0x1964 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    1958:	e1 ed       	ldi	r30, 0xD1	; 209
    195a:	f0 e0       	ldi	r31, 0x00	; 0
    195c:	80 81       	ld	r24, Z
    195e:	8f 7d       	andi	r24, 0xDF	; 223
    1960:	80 83       	st	Z, r24
    1962:	1c c0       	rjmp	.+56     	; 0x199c <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1964:	e2 e6       	ldi	r30, 0x62	; 98
    1966:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1968:	a4 81       	ldd	r26, Z+4	; 0x04
    196a:	b5 81       	ldd	r27, Z+5	; 0x05
    196c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    196e:	b5 83       	std	Z+5, r27	; 0x05
    1970:	a4 83       	std	Z+4, r26	; 0x04
    1972:	80 85       	ldd	r24, Z+8	; 0x08
    1974:	91 85       	ldd	r25, Z+9	; 0x09
    1976:	a8 17       	cp	r26, r24
    1978:	b9 07       	cpc	r27, r25
    197a:	21 f4       	brne	.+8      	; 0x1984 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    197c:	86 81       	ldd	r24, Z+6	; 0x06
    197e:	97 81       	ldd	r25, Z+7	; 0x07
    1980:	95 83       	std	Z+5, r25	; 0x05
    1982:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
	{
	    buffer->count--;
    198a:	80 81       	ld	r24, Z
    198c:	91 81       	ldd	r25, Z+1	; 0x01
    198e:	01 97       	sbiw	r24, 0x01	; 1
    1990:	91 83       	std	Z+1, r25	; 0x01
    1992:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1994:	0f 90       	pop	r0
    1996:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    1998:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    199c:	ff 91       	pop	r31
    199e:	ef 91       	pop	r30
    19a0:	bf 91       	pop	r27
    19a2:	af 91       	pop	r26
    19a4:	9f 91       	pop	r25
    19a6:	8f 91       	pop	r24
    19a8:	2f 91       	pop	r18
    19aa:	0f 90       	pop	r0
    19ac:	0b be       	out	0x3b, r0	; 59
    19ae:	0f 90       	pop	r0
    19b0:	0f be       	out	0x3f, r0	; 63
    19b2:	0f 90       	pop	r0
    19b4:	1f 90       	pop	r1
    19b6:	18 95       	reti

000019b8 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    19b8:	1f 92       	push	r1
    19ba:	0f 92       	push	r0
    19bc:	0f b6       	in	r0, 0x3f	; 63
    19be:	0f 92       	push	r0
    19c0:	11 24       	eor	r1, r1
    19c2:	0b b6       	in	r0, 0x3b	; 59
    19c4:	0f 92       	push	r0
    19c6:	2f 93       	push	r18
    19c8:	3f 93       	push	r19
    19ca:	4f 93       	push	r20
    19cc:	8f 93       	push	r24
    19ce:	9f 93       	push	r25
    19d0:	af 93       	push	r26
    19d2:	bf 93       	push	r27
    19d4:	ef 93       	push	r30
    19d6:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    19d8:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    19dc:	8c 71       	andi	r24, 0x1C	; 28
    19de:	71 f0       	breq	.+28     	; 0x19fc <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    19e0:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    19e4:	88 23       	and	r24, r24
    19e6:	0c f0       	brlt	.+2      	; 0x19ea <__vector_54+0x32>
    19e8:	36 c0       	rjmp	.+108    	; 0x1a56 <__vector_54+0x9e>
    19ea:	a6 e3       	ldi	r26, 0x36	; 54
    19ec:	b1 e0       	ldi	r27, 0x01	; 1
    19ee:	e0 e3       	ldi	r30, 0x30	; 48
    19f0:	f1 e0       	ldi	r31, 0x01	; 1
    19f2:	8c 91       	ld	r24, X
    19f4:	80 81       	ld	r24, Z
    19f6:	88 23       	and	r24, r24
    19f8:	e4 f3       	brlt	.-8      	; 0x19f2 <__vector_54+0x3a>
    19fa:	2d c0       	rjmp	.+90     	; 0x1a56 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    19fc:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a06:	e7 e7       	ldi	r30, 0x77	; 119
    1a08:	f4 e0       	ldi	r31, 0x04	; 4
    1a0a:	21 81       	ldd	r18, Z+1	; 0x01
    1a0c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    1a0e:	0f 90       	pop	r0
    1a10:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    1a12:	83 85       	ldd	r24, Z+11	; 0x0b
    1a14:	94 85       	ldd	r25, Z+12	; 0x0c
    1a16:	28 17       	cp	r18, r24
    1a18:	39 07       	cpc	r19, r25
    1a1a:	e9 f0       	breq	.+58     	; 0x1a56 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1a1c:	e8 e7       	ldi	r30, 0x78	; 120
    1a1e:	f4 e0       	ldi	r31, 0x04	; 4

	*buffer->in = data;
    1a20:	a2 81       	ldd	r26, Z+2	; 0x02
    1a22:	b3 81       	ldd	r27, Z+3	; 0x03
    1a24:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    1a26:	82 81       	ldd	r24, Z+2	; 0x02
    1a28:	93 81       	ldd	r25, Z+3	; 0x03
    1a2a:	01 96       	adiw	r24, 0x01	; 1
    1a2c:	93 83       	std	Z+3, r25	; 0x03
    1a2e:	82 83       	std	Z+2, r24	; 0x02
    1a30:	20 85       	ldd	r18, Z+8	; 0x08
    1a32:	31 85       	ldd	r19, Z+9	; 0x09
    1a34:	82 17       	cp	r24, r18
    1a36:	93 07       	cpc	r25, r19
    1a38:	21 f4       	brne	.+8      	; 0x1a42 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    1a3a:	86 81       	ldd	r24, Z+6	; 0x06
    1a3c:	97 81       	ldd	r25, Z+7	; 0x07
    1a3e:	93 83       	std	Z+3, r25	; 0x03
    1a40:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    1a42:	0f b6       	in	r0, 0x3f	; 63
    1a44:	f8 94       	cli
    1a46:	0f 92       	push	r0
	{
	    buffer->count++;
    1a48:	80 81       	ld	r24, Z
    1a4a:	91 81       	ldd	r25, Z+1	; 0x01
    1a4c:	01 96       	adiw	r24, 0x01	; 1
    1a4e:	91 83       	std	Z+1, r25	; 0x01
    1a50:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    1a56:	ff 91       	pop	r31
    1a58:	ef 91       	pop	r30
    1a5a:	bf 91       	pop	r27
    1a5c:	af 91       	pop	r26
    1a5e:	9f 91       	pop	r25
    1a60:	8f 91       	pop	r24
    1a62:	4f 91       	pop	r20
    1a64:	3f 91       	pop	r19
    1a66:	2f 91       	pop	r18
    1a68:	0f 90       	pop	r0
    1a6a:	0b be       	out	0x3b, r0	; 59
    1a6c:	0f 90       	pop	r0
    1a6e:	0f be       	out	0x3f, r0	; 63
    1a70:	0f 90       	pop	r0
    1a72:	1f 90       	pop	r1
    1a74:	18 95       	reti

00001a76 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    1a76:	1f 92       	push	r1
    1a78:	0f 92       	push	r0
    1a7a:	0f b6       	in	r0, 0x3f	; 63
    1a7c:	0f 92       	push	r0
    1a7e:	11 24       	eor	r1, r1
    1a80:	0b b6       	in	r0, 0x3b	; 59
    1a82:	0f 92       	push	r0
    1a84:	2f 93       	push	r18
    1a86:	8f 93       	push	r24
    1a88:	9f 93       	push	r25
    1a8a:	af 93       	push	r26
    1a8c:	bf 93       	push	r27
    1a8e:	ef 93       	push	r30
    1a90:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	0f 92       	push	r0
	{
	    count = buffer->count;
    1a98:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <xSerial3Port+0xd>
    1a9c:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    1aa0:	0f 90       	pop	r0
    1aa2:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    1aa4:	89 2b       	or	r24, r25
    1aa6:	31 f4       	brne	.+12     	; 0x1ab4 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    1aa8:	e1 e3       	ldi	r30, 0x31	; 49
    1aaa:	f1 e0       	ldi	r31, 0x01	; 1
    1aac:	80 81       	ld	r24, Z
    1aae:	8f 7d       	andi	r24, 0xDF	; 223
    1ab0:	80 83       	st	Z, r24
    1ab2:	1c c0       	rjmp	.+56     	; 0x1aec <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    1ab4:	e4 e8       	ldi	r30, 0x84	; 132
    1ab6:	f4 e0       	ldi	r31, 0x04	; 4

	uint8_t data = *buffer->out;
    1ab8:	a4 81       	ldd	r26, Z+4	; 0x04
    1aba:	b5 81       	ldd	r27, Z+5	; 0x05
    1abc:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    1abe:	b5 83       	std	Z+5, r27	; 0x05
    1ac0:	a4 83       	std	Z+4, r26	; 0x04
    1ac2:	80 85       	ldd	r24, Z+8	; 0x08
    1ac4:	91 85       	ldd	r25, Z+9	; 0x09
    1ac6:	a8 17       	cp	r26, r24
    1ac8:	b9 07       	cpc	r27, r25
    1aca:	21 f4       	brne	.+8      	; 0x1ad4 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    1acc:	86 81       	ldd	r24, Z+6	; 0x06
    1ace:	97 81       	ldd	r25, Z+7	; 0x07
    1ad0:	95 83       	std	Z+5, r25	; 0x05
    1ad2:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    1ad4:	0f b6       	in	r0, 0x3f	; 63
    1ad6:	f8 94       	cli
    1ad8:	0f 92       	push	r0
	{
	    buffer->count--;
    1ada:	80 81       	ld	r24, Z
    1adc:	91 81       	ldd	r25, Z+1	; 0x01
    1ade:	01 97       	sbiw	r24, 0x01	; 1
    1ae0:	91 83       	std	Z+1, r25	; 0x01
    1ae2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    1ae4:	0f 90       	pop	r0
    1ae6:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    1ae8:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    1aec:	ff 91       	pop	r31
    1aee:	ef 91       	pop	r30
    1af0:	bf 91       	pop	r27
    1af2:	af 91       	pop	r26
    1af4:	9f 91       	pop	r25
    1af6:	8f 91       	pop	r24
    1af8:	2f 91       	pop	r18
    1afa:	0f 90       	pop	r0
    1afc:	0b be       	out	0x3b, r0	; 59
    1afe:	0f 90       	pop	r0
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	0f 90       	pop	r0
    1b04:	1f 90       	pop	r1
    1b06:	18 95       	reti

00001b08 <prvResetNextTaskUnblockTime>:
    1b08:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1b0c:	f0 91 e1 02 	lds	r31, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1b10:	80 81       	ld	r24, Z
    1b12:	81 11       	cpse	r24, r1
    1b14:	07 c0       	rjmp	.+14     	; 0x1b24 <prvResetNextTaskUnblockTime+0x1c>
    1b16:	8f ef       	ldi	r24, 0xFF	; 255
    1b18:	9f ef       	ldi	r25, 0xFF	; 255
    1b1a:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1b1e:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xNextTaskUnblockTime>
    1b22:	08 95       	ret
    1b24:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1b28:	f0 91 e1 02 	lds	r31, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1b2c:	05 80       	ldd	r0, Z+5	; 0x05
    1b2e:	f6 81       	ldd	r31, Z+6	; 0x06
    1b30:	e0 2d       	mov	r30, r0
    1b32:	06 80       	ldd	r0, Z+6	; 0x06
    1b34:	f7 81       	ldd	r31, Z+7	; 0x07
    1b36:	e0 2d       	mov	r30, r0
    1b38:	82 81       	ldd	r24, Z+2	; 0x02
    1b3a:	93 81       	ldd	r25, Z+3	; 0x03
    1b3c:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1b40:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xNextTaskUnblockTime>
    1b44:	08 95       	ret

00001b46 <prvAddCurrentTaskToDelayedList>:
    1b46:	ff 92       	push	r15
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	ec 01       	movw	r28, r24
    1b52:	f6 2e       	mov	r15, r22
    1b54:	00 91 bf 02 	lds	r16, 0x02BF	; 0x8002bf <xTickCount>
    1b58:	10 91 c0 02 	lds	r17, 0x02C0	; 0x8002c0 <xTickCount+0x1>
    1b5c:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <pxCurrentTCB>
    1b60:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1b64:	02 96       	adiw	r24, 0x02	; 2
    1b66:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1b6a:	cf 3f       	cpi	r28, 0xFF	; 255
    1b6c:	8f ef       	ldi	r24, 0xFF	; 255
    1b6e:	d8 07       	cpc	r29, r24
    1b70:	69 f4       	brne	.+26     	; 0x1b8c <prvAddCurrentTaskToDelayedList+0x46>
    1b72:	ff 20       	and	r15, r15
    1b74:	59 f0       	breq	.+22     	; 0x1b8c <prvAddCurrentTaskToDelayedList+0x46>
    1b76:	60 91 18 03 	lds	r22, 0x0318	; 0x800318 <pxCurrentTCB>
    1b7a:	70 91 19 03 	lds	r23, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1b7e:	6e 5f       	subi	r22, 0xFE	; 254
    1b80:	7f 4f       	sbci	r23, 0xFF	; 255
    1b82:	82 ec       	ldi	r24, 0xC2	; 194
    1b84:	92 e0       	ldi	r25, 0x02	; 2
    1b86:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1b8a:	2f c0       	rjmp	.+94     	; 0x1bea <prvAddCurrentTaskToDelayedList+0xa4>
    1b8c:	c0 0f       	add	r28, r16
    1b8e:	d1 1f       	adc	r29, r17
    1b90:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    1b94:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1b98:	d3 83       	std	Z+3, r29	; 0x03
    1b9a:	c2 83       	std	Z+2, r28	; 0x02
    1b9c:	c0 17       	cp	r28, r16
    1b9e:	d1 07       	cpc	r29, r17
    1ba0:	68 f4       	brcc	.+26     	; 0x1bbc <prvAddCurrentTaskToDelayedList+0x76>
    1ba2:	60 91 18 03 	lds	r22, 0x0318	; 0x800318 <pxCurrentTCB>
    1ba6:	70 91 19 03 	lds	r23, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1baa:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <pxOverflowDelayedTaskList>
    1bae:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <pxOverflowDelayedTaskList+0x1>
    1bb2:	6e 5f       	subi	r22, 0xFE	; 254
    1bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb6:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1bba:	17 c0       	rjmp	.+46     	; 0x1bea <prvAddCurrentTaskToDelayedList+0xa4>
    1bbc:	60 91 18 03 	lds	r22, 0x0318	; 0x800318 <pxCurrentTCB>
    1bc0:	70 91 19 03 	lds	r23, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1bc4:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1bc8:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1bcc:	6e 5f       	subi	r22, 0xFE	; 254
    1bce:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd0:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    1bd4:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <xNextTaskUnblockTime>
    1bd8:	90 91 b8 02 	lds	r25, 0x02B8	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1bdc:	c8 17       	cp	r28, r24
    1bde:	d9 07       	cpc	r29, r25
    1be0:	20 f4       	brcc	.+8      	; 0x1bea <prvAddCurrentTaskToDelayedList+0xa4>
    1be2:	d0 93 b8 02 	sts	0x02B8, r29	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1be6:	c0 93 b7 02 	sts	0x02B7, r28	; 0x8002b7 <xNextTaskUnblockTime>
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	1f 91       	pop	r17
    1bf0:	0f 91       	pop	r16
    1bf2:	ff 90       	pop	r15
    1bf4:	08 95       	ret

00001bf6 <xTaskCreate>:
    1bf6:	4f 92       	push	r4
    1bf8:	5f 92       	push	r5
    1bfa:	6f 92       	push	r6
    1bfc:	7f 92       	push	r7
    1bfe:	8f 92       	push	r8
    1c00:	9f 92       	push	r9
    1c02:	af 92       	push	r10
    1c04:	bf 92       	push	r11
    1c06:	cf 92       	push	r12
    1c08:	df 92       	push	r13
    1c0a:	ef 92       	push	r14
    1c0c:	ff 92       	push	r15
    1c0e:	0f 93       	push	r16
    1c10:	cf 93       	push	r28
    1c12:	df 93       	push	r29
    1c14:	4c 01       	movw	r8, r24
    1c16:	6b 01       	movw	r12, r22
    1c18:	5a 01       	movw	r10, r20
    1c1a:	29 01       	movw	r4, r18
    1c1c:	ca 01       	movw	r24, r20
    1c1e:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1c22:	3c 01       	movw	r6, r24
    1c24:	89 2b       	or	r24, r25
    1c26:	09 f4       	brne	.+2      	; 0x1c2a <xTaskCreate+0x34>
    1c28:	e9 c0       	rjmp	.+466    	; 0x1dfc <xTaskCreate+0x206>
    1c2a:	88 e2       	ldi	r24, 0x28	; 40
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	0e 94 aa 01 	call	0x354	; 0x354 <pvPortMalloc>
    1c32:	ec 01       	movw	r28, r24
    1c34:	89 2b       	or	r24, r25
    1c36:	a9 f0       	breq	.+42     	; 0x1c62 <xTaskCreate+0x6c>
    1c38:	78 8e       	std	Y+24, r7	; 0x18
    1c3a:	6f 8a       	std	Y+23, r6	; 0x17
    1c3c:	a5 01       	movw	r20, r10
    1c3e:	65 ea       	ldi	r22, 0xA5	; 165
    1c40:	70 e0       	ldi	r23, 0x00	; 0
    1c42:	c3 01       	movw	r24, r6
    1c44:	2b d7       	rcall	.+3670   	; 0x2a9c <memset>
    1c46:	81 e0       	ldi	r24, 0x01	; 1
    1c48:	a8 1a       	sub	r10, r24
    1c4a:	b1 08       	sbc	r11, r1
    1c4c:	8f 89       	ldd	r24, Y+23	; 0x17
    1c4e:	98 8d       	ldd	r25, Y+24	; 0x18
    1c50:	a8 0e       	add	r10, r24
    1c52:	b9 1e       	adc	r11, r25
    1c54:	d6 01       	movw	r26, r12
    1c56:	8c 91       	ld	r24, X
    1c58:	89 8f       	std	Y+25, r24	; 0x19
    1c5a:	8c 91       	ld	r24, X
    1c5c:	81 11       	cpse	r24, r1
    1c5e:	05 c0       	rjmp	.+10     	; 0x1c6a <xTaskCreate+0x74>
    1c60:	18 c0       	rjmp	.+48     	; 0x1c92 <xTaskCreate+0x9c>
    1c62:	c3 01       	movw	r24, r6
    1c64:	0e 94 bc 01 	call	0x378	; 0x378 <vPortFree>
    1c68:	c9 c0       	rjmp	.+402    	; 0x1dfc <xTaskCreate+0x206>
    1c6a:	ae 01       	movw	r20, r28
    1c6c:	46 5e       	subi	r20, 0xE6	; 230
    1c6e:	5f 4f       	sbci	r21, 0xFF	; 255
    1c70:	f6 01       	movw	r30, r12
    1c72:	31 96       	adiw	r30, 0x01	; 1
    1c74:	b8 e0       	ldi	r27, 0x08	; 8
    1c76:	cb 0e       	add	r12, r27
    1c78:	d1 1c       	adc	r13, r1
    1c7a:	cf 01       	movw	r24, r30
    1c7c:	21 91       	ld	r18, Z+
    1c7e:	da 01       	movw	r26, r20
    1c80:	2d 93       	st	X+, r18
    1c82:	ad 01       	movw	r20, r26
    1c84:	dc 01       	movw	r26, r24
    1c86:	8c 91       	ld	r24, X
    1c88:	88 23       	and	r24, r24
    1c8a:	19 f0       	breq	.+6      	; 0x1c92 <xTaskCreate+0x9c>
    1c8c:	ec 15       	cp	r30, r12
    1c8e:	fd 05       	cpc	r31, r13
    1c90:	a1 f7       	brne	.-24     	; 0x1c7a <xTaskCreate+0x84>
    1c92:	18 a2       	std	Y+32, r1	; 0x20
    1c94:	04 30       	cpi	r16, 0x04	; 4
    1c96:	08 f0       	brcs	.+2      	; 0x1c9a <xTaskCreate+0xa4>
    1c98:	03 e0       	ldi	r16, 0x03	; 3
    1c9a:	0e 8b       	std	Y+22, r16	; 0x16
    1c9c:	09 a3       	std	Y+33, r16	; 0x21
    1c9e:	1a a2       	std	Y+34, r1	; 0x22
    1ca0:	6e 01       	movw	r12, r28
    1ca2:	b2 e0       	ldi	r27, 0x02	; 2
    1ca4:	cb 0e       	add	r12, r27
    1ca6:	d1 1c       	adc	r13, r1
    1ca8:	c6 01       	movw	r24, r12
    1caa:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1cae:	ce 01       	movw	r24, r28
    1cb0:	0c 96       	adiw	r24, 0x0c	; 12
    1cb2:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <vListInitialiseItem>
    1cb6:	d9 87       	std	Y+9, r29	; 0x09
    1cb8:	c8 87       	std	Y+8, r28	; 0x08
    1cba:	84 e0       	ldi	r24, 0x04	; 4
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	80 1b       	sub	r24, r16
    1cc0:	91 09       	sbc	r25, r1
    1cc2:	9d 87       	std	Y+13, r25	; 0x0d
    1cc4:	8c 87       	std	Y+12, r24	; 0x0c
    1cc6:	db 8b       	std	Y+19, r29	; 0x13
    1cc8:	ca 8b       	std	Y+18, r28	; 0x12
    1cca:	1b a2       	std	Y+35, r1	; 0x23
    1ccc:	1c a2       	std	Y+36, r1	; 0x24
    1cce:	1d a2       	std	Y+37, r1	; 0x25
    1cd0:	1e a2       	std	Y+38, r1	; 0x26
    1cd2:	1f a2       	std	Y+39, r1	; 0x27
    1cd4:	a2 01       	movw	r20, r4
    1cd6:	b4 01       	movw	r22, r8
    1cd8:	c5 01       	movw	r24, r10
    1cda:	2b d9       	rcall	.-3498   	; 0xf32 <pxPortInitialiseStack>
    1cdc:	99 83       	std	Y+1, r25	; 0x01
    1cde:	88 83       	st	Y, r24
    1ce0:	e1 14       	cp	r14, r1
    1ce2:	f1 04       	cpc	r15, r1
    1ce4:	19 f0       	breq	.+6      	; 0x1cec <xTaskCreate+0xf6>
    1ce6:	f7 01       	movw	r30, r14
    1ce8:	d1 83       	std	Z+1, r29	; 0x01
    1cea:	c0 83       	st	Z, r28
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	0f 92       	push	r0
    1cf2:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxCurrentNumberOfTasks>
    1cf6:	8f 5f       	subi	r24, 0xFF	; 255
    1cf8:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <uxCurrentNumberOfTasks>
    1cfc:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <pxCurrentTCB>
    1d00:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1d04:	89 2b       	or	r24, r25
    1d06:	d1 f5       	brne	.+116    	; 0x1d7c <xTaskCreate+0x186>
    1d08:	d0 93 19 03 	sts	0x0319, r29	; 0x800319 <pxCurrentTCB+0x1>
    1d0c:	c0 93 18 03 	sts	0x0318, r28	; 0x800318 <pxCurrentTCB>
    1d10:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxCurrentNumberOfTasks>
    1d14:	81 30       	cpi	r24, 0x01	; 1
    1d16:	09 f0       	breq	.+2      	; 0x1d1a <xTaskCreate+0x124>
    1d18:	41 c0       	rjmp	.+130    	; 0x1d9c <xTaskCreate+0x1a6>
    1d1a:	84 ef       	ldi	r24, 0xF4	; 244
    1d1c:	92 e0       	ldi	r25, 0x02	; 2
    1d1e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d22:	8d ef       	ldi	r24, 0xFD	; 253
    1d24:	92 e0       	ldi	r25, 0x02	; 2
    1d26:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d2a:	86 e0       	ldi	r24, 0x06	; 6
    1d2c:	93 e0       	ldi	r25, 0x03	; 3
    1d2e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d32:	8f e0       	ldi	r24, 0x0F	; 15
    1d34:	93 e0       	ldi	r25, 0x03	; 3
    1d36:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d3a:	8b ee       	ldi	r24, 0xEB	; 235
    1d3c:	92 e0       	ldi	r25, 0x02	; 2
    1d3e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d42:	82 ee       	ldi	r24, 0xE2	; 226
    1d44:	92 e0       	ldi	r25, 0x02	; 2
    1d46:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d4a:	85 ed       	ldi	r24, 0xD5	; 213
    1d4c:	92 e0       	ldi	r25, 0x02	; 2
    1d4e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d52:	8c ec       	ldi	r24, 0xCC	; 204
    1d54:	92 e0       	ldi	r25, 0x02	; 2
    1d56:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d5a:	82 ec       	ldi	r24, 0xC2	; 194
    1d5c:	92 e0       	ldi	r25, 0x02	; 2
    1d5e:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <vListInitialise>
    1d62:	8b ee       	ldi	r24, 0xEB	; 235
    1d64:	92 e0       	ldi	r25, 0x02	; 2
    1d66:	90 93 e1 02 	sts	0x02E1, r25	; 0x8002e1 <pxDelayedTaskList+0x1>
    1d6a:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <pxDelayedTaskList>
    1d6e:	82 ee       	ldi	r24, 0xE2	; 226
    1d70:	92 e0       	ldi	r25, 0x02	; 2
    1d72:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <pxOverflowDelayedTaskList+0x1>
    1d76:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <pxOverflowDelayedTaskList>
    1d7a:	10 c0       	rjmp	.+32     	; 0x1d9c <xTaskCreate+0x1a6>
    1d7c:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <xSchedulerRunning>
    1d80:	81 11       	cpse	r24, r1
    1d82:	0c c0       	rjmp	.+24     	; 0x1d9c <xTaskCreate+0x1a6>
    1d84:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    1d88:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1d8c:	96 89       	ldd	r25, Z+22	; 0x16
    1d8e:	8e 89       	ldd	r24, Y+22	; 0x16
    1d90:	89 17       	cp	r24, r25
    1d92:	20 f0       	brcs	.+8      	; 0x1d9c <xTaskCreate+0x1a6>
    1d94:	d0 93 19 03 	sts	0x0319, r29	; 0x800319 <pxCurrentTCB+0x1>
    1d98:	c0 93 18 03 	sts	0x0318, r28	; 0x800318 <pxCurrentTCB>
    1d9c:	80 91 b9 02 	lds	r24, 0x02B9	; 0x8002b9 <uxTaskNumber>
    1da0:	8f 5f       	subi	r24, 0xFF	; 255
    1da2:	80 93 b9 02 	sts	0x02B9, r24	; 0x8002b9 <uxTaskNumber>
    1da6:	8e 89       	ldd	r24, Y+22	; 0x16
    1da8:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    1dac:	98 17       	cp	r25, r24
    1dae:	10 f4       	brcc	.+4      	; 0x1db4 <xTaskCreate+0x1be>
    1db0:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	9c 01       	movw	r18, r24
    1db8:	22 0f       	add	r18, r18
    1dba:	33 1f       	adc	r19, r19
    1dbc:	22 0f       	add	r18, r18
    1dbe:	33 1f       	adc	r19, r19
    1dc0:	22 0f       	add	r18, r18
    1dc2:	33 1f       	adc	r19, r19
    1dc4:	82 0f       	add	r24, r18
    1dc6:	93 1f       	adc	r25, r19
    1dc8:	b6 01       	movw	r22, r12
    1dca:	8c 50       	subi	r24, 0x0C	; 12
    1dcc:	9d 4f       	sbci	r25, 0xFD	; 253
    1dce:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1dd2:	0f 90       	pop	r0
    1dd4:	0f be       	out	0x3f, r0	; 63
    1dd6:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <xSchedulerRunning>
    1dda:	88 23       	and	r24, r24
    1ddc:	59 f0       	breq	.+22     	; 0x1df4 <xTaskCreate+0x1fe>
    1dde:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    1de2:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1de6:	96 89       	ldd	r25, Z+22	; 0x16
    1de8:	8e 89       	ldd	r24, Y+22	; 0x16
    1dea:	98 17       	cp	r25, r24
    1dec:	28 f4       	brcc	.+10     	; 0x1df8 <xTaskCreate+0x202>
    1dee:	59 d9       	rcall	.-3406   	; 0x10a2 <vPortYield>
    1df0:	81 e0       	ldi	r24, 0x01	; 1
    1df2:	05 c0       	rjmp	.+10     	; 0x1dfe <xTaskCreate+0x208>
    1df4:	81 e0       	ldi	r24, 0x01	; 1
    1df6:	03 c0       	rjmp	.+6      	; 0x1dfe <xTaskCreate+0x208>
    1df8:	81 e0       	ldi	r24, 0x01	; 1
    1dfa:	01 c0       	rjmp	.+2      	; 0x1dfe <xTaskCreate+0x208>
    1dfc:	8f ef       	ldi	r24, 0xFF	; 255
    1dfe:	df 91       	pop	r29
    1e00:	cf 91       	pop	r28
    1e02:	0f 91       	pop	r16
    1e04:	ff 90       	pop	r15
    1e06:	ef 90       	pop	r14
    1e08:	df 90       	pop	r13
    1e0a:	cf 90       	pop	r12
    1e0c:	bf 90       	pop	r11
    1e0e:	af 90       	pop	r10
    1e10:	9f 90       	pop	r9
    1e12:	8f 90       	pop	r8
    1e14:	7f 90       	pop	r7
    1e16:	6f 90       	pop	r6
    1e18:	5f 90       	pop	r5
    1e1a:	4f 90       	pop	r4
    1e1c:	08 95       	ret

00001e1e <vTaskStartScheduler>:
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	0f 93       	push	r16
    1e24:	0f 2e       	mov	r0, r31
    1e26:	f5 eb       	ldi	r31, 0xB5	; 181
    1e28:	ef 2e       	mov	r14, r31
    1e2a:	f2 e0       	ldi	r31, 0x02	; 2
    1e2c:	ff 2e       	mov	r15, r31
    1e2e:	f0 2d       	mov	r31, r0
    1e30:	00 e0       	ldi	r16, 0x00	; 0
    1e32:	20 e0       	ldi	r18, 0x00	; 0
    1e34:	30 e0       	ldi	r19, 0x00	; 0
    1e36:	45 e5       	ldi	r20, 0x55	; 85
    1e38:	50 e0       	ldi	r21, 0x00	; 0
    1e3a:	67 e8       	ldi	r22, 0x87	; 135
    1e3c:	72 e0       	ldi	r23, 0x02	; 2
    1e3e:	83 e3       	ldi	r24, 0x33	; 51
    1e40:	91 e0       	ldi	r25, 0x01	; 1
    1e42:	d9 de       	rcall	.-590    	; 0x1bf6 <xTaskCreate>
    1e44:	81 30       	cpi	r24, 0x01	; 1
    1e46:	79 f4       	brne	.+30     	; 0x1e66 <vTaskStartScheduler+0x48>
    1e48:	f8 94       	cli
    1e4a:	8f ef       	ldi	r24, 0xFF	; 255
    1e4c:	9f ef       	ldi	r25, 0xFF	; 255
    1e4e:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1e52:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xNextTaskUnblockTime>
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <xSchedulerRunning>
    1e5c:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <xTickCount+0x1>
    1e60:	10 92 bf 02 	sts	0x02BF, r1	; 0x8002bf <xTickCount>
    1e64:	d8 d8       	rcall	.-3664   	; 0x1016 <xPortStartScheduler>
    1e66:	0f 91       	pop	r16
    1e68:	ff 90       	pop	r15
    1e6a:	ef 90       	pop	r14
    1e6c:	08 95       	ret

00001e6e <vTaskSuspendAll>:
    1e6e:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    1e72:	8f 5f       	subi	r24, 0xFF	; 255
    1e74:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxSchedulerSuspended>
    1e78:	08 95       	ret

00001e7a <xTaskIncrementTick>:
    1e7a:	cf 92       	push	r12
    1e7c:	df 92       	push	r13
    1e7e:	ef 92       	push	r14
    1e80:	ff 92       	push	r15
    1e82:	0f 93       	push	r16
    1e84:	1f 93       	push	r17
    1e86:	cf 93       	push	r28
    1e88:	df 93       	push	r29
    1e8a:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    1e8e:	81 11       	cpse	r24, r1
    1e90:	98 c0       	rjmp	.+304    	; 0x1fc2 <xTaskIncrementTick+0x148>
    1e92:	e0 90 bf 02 	lds	r14, 0x02BF	; 0x8002bf <xTickCount>
    1e96:	f0 90 c0 02 	lds	r15, 0x02C0	; 0x8002c0 <xTickCount+0x1>
    1e9a:	8f ef       	ldi	r24, 0xFF	; 255
    1e9c:	e8 1a       	sub	r14, r24
    1e9e:	f8 0a       	sbc	r15, r24
    1ea0:	f0 92 c0 02 	sts	0x02C0, r15	; 0x8002c0 <xTickCount+0x1>
    1ea4:	e0 92 bf 02 	sts	0x02BF, r14	; 0x8002bf <xTickCount>
    1ea8:	e1 14       	cp	r14, r1
    1eaa:	f1 04       	cpc	r15, r1
    1eac:	b1 f4       	brne	.+44     	; 0x1eda <xTaskIncrementTick+0x60>
    1eae:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1eb2:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1eb6:	20 91 de 02 	lds	r18, 0x02DE	; 0x8002de <pxOverflowDelayedTaskList>
    1eba:	30 91 df 02 	lds	r19, 0x02DF	; 0x8002df <pxOverflowDelayedTaskList+0x1>
    1ebe:	30 93 e1 02 	sts	0x02E1, r19	; 0x8002e1 <pxDelayedTaskList+0x1>
    1ec2:	20 93 e0 02 	sts	0x02E0, r18	; 0x8002e0 <pxDelayedTaskList>
    1ec6:	90 93 df 02 	sts	0x02DF, r25	; 0x8002df <pxOverflowDelayedTaskList+0x1>
    1eca:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <pxOverflowDelayedTaskList>
    1ece:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <xNumOfOverflows>
    1ed2:	8f 5f       	subi	r24, 0xFF	; 255
    1ed4:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <xNumOfOverflows>
    1ed8:	17 de       	rcall	.-978    	; 0x1b08 <prvResetNextTaskUnblockTime>
    1eda:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <xNextTaskUnblockTime>
    1ede:	90 91 b8 02 	lds	r25, 0x02B8	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1ee2:	e8 16       	cp	r14, r24
    1ee4:	f9 06       	cpc	r15, r25
    1ee6:	10 f4       	brcc	.+4      	; 0x1eec <xTaskIncrementTick+0x72>
    1ee8:	d1 2c       	mov	r13, r1
    1eea:	53 c0       	rjmp	.+166    	; 0x1f92 <xTaskIncrementTick+0x118>
    1eec:	d1 2c       	mov	r13, r1
    1eee:	cc 24       	eor	r12, r12
    1ef0:	c3 94       	inc	r12
    1ef2:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1ef6:	f0 91 e1 02 	lds	r31, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1efa:	80 81       	ld	r24, Z
    1efc:	81 11       	cpse	r24, r1
    1efe:	07 c0       	rjmp	.+14     	; 0x1f0e <xTaskIncrementTick+0x94>
    1f00:	8f ef       	ldi	r24, 0xFF	; 255
    1f02:	9f ef       	ldi	r25, 0xFF	; 255
    1f04:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1f08:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xNextTaskUnblockTime>
    1f0c:	42 c0       	rjmp	.+132    	; 0x1f92 <xTaskIncrementTick+0x118>
    1f0e:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <pxDelayedTaskList>
    1f12:	f0 91 e1 02 	lds	r31, 0x02E1	; 0x8002e1 <pxDelayedTaskList+0x1>
    1f16:	05 80       	ldd	r0, Z+5	; 0x05
    1f18:	f6 81       	ldd	r31, Z+6	; 0x06
    1f1a:	e0 2d       	mov	r30, r0
    1f1c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f1e:	d7 81       	ldd	r29, Z+7	; 0x07
    1f20:	8a 81       	ldd	r24, Y+2	; 0x02
    1f22:	9b 81       	ldd	r25, Y+3	; 0x03
    1f24:	e8 16       	cp	r14, r24
    1f26:	f9 06       	cpc	r15, r25
    1f28:	28 f4       	brcc	.+10     	; 0x1f34 <xTaskIncrementTick+0xba>
    1f2a:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <xNextTaskUnblockTime+0x1>
    1f2e:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <xNextTaskUnblockTime>
    1f32:	2f c0       	rjmp	.+94     	; 0x1f92 <xTaskIncrementTick+0x118>
    1f34:	8e 01       	movw	r16, r28
    1f36:	0e 5f       	subi	r16, 0xFE	; 254
    1f38:	1f 4f       	sbci	r17, 0xFF	; 255
    1f3a:	c8 01       	movw	r24, r16
    1f3c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f40:	8c 89       	ldd	r24, Y+20	; 0x14
    1f42:	9d 89       	ldd	r25, Y+21	; 0x15
    1f44:	89 2b       	or	r24, r25
    1f46:	21 f0       	breq	.+8      	; 0x1f50 <xTaskIncrementTick+0xd6>
    1f48:	ce 01       	movw	r24, r28
    1f4a:	0c 96       	adiw	r24, 0x0c	; 12
    1f4c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    1f50:	8e 89       	ldd	r24, Y+22	; 0x16
    1f52:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    1f56:	98 17       	cp	r25, r24
    1f58:	10 f4       	brcc	.+4      	; 0x1f5e <xTaskIncrementTick+0xe4>
    1f5a:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    1f5e:	90 e0       	ldi	r25, 0x00	; 0
    1f60:	9c 01       	movw	r18, r24
    1f62:	22 0f       	add	r18, r18
    1f64:	33 1f       	adc	r19, r19
    1f66:	22 0f       	add	r18, r18
    1f68:	33 1f       	adc	r19, r19
    1f6a:	22 0f       	add	r18, r18
    1f6c:	33 1f       	adc	r19, r19
    1f6e:	82 0f       	add	r24, r18
    1f70:	93 1f       	adc	r25, r19
    1f72:	b8 01       	movw	r22, r16
    1f74:	8c 50       	subi	r24, 0x0C	; 12
    1f76:	9d 4f       	sbci	r25, 0xFD	; 253
    1f78:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    1f7c:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    1f80:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1f84:	9e 89       	ldd	r25, Y+22	; 0x16
    1f86:	86 89       	ldd	r24, Z+22	; 0x16
    1f88:	98 17       	cp	r25, r24
    1f8a:	08 f4       	brcc	.+2      	; 0x1f8e <xTaskIncrementTick+0x114>
    1f8c:	b2 cf       	rjmp	.-156    	; 0x1ef2 <xTaskIncrementTick+0x78>
    1f8e:	dc 2c       	mov	r13, r12
    1f90:	b0 cf       	rjmp	.-160    	; 0x1ef2 <xTaskIncrementTick+0x78>
    1f92:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    1f96:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    1f9a:	86 89       	ldd	r24, Z+22	; 0x16
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	fc 01       	movw	r30, r24
    1fa0:	ee 0f       	add	r30, r30
    1fa2:	ff 1f       	adc	r31, r31
    1fa4:	ee 0f       	add	r30, r30
    1fa6:	ff 1f       	adc	r31, r31
    1fa8:	ee 0f       	add	r30, r30
    1faa:	ff 1f       	adc	r31, r31
    1fac:	8e 0f       	add	r24, r30
    1fae:	9f 1f       	adc	r25, r31
    1fb0:	fc 01       	movw	r30, r24
    1fb2:	ec 50       	subi	r30, 0x0C	; 12
    1fb4:	fd 4f       	sbci	r31, 0xFD	; 253
    1fb6:	80 81       	ld	r24, Z
    1fb8:	82 30       	cpi	r24, 0x02	; 2
    1fba:	48 f0       	brcs	.+18     	; 0x1fce <xTaskIncrementTick+0x154>
    1fbc:	dd 24       	eor	r13, r13
    1fbe:	d3 94       	inc	r13
    1fc0:	06 c0       	rjmp	.+12     	; 0x1fce <xTaskIncrementTick+0x154>
    1fc2:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <uxPendedTicks>
    1fc6:	8f 5f       	subi	r24, 0xFF	; 255
    1fc8:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <uxPendedTicks>
    1fcc:	d1 2c       	mov	r13, r1
    1fce:	80 91 bb 02 	lds	r24, 0x02BB	; 0x8002bb <xYieldPending>
    1fd2:	88 23       	and	r24, r24
    1fd4:	11 f0       	breq	.+4      	; 0x1fda <xTaskIncrementTick+0x160>
    1fd6:	dd 24       	eor	r13, r13
    1fd8:	d3 94       	inc	r13
    1fda:	8d 2d       	mov	r24, r13
    1fdc:	df 91       	pop	r29
    1fde:	cf 91       	pop	r28
    1fe0:	1f 91       	pop	r17
    1fe2:	0f 91       	pop	r16
    1fe4:	ff 90       	pop	r15
    1fe6:	ef 90       	pop	r14
    1fe8:	df 90       	pop	r13
    1fea:	cf 90       	pop	r12
    1fec:	08 95       	ret

00001fee <xTaskResumeAll>:
    1fee:	df 92       	push	r13
    1ff0:	ef 92       	push	r14
    1ff2:	ff 92       	push	r15
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
    2002:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    2006:	81 50       	subi	r24, 0x01	; 1
    2008:	80 93 b4 02 	sts	0x02B4, r24	; 0x8002b4 <uxSchedulerSuspended>
    200c:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    2010:	81 11       	cpse	r24, r1
    2012:	5d c0       	rjmp	.+186    	; 0x20ce <xTaskResumeAll+0xe0>
    2014:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <uxCurrentNumberOfTasks>
    2018:	81 11       	cpse	r24, r1
    201a:	33 c0       	rjmp	.+102    	; 0x2082 <xTaskResumeAll+0x94>
    201c:	5b c0       	rjmp	.+182    	; 0x20d4 <xTaskResumeAll+0xe6>
    201e:	d7 01       	movw	r26, r14
    2020:	15 96       	adiw	r26, 0x05	; 5
    2022:	ed 91       	ld	r30, X+
    2024:	fc 91       	ld	r31, X
    2026:	16 97       	sbiw	r26, 0x06	; 6
    2028:	c6 81       	ldd	r28, Z+6	; 0x06
    202a:	d7 81       	ldd	r29, Z+7	; 0x07
    202c:	ce 01       	movw	r24, r28
    202e:	0c 96       	adiw	r24, 0x0c	; 12
    2030:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2034:	8e 01       	movw	r16, r28
    2036:	0e 5f       	subi	r16, 0xFE	; 254
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	c8 01       	movw	r24, r16
    203c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2040:	8e 89       	ldd	r24, Y+22	; 0x16
    2042:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    2046:	98 17       	cp	r25, r24
    2048:	10 f4       	brcc	.+4      	; 0x204e <xTaskResumeAll+0x60>
    204a:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	9c 01       	movw	r18, r24
    2052:	22 0f       	add	r18, r18
    2054:	33 1f       	adc	r19, r19
    2056:	22 0f       	add	r18, r18
    2058:	33 1f       	adc	r19, r19
    205a:	22 0f       	add	r18, r18
    205c:	33 1f       	adc	r19, r19
    205e:	82 0f       	add	r24, r18
    2060:	93 1f       	adc	r25, r19
    2062:	b8 01       	movw	r22, r16
    2064:	8c 50       	subi	r24, 0x0C	; 12
    2066:	9d 4f       	sbci	r25, 0xFD	; 253
    2068:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    206c:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    2070:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2074:	9e 89       	ldd	r25, Y+22	; 0x16
    2076:	86 89       	ldd	r24, Z+22	; 0x16
    2078:	98 17       	cp	r25, r24
    207a:	68 f0       	brcs	.+26     	; 0x2096 <xTaskResumeAll+0xa8>
    207c:	d0 92 bb 02 	sts	0x02BB, r13	; 0x8002bb <xYieldPending>
    2080:	0a c0       	rjmp	.+20     	; 0x2096 <xTaskResumeAll+0xa8>
    2082:	c0 e0       	ldi	r28, 0x00	; 0
    2084:	d0 e0       	ldi	r29, 0x00	; 0
    2086:	0f 2e       	mov	r0, r31
    2088:	f5 ed       	ldi	r31, 0xD5	; 213
    208a:	ef 2e       	mov	r14, r31
    208c:	f2 e0       	ldi	r31, 0x02	; 2
    208e:	ff 2e       	mov	r15, r31
    2090:	f0 2d       	mov	r31, r0
    2092:	dd 24       	eor	r13, r13
    2094:	d3 94       	inc	r13
    2096:	f7 01       	movw	r30, r14
    2098:	80 81       	ld	r24, Z
    209a:	81 11       	cpse	r24, r1
    209c:	c0 cf       	rjmp	.-128    	; 0x201e <xTaskResumeAll+0x30>
    209e:	cd 2b       	or	r28, r29
    20a0:	09 f0       	breq	.+2      	; 0x20a4 <xTaskResumeAll+0xb6>
    20a2:	32 dd       	rcall	.-1436   	; 0x1b08 <prvResetNextTaskUnblockTime>
    20a4:	c0 91 bc 02 	lds	r28, 0x02BC	; 0x8002bc <uxPendedTicks>
    20a8:	cc 23       	and	r28, r28
    20aa:	49 f0       	breq	.+18     	; 0x20be <xTaskResumeAll+0xd0>
    20ac:	d1 e0       	ldi	r29, 0x01	; 1
    20ae:	e5 de       	rcall	.-566    	; 0x1e7a <xTaskIncrementTick>
    20b0:	81 11       	cpse	r24, r1
    20b2:	d0 93 bb 02 	sts	0x02BB, r29	; 0x8002bb <xYieldPending>
    20b6:	c1 50       	subi	r28, 0x01	; 1
    20b8:	d1 f7       	brne	.-12     	; 0x20ae <xTaskResumeAll+0xc0>
    20ba:	10 92 bc 02 	sts	0x02BC, r1	; 0x8002bc <uxPendedTicks>
    20be:	80 91 bb 02 	lds	r24, 0x02BB	; 0x8002bb <xYieldPending>
    20c2:	88 23       	and	r24, r24
    20c4:	31 f0       	breq	.+12     	; 0x20d2 <xTaskResumeAll+0xe4>
    20c6:	0e 94 51 08 	call	0x10a2	; 0x10a2 <vPortYield>
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	03 c0       	rjmp	.+6      	; 0x20d4 <xTaskResumeAll+0xe6>
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <xTaskResumeAll+0xe6>
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	0f 90       	pop	r0
    20d6:	0f be       	out	0x3f, r0	; 63
    20d8:	df 91       	pop	r29
    20da:	cf 91       	pop	r28
    20dc:	1f 91       	pop	r17
    20de:	0f 91       	pop	r16
    20e0:	ff 90       	pop	r15
    20e2:	ef 90       	pop	r14
    20e4:	df 90       	pop	r13
    20e6:	08 95       	ret

000020e8 <vTaskDelay>:
    20e8:	cf 93       	push	r28
    20ea:	df 93       	push	r29
    20ec:	ec 01       	movw	r28, r24
    20ee:	89 2b       	or	r24, r25
    20f0:	39 f0       	breq	.+14     	; 0x2100 <vTaskDelay+0x18>
    20f2:	bd de       	rcall	.-646    	; 0x1e6e <vTaskSuspendAll>
    20f4:	60 e0       	ldi	r22, 0x00	; 0
    20f6:	ce 01       	movw	r24, r28
    20f8:	26 dd       	rcall	.-1460   	; 0x1b46 <prvAddCurrentTaskToDelayedList>
    20fa:	79 df       	rcall	.-270    	; 0x1fee <xTaskResumeAll>
    20fc:	81 11       	cpse	r24, r1
    20fe:	02 c0       	rjmp	.+4      	; 0x2104 <vTaskDelay+0x1c>
    2100:	0e 94 51 08 	call	0x10a2	; 0x10a2 <vPortYield>
    2104:	df 91       	pop	r29
    2106:	cf 91       	pop	r28
    2108:	08 95       	ret

0000210a <vTaskSwitchContext>:
    210a:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    210e:	88 23       	and	r24, r24
    2110:	21 f0       	breq	.+8      	; 0x211a <vTaskSwitchContext+0x10>
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <xYieldPending>
    2118:	08 95       	ret
    211a:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <xYieldPending>
    211e:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    2122:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2126:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    212a:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    212e:	2d 91       	ld	r18, X+
    2130:	3c 91       	ld	r19, X
    2132:	87 89       	ldd	r24, Z+23	; 0x17
    2134:	90 8d       	ldd	r25, Z+24	; 0x18
    2136:	82 17       	cp	r24, r18
    2138:	93 07       	cpc	r25, r19
    213a:	60 f0       	brcs	.+24     	; 0x2154 <vTaskSwitchContext+0x4a>
    213c:	60 91 18 03 	lds	r22, 0x0318	; 0x800318 <pxCurrentTCB>
    2140:	70 91 19 03 	lds	r23, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2144:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <pxCurrentTCB>
    2148:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    214c:	67 5e       	subi	r22, 0xE7	; 231
    214e:	7f 4f       	sbci	r23, 0xFF	; 255
    2150:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vApplicationStackOverflowHook>
    2154:	20 91 be 02 	lds	r18, 0x02BE	; 0x8002be <uxTopReadyPriority>
    2158:	82 2f       	mov	r24, r18
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	fc 01       	movw	r30, r24
    215e:	ee 0f       	add	r30, r30
    2160:	ff 1f       	adc	r31, r31
    2162:	ee 0f       	add	r30, r30
    2164:	ff 1f       	adc	r31, r31
    2166:	ee 0f       	add	r30, r30
    2168:	ff 1f       	adc	r31, r31
    216a:	e8 0f       	add	r30, r24
    216c:	f9 1f       	adc	r31, r25
    216e:	ec 50       	subi	r30, 0x0C	; 12
    2170:	fd 4f       	sbci	r31, 0xFD	; 253
    2172:	30 81       	ld	r19, Z
    2174:	31 11       	cpse	r19, r1
    2176:	11 c0       	rjmp	.+34     	; 0x219a <vTaskSwitchContext+0x90>
    2178:	21 50       	subi	r18, 0x01	; 1
    217a:	82 2f       	mov	r24, r18
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	fc 01       	movw	r30, r24
    2180:	ee 0f       	add	r30, r30
    2182:	ff 1f       	adc	r31, r31
    2184:	ee 0f       	add	r30, r30
    2186:	ff 1f       	adc	r31, r31
    2188:	ee 0f       	add	r30, r30
    218a:	ff 1f       	adc	r31, r31
    218c:	e8 0f       	add	r30, r24
    218e:	f9 1f       	adc	r31, r25
    2190:	ec 50       	subi	r30, 0x0C	; 12
    2192:	fd 4f       	sbci	r31, 0xFD	; 253
    2194:	30 81       	ld	r19, Z
    2196:	33 23       	and	r19, r19
    2198:	79 f3       	breq	.-34     	; 0x2178 <vTaskSwitchContext+0x6e>
    219a:	ac 01       	movw	r20, r24
    219c:	44 0f       	add	r20, r20
    219e:	55 1f       	adc	r21, r21
    21a0:	44 0f       	add	r20, r20
    21a2:	55 1f       	adc	r21, r21
    21a4:	44 0f       	add	r20, r20
    21a6:	55 1f       	adc	r21, r21
    21a8:	48 0f       	add	r20, r24
    21aa:	59 1f       	adc	r21, r25
    21ac:	da 01       	movw	r26, r20
    21ae:	ac 50       	subi	r26, 0x0C	; 12
    21b0:	bd 4f       	sbci	r27, 0xFD	; 253
    21b2:	11 96       	adiw	r26, 0x01	; 1
    21b4:	ed 91       	ld	r30, X+
    21b6:	fc 91       	ld	r31, X
    21b8:	12 97       	sbiw	r26, 0x02	; 2
    21ba:	02 80       	ldd	r0, Z+2	; 0x02
    21bc:	f3 81       	ldd	r31, Z+3	; 0x03
    21be:	e0 2d       	mov	r30, r0
    21c0:	12 96       	adiw	r26, 0x02	; 2
    21c2:	fc 93       	st	X, r31
    21c4:	ee 93       	st	-X, r30
    21c6:	11 97       	sbiw	r26, 0x01	; 1
    21c8:	49 50       	subi	r20, 0x09	; 9
    21ca:	5d 4f       	sbci	r21, 0xFD	; 253
    21cc:	e4 17       	cp	r30, r20
    21ce:	f5 07       	cpc	r31, r21
    21d0:	29 f4       	brne	.+10     	; 0x21dc <vTaskSwitchContext+0xd2>
    21d2:	42 81       	ldd	r20, Z+2	; 0x02
    21d4:	53 81       	ldd	r21, Z+3	; 0x03
    21d6:	fd 01       	movw	r30, r26
    21d8:	52 83       	std	Z+2, r21	; 0x02
    21da:	41 83       	std	Z+1, r20	; 0x01
    21dc:	fc 01       	movw	r30, r24
    21de:	ee 0f       	add	r30, r30
    21e0:	ff 1f       	adc	r31, r31
    21e2:	ee 0f       	add	r30, r30
    21e4:	ff 1f       	adc	r31, r31
    21e6:	ee 0f       	add	r30, r30
    21e8:	ff 1f       	adc	r31, r31
    21ea:	8e 0f       	add	r24, r30
    21ec:	9f 1f       	adc	r25, r31
    21ee:	fc 01       	movw	r30, r24
    21f0:	ec 50       	subi	r30, 0x0C	; 12
    21f2:	fd 4f       	sbci	r31, 0xFD	; 253
    21f4:	01 80       	ldd	r0, Z+1	; 0x01
    21f6:	f2 81       	ldd	r31, Z+2	; 0x02
    21f8:	e0 2d       	mov	r30, r0
    21fa:	86 81       	ldd	r24, Z+6	; 0x06
    21fc:	97 81       	ldd	r25, Z+7	; 0x07
    21fe:	90 93 19 03 	sts	0x0319, r25	; 0x800319 <pxCurrentTCB+0x1>
    2202:	80 93 18 03 	sts	0x0318, r24	; 0x800318 <pxCurrentTCB>
    2206:	20 93 be 02 	sts	0x02BE, r18	; 0x8002be <uxTopReadyPriority>
    220a:	08 95       	ret

0000220c <vTaskPlaceOnEventList>:
    220c:	cf 93       	push	r28
    220e:	df 93       	push	r29
    2210:	eb 01       	movw	r28, r22
    2212:	60 91 18 03 	lds	r22, 0x0318	; 0x800318 <pxCurrentTCB>
    2216:	70 91 19 03 	lds	r23, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    221a:	64 5f       	subi	r22, 0xF4	; 244
    221c:	7f 4f       	sbci	r23, 0xFF	; 255
    221e:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInsert>
    2222:	61 e0       	ldi	r22, 0x01	; 1
    2224:	ce 01       	movw	r24, r28
    2226:	8f dc       	rcall	.-1762   	; 0x1b46 <prvAddCurrentTaskToDelayedList>
    2228:	df 91       	pop	r29
    222a:	cf 91       	pop	r28
    222c:	08 95       	ret

0000222e <xTaskRemoveFromEventList>:
    222e:	0f 93       	push	r16
    2230:	1f 93       	push	r17
    2232:	cf 93       	push	r28
    2234:	df 93       	push	r29
    2236:	dc 01       	movw	r26, r24
    2238:	15 96       	adiw	r26, 0x05	; 5
    223a:	ed 91       	ld	r30, X+
    223c:	fc 91       	ld	r31, X
    223e:	16 97       	sbiw	r26, 0x06	; 6
    2240:	c6 81       	ldd	r28, Z+6	; 0x06
    2242:	d7 81       	ldd	r29, Z+7	; 0x07
    2244:	8e 01       	movw	r16, r28
    2246:	04 5f       	subi	r16, 0xF4	; 244
    2248:	1f 4f       	sbci	r17, 0xFF	; 255
    224a:	c8 01       	movw	r24, r16
    224c:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2250:	80 91 b4 02 	lds	r24, 0x02B4	; 0x8002b4 <uxSchedulerSuspended>
    2254:	81 11       	cpse	r24, r1
    2256:	1c c0       	rjmp	.+56     	; 0x2290 <xTaskRemoveFromEventList+0x62>
    2258:	0a 50       	subi	r16, 0x0A	; 10
    225a:	11 09       	sbc	r17, r1
    225c:	c8 01       	movw	r24, r16
    225e:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    2262:	8e 89       	ldd	r24, Y+22	; 0x16
    2264:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    2268:	98 17       	cp	r25, r24
    226a:	10 f4       	brcc	.+4      	; 0x2270 <xTaskRemoveFromEventList+0x42>
    226c:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	9c 01       	movw	r18, r24
    2274:	22 0f       	add	r18, r18
    2276:	33 1f       	adc	r19, r19
    2278:	22 0f       	add	r18, r18
    227a:	33 1f       	adc	r19, r19
    227c:	22 0f       	add	r18, r18
    227e:	33 1f       	adc	r19, r19
    2280:	82 0f       	add	r24, r18
    2282:	93 1f       	adc	r25, r19
    2284:	b8 01       	movw	r22, r16
    2286:	8c 50       	subi	r24, 0x0C	; 12
    2288:	9d 4f       	sbci	r25, 0xFD	; 253
    228a:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    228e:	05 c0       	rjmp	.+10     	; 0x229a <xTaskRemoveFromEventList+0x6c>
    2290:	b8 01       	movw	r22, r16
    2292:	85 ed       	ldi	r24, 0xD5	; 213
    2294:	92 e0       	ldi	r25, 0x02	; 2
    2296:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    229a:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    229e:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    22a2:	9e 89       	ldd	r25, Y+22	; 0x16
    22a4:	86 89       	ldd	r24, Z+22	; 0x16
    22a6:	89 17       	cp	r24, r25
    22a8:	20 f4       	brcc	.+8      	; 0x22b2 <xTaskRemoveFromEventList+0x84>
    22aa:	81 e0       	ldi	r24, 0x01	; 1
    22ac:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <xYieldPending>
    22b0:	01 c0       	rjmp	.+2      	; 0x22b4 <xTaskRemoveFromEventList+0x86>
    22b2:	80 e0       	ldi	r24, 0x00	; 0
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	1f 91       	pop	r17
    22ba:	0f 91       	pop	r16
    22bc:	08 95       	ret

000022be <vTaskSetTimeOutState>:
    22be:	20 91 ba 02 	lds	r18, 0x02BA	; 0x8002ba <xNumOfOverflows>
    22c2:	fc 01       	movw	r30, r24
    22c4:	20 83       	st	Z, r18
    22c6:	20 91 bf 02 	lds	r18, 0x02BF	; 0x8002bf <xTickCount>
    22ca:	30 91 c0 02 	lds	r19, 0x02C0	; 0x8002c0 <xTickCount+0x1>
    22ce:	32 83       	std	Z+2, r19	; 0x02
    22d0:	21 83       	std	Z+1, r18	; 0x01
    22d2:	08 95       	ret

000022d4 <xTaskCheckForTimeOut>:
    22d4:	0f b6       	in	r0, 0x3f	; 63
    22d6:	f8 94       	cli
    22d8:	0f 92       	push	r0
    22da:	40 91 bf 02 	lds	r20, 0x02BF	; 0x8002bf <xTickCount>
    22de:	50 91 c0 02 	lds	r21, 0x02C0	; 0x8002c0 <xTickCount+0x1>
    22e2:	db 01       	movw	r26, r22
    22e4:	2d 91       	ld	r18, X+
    22e6:	3c 91       	ld	r19, X
    22e8:	2f 3f       	cpi	r18, 0xFF	; 255
    22ea:	bf ef       	ldi	r27, 0xFF	; 255
    22ec:	3b 07       	cpc	r19, r27
    22ee:	11 f1       	breq	.+68     	; 0x2334 <xTaskCheckForTimeOut+0x60>
    22f0:	e0 91 ba 02 	lds	r30, 0x02BA	; 0x8002ba <xNumOfOverflows>
    22f4:	dc 01       	movw	r26, r24
    22f6:	fc 91       	ld	r31, X
    22f8:	fe 17       	cp	r31, r30
    22fa:	39 f0       	breq	.+14     	; 0x230a <xTaskCheckForTimeOut+0x36>
    22fc:	11 96       	adiw	r26, 0x01	; 1
    22fe:	ed 91       	ld	r30, X+
    2300:	fc 91       	ld	r31, X
    2302:	12 97       	sbiw	r26, 0x02	; 2
    2304:	4e 17       	cp	r20, r30
    2306:	5f 07       	cpc	r21, r31
    2308:	b8 f4       	brcc	.+46     	; 0x2338 <xTaskCheckForTimeOut+0x64>
    230a:	dc 01       	movw	r26, r24
    230c:	11 96       	adiw	r26, 0x01	; 1
    230e:	ed 91       	ld	r30, X+
    2310:	fc 91       	ld	r31, X
    2312:	12 97       	sbiw	r26, 0x02	; 2
    2314:	da 01       	movw	r26, r20
    2316:	ae 1b       	sub	r26, r30
    2318:	bf 0b       	sbc	r27, r31
    231a:	a2 17       	cp	r26, r18
    231c:	b3 07       	cpc	r27, r19
    231e:	70 f4       	brcc	.+28     	; 0x233c <xTaskCheckForTimeOut+0x68>
    2320:	db 01       	movw	r26, r22
    2322:	e4 1b       	sub	r30, r20
    2324:	f5 0b       	sbc	r31, r21
    2326:	2e 0f       	add	r18, r30
    2328:	3f 1f       	adc	r19, r31
    232a:	2d 93       	st	X+, r18
    232c:	3c 93       	st	X, r19
    232e:	c7 df       	rcall	.-114    	; 0x22be <vTaskSetTimeOutState>
    2330:	80 e0       	ldi	r24, 0x00	; 0
    2332:	05 c0       	rjmp	.+10     	; 0x233e <xTaskCheckForTimeOut+0x6a>
    2334:	80 e0       	ldi	r24, 0x00	; 0
    2336:	03 c0       	rjmp	.+6      	; 0x233e <xTaskCheckForTimeOut+0x6a>
    2338:	81 e0       	ldi	r24, 0x01	; 1
    233a:	01 c0       	rjmp	.+2      	; 0x233e <xTaskCheckForTimeOut+0x6a>
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	0f 90       	pop	r0
    2340:	0f be       	out	0x3f, r0	; 63
    2342:	08 95       	ret

00002344 <vTaskMissedYield>:
    2344:	81 e0       	ldi	r24, 0x01	; 1
    2346:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <xYieldPending>
    234a:	08 95       	ret

0000234c <vTaskPriorityInherit>:
    234c:	0f 93       	push	r16
    234e:	1f 93       	push	r17
    2350:	cf 93       	push	r28
    2352:	df 93       	push	r29
    2354:	fc 01       	movw	r30, r24
    2356:	89 2b       	or	r24, r25
    2358:	09 f4       	brne	.+2      	; 0x235c <vTaskPriorityInherit+0x10>
    235a:	55 c0       	rjmp	.+170    	; 0x2406 <vTaskPriorityInherit+0xba>
    235c:	26 89       	ldd	r18, Z+22	; 0x16
    235e:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    2362:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2366:	56 96       	adiw	r26, 0x16	; 22
    2368:	8c 91       	ld	r24, X
    236a:	28 17       	cp	r18, r24
    236c:	08 f0       	brcs	.+2      	; 0x2370 <vTaskPriorityInherit+0x24>
    236e:	4b c0       	rjmp	.+150    	; 0x2406 <vTaskPriorityInherit+0xba>
    2370:	84 85       	ldd	r24, Z+12	; 0x0c
    2372:	95 85       	ldd	r25, Z+13	; 0x0d
    2374:	99 23       	and	r25, r25
    2376:	64 f0       	brlt	.+24     	; 0x2390 <vTaskPriorityInherit+0x44>
    2378:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    237c:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2380:	56 96       	adiw	r26, 0x16	; 22
    2382:	3c 91       	ld	r19, X
    2384:	84 e0       	ldi	r24, 0x04	; 4
    2386:	90 e0       	ldi	r25, 0x00	; 0
    2388:	83 1b       	sub	r24, r19
    238a:	91 09       	sbc	r25, r1
    238c:	95 87       	std	Z+13, r25	; 0x0d
    238e:	84 87       	std	Z+12, r24	; 0x0c
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	c9 01       	movw	r24, r18
    2394:	88 0f       	add	r24, r24
    2396:	99 1f       	adc	r25, r25
    2398:	88 0f       	add	r24, r24
    239a:	99 1f       	adc	r25, r25
    239c:	88 0f       	add	r24, r24
    239e:	99 1f       	adc	r25, r25
    23a0:	28 0f       	add	r18, r24
    23a2:	39 1f       	adc	r19, r25
    23a4:	2c 50       	subi	r18, 0x0C	; 12
    23a6:	3d 4f       	sbci	r19, 0xFD	; 253
    23a8:	82 85       	ldd	r24, Z+10	; 0x0a
    23aa:	93 85       	ldd	r25, Z+11	; 0x0b
    23ac:	82 17       	cp	r24, r18
    23ae:	93 07       	cpc	r25, r19
    23b0:	19 f5       	brne	.+70     	; 0x23f8 <vTaskPriorityInherit+0xac>
    23b2:	8f 01       	movw	r16, r30
    23b4:	ef 01       	movw	r28, r30
    23b6:	22 96       	adiw	r28, 0x02	; 2
    23b8:	ce 01       	movw	r24, r28
    23ba:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    23be:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    23c2:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    23c6:	86 89       	ldd	r24, Z+22	; 0x16
    23c8:	f8 01       	movw	r30, r16
    23ca:	86 8b       	std	Z+22, r24	; 0x16
    23cc:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    23d0:	98 17       	cp	r25, r24
    23d2:	10 f4       	brcc	.+4      	; 0x23d8 <vTaskPriorityInherit+0x8c>
    23d4:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    23d8:	90 e0       	ldi	r25, 0x00	; 0
    23da:	9c 01       	movw	r18, r24
    23dc:	22 0f       	add	r18, r18
    23de:	33 1f       	adc	r19, r19
    23e0:	22 0f       	add	r18, r18
    23e2:	33 1f       	adc	r19, r19
    23e4:	22 0f       	add	r18, r18
    23e6:	33 1f       	adc	r19, r19
    23e8:	82 0f       	add	r24, r18
    23ea:	93 1f       	adc	r25, r19
    23ec:	be 01       	movw	r22, r28
    23ee:	8c 50       	subi	r24, 0x0C	; 12
    23f0:	9d 4f       	sbci	r25, 0xFD	; 253
    23f2:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    23f6:	07 c0       	rjmp	.+14     	; 0x2406 <vTaskPriorityInherit+0xba>
    23f8:	a0 91 18 03 	lds	r26, 0x0318	; 0x800318 <pxCurrentTCB>
    23fc:	b0 91 19 03 	lds	r27, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2400:	56 96       	adiw	r26, 0x16	; 22
    2402:	8c 91       	ld	r24, X
    2404:	86 8b       	std	Z+22, r24	; 0x16
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	1f 91       	pop	r17
    240c:	0f 91       	pop	r16
    240e:	08 95       	ret

00002410 <xTaskPriorityDisinherit>:
    2410:	0f 93       	push	r16
    2412:	1f 93       	push	r17
    2414:	cf 93       	push	r28
    2416:	df 93       	push	r29
    2418:	fc 01       	movw	r30, r24
    241a:	89 2b       	or	r24, r25
    241c:	79 f1       	breq	.+94     	; 0x247c <xTaskPriorityDisinherit+0x6c>
    241e:	82 a1       	ldd	r24, Z+34	; 0x22
    2420:	81 50       	subi	r24, 0x01	; 1
    2422:	82 a3       	std	Z+34, r24	; 0x22
    2424:	26 89       	ldd	r18, Z+22	; 0x16
    2426:	91 a1       	ldd	r25, Z+33	; 0x21
    2428:	29 17       	cp	r18, r25
    242a:	51 f1       	breq	.+84     	; 0x2480 <xTaskPriorityDisinherit+0x70>
    242c:	81 11       	cpse	r24, r1
    242e:	2a c0       	rjmp	.+84     	; 0x2484 <xTaskPriorityDisinherit+0x74>
    2430:	ef 01       	movw	r28, r30
    2432:	8f 01       	movw	r16, r30
    2434:	0e 5f       	subi	r16, 0xFE	; 254
    2436:	1f 4f       	sbci	r17, 0xFF	; 255
    2438:	c8 01       	movw	r24, r16
    243a:	0e 94 4f 03 	call	0x69e	; 0x69e <uxListRemove>
    243e:	89 a1       	ldd	r24, Y+33	; 0x21
    2440:	8e 8b       	std	Y+22, r24	; 0x16
    2442:	24 e0       	ldi	r18, 0x04	; 4
    2444:	30 e0       	ldi	r19, 0x00	; 0
    2446:	28 1b       	sub	r18, r24
    2448:	31 09       	sbc	r19, r1
    244a:	3d 87       	std	Y+13, r19	; 0x0d
    244c:	2c 87       	std	Y+12, r18	; 0x0c
    244e:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <uxTopReadyPriority>
    2452:	98 17       	cp	r25, r24
    2454:	10 f4       	brcc	.+4      	; 0x245a <xTaskPriorityDisinherit+0x4a>
    2456:	80 93 be 02 	sts	0x02BE, r24	; 0x8002be <uxTopReadyPriority>
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	9c 01       	movw	r18, r24
    245e:	22 0f       	add	r18, r18
    2460:	33 1f       	adc	r19, r19
    2462:	22 0f       	add	r18, r18
    2464:	33 1f       	adc	r19, r19
    2466:	22 0f       	add	r18, r18
    2468:	33 1f       	adc	r19, r19
    246a:	82 0f       	add	r24, r18
    246c:	93 1f       	adc	r25, r19
    246e:	b8 01       	movw	r22, r16
    2470:	8c 50       	subi	r24, 0x0C	; 12
    2472:	9d 4f       	sbci	r25, 0xFD	; 253
    2474:	0e 94 fd 02 	call	0x5fa	; 0x5fa <vListInsertEnd>
    2478:	81 e0       	ldi	r24, 0x01	; 1
    247a:	05 c0       	rjmp	.+10     	; 0x2486 <xTaskPriorityDisinherit+0x76>
    247c:	80 e0       	ldi	r24, 0x00	; 0
    247e:	03 c0       	rjmp	.+6      	; 0x2486 <xTaskPriorityDisinherit+0x76>
    2480:	80 e0       	ldi	r24, 0x00	; 0
    2482:	01 c0       	rjmp	.+2      	; 0x2486 <xTaskPriorityDisinherit+0x76>
    2484:	80 e0       	ldi	r24, 0x00	; 0
    2486:	df 91       	pop	r29
    2488:	cf 91       	pop	r28
    248a:	1f 91       	pop	r17
    248c:	0f 91       	pop	r16
    248e:	08 95       	ret

00002490 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2490:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <pxCurrentTCB>
    2494:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    2498:	89 2b       	or	r24, r25
    249a:	39 f0       	breq	.+14     	; 0x24aa <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    249c:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <pxCurrentTCB>
    24a0:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
    24a4:	82 a1       	ldd	r24, Z+34	; 0x22
    24a6:	8f 5f       	subi	r24, 0xFF	; 255
    24a8:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    24aa:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <pxCurrentTCB>
    24ae:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <pxCurrentTCB+0x1>
	}
    24b2:	08 95       	ret

000024b4 <__subsf3>:
    24b4:	50 58       	subi	r21, 0x80	; 128

000024b6 <__addsf3>:
    24b6:	bb 27       	eor	r27, r27
    24b8:	aa 27       	eor	r26, r26
    24ba:	0e d0       	rcall	.+28     	; 0x24d8 <__addsf3x>
    24bc:	e5 c0       	rjmp	.+458    	; 0x2688 <__fp_round>
    24be:	d6 d0       	rcall	.+428    	; 0x266c <__fp_pscA>
    24c0:	30 f0       	brcs	.+12     	; 0x24ce <__addsf3+0x18>
    24c2:	db d0       	rcall	.+438    	; 0x267a <__fp_pscB>
    24c4:	20 f0       	brcs	.+8      	; 0x24ce <__addsf3+0x18>
    24c6:	31 f4       	brne	.+12     	; 0x24d4 <__addsf3+0x1e>
    24c8:	9f 3f       	cpi	r25, 0xFF	; 255
    24ca:	11 f4       	brne	.+4      	; 0x24d0 <__addsf3+0x1a>
    24cc:	1e f4       	brtc	.+6      	; 0x24d4 <__addsf3+0x1e>
    24ce:	cb c0       	rjmp	.+406    	; 0x2666 <__fp_nan>
    24d0:	0e f4       	brtc	.+2      	; 0x24d4 <__addsf3+0x1e>
    24d2:	e0 95       	com	r30
    24d4:	e7 fb       	bst	r30, 7
    24d6:	c1 c0       	rjmp	.+386    	; 0x265a <__fp_inf>

000024d8 <__addsf3x>:
    24d8:	e9 2f       	mov	r30, r25
    24da:	e7 d0       	rcall	.+462    	; 0x26aa <__fp_split3>
    24dc:	80 f3       	brcs	.-32     	; 0x24be <__addsf3+0x8>
    24de:	ba 17       	cp	r27, r26
    24e0:	62 07       	cpc	r22, r18
    24e2:	73 07       	cpc	r23, r19
    24e4:	84 07       	cpc	r24, r20
    24e6:	95 07       	cpc	r25, r21
    24e8:	18 f0       	brcs	.+6      	; 0x24f0 <__addsf3x+0x18>
    24ea:	71 f4       	brne	.+28     	; 0x2508 <__addsf3x+0x30>
    24ec:	9e f5       	brtc	.+102    	; 0x2554 <__addsf3x+0x7c>
    24ee:	ff c0       	rjmp	.+510    	; 0x26ee <__fp_zero>
    24f0:	0e f4       	brtc	.+2      	; 0x24f4 <__addsf3x+0x1c>
    24f2:	e0 95       	com	r30
    24f4:	0b 2e       	mov	r0, r27
    24f6:	ba 2f       	mov	r27, r26
    24f8:	a0 2d       	mov	r26, r0
    24fa:	0b 01       	movw	r0, r22
    24fc:	b9 01       	movw	r22, r18
    24fe:	90 01       	movw	r18, r0
    2500:	0c 01       	movw	r0, r24
    2502:	ca 01       	movw	r24, r20
    2504:	a0 01       	movw	r20, r0
    2506:	11 24       	eor	r1, r1
    2508:	ff 27       	eor	r31, r31
    250a:	59 1b       	sub	r21, r25
    250c:	99 f0       	breq	.+38     	; 0x2534 <__addsf3x+0x5c>
    250e:	59 3f       	cpi	r21, 0xF9	; 249
    2510:	50 f4       	brcc	.+20     	; 0x2526 <__addsf3x+0x4e>
    2512:	50 3e       	cpi	r21, 0xE0	; 224
    2514:	68 f1       	brcs	.+90     	; 0x2570 <__addsf3x+0x98>
    2516:	1a 16       	cp	r1, r26
    2518:	f0 40       	sbci	r31, 0x00	; 0
    251a:	a2 2f       	mov	r26, r18
    251c:	23 2f       	mov	r18, r19
    251e:	34 2f       	mov	r19, r20
    2520:	44 27       	eor	r20, r20
    2522:	58 5f       	subi	r21, 0xF8	; 248
    2524:	f3 cf       	rjmp	.-26     	; 0x250c <__addsf3x+0x34>
    2526:	46 95       	lsr	r20
    2528:	37 95       	ror	r19
    252a:	27 95       	ror	r18
    252c:	a7 95       	ror	r26
    252e:	f0 40       	sbci	r31, 0x00	; 0
    2530:	53 95       	inc	r21
    2532:	c9 f7       	brne	.-14     	; 0x2526 <__addsf3x+0x4e>
    2534:	7e f4       	brtc	.+30     	; 0x2554 <__addsf3x+0x7c>
    2536:	1f 16       	cp	r1, r31
    2538:	ba 0b       	sbc	r27, r26
    253a:	62 0b       	sbc	r22, r18
    253c:	73 0b       	sbc	r23, r19
    253e:	84 0b       	sbc	r24, r20
    2540:	ba f0       	brmi	.+46     	; 0x2570 <__addsf3x+0x98>
    2542:	91 50       	subi	r25, 0x01	; 1
    2544:	a1 f0       	breq	.+40     	; 0x256e <__addsf3x+0x96>
    2546:	ff 0f       	add	r31, r31
    2548:	bb 1f       	adc	r27, r27
    254a:	66 1f       	adc	r22, r22
    254c:	77 1f       	adc	r23, r23
    254e:	88 1f       	adc	r24, r24
    2550:	c2 f7       	brpl	.-16     	; 0x2542 <__addsf3x+0x6a>
    2552:	0e c0       	rjmp	.+28     	; 0x2570 <__addsf3x+0x98>
    2554:	ba 0f       	add	r27, r26
    2556:	62 1f       	adc	r22, r18
    2558:	73 1f       	adc	r23, r19
    255a:	84 1f       	adc	r24, r20
    255c:	48 f4       	brcc	.+18     	; 0x2570 <__addsf3x+0x98>
    255e:	87 95       	ror	r24
    2560:	77 95       	ror	r23
    2562:	67 95       	ror	r22
    2564:	b7 95       	ror	r27
    2566:	f7 95       	ror	r31
    2568:	9e 3f       	cpi	r25, 0xFE	; 254
    256a:	08 f0       	brcs	.+2      	; 0x256e <__addsf3x+0x96>
    256c:	b3 cf       	rjmp	.-154    	; 0x24d4 <__addsf3+0x1e>
    256e:	93 95       	inc	r25
    2570:	88 0f       	add	r24, r24
    2572:	08 f0       	brcs	.+2      	; 0x2576 <__addsf3x+0x9e>
    2574:	99 27       	eor	r25, r25
    2576:	ee 0f       	add	r30, r30
    2578:	97 95       	ror	r25
    257a:	87 95       	ror	r24
    257c:	08 95       	ret

0000257e <__fixsfsi>:
    257e:	04 d0       	rcall	.+8      	; 0x2588 <__fixunssfsi>
    2580:	68 94       	set
    2582:	b1 11       	cpse	r27, r1
    2584:	b5 c0       	rjmp	.+362    	; 0x26f0 <__fp_szero>
    2586:	08 95       	ret

00002588 <__fixunssfsi>:
    2588:	98 d0       	rcall	.+304    	; 0x26ba <__fp_splitA>
    258a:	88 f0       	brcs	.+34     	; 0x25ae <__fixunssfsi+0x26>
    258c:	9f 57       	subi	r25, 0x7F	; 127
    258e:	90 f0       	brcs	.+36     	; 0x25b4 <__fixunssfsi+0x2c>
    2590:	b9 2f       	mov	r27, r25
    2592:	99 27       	eor	r25, r25
    2594:	b7 51       	subi	r27, 0x17	; 23
    2596:	a0 f0       	brcs	.+40     	; 0x25c0 <__fixunssfsi+0x38>
    2598:	d1 f0       	breq	.+52     	; 0x25ce <__fixunssfsi+0x46>
    259a:	66 0f       	add	r22, r22
    259c:	77 1f       	adc	r23, r23
    259e:	88 1f       	adc	r24, r24
    25a0:	99 1f       	adc	r25, r25
    25a2:	1a f0       	brmi	.+6      	; 0x25aa <__fixunssfsi+0x22>
    25a4:	ba 95       	dec	r27
    25a6:	c9 f7       	brne	.-14     	; 0x259a <__fixunssfsi+0x12>
    25a8:	12 c0       	rjmp	.+36     	; 0x25ce <__fixunssfsi+0x46>
    25aa:	b1 30       	cpi	r27, 0x01	; 1
    25ac:	81 f0       	breq	.+32     	; 0x25ce <__fixunssfsi+0x46>
    25ae:	9f d0       	rcall	.+318    	; 0x26ee <__fp_zero>
    25b0:	b1 e0       	ldi	r27, 0x01	; 1
    25b2:	08 95       	ret
    25b4:	9c c0       	rjmp	.+312    	; 0x26ee <__fp_zero>
    25b6:	67 2f       	mov	r22, r23
    25b8:	78 2f       	mov	r23, r24
    25ba:	88 27       	eor	r24, r24
    25bc:	b8 5f       	subi	r27, 0xF8	; 248
    25be:	39 f0       	breq	.+14     	; 0x25ce <__fixunssfsi+0x46>
    25c0:	b9 3f       	cpi	r27, 0xF9	; 249
    25c2:	cc f3       	brlt	.-14     	; 0x25b6 <__fixunssfsi+0x2e>
    25c4:	86 95       	lsr	r24
    25c6:	77 95       	ror	r23
    25c8:	67 95       	ror	r22
    25ca:	b3 95       	inc	r27
    25cc:	d9 f7       	brne	.-10     	; 0x25c4 <__fixunssfsi+0x3c>
    25ce:	3e f4       	brtc	.+14     	; 0x25de <__fixunssfsi+0x56>
    25d0:	90 95       	com	r25
    25d2:	80 95       	com	r24
    25d4:	70 95       	com	r23
    25d6:	61 95       	neg	r22
    25d8:	7f 4f       	sbci	r23, 0xFF	; 255
    25da:	8f 4f       	sbci	r24, 0xFF	; 255
    25dc:	9f 4f       	sbci	r25, 0xFF	; 255
    25de:	08 95       	ret

000025e0 <__floatunsisf>:
    25e0:	e8 94       	clt
    25e2:	09 c0       	rjmp	.+18     	; 0x25f6 <__floatsisf+0x12>

000025e4 <__floatsisf>:
    25e4:	97 fb       	bst	r25, 7
    25e6:	3e f4       	brtc	.+14     	; 0x25f6 <__floatsisf+0x12>
    25e8:	90 95       	com	r25
    25ea:	80 95       	com	r24
    25ec:	70 95       	com	r23
    25ee:	61 95       	neg	r22
    25f0:	7f 4f       	sbci	r23, 0xFF	; 255
    25f2:	8f 4f       	sbci	r24, 0xFF	; 255
    25f4:	9f 4f       	sbci	r25, 0xFF	; 255
    25f6:	99 23       	and	r25, r25
    25f8:	a9 f0       	breq	.+42     	; 0x2624 <__floatsisf+0x40>
    25fa:	f9 2f       	mov	r31, r25
    25fc:	96 e9       	ldi	r25, 0x96	; 150
    25fe:	bb 27       	eor	r27, r27
    2600:	93 95       	inc	r25
    2602:	f6 95       	lsr	r31
    2604:	87 95       	ror	r24
    2606:	77 95       	ror	r23
    2608:	67 95       	ror	r22
    260a:	b7 95       	ror	r27
    260c:	f1 11       	cpse	r31, r1
    260e:	f8 cf       	rjmp	.-16     	; 0x2600 <__floatsisf+0x1c>
    2610:	fa f4       	brpl	.+62     	; 0x2650 <__floatsisf+0x6c>
    2612:	bb 0f       	add	r27, r27
    2614:	11 f4       	brne	.+4      	; 0x261a <__floatsisf+0x36>
    2616:	60 ff       	sbrs	r22, 0
    2618:	1b c0       	rjmp	.+54     	; 0x2650 <__floatsisf+0x6c>
    261a:	6f 5f       	subi	r22, 0xFF	; 255
    261c:	7f 4f       	sbci	r23, 0xFF	; 255
    261e:	8f 4f       	sbci	r24, 0xFF	; 255
    2620:	9f 4f       	sbci	r25, 0xFF	; 255
    2622:	16 c0       	rjmp	.+44     	; 0x2650 <__floatsisf+0x6c>
    2624:	88 23       	and	r24, r24
    2626:	11 f0       	breq	.+4      	; 0x262c <__floatsisf+0x48>
    2628:	96 e9       	ldi	r25, 0x96	; 150
    262a:	11 c0       	rjmp	.+34     	; 0x264e <__floatsisf+0x6a>
    262c:	77 23       	and	r23, r23
    262e:	21 f0       	breq	.+8      	; 0x2638 <__floatsisf+0x54>
    2630:	9e e8       	ldi	r25, 0x8E	; 142
    2632:	87 2f       	mov	r24, r23
    2634:	76 2f       	mov	r23, r22
    2636:	05 c0       	rjmp	.+10     	; 0x2642 <__floatsisf+0x5e>
    2638:	66 23       	and	r22, r22
    263a:	71 f0       	breq	.+28     	; 0x2658 <__floatsisf+0x74>
    263c:	96 e8       	ldi	r25, 0x86	; 134
    263e:	86 2f       	mov	r24, r22
    2640:	70 e0       	ldi	r23, 0x00	; 0
    2642:	60 e0       	ldi	r22, 0x00	; 0
    2644:	2a f0       	brmi	.+10     	; 0x2650 <__floatsisf+0x6c>
    2646:	9a 95       	dec	r25
    2648:	66 0f       	add	r22, r22
    264a:	77 1f       	adc	r23, r23
    264c:	88 1f       	adc	r24, r24
    264e:	da f7       	brpl	.-10     	; 0x2646 <__floatsisf+0x62>
    2650:	88 0f       	add	r24, r24
    2652:	96 95       	lsr	r25
    2654:	87 95       	ror	r24
    2656:	97 f9       	bld	r25, 7
    2658:	08 95       	ret

0000265a <__fp_inf>:
    265a:	97 f9       	bld	r25, 7
    265c:	9f 67       	ori	r25, 0x7F	; 127
    265e:	80 e8       	ldi	r24, 0x80	; 128
    2660:	70 e0       	ldi	r23, 0x00	; 0
    2662:	60 e0       	ldi	r22, 0x00	; 0
    2664:	08 95       	ret

00002666 <__fp_nan>:
    2666:	9f ef       	ldi	r25, 0xFF	; 255
    2668:	80 ec       	ldi	r24, 0xC0	; 192
    266a:	08 95       	ret

0000266c <__fp_pscA>:
    266c:	00 24       	eor	r0, r0
    266e:	0a 94       	dec	r0
    2670:	16 16       	cp	r1, r22
    2672:	17 06       	cpc	r1, r23
    2674:	18 06       	cpc	r1, r24
    2676:	09 06       	cpc	r0, r25
    2678:	08 95       	ret

0000267a <__fp_pscB>:
    267a:	00 24       	eor	r0, r0
    267c:	0a 94       	dec	r0
    267e:	12 16       	cp	r1, r18
    2680:	13 06       	cpc	r1, r19
    2682:	14 06       	cpc	r1, r20
    2684:	05 06       	cpc	r0, r21
    2686:	08 95       	ret

00002688 <__fp_round>:
    2688:	09 2e       	mov	r0, r25
    268a:	03 94       	inc	r0
    268c:	00 0c       	add	r0, r0
    268e:	11 f4       	brne	.+4      	; 0x2694 <__fp_round+0xc>
    2690:	88 23       	and	r24, r24
    2692:	52 f0       	brmi	.+20     	; 0x26a8 <__fp_round+0x20>
    2694:	bb 0f       	add	r27, r27
    2696:	40 f4       	brcc	.+16     	; 0x26a8 <__fp_round+0x20>
    2698:	bf 2b       	or	r27, r31
    269a:	11 f4       	brne	.+4      	; 0x26a0 <__fp_round+0x18>
    269c:	60 ff       	sbrs	r22, 0
    269e:	04 c0       	rjmp	.+8      	; 0x26a8 <__fp_round+0x20>
    26a0:	6f 5f       	subi	r22, 0xFF	; 255
    26a2:	7f 4f       	sbci	r23, 0xFF	; 255
    26a4:	8f 4f       	sbci	r24, 0xFF	; 255
    26a6:	9f 4f       	sbci	r25, 0xFF	; 255
    26a8:	08 95       	ret

000026aa <__fp_split3>:
    26aa:	57 fd       	sbrc	r21, 7
    26ac:	90 58       	subi	r25, 0x80	; 128
    26ae:	44 0f       	add	r20, r20
    26b0:	55 1f       	adc	r21, r21
    26b2:	59 f0       	breq	.+22     	; 0x26ca <__fp_splitA+0x10>
    26b4:	5f 3f       	cpi	r21, 0xFF	; 255
    26b6:	71 f0       	breq	.+28     	; 0x26d4 <__fp_splitA+0x1a>
    26b8:	47 95       	ror	r20

000026ba <__fp_splitA>:
    26ba:	88 0f       	add	r24, r24
    26bc:	97 fb       	bst	r25, 7
    26be:	99 1f       	adc	r25, r25
    26c0:	61 f0       	breq	.+24     	; 0x26da <__fp_splitA+0x20>
    26c2:	9f 3f       	cpi	r25, 0xFF	; 255
    26c4:	79 f0       	breq	.+30     	; 0x26e4 <__fp_splitA+0x2a>
    26c6:	87 95       	ror	r24
    26c8:	08 95       	ret
    26ca:	12 16       	cp	r1, r18
    26cc:	13 06       	cpc	r1, r19
    26ce:	14 06       	cpc	r1, r20
    26d0:	55 1f       	adc	r21, r21
    26d2:	f2 cf       	rjmp	.-28     	; 0x26b8 <__fp_split3+0xe>
    26d4:	46 95       	lsr	r20
    26d6:	f1 df       	rcall	.-30     	; 0x26ba <__fp_splitA>
    26d8:	08 c0       	rjmp	.+16     	; 0x26ea <__fp_splitA+0x30>
    26da:	16 16       	cp	r1, r22
    26dc:	17 06       	cpc	r1, r23
    26de:	18 06       	cpc	r1, r24
    26e0:	99 1f       	adc	r25, r25
    26e2:	f1 cf       	rjmp	.-30     	; 0x26c6 <__fp_splitA+0xc>
    26e4:	86 95       	lsr	r24
    26e6:	71 05       	cpc	r23, r1
    26e8:	61 05       	cpc	r22, r1
    26ea:	08 94       	sec
    26ec:	08 95       	ret

000026ee <__fp_zero>:
    26ee:	e8 94       	clt

000026f0 <__fp_szero>:
    26f0:	bb 27       	eor	r27, r27
    26f2:	66 27       	eor	r22, r22
    26f4:	77 27       	eor	r23, r23
    26f6:	cb 01       	movw	r24, r22
    26f8:	97 f9       	bld	r25, 7
    26fa:	08 95       	ret

000026fc <__mulsf3>:
    26fc:	0b d0       	rcall	.+22     	; 0x2714 <__mulsf3x>
    26fe:	c4 cf       	rjmp	.-120    	; 0x2688 <__fp_round>
    2700:	b5 df       	rcall	.-150    	; 0x266c <__fp_pscA>
    2702:	28 f0       	brcs	.+10     	; 0x270e <__mulsf3+0x12>
    2704:	ba df       	rcall	.-140    	; 0x267a <__fp_pscB>
    2706:	18 f0       	brcs	.+6      	; 0x270e <__mulsf3+0x12>
    2708:	95 23       	and	r25, r21
    270a:	09 f0       	breq	.+2      	; 0x270e <__mulsf3+0x12>
    270c:	a6 cf       	rjmp	.-180    	; 0x265a <__fp_inf>
    270e:	ab cf       	rjmp	.-170    	; 0x2666 <__fp_nan>
    2710:	11 24       	eor	r1, r1
    2712:	ee cf       	rjmp	.-36     	; 0x26f0 <__fp_szero>

00002714 <__mulsf3x>:
    2714:	ca df       	rcall	.-108    	; 0x26aa <__fp_split3>
    2716:	a0 f3       	brcs	.-24     	; 0x2700 <__mulsf3+0x4>

00002718 <__mulsf3_pse>:
    2718:	95 9f       	mul	r25, r21
    271a:	d1 f3       	breq	.-12     	; 0x2710 <__mulsf3+0x14>
    271c:	95 0f       	add	r25, r21
    271e:	50 e0       	ldi	r21, 0x00	; 0
    2720:	55 1f       	adc	r21, r21
    2722:	62 9f       	mul	r22, r18
    2724:	f0 01       	movw	r30, r0
    2726:	72 9f       	mul	r23, r18
    2728:	bb 27       	eor	r27, r27
    272a:	f0 0d       	add	r31, r0
    272c:	b1 1d       	adc	r27, r1
    272e:	63 9f       	mul	r22, r19
    2730:	aa 27       	eor	r26, r26
    2732:	f0 0d       	add	r31, r0
    2734:	b1 1d       	adc	r27, r1
    2736:	aa 1f       	adc	r26, r26
    2738:	64 9f       	mul	r22, r20
    273a:	66 27       	eor	r22, r22
    273c:	b0 0d       	add	r27, r0
    273e:	a1 1d       	adc	r26, r1
    2740:	66 1f       	adc	r22, r22
    2742:	82 9f       	mul	r24, r18
    2744:	22 27       	eor	r18, r18
    2746:	b0 0d       	add	r27, r0
    2748:	a1 1d       	adc	r26, r1
    274a:	62 1f       	adc	r22, r18
    274c:	73 9f       	mul	r23, r19
    274e:	b0 0d       	add	r27, r0
    2750:	a1 1d       	adc	r26, r1
    2752:	62 1f       	adc	r22, r18
    2754:	83 9f       	mul	r24, r19
    2756:	a0 0d       	add	r26, r0
    2758:	61 1d       	adc	r22, r1
    275a:	22 1f       	adc	r18, r18
    275c:	74 9f       	mul	r23, r20
    275e:	33 27       	eor	r19, r19
    2760:	a0 0d       	add	r26, r0
    2762:	61 1d       	adc	r22, r1
    2764:	23 1f       	adc	r18, r19
    2766:	84 9f       	mul	r24, r20
    2768:	60 0d       	add	r22, r0
    276a:	21 1d       	adc	r18, r1
    276c:	82 2f       	mov	r24, r18
    276e:	76 2f       	mov	r23, r22
    2770:	6a 2f       	mov	r22, r26
    2772:	11 24       	eor	r1, r1
    2774:	9f 57       	subi	r25, 0x7F	; 127
    2776:	50 40       	sbci	r21, 0x00	; 0
    2778:	8a f0       	brmi	.+34     	; 0x279c <__mulsf3_pse+0x84>
    277a:	e1 f0       	breq	.+56     	; 0x27b4 <__mulsf3_pse+0x9c>
    277c:	88 23       	and	r24, r24
    277e:	4a f0       	brmi	.+18     	; 0x2792 <__mulsf3_pse+0x7a>
    2780:	ee 0f       	add	r30, r30
    2782:	ff 1f       	adc	r31, r31
    2784:	bb 1f       	adc	r27, r27
    2786:	66 1f       	adc	r22, r22
    2788:	77 1f       	adc	r23, r23
    278a:	88 1f       	adc	r24, r24
    278c:	91 50       	subi	r25, 0x01	; 1
    278e:	50 40       	sbci	r21, 0x00	; 0
    2790:	a9 f7       	brne	.-22     	; 0x277c <__mulsf3_pse+0x64>
    2792:	9e 3f       	cpi	r25, 0xFE	; 254
    2794:	51 05       	cpc	r21, r1
    2796:	70 f0       	brcs	.+28     	; 0x27b4 <__mulsf3_pse+0x9c>
    2798:	60 cf       	rjmp	.-320    	; 0x265a <__fp_inf>
    279a:	aa cf       	rjmp	.-172    	; 0x26f0 <__fp_szero>
    279c:	5f 3f       	cpi	r21, 0xFF	; 255
    279e:	ec f3       	brlt	.-6      	; 0x279a <__mulsf3_pse+0x82>
    27a0:	98 3e       	cpi	r25, 0xE8	; 232
    27a2:	dc f3       	brlt	.-10     	; 0x279a <__mulsf3_pse+0x82>
    27a4:	86 95       	lsr	r24
    27a6:	77 95       	ror	r23
    27a8:	67 95       	ror	r22
    27aa:	b7 95       	ror	r27
    27ac:	f7 95       	ror	r31
    27ae:	e7 95       	ror	r30
    27b0:	9f 5f       	subi	r25, 0xFF	; 255
    27b2:	c1 f7       	brne	.-16     	; 0x27a4 <__mulsf3_pse+0x8c>
    27b4:	fe 2b       	or	r31, r30
    27b6:	88 0f       	add	r24, r24
    27b8:	91 1d       	adc	r25, r1
    27ba:	96 95       	lsr	r25
    27bc:	87 95       	ror	r24
    27be:	97 f9       	bld	r25, 7
    27c0:	08 95       	ret

000027c2 <__udivmodsi4>:
    27c2:	a1 e2       	ldi	r26, 0x21	; 33
    27c4:	1a 2e       	mov	r1, r26
    27c6:	aa 1b       	sub	r26, r26
    27c8:	bb 1b       	sub	r27, r27
    27ca:	fd 01       	movw	r30, r26
    27cc:	0d c0       	rjmp	.+26     	; 0x27e8 <__udivmodsi4_ep>

000027ce <__udivmodsi4_loop>:
    27ce:	aa 1f       	adc	r26, r26
    27d0:	bb 1f       	adc	r27, r27
    27d2:	ee 1f       	adc	r30, r30
    27d4:	ff 1f       	adc	r31, r31
    27d6:	a2 17       	cp	r26, r18
    27d8:	b3 07       	cpc	r27, r19
    27da:	e4 07       	cpc	r30, r20
    27dc:	f5 07       	cpc	r31, r21
    27de:	20 f0       	brcs	.+8      	; 0x27e8 <__udivmodsi4_ep>
    27e0:	a2 1b       	sub	r26, r18
    27e2:	b3 0b       	sbc	r27, r19
    27e4:	e4 0b       	sbc	r30, r20
    27e6:	f5 0b       	sbc	r31, r21

000027e8 <__udivmodsi4_ep>:
    27e8:	66 1f       	adc	r22, r22
    27ea:	77 1f       	adc	r23, r23
    27ec:	88 1f       	adc	r24, r24
    27ee:	99 1f       	adc	r25, r25
    27f0:	1a 94       	dec	r1
    27f2:	69 f7       	brne	.-38     	; 0x27ce <__udivmodsi4_loop>
    27f4:	60 95       	com	r22
    27f6:	70 95       	com	r23
    27f8:	80 95       	com	r24
    27fa:	90 95       	com	r25
    27fc:	9b 01       	movw	r18, r22
    27fe:	ac 01       	movw	r20, r24
    2800:	bd 01       	movw	r22, r26
    2802:	cf 01       	movw	r24, r30
    2804:	08 95       	ret

00002806 <__tablejump2__>:
    2806:	ee 0f       	add	r30, r30
    2808:	ff 1f       	adc	r31, r31
    280a:	88 1f       	adc	r24, r24
    280c:	8b bf       	out	0x3b, r24	; 59
    280e:	07 90       	elpm	r0, Z+
    2810:	f6 91       	elpm	r31, Z
    2812:	e0 2d       	mov	r30, r0
    2814:	19 94       	eijmp

00002816 <__umulhisi3>:
    2816:	a2 9f       	mul	r26, r18
    2818:	b0 01       	movw	r22, r0
    281a:	b3 9f       	mul	r27, r19
    281c:	c0 01       	movw	r24, r0
    281e:	a3 9f       	mul	r26, r19
    2820:	70 0d       	add	r23, r0
    2822:	81 1d       	adc	r24, r1
    2824:	11 24       	eor	r1, r1
    2826:	91 1d       	adc	r25, r1
    2828:	b2 9f       	mul	r27, r18
    282a:	70 0d       	add	r23, r0
    282c:	81 1d       	adc	r24, r1
    282e:	11 24       	eor	r1, r1
    2830:	91 1d       	adc	r25, r1
    2832:	08 95       	ret

00002834 <__muluhisi3>:
    2834:	f0 df       	rcall	.-32     	; 0x2816 <__umulhisi3>
    2836:	a5 9f       	mul	r26, r21
    2838:	90 0d       	add	r25, r0
    283a:	b4 9f       	mul	r27, r20
    283c:	90 0d       	add	r25, r0
    283e:	a4 9f       	mul	r26, r20
    2840:	80 0d       	add	r24, r0
    2842:	91 1d       	adc	r25, r1
    2844:	11 24       	eor	r1, r1
    2846:	08 95       	ret

00002848 <malloc>:
    2848:	0f 93       	push	r16
    284a:	1f 93       	push	r17
    284c:	cf 93       	push	r28
    284e:	df 93       	push	r29
    2850:	82 30       	cpi	r24, 0x02	; 2
    2852:	91 05       	cpc	r25, r1
    2854:	10 f4       	brcc	.+4      	; 0x285a <malloc+0x12>
    2856:	82 e0       	ldi	r24, 0x02	; 2
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <__flp>
    285e:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <__flp+0x1>
    2862:	20 e0       	ldi	r18, 0x00	; 0
    2864:	30 e0       	ldi	r19, 0x00	; 0
    2866:	a0 e0       	ldi	r26, 0x00	; 0
    2868:	b0 e0       	ldi	r27, 0x00	; 0
    286a:	30 97       	sbiw	r30, 0x00	; 0
    286c:	19 f1       	breq	.+70     	; 0x28b4 <malloc+0x6c>
    286e:	40 81       	ld	r20, Z
    2870:	51 81       	ldd	r21, Z+1	; 0x01
    2872:	02 81       	ldd	r16, Z+2	; 0x02
    2874:	13 81       	ldd	r17, Z+3	; 0x03
    2876:	48 17       	cp	r20, r24
    2878:	59 07       	cpc	r21, r25
    287a:	c8 f0       	brcs	.+50     	; 0x28ae <malloc+0x66>
    287c:	84 17       	cp	r24, r20
    287e:	95 07       	cpc	r25, r21
    2880:	69 f4       	brne	.+26     	; 0x289c <malloc+0x54>
    2882:	10 97       	sbiw	r26, 0x00	; 0
    2884:	31 f0       	breq	.+12     	; 0x2892 <malloc+0x4a>
    2886:	12 96       	adiw	r26, 0x02	; 2
    2888:	0c 93       	st	X, r16
    288a:	12 97       	sbiw	r26, 0x02	; 2
    288c:	13 96       	adiw	r26, 0x03	; 3
    288e:	1c 93       	st	X, r17
    2890:	27 c0       	rjmp	.+78     	; 0x28e0 <malloc+0x98>
    2892:	00 93 bd 04 	sts	0x04BD, r16	; 0x8004bd <__flp>
    2896:	10 93 be 04 	sts	0x04BE, r17	; 0x8004be <__flp+0x1>
    289a:	22 c0       	rjmp	.+68     	; 0x28e0 <malloc+0x98>
    289c:	21 15       	cp	r18, r1
    289e:	31 05       	cpc	r19, r1
    28a0:	19 f0       	breq	.+6      	; 0x28a8 <malloc+0x60>
    28a2:	42 17       	cp	r20, r18
    28a4:	53 07       	cpc	r21, r19
    28a6:	18 f4       	brcc	.+6      	; 0x28ae <malloc+0x66>
    28a8:	9a 01       	movw	r18, r20
    28aa:	bd 01       	movw	r22, r26
    28ac:	ef 01       	movw	r28, r30
    28ae:	df 01       	movw	r26, r30
    28b0:	f8 01       	movw	r30, r16
    28b2:	db cf       	rjmp	.-74     	; 0x286a <malloc+0x22>
    28b4:	21 15       	cp	r18, r1
    28b6:	31 05       	cpc	r19, r1
    28b8:	f9 f0       	breq	.+62     	; 0x28f8 <malloc+0xb0>
    28ba:	28 1b       	sub	r18, r24
    28bc:	39 0b       	sbc	r19, r25
    28be:	24 30       	cpi	r18, 0x04	; 4
    28c0:	31 05       	cpc	r19, r1
    28c2:	80 f4       	brcc	.+32     	; 0x28e4 <malloc+0x9c>
    28c4:	8a 81       	ldd	r24, Y+2	; 0x02
    28c6:	9b 81       	ldd	r25, Y+3	; 0x03
    28c8:	61 15       	cp	r22, r1
    28ca:	71 05       	cpc	r23, r1
    28cc:	21 f0       	breq	.+8      	; 0x28d6 <malloc+0x8e>
    28ce:	fb 01       	movw	r30, r22
    28d0:	93 83       	std	Z+3, r25	; 0x03
    28d2:	82 83       	std	Z+2, r24	; 0x02
    28d4:	04 c0       	rjmp	.+8      	; 0x28de <malloc+0x96>
    28d6:	90 93 be 04 	sts	0x04BE, r25	; 0x8004be <__flp+0x1>
    28da:	80 93 bd 04 	sts	0x04BD, r24	; 0x8004bd <__flp>
    28de:	fe 01       	movw	r30, r28
    28e0:	32 96       	adiw	r30, 0x02	; 2
    28e2:	44 c0       	rjmp	.+136    	; 0x296c <malloc+0x124>
    28e4:	fe 01       	movw	r30, r28
    28e6:	e2 0f       	add	r30, r18
    28e8:	f3 1f       	adc	r31, r19
    28ea:	81 93       	st	Z+, r24
    28ec:	91 93       	st	Z+, r25
    28ee:	22 50       	subi	r18, 0x02	; 2
    28f0:	31 09       	sbc	r19, r1
    28f2:	39 83       	std	Y+1, r19	; 0x01
    28f4:	28 83       	st	Y, r18
    28f6:	3a c0       	rjmp	.+116    	; 0x296c <malloc+0x124>
    28f8:	20 91 bb 04 	lds	r18, 0x04BB	; 0x8004bb <__brkval>
    28fc:	30 91 bc 04 	lds	r19, 0x04BC	; 0x8004bc <__brkval+0x1>
    2900:	23 2b       	or	r18, r19
    2902:	41 f4       	brne	.+16     	; 0x2914 <malloc+0xcc>
    2904:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2908:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    290c:	30 93 bc 04 	sts	0x04BC, r19	; 0x8004bc <__brkval+0x1>
    2910:	20 93 bb 04 	sts	0x04BB, r18	; 0x8004bb <__brkval>
    2914:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2918:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    291c:	21 15       	cp	r18, r1
    291e:	31 05       	cpc	r19, r1
    2920:	41 f4       	brne	.+16     	; 0x2932 <malloc+0xea>
    2922:	2d b7       	in	r18, 0x3d	; 61
    2924:	3e b7       	in	r19, 0x3e	; 62
    2926:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    292a:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    292e:	24 1b       	sub	r18, r20
    2930:	35 0b       	sbc	r19, r21
    2932:	e0 91 bb 04 	lds	r30, 0x04BB	; 0x8004bb <__brkval>
    2936:	f0 91 bc 04 	lds	r31, 0x04BC	; 0x8004bc <__brkval+0x1>
    293a:	e2 17       	cp	r30, r18
    293c:	f3 07       	cpc	r31, r19
    293e:	a0 f4       	brcc	.+40     	; 0x2968 <malloc+0x120>
    2940:	2e 1b       	sub	r18, r30
    2942:	3f 0b       	sbc	r19, r31
    2944:	28 17       	cp	r18, r24
    2946:	39 07       	cpc	r19, r25
    2948:	78 f0       	brcs	.+30     	; 0x2968 <malloc+0x120>
    294a:	ac 01       	movw	r20, r24
    294c:	4e 5f       	subi	r20, 0xFE	; 254
    294e:	5f 4f       	sbci	r21, 0xFF	; 255
    2950:	24 17       	cp	r18, r20
    2952:	35 07       	cpc	r19, r21
    2954:	48 f0       	brcs	.+18     	; 0x2968 <malloc+0x120>
    2956:	4e 0f       	add	r20, r30
    2958:	5f 1f       	adc	r21, r31
    295a:	50 93 bc 04 	sts	0x04BC, r21	; 0x8004bc <__brkval+0x1>
    295e:	40 93 bb 04 	sts	0x04BB, r20	; 0x8004bb <__brkval>
    2962:	81 93       	st	Z+, r24
    2964:	91 93       	st	Z+, r25
    2966:	02 c0       	rjmp	.+4      	; 0x296c <malloc+0x124>
    2968:	e0 e0       	ldi	r30, 0x00	; 0
    296a:	f0 e0       	ldi	r31, 0x00	; 0
    296c:	cf 01       	movw	r24, r30
    296e:	df 91       	pop	r29
    2970:	cf 91       	pop	r28
    2972:	1f 91       	pop	r17
    2974:	0f 91       	pop	r16
    2976:	08 95       	ret

00002978 <free>:
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	09 f4       	brne	.+2      	; 0x2982 <free+0xa>
    2980:	81 c0       	rjmp	.+258    	; 0x2a84 <free+0x10c>
    2982:	fc 01       	movw	r30, r24
    2984:	32 97       	sbiw	r30, 0x02	; 2
    2986:	13 82       	std	Z+3, r1	; 0x03
    2988:	12 82       	std	Z+2, r1	; 0x02
    298a:	a0 91 bd 04 	lds	r26, 0x04BD	; 0x8004bd <__flp>
    298e:	b0 91 be 04 	lds	r27, 0x04BE	; 0x8004be <__flp+0x1>
    2992:	10 97       	sbiw	r26, 0x00	; 0
    2994:	81 f4       	brne	.+32     	; 0x29b6 <free+0x3e>
    2996:	20 81       	ld	r18, Z
    2998:	31 81       	ldd	r19, Z+1	; 0x01
    299a:	82 0f       	add	r24, r18
    299c:	93 1f       	adc	r25, r19
    299e:	20 91 bb 04 	lds	r18, 0x04BB	; 0x8004bb <__brkval>
    29a2:	30 91 bc 04 	lds	r19, 0x04BC	; 0x8004bc <__brkval+0x1>
    29a6:	28 17       	cp	r18, r24
    29a8:	39 07       	cpc	r19, r25
    29aa:	51 f5       	brne	.+84     	; 0x2a00 <free+0x88>
    29ac:	f0 93 bc 04 	sts	0x04BC, r31	; 0x8004bc <__brkval+0x1>
    29b0:	e0 93 bb 04 	sts	0x04BB, r30	; 0x8004bb <__brkval>
    29b4:	67 c0       	rjmp	.+206    	; 0x2a84 <free+0x10c>
    29b6:	ed 01       	movw	r28, r26
    29b8:	20 e0       	ldi	r18, 0x00	; 0
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	ce 17       	cp	r28, r30
    29be:	df 07       	cpc	r29, r31
    29c0:	40 f4       	brcc	.+16     	; 0x29d2 <free+0x5a>
    29c2:	4a 81       	ldd	r20, Y+2	; 0x02
    29c4:	5b 81       	ldd	r21, Y+3	; 0x03
    29c6:	9e 01       	movw	r18, r28
    29c8:	41 15       	cp	r20, r1
    29ca:	51 05       	cpc	r21, r1
    29cc:	f1 f0       	breq	.+60     	; 0x2a0a <free+0x92>
    29ce:	ea 01       	movw	r28, r20
    29d0:	f5 cf       	rjmp	.-22     	; 0x29bc <free+0x44>
    29d2:	d3 83       	std	Z+3, r29	; 0x03
    29d4:	c2 83       	std	Z+2, r28	; 0x02
    29d6:	40 81       	ld	r20, Z
    29d8:	51 81       	ldd	r21, Z+1	; 0x01
    29da:	84 0f       	add	r24, r20
    29dc:	95 1f       	adc	r25, r21
    29de:	c8 17       	cp	r28, r24
    29e0:	d9 07       	cpc	r29, r25
    29e2:	59 f4       	brne	.+22     	; 0x29fa <free+0x82>
    29e4:	88 81       	ld	r24, Y
    29e6:	99 81       	ldd	r25, Y+1	; 0x01
    29e8:	84 0f       	add	r24, r20
    29ea:	95 1f       	adc	r25, r21
    29ec:	02 96       	adiw	r24, 0x02	; 2
    29ee:	91 83       	std	Z+1, r25	; 0x01
    29f0:	80 83       	st	Z, r24
    29f2:	8a 81       	ldd	r24, Y+2	; 0x02
    29f4:	9b 81       	ldd	r25, Y+3	; 0x03
    29f6:	93 83       	std	Z+3, r25	; 0x03
    29f8:	82 83       	std	Z+2, r24	; 0x02
    29fa:	21 15       	cp	r18, r1
    29fc:	31 05       	cpc	r19, r1
    29fe:	29 f4       	brne	.+10     	; 0x2a0a <free+0x92>
    2a00:	f0 93 be 04 	sts	0x04BE, r31	; 0x8004be <__flp+0x1>
    2a04:	e0 93 bd 04 	sts	0x04BD, r30	; 0x8004bd <__flp>
    2a08:	3d c0       	rjmp	.+122    	; 0x2a84 <free+0x10c>
    2a0a:	e9 01       	movw	r28, r18
    2a0c:	fb 83       	std	Y+3, r31	; 0x03
    2a0e:	ea 83       	std	Y+2, r30	; 0x02
    2a10:	49 91       	ld	r20, Y+
    2a12:	59 91       	ld	r21, Y+
    2a14:	c4 0f       	add	r28, r20
    2a16:	d5 1f       	adc	r29, r21
    2a18:	ec 17       	cp	r30, r28
    2a1a:	fd 07       	cpc	r31, r29
    2a1c:	61 f4       	brne	.+24     	; 0x2a36 <free+0xbe>
    2a1e:	80 81       	ld	r24, Z
    2a20:	91 81       	ldd	r25, Z+1	; 0x01
    2a22:	84 0f       	add	r24, r20
    2a24:	95 1f       	adc	r25, r21
    2a26:	02 96       	adiw	r24, 0x02	; 2
    2a28:	e9 01       	movw	r28, r18
    2a2a:	99 83       	std	Y+1, r25	; 0x01
    2a2c:	88 83       	st	Y, r24
    2a2e:	82 81       	ldd	r24, Z+2	; 0x02
    2a30:	93 81       	ldd	r25, Z+3	; 0x03
    2a32:	9b 83       	std	Y+3, r25	; 0x03
    2a34:	8a 83       	std	Y+2, r24	; 0x02
    2a36:	e0 e0       	ldi	r30, 0x00	; 0
    2a38:	f0 e0       	ldi	r31, 0x00	; 0
    2a3a:	12 96       	adiw	r26, 0x02	; 2
    2a3c:	8d 91       	ld	r24, X+
    2a3e:	9c 91       	ld	r25, X
    2a40:	13 97       	sbiw	r26, 0x03	; 3
    2a42:	00 97       	sbiw	r24, 0x00	; 0
    2a44:	19 f0       	breq	.+6      	; 0x2a4c <free+0xd4>
    2a46:	fd 01       	movw	r30, r26
    2a48:	dc 01       	movw	r26, r24
    2a4a:	f7 cf       	rjmp	.-18     	; 0x2a3a <free+0xc2>
    2a4c:	8d 91       	ld	r24, X+
    2a4e:	9c 91       	ld	r25, X
    2a50:	11 97       	sbiw	r26, 0x01	; 1
    2a52:	9d 01       	movw	r18, r26
    2a54:	2e 5f       	subi	r18, 0xFE	; 254
    2a56:	3f 4f       	sbci	r19, 0xFF	; 255
    2a58:	82 0f       	add	r24, r18
    2a5a:	93 1f       	adc	r25, r19
    2a5c:	20 91 bb 04 	lds	r18, 0x04BB	; 0x8004bb <__brkval>
    2a60:	30 91 bc 04 	lds	r19, 0x04BC	; 0x8004bc <__brkval+0x1>
    2a64:	28 17       	cp	r18, r24
    2a66:	39 07       	cpc	r19, r25
    2a68:	69 f4       	brne	.+26     	; 0x2a84 <free+0x10c>
    2a6a:	30 97       	sbiw	r30, 0x00	; 0
    2a6c:	29 f4       	brne	.+10     	; 0x2a78 <free+0x100>
    2a6e:	10 92 be 04 	sts	0x04BE, r1	; 0x8004be <__flp+0x1>
    2a72:	10 92 bd 04 	sts	0x04BD, r1	; 0x8004bd <__flp>
    2a76:	02 c0       	rjmp	.+4      	; 0x2a7c <free+0x104>
    2a78:	13 82       	std	Z+3, r1	; 0x03
    2a7a:	12 82       	std	Z+2, r1	; 0x02
    2a7c:	b0 93 bc 04 	sts	0x04BC, r27	; 0x8004bc <__brkval+0x1>
    2a80:	a0 93 bb 04 	sts	0x04BB, r26	; 0x8004bb <__brkval>
    2a84:	df 91       	pop	r29
    2a86:	cf 91       	pop	r28
    2a88:	08 95       	ret

00002a8a <memcpy>:
    2a8a:	fb 01       	movw	r30, r22
    2a8c:	dc 01       	movw	r26, r24
    2a8e:	02 c0       	rjmp	.+4      	; 0x2a94 <memcpy+0xa>
    2a90:	01 90       	ld	r0, Z+
    2a92:	0d 92       	st	X+, r0
    2a94:	41 50       	subi	r20, 0x01	; 1
    2a96:	50 40       	sbci	r21, 0x00	; 0
    2a98:	d8 f7       	brcc	.-10     	; 0x2a90 <memcpy+0x6>
    2a9a:	08 95       	ret

00002a9c <memset>:
    2a9c:	dc 01       	movw	r26, r24
    2a9e:	01 c0       	rjmp	.+2      	; 0x2aa2 <memset+0x6>
    2aa0:	6d 93       	st	X+, r22
    2aa2:	41 50       	subi	r20, 0x01	; 1
    2aa4:	50 40       	sbci	r21, 0x00	; 0
    2aa6:	e0 f7       	brcc	.-8      	; 0x2aa0 <memset+0x4>
    2aa8:	08 95       	ret

00002aaa <__itoa_ncheck>:
    2aaa:	bb 27       	eor	r27, r27
    2aac:	4a 30       	cpi	r20, 0x0A	; 10
    2aae:	31 f4       	brne	.+12     	; 0x2abc <__itoa_ncheck+0x12>
    2ab0:	99 23       	and	r25, r25
    2ab2:	22 f4       	brpl	.+8      	; 0x2abc <__itoa_ncheck+0x12>
    2ab4:	bd e2       	ldi	r27, 0x2D	; 45
    2ab6:	90 95       	com	r25
    2ab8:	81 95       	neg	r24
    2aba:	9f 4f       	sbci	r25, 0xFF	; 255
    2abc:	01 c0       	rjmp	.+2      	; 0x2ac0 <__utoa_common>

00002abe <__utoa_ncheck>:
    2abe:	bb 27       	eor	r27, r27

00002ac0 <__utoa_common>:
    2ac0:	fb 01       	movw	r30, r22
    2ac2:	55 27       	eor	r21, r21
    2ac4:	aa 27       	eor	r26, r26
    2ac6:	88 0f       	add	r24, r24
    2ac8:	99 1f       	adc	r25, r25
    2aca:	aa 1f       	adc	r26, r26
    2acc:	a4 17       	cp	r26, r20
    2ace:	10 f0       	brcs	.+4      	; 0x2ad4 <__utoa_common+0x14>
    2ad0:	a4 1b       	sub	r26, r20
    2ad2:	83 95       	inc	r24
    2ad4:	50 51       	subi	r21, 0x10	; 16
    2ad6:	b9 f7       	brne	.-18     	; 0x2ac6 <__utoa_common+0x6>
    2ad8:	a0 5d       	subi	r26, 0xD0	; 208
    2ada:	aa 33       	cpi	r26, 0x3A	; 58
    2adc:	08 f0       	brcs	.+2      	; 0x2ae0 <__utoa_common+0x20>
    2ade:	a9 5d       	subi	r26, 0xD9	; 217
    2ae0:	a1 93       	st	Z+, r26
    2ae2:	00 97       	sbiw	r24, 0x00	; 0
    2ae4:	79 f7       	brne	.-34     	; 0x2ac4 <__utoa_common+0x4>
    2ae6:	b1 11       	cpse	r27, r1
    2ae8:	b1 93       	st	Z+, r27
    2aea:	11 92       	st	Z+, r1
    2aec:	cb 01       	movw	r24, r22
    2aee:	00 c0       	rjmp	.+0      	; 0x2af0 <strrev>

00002af0 <strrev>:
    2af0:	dc 01       	movw	r26, r24
    2af2:	fc 01       	movw	r30, r24
    2af4:	67 2f       	mov	r22, r23
    2af6:	71 91       	ld	r23, Z+
    2af8:	77 23       	and	r23, r23
    2afa:	e1 f7       	brne	.-8      	; 0x2af4 <strrev+0x4>
    2afc:	32 97       	sbiw	r30, 0x02	; 2
    2afe:	04 c0       	rjmp	.+8      	; 0x2b08 <strrev+0x18>
    2b00:	7c 91       	ld	r23, X
    2b02:	6d 93       	st	X+, r22
    2b04:	70 83       	st	Z, r23
    2b06:	62 91       	ld	r22, -Z
    2b08:	ae 17       	cp	r26, r30
    2b0a:	bf 07       	cpc	r27, r31
    2b0c:	c8 f3       	brcs	.-14     	; 0x2b00 <strrev+0x10>
    2b0e:	08 95       	ret

00002b10 <_exit>:
    2b10:	f8 94       	cli

00002b12 <__stop_program>:
    2b12:	ff cf       	rjmp	.-2      	; 0x2b12 <__stop_program>
